import { jsxs as lY, jsx as jq } from "react/jsx-runtime";
import * as WI from "react";
import { useMemo as py, useCallback as gj, useRef as uY } from "react";
import { Container as dY } from "@zextras/carbonio-design-system";
import { useTranslation as mY } from "react-i18next";
function fY(vt) {
  return vt && vt.__esModule && Object.prototype.hasOwnProperty.call(vt, "default") ? vt.default : vt;
}
var hj = { exports: {} }, pj, qq;
function gY() {
  if (qq) return pj;
  qq = 1;
  var vt = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return pj = vt, pj;
}
var bj, Gq;
function hY() {
  if (Gq) return bj;
  Gq = 1;
  var vt = /* @__PURE__ */ gY();
  function Ot() {
  }
  function Pt() {
  }
  return Pt.resetWarningCache = Ot, bj = function() {
    function yt(Fe, Ee, Bt, fn, dn, Sn) {
      if (Sn !== vt) {
        var Ft = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw Ft.name = "Invariant Violation", Ft;
      }
    }
    yt.isRequired = yt;
    function Nt() {
      return yt;
    }
    var Wt = {
      array: yt,
      bigint: yt,
      bool: yt,
      func: yt,
      number: yt,
      object: yt,
      string: yt,
      symbol: yt,
      any: yt,
      arrayOf: Nt,
      element: yt,
      elementType: yt,
      instanceOf: Nt,
      node: yt,
      objectOf: Nt,
      oneOf: Nt,
      oneOfType: Nt,
      shape: Nt,
      exact: Nt,
      checkPropTypes: Pt,
      resetWarningCache: Ot
    };
    return Wt.PropTypes = Wt, Wt;
  }, bj;
}
var Kq;
function pY() {
  return Kq || (Kq = 1, hj.exports = /* @__PURE__ */ hY()()), hj.exports;
}
var wn = /* @__PURE__ */ pY(), wj = function() {
  return wj = Object.assign || function(vt) {
    for (var Ot, Pt = 1, yt = arguments.length; Pt < yt; Pt++) {
      Ot = arguments[Pt];
      for (var Nt in Ot) Object.prototype.hasOwnProperty.call(Ot, Nt) && (vt[Nt] = Ot[Nt]);
    }
    return vt;
  }, wj.apply(this, arguments);
}, zK = {
  onActivate: wn.func,
  onAddUndo: wn.func,
  onBeforeAddUndo: wn.func,
  onBeforeExecCommand: wn.func,
  onBeforeGetContent: wn.func,
  onBeforeRenderUI: wn.func,
  onBeforeSetContent: wn.func,
  onBeforePaste: wn.func,
  onBlur: wn.func,
  onChange: wn.func,
  onClearUndos: wn.func,
  onClick: wn.func,
  onContextMenu: wn.func,
  onCommentChange: wn.func,
  onCopy: wn.func,
  onCut: wn.func,
  onDblclick: wn.func,
  onDeactivate: wn.func,
  onDirty: wn.func,
  onDrag: wn.func,
  onDragDrop: wn.func,
  onDragEnd: wn.func,
  onDragGesture: wn.func,
  onDragOver: wn.func,
  onDrop: wn.func,
  onExecCommand: wn.func,
  onFocus: wn.func,
  onFocusIn: wn.func,
  onFocusOut: wn.func,
  onGetContent: wn.func,
  onHide: wn.func,
  onInit: wn.func,
  onKeyDown: wn.func,
  onKeyPress: wn.func,
  onKeyUp: wn.func,
  onLoadContent: wn.func,
  onMouseDown: wn.func,
  onMouseEnter: wn.func,
  onMouseLeave: wn.func,
  onMouseMove: wn.func,
  onMouseOut: wn.func,
  onMouseOver: wn.func,
  onMouseUp: wn.func,
  onNodeChange: wn.func,
  onObjectResizeStart: wn.func,
  onObjectResized: wn.func,
  onObjectSelected: wn.func,
  onPaste: wn.func,
  onPostProcess: wn.func,
  onPostRender: wn.func,
  onPreProcess: wn.func,
  onProgressState: wn.func,
  onRedo: wn.func,
  onRemove: wn.func,
  onReset: wn.func,
  onSaveContent: wn.func,
  onSelectionChange: wn.func,
  onSetAttrib: wn.func,
  onSetContent: wn.func,
  onShow: wn.func,
  onSubmit: wn.func,
  onUndo: wn.func,
  onVisualAid: wn.func,
  onSkinLoadError: wn.func,
  onThemeLoadError: wn.func,
  onModelLoadError: wn.func,
  onPluginLoadError: wn.func,
  onIconsLoadError: wn.func,
  onLanguageLoadError: wn.func,
  onScriptsLoad: wn.func,
  onScriptsLoadError: wn.func
}, bY = wj({ apiKey: wn.string, id: wn.string, inline: wn.bool, init: wn.object, initialValue: wn.string, onEditorChange: wn.func, value: wn.string, tagName: wn.string, cloudChannel: wn.string, plugins: wn.oneOfType([wn.string, wn.array]), toolbar: wn.oneOfType([wn.string, wn.array]), disabled: wn.bool, textareaName: wn.string, tinymceScriptSrc: wn.oneOfType([
  wn.string,
  wn.arrayOf(wn.string),
  wn.arrayOf(wn.shape({
    src: wn.string,
    async: wn.bool,
    defer: wn.bool
  }))
]), rollback: wn.oneOfType([wn.number, wn.oneOf([!1])]), scriptLoading: wn.shape({
  async: wn.bool,
  defer: wn.bool,
  delay: wn.number
}) }, zK), vj = function(vt) {
  return typeof vt == "function";
}, Yq = function(vt) {
  return vt in zK;
}, Xq = function(vt) {
  return vt.substr(2);
}, vY = function(vt, Ot, Pt, yt, Nt, Wt, Fe) {
  var Ee = Object.keys(Nt).filter(Yq), Bt = Object.keys(Wt).filter(Yq), fn = Ee.filter(function(Sn) {
    return Wt[Sn] === void 0;
  }), dn = Bt.filter(function(Sn) {
    return Nt[Sn] === void 0;
  });
  fn.forEach(function(Sn) {
    var Ft = Xq(Sn), Zt = Fe[Ft];
    Pt(Ft, Zt), delete Fe[Ft];
  }), dn.forEach(function(Sn) {
    var Ft = yt(vt, Sn), Zt = Xq(Sn);
    Fe[Zt] = Ft, Ot(Zt, Ft);
  });
}, yY = function(vt, Ot, Pt, yt, Nt) {
  return vY(
    Nt,
    vt.on.bind(vt),
    vt.off.bind(vt),
    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    function(Wt, Fe) {
      return function(Ee) {
        var Bt;
        return (Bt = Wt(Fe)) === null || Bt === void 0 ? void 0 : Bt(Ee, vt);
      };
    },
    Ot,
    Pt,
    yt
  );
}, Jq = 0, VK = function(vt) {
  var Ot = Date.now(), Pt = Math.floor(Math.random() * 1e9);
  return Jq++, vt + "_" + Pt + Jq + String(Ot);
}, Qq = function(vt) {
  return vt !== null && (vt.tagName.toLowerCase() === "textarea" || vt.tagName.toLowerCase() === "input");
}, eG = function(vt) {
  return typeof vt > "u" || vt === "" ? [] : Array.isArray(vt) ? vt : vt.split(" ");
}, CY = function(vt, Ot) {
  return eG(vt).concat(eG(Ot));
}, wY = function() {
  return window.InputEvent && typeof InputEvent.prototype.getTargetRanges == "function";
}, SY = function(vt) {
  if (!("isConnected" in Node.prototype)) {
    for (var Ot = vt, Pt = vt.parentNode; Pt != null; )
      Ot = Pt, Pt = Ot.parentNode;
    return Ot === vt.ownerDocument;
  }
  return vt.isConnected;
}, tG = function(vt, Ot) {
  vt !== void 0 && (vt.mode != null && typeof vt.mode == "object" && typeof vt.mode.set == "function" ? vt.mode.set(Ot) : vt.setMode(Ot));
}, Sj = function() {
  return Sj = Object.assign || function(vt) {
    for (var Ot, Pt = 1, yt = arguments.length; Pt < yt; Pt++) {
      Ot = arguments[Pt];
      for (var Nt in Ot) Object.prototype.hasOwnProperty.call(Ot, Nt) && (vt[Nt] = Ot[Nt]);
    }
    return vt;
  }, Sj.apply(this, arguments);
}, xY = function(vt, Ot, Pt) {
  var yt, Nt, Wt = vt.createElement("script");
  Wt.referrerPolicy = "origin", Wt.type = "application/javascript", Wt.id = Ot.id, Wt.src = Ot.src, Wt.async = (yt = Ot.async) !== null && yt !== void 0 ? yt : !1, Wt.defer = (Nt = Ot.defer) !== null && Nt !== void 0 ? Nt : !1;
  var Fe = function() {
    Wt.removeEventListener("load", Fe), Wt.removeEventListener("error", Ee), Pt(Ot.src);
  }, Ee = function(Bt) {
    Wt.removeEventListener("load", Fe), Wt.removeEventListener("error", Ee), Pt(Ot.src, Bt);
  };
  Wt.addEventListener("load", Fe), Wt.addEventListener("error", Ee), vt.head && vt.head.appendChild(Wt);
}, TY = function(vt) {
  var Ot = {}, Pt = function(Fe, Ee) {
    var Bt = Ot[Fe];
    Bt.done = !0, Bt.error = Ee;
    for (var fn = 0, dn = Bt.handlers; fn < dn.length; fn++) {
      var Sn = dn[fn];
      Sn(Fe, Ee);
    }
    Bt.handlers = [];
  }, yt = function(Fe, Ee, Bt) {
    var fn = function(Kt) {
      return Bt !== void 0 ? Bt(Kt) : void 0;
    };
    if (Fe.length === 0) {
      fn(new Error("At least one script must be provided"));
      return;
    }
    for (var dn = 0, Sn = !1, Ft = function(Kt, J) {
      Sn || (J ? (Sn = !0, fn(J)) : ++dn === Fe.length && Ee());
    }, Zt = 0, Qt = Fe; Zt < Qt.length; Zt++) {
      var En = Qt[Zt], st = Ot[En.src];
      if (st)
        st.done ? Ft(En.src, st.error) : st.handlers.push(Ft);
      else {
        var Pn = VK("tiny-");
        Ot[En.src] = {
          id: Pn,
          src: En.src,
          done: !1,
          error: null,
          handlers: [Ft]
        }, xY(vt, Sj({ id: Pn }, En), Pt);
      }
    }
  }, Nt = function() {
    for (var Fe, Ee = 0, Bt = Object.values(Ot); Ee < Bt.length; Ee++) {
      var fn = Bt[Ee], dn = vt.getElementById(fn.id);
      dn != null && dn.tagName === "SCRIPT" && ((Fe = dn.parentNode) === null || Fe === void 0 || Fe.removeChild(dn));
    }
    Ot = {};
  }, Wt = function() {
    return vt;
  };
  return {
    loadScripts: yt,
    deleteScripts: Nt,
    getDocument: Wt
  };
}, EY = function() {
  var vt = [], Ot = function(Nt) {
    var Wt = vt.find(function(Fe) {
      return Fe.getDocument() === Nt;
    });
    return Wt === void 0 && (Wt = TY(Nt), vt.push(Wt)), Wt;
  }, Pt = function(Nt, Wt, Fe, Ee, Bt) {
    var fn = function() {
      return Ot(Nt).loadScripts(Wt, Ee, Bt);
    };
    Fe > 0 ? setTimeout(fn, Fe) : fn();
  }, yt = function() {
    for (var Nt = vt.pop(); Nt != null; Nt = vt.pop())
      Nt.deleteScripts();
  };
  return {
    loadList: Pt,
    reinitialize: yt
  };
}, kY = EY(), yj = function(vt) {
  var Ot = vt;
  return Ot && Ot.tinymce ? Ot.tinymce : null;
}, _Y = /* @__PURE__ */ (function() {
  var vt = function(Ot, Pt) {
    return vt = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(yt, Nt) {
      yt.__proto__ = Nt;
    } || function(yt, Nt) {
      for (var Wt in Nt) Object.prototype.hasOwnProperty.call(Nt, Wt) && (yt[Wt] = Nt[Wt]);
    }, vt(Ot, Pt);
  };
  return function(Ot, Pt) {
    if (typeof Pt != "function" && Pt !== null)
      throw new TypeError("Class extends value " + String(Pt) + " is not a constructor or null");
    vt(Ot, Pt);
    function yt() {
      this.constructor = Ot;
    }
    Ot.prototype = Pt === null ? Object.create(Pt) : (yt.prototype = Pt.prototype, new yt());
  };
})(), ZI = function() {
  return ZI = Object.assign || function(vt) {
    for (var Ot, Pt = 1, yt = arguments.length; Pt < yt; Pt++) {
      Ot = arguments[Pt];
      for (var Nt in Ot) Object.prototype.hasOwnProperty.call(Ot, Nt) && (vt[Nt] = Ot[Nt]);
    }
    return vt;
  }, ZI.apply(this, arguments);
}, AY = (
  /** @class */
  (function(vt) {
    _Y(Ot, vt);
    function Ot(Pt) {
      var yt, Nt, Wt, Fe = vt.call(this, Pt) || this;
      return Fe.rollbackTimer = void 0, Fe.valueCursor = void 0, Fe.rollbackChange = function() {
        var Ee = Fe.editor, Bt = Fe.props.value;
        Ee && Bt && Bt !== Fe.currentContent && Ee.undoManager.ignore(function() {
          if (Ee.setContent(Bt), Fe.valueCursor && (!Fe.inline || Ee.hasFocus()))
            try {
              Ee.selection.moveToBookmark(Fe.valueCursor);
            } catch {
            }
        }), Fe.rollbackTimer = void 0;
      }, Fe.handleBeforeInput = function(Ee) {
        if (Fe.props.value !== void 0 && Fe.props.value === Fe.currentContent && Fe.editor && (!Fe.inline || Fe.editor.hasFocus()))
          try {
            Fe.valueCursor = Fe.editor.selection.getBookmark(3);
          } catch {
          }
      }, Fe.handleBeforeInputSpecial = function(Ee) {
        (Ee.key === "Enter" || Ee.key === "Backspace" || Ee.key === "Delete") && Fe.handleBeforeInput(Ee);
      }, Fe.handleEditorChange = function(Ee) {
        var Bt = Fe.editor;
        if (Bt && Bt.initialized) {
          var fn = Bt.getContent();
          Fe.props.value !== void 0 && Fe.props.value !== fn && Fe.props.rollback !== !1 && (Fe.rollbackTimer || (Fe.rollbackTimer = window.setTimeout(Fe.rollbackChange, typeof Fe.props.rollback == "number" ? Fe.props.rollback : 200))), fn !== Fe.currentContent && (Fe.currentContent = fn, vj(Fe.props.onEditorChange) && Fe.props.onEditorChange(fn, Bt));
        }
      }, Fe.handleEditorChangeSpecial = function(Ee) {
        (Ee.key === "Backspace" || Ee.key === "Delete") && Fe.handleEditorChange(Ee);
      }, Fe.initialise = function(Ee) {
        var Bt, fn, dn;
        Ee === void 0 && (Ee = 0);
        var Sn = Fe.elementRef.current;
        if (Sn) {
          if (!SY(Sn)) {
            if (Ee === 0)
              setTimeout(function() {
                return Fe.initialise(1);
              }, 1);
            else if (Ee < 100)
              setTimeout(function() {
                return Fe.initialise(Ee + 1);
              }, 100);
            else
              throw new Error("tinymce can only be initialised when in a document");
            return;
          }
          var Ft = yj(Fe.view);
          if (!Ft)
            throw new Error("tinymce should have been loaded into global scope");
          var Zt = ZI(ZI({}, Fe.props.init), { selector: void 0, target: Sn, readonly: Fe.props.disabled, inline: Fe.inline, plugins: CY((Bt = Fe.props.init) === null || Bt === void 0 ? void 0 : Bt.plugins, Fe.props.plugins), toolbar: (fn = Fe.props.toolbar) !== null && fn !== void 0 ? fn : (dn = Fe.props.init) === null || dn === void 0 ? void 0 : dn.toolbar, setup: function(Qt) {
            Fe.editor = Qt, Fe.bindHandlers({}), Fe.inline && !Qq(Sn) && Qt.once("PostRender", function(En) {
              Qt.setContent(Fe.getInitialValue(), { no_events: !0 });
            }), Fe.props.init && vj(Fe.props.init.setup) && Fe.props.init.setup(Qt);
          }, init_instance_callback: function(Qt) {
            var En, st, Pn = Fe.getInitialValue();
            Fe.currentContent = (En = Fe.currentContent) !== null && En !== void 0 ? En : Qt.getContent(), Fe.currentContent !== Pn && (Fe.currentContent = Pn, Qt.setContent(Pn), Qt.undoManager.clear(), Qt.undoManager.add(), Qt.setDirty(!1));
            var Kt = (st = Fe.props.disabled) !== null && st !== void 0 ? st : !1;
            tG(Fe.editor, Kt ? "readonly" : "design"), Fe.props.init && vj(Fe.props.init.init_instance_callback) && Fe.props.init.init_instance_callback(Qt);
          } });
          Fe.inline || (Sn.style.visibility = ""), Qq(Sn) && (Sn.value = Fe.getInitialValue()), Ft.init(Zt);
        }
      }, Fe.id = Fe.props.id || VK("tiny-react"), Fe.elementRef = WI.createRef(), Fe.inline = (Wt = (yt = Fe.props.inline) !== null && yt !== void 0 ? yt : (Nt = Fe.props.init) === null || Nt === void 0 ? void 0 : Nt.inline) !== null && Wt !== void 0 ? Wt : !1, Fe.boundHandlers = {}, Fe;
    }
    return Object.defineProperty(Ot.prototype, "view", {
      get: function() {
        var Pt, yt;
        return (yt = (Pt = this.elementRef.current) === null || Pt === void 0 ? void 0 : Pt.ownerDocument.defaultView) !== null && yt !== void 0 ? yt : window;
      },
      enumerable: !1,
      configurable: !0
    }), Ot.prototype.componentDidUpdate = function(Pt) {
      var yt = this, Nt, Wt;
      if (this.rollbackTimer && (clearTimeout(this.rollbackTimer), this.rollbackTimer = void 0), this.editor && (this.bindHandlers(Pt), this.editor.initialized)) {
        if (this.currentContent = (Nt = this.currentContent) !== null && Nt !== void 0 ? Nt : this.editor.getContent(), typeof this.props.initialValue == "string" && this.props.initialValue !== Pt.initialValue)
          this.editor.setContent(this.props.initialValue), this.editor.undoManager.clear(), this.editor.undoManager.add(), this.editor.setDirty(!1);
        else if (typeof this.props.value == "string" && this.props.value !== this.currentContent) {
          var Fe = this.editor;
          Fe.undoManager.transact(function() {
            var Bt;
            if (!yt.inline || Fe.hasFocus())
              try {
                Bt = Fe.selection.getBookmark(3);
              } catch {
              }
            var fn = yt.valueCursor;
            if (Fe.setContent(yt.props.value), !yt.inline || Fe.hasFocus())
              for (var dn = 0, Sn = [Bt, fn]; dn < Sn.length; dn++) {
                var Ft = Sn[dn];
                if (Ft)
                  try {
                    Fe.selection.moveToBookmark(Ft), yt.valueCursor = Ft;
                    break;
                  } catch {
                  }
              }
          });
        }
        if (this.props.disabled !== Pt.disabled) {
          var Ee = (Wt = this.props.disabled) !== null && Wt !== void 0 ? Wt : !1;
          tG(this.editor, Ee ? "readonly" : "design");
        }
      }
    }, Ot.prototype.componentDidMount = function() {
      var Pt = this, yt, Nt, Wt, Fe, Ee;
      if (yj(this.view) !== null)
        this.initialise();
      else if (Array.isArray(this.props.tinymceScriptSrc) && this.props.tinymceScriptSrc.length === 0)
        (Nt = (yt = this.props).onScriptsLoadError) === null || Nt === void 0 || Nt.call(yt, new Error("No `tinymce` global is present but the `tinymceScriptSrc` prop was an empty array."));
      else if (!((Wt = this.elementRef.current) === null || Wt === void 0) && Wt.ownerDocument) {
        var Bt = function() {
          var dn, Sn;
          (Sn = (dn = Pt.props).onScriptsLoad) === null || Sn === void 0 || Sn.call(dn), Pt.initialise();
        }, fn = function(dn) {
          var Sn, Ft;
          (Ft = (Sn = Pt.props).onScriptsLoadError) === null || Ft === void 0 || Ft.call(Sn, dn);
        };
        kY.loadList(this.elementRef.current.ownerDocument, this.getScriptSources(), (Ee = (Fe = this.props.scriptLoading) === null || Fe === void 0 ? void 0 : Fe.delay) !== null && Ee !== void 0 ? Ee : 0, Bt, fn);
      }
    }, Ot.prototype.componentWillUnmount = function() {
      var Pt = this, yt = this.editor;
      yt && (yt.off(this.changeEvents(), this.handleEditorChange), yt.off(this.beforeInputEvent(), this.handleBeforeInput), yt.off("keypress", this.handleEditorChangeSpecial), yt.off("keydown", this.handleBeforeInputSpecial), yt.off("NewBlock", this.handleEditorChange), Object.keys(this.boundHandlers).forEach(function(Nt) {
        yt.off(Nt, Pt.boundHandlers[Nt]);
      }), this.boundHandlers = {}, yt.remove(), this.editor = void 0);
    }, Ot.prototype.render = function() {
      return this.inline ? this.renderInline() : this.renderIframe();
    }, Ot.prototype.changeEvents = function() {
      var Pt, yt, Nt, Wt = (Nt = (yt = (Pt = yj(this.view)) === null || Pt === void 0 ? void 0 : Pt.Env) === null || yt === void 0 ? void 0 : yt.browser) === null || Nt === void 0 ? void 0 : Nt.isIE();
      return Wt ? "change keyup compositionend setcontent CommentChange" : "change input compositionend setcontent CommentChange";
    }, Ot.prototype.beforeInputEvent = function() {
      return wY() ? "beforeinput SelectionChange" : "SelectionChange";
    }, Ot.prototype.renderInline = function() {
      var Pt = this.props.tagName, yt = Pt === void 0 ? "div" : Pt;
      return WI.createElement(yt, {
        ref: this.elementRef,
        id: this.id
      });
    }, Ot.prototype.renderIframe = function() {
      return WI.createElement("textarea", {
        ref: this.elementRef,
        style: { visibility: "hidden" },
        name: this.props.textareaName,
        id: this.id
      });
    }, Ot.prototype.getScriptSources = function() {
      var Pt, yt, Nt = (Pt = this.props.scriptLoading) === null || Pt === void 0 ? void 0 : Pt.async, Wt = (yt = this.props.scriptLoading) === null || yt === void 0 ? void 0 : yt.defer;
      if (this.props.tinymceScriptSrc !== void 0)
        return typeof this.props.tinymceScriptSrc == "string" ? [{ src: this.props.tinymceScriptSrc, async: Nt, defer: Wt }] : this.props.tinymceScriptSrc.map(function(fn) {
          return typeof fn == "string" ? { src: fn, async: Nt, defer: Wt } : fn;
        });
      var Fe = this.props.cloudChannel, Ee = this.props.apiKey ? this.props.apiKey : "no-api-key", Bt = "https://cdn.tiny.cloud/1/".concat(Ee, "/tinymce/").concat(Fe, "/tinymce.min.js");
      return [{ src: Bt, async: Nt, defer: Wt }];
    }, Ot.prototype.getInitialValue = function() {
      return typeof this.props.initialValue == "string" ? this.props.initialValue : typeof this.props.value == "string" ? this.props.value : "";
    }, Ot.prototype.bindHandlers = function(Pt) {
      var yt = this;
      if (this.editor !== void 0) {
        yY(this.editor, Pt, this.props, this.boundHandlers, function(Ee) {
          return yt.props[Ee];
        });
        var Nt = function(Ee) {
          return Ee.onEditorChange !== void 0 || Ee.value !== void 0;
        }, Wt = Nt(Pt), Fe = Nt(this.props);
        !Wt && Fe ? (this.editor.on(this.changeEvents(), this.handleEditorChange), this.editor.on(this.beforeInputEvent(), this.handleBeforeInput), this.editor.on("keydown", this.handleBeforeInputSpecial), this.editor.on("keyup", this.handleEditorChangeSpecial), this.editor.on("NewBlock", this.handleEditorChange)) : Wt && !Fe && (this.editor.off(this.changeEvents(), this.handleEditorChange), this.editor.off(this.beforeInputEvent(), this.handleBeforeInput), this.editor.off("keydown", this.handleBeforeInputSpecial), this.editor.off("keyup", this.handleEditorChangeSpecial), this.editor.off("NewBlock", this.handleEditorChange));
      }
    }, Ot.propTypes = bY, Ot.defaultProps = {
      cloudChannel: "6"
    }, Ot;
  })(WI.Component)
), Cj = { exports: {} }, nG;
function OY() {
  return nG || (nG = 1, (function(vt) {
    (function() {
      var Ot = function(e) {
        if (e === null)
          return "null";
        if (e === void 0)
          return "undefined";
        var n = typeof e;
        return n === "object" && (Array.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === "Array") ? "array" : n === "object" && (String.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === "String") ? "string" : n;
      }, Pt = function(e) {
        return [
          "undefined",
          "boolean",
          "number",
          "string",
          "function",
          "xml",
          "null"
        ].indexOf(e) !== -1;
      }, yt = function(e, n) {
        var o = Array.prototype.slice.call(e);
        return o.sort(n);
      }, Nt = function(e, n) {
        return Wt(function(o, r) {
          return e.eq(n(o), n(r));
        });
      }, Wt = function(e) {
        return { eq: e };
      }, Fe = Wt(function(e, n) {
        return e === n;
      }), Ee = Fe, Bt = function(e) {
        return Wt(function(n, o) {
          if (n.length !== o.length)
            return !1;
          for (var r = n.length, c = 0; c < r; c++)
            if (!e.eq(n[c], o[c]))
              return !1;
          return !0;
        });
      }, fn = function(e, n) {
        return Nt(Bt(e), function(o) {
          return yt(o, n);
        });
      }, dn = function(e) {
        return Wt(function(n, o) {
          var r = Object.keys(n), c = Object.keys(o);
          if (!fn(Ee).eq(r, c))
            return !1;
          for (var u = r.length, f = 0; f < u; f++) {
            var b = r[f];
            if (!e.eq(n[b], o[b]))
              return !1;
          }
          return !0;
        });
      }, Sn = Wt(function(e, n) {
        if (e === n)
          return !0;
        var o = Ot(e), r = Ot(n);
        return o !== r ? !1 : Pt(o) ? e === n : o === "array" ? Bt(Sn).eq(e, n) : o === "object" ? dn(Sn).eq(e, n) : !1;
      });
      const Ft = Object.getPrototypeOf, Zt = (e, n, o) => {
        var r;
        return o(e, n.prototype) ? !0 : ((r = e.constructor) === null || r === void 0 ? void 0 : r.name) === n.name;
      }, Qt = (e) => {
        const n = typeof e;
        return e === null ? "null" : n === "object" && Array.isArray(e) ? "array" : n === "object" && Zt(e, String, (o, r) => r.isPrototypeOf(o)) ? "string" : n;
      }, En = (e) => (n) => Qt(n) === e, st = (e) => (n) => typeof n === e, Pn = (e) => (n) => e === n, Kt = (e, n) => Qe(e) && Zt(e, n, (o, r) => Ft(o) === r), J = En("string"), Qe = En("object"), xo = (e) => Kt(e, Object), ht = En("array"), U = Pn(null), Tt = st("boolean"), Ht = Pn(void 0), gn = (e) => e == null, De = (e) => !gn(e), re = st("function"), ho = st("number"), Te = (e, n) => {
        if (ht(e)) {
          for (let o = 0, r = e.length; o < r; ++o)
            if (!n(e[o]))
              return !1;
          return !0;
        }
        return !1;
      }, Oe = () => {
      }, A = (e, n) => (...o) => e(n.apply(null, o)), mn = (e, n) => (o) => e(n(o)), it = (e) => () => e, Gn = (e) => e, rn = (e, n) => e === n;
      function Ye(e, ...n) {
        return (...o) => {
          const r = n.concat(o);
          return e.apply(null, r);
        };
      }
      const io = (e) => (n) => !e(n), jo = (e) => () => {
        throw new Error(e);
      }, bt = (e) => e(), kn = (e) => {
        e();
      }, $e = it(!1), ot = it(!0);
      class F {
        constructor(n, o) {
          this.tag = n, this.value = o;
        }
        static some(n) {
          return new F(!0, n);
        }
        static none() {
          return F.singletonNone;
        }
        fold(n, o) {
          return this.tag ? o(this.value) : n();
        }
        isSome() {
          return this.tag;
        }
        isNone() {
          return !this.tag;
        }
        map(n) {
          return this.tag ? F.some(n(this.value)) : F.none();
        }
        bind(n) {
          return this.tag ? n(this.value) : F.none();
        }
        exists(n) {
          return this.tag && n(this.value);
        }
        forall(n) {
          return !this.tag || n(this.value);
        }
        filter(n) {
          return !this.tag || n(this.value) ? this : F.none();
        }
        getOr(n) {
          return this.tag ? this.value : n;
        }
        or(n) {
          return this.tag ? this : n;
        }
        getOrThunk(n) {
          return this.tag ? this.value : n();
        }
        orThunk(n) {
          return this.tag ? this : n();
        }
        getOrDie(n) {
          if (this.tag)
            return this.value;
          throw new Error(n ?? "Called getOrDie on None");
        }
        static from(n) {
          return De(n) ? F.some(n) : F.none();
        }
        getOrNull() {
          return this.tag ? this.value : null;
        }
        getOrUndefined() {
          return this.value;
        }
        each(n) {
          this.tag && n(this.value);
        }
        toArray() {
          return this.tag ? [this.value] : [];
        }
        toString() {
          return this.tag ? `some(${this.value})` : "none()";
        }
      }
      F.singletonNone = new F(!1);
      const ss = Array.prototype.slice, fo = Array.prototype.indexOf, at = Array.prototype.push, lt = (e, n) => fo.call(e, n), Rn = (e, n) => {
        const o = lt(e, n);
        return o === -1 ? F.none() : F.some(o);
      }, ee = (e, n) => lt(e, n) > -1, pe = (e, n) => {
        for (let o = 0, r = e.length; o < r; o++) {
          const c = e[o];
          if (n(c, o))
            return !0;
        }
        return !1;
      }, ye = (e, n) => {
        const o = e.length, r = new Array(o);
        for (let c = 0; c < o; c++) {
          const u = e[c];
          r[c] = n(u, c);
        }
        return r;
      }, ae = (e, n) => {
        for (let o = 0, r = e.length; o < r; o++) {
          const c = e[o];
          n(c, o);
        }
      }, kt = (e, n) => {
        for (let o = e.length - 1; o >= 0; o--) {
          const r = e[o];
          n(r, o);
        }
      }, Vn = (e, n) => {
        const o = [], r = [];
        for (let c = 0, u = e.length; c < u; c++) {
          const f = e[c];
          (n(f, c) ? o : r).push(f);
        }
        return {
          pass: o,
          fail: r
        };
      }, Yt = (e, n) => {
        const o = [];
        for (let r = 0, c = e.length; r < c; r++) {
          const u = e[r];
          n(u, r) && o.push(u);
        }
        return o;
      }, Ct = (e, n, o) => (kt(e, (r, c) => {
        o = n(o, r, c);
      }), o), Xe = (e, n, o) => (ae(e, (r, c) => {
        o = n(o, r, c);
      }), o), In = (e, n, o) => {
        for (let r = 0, c = e.length; r < c; r++) {
          const u = e[r];
          if (n(u, r))
            return F.some(u);
          if (o(u, r))
            break;
        }
        return F.none();
      }, hn = (e, n) => In(e, n, $e), Xn = (e, n) => {
        for (let o = 0, r = e.length; o < r; o++) {
          const c = e[o];
          if (n(c, o))
            return F.some(o);
        }
        return F.none();
      }, Xo = (e) => {
        const n = [];
        for (let o = 0, r = e.length; o < r; ++o) {
          if (!ht(e[o]))
            throw new Error("Arr.flatten item " + o + " was not an array, input: " + e);
          at.apply(n, e[o]);
        }
        return n;
      }, ds = (e, n) => Xo(ye(e, n)), No = (e, n) => {
        for (let o = 0, r = e.length; o < r; ++o) {
          const c = e[o];
          if (n(c, o) !== !0)
            return !1;
        }
        return !0;
      }, Ao = (e) => {
        const n = ss.call(e, 0);
        return n.reverse(), n;
      }, Cs = (e, n) => Yt(e, (o) => !ee(n, o)), Ie = (e, n) => {
        const o = {};
        for (let r = 0, c = e.length; r < c; r++) {
          const u = e[r];
          o[String(u)] = n(u, r);
        }
        return o;
      }, et = (e, n) => {
        const o = ss.call(e, 0);
        return o.sort(n), o;
      }, nn = (e, n) => n >= 0 && n < e.length ? F.some(e[n]) : F.none(), qt = (e) => nn(e, 0), ko = (e) => nn(e, e.length - 1), rs = re(Array.from) ? Array.from : (e) => ss.call(e), Gs = (e, n) => {
        for (let o = 0; o < e.length; o++) {
          const r = n(e[o], o);
          if (r.isSome())
            return r;
        }
        return F.none();
      }, Yr = (e, n) => {
        const o = [], r = re(n) ? (c) => pe(o, (u) => n(u, c)) : (c) => ee(o, c);
        for (let c = 0, u = e.length; c < u; c++) {
          const f = e[c];
          r(f) || o.push(f);
        }
        return o;
      }, Ss = Object.keys, or = Object.hasOwnProperty, Dt = (e, n) => {
        const o = Ss(e);
        for (let r = 0, c = o.length; r < c; r++) {
          const u = o[r], f = e[u];
          n(f, u);
        }
      }, Lo = (e, n) => Or(e, (o, r) => ({
        k: r,
        v: n(o, r)
      })), Or = (e, n) => {
        const o = {};
        return Dt(e, (r, c) => {
          const u = n(r, c);
          o[u.k] = u.v;
        }), o;
      }, aa = (e) => (n, o) => {
        e[o] = n;
      }, Xr = (e, n, o, r) => {
        Dt(e, (c, u) => {
          (n(c, u) ? o : r)(c, u);
        });
      }, Jr = (e, n) => {
        const o = {}, r = {};
        return Xr(e, n, aa(o), aa(r)), {
          t: o,
          f: r
        };
      }, xs = (e, n) => {
        const o = {};
        return Xr(e, n, aa(o), Oe), o;
      }, fa = (e, n) => {
        const o = [];
        return Dt(e, (r, c) => {
          o.push(n(r, c));
        }), o;
      }, Qr = (e) => fa(e, Gn), Ts = (e, n) => Zn(e, n) ? F.from(e[n]) : F.none(), Zn = (e, n) => or.call(e, n), dr = (e, n) => Zn(e, n) && e[n] !== void 0 && e[n] !== null, ga = (e, n, o = Sn) => dn(o).eq(e, n), Za = (e) => {
        const n = {};
        return ae(e, (o) => {
          n[o] = {};
        }), Ss(n);
      }, _c = (e) => e.length !== void 0, sr = Array.isArray, Ks = (e) => {
        if (sr(e))
          return e;
        {
          const n = [];
          for (let o = 0, r = e.length; o < r; o++)
            n[o] = e[o];
          return n;
        }
      }, Vs = (e, n, o) => {
        if (!e)
          return !1;
        if (o = o || e, _c(e)) {
          for (let r = 0, c = e.length; r < c; r++)
            if (n.call(o, e[r], r, e) === !1)
              return !1;
        } else
          for (const r in e)
            if (Zn(e, r) && n.call(o, e[r], r, e) === !1)
              return !1;
        return !0;
      }, Sa = (e, n) => {
        const o = [];
        return Vs(e, (r, c) => {
          o.push(n(r, c, e));
        }), o;
      }, rc = (e, n) => {
        const o = [];
        return Vs(e, (r, c) => {
          (!n || n(r, c, e)) && o.push(r);
        }), o;
      }, wr = (e, n) => {
        if (e) {
          for (let o = 0, r = e.length; o < r; o++)
            if (e[o] === n)
              return o;
        }
        return -1;
      }, de = (e, n, o, r) => {
        let c = Ht(o) ? e[0] : o;
        for (let u = 0; u < e.length; u++)
          c = n.call(r, c, e[u], u);
        return c;
      }, ie = (e, n, o) => {
        for (let r = 0, c = e.length; r < c; r++)
          if (n.call(o, e[r], r, e))
            return r;
        return -1;
      }, ze = (e) => e[e.length - 1], Je = (e) => {
        let n = !1, o;
        return (...r) => (n || (n = !0, o = e.apply(null, r)), o);
      }, Nn = (e, n, o, r) => {
        const c = e.isiOS() && /ipad/i.test(o) === !0, u = e.isiOS() && !c, f = e.isiOS() || e.isAndroid(), b = f || r("(pointer:coarse)"), y = c || !u && f && r("(min-device-width:768px)"), E = u || f && !y, N = n.isSafari() && e.isiOS() && /safari/i.test(o) === !1, M = !E && !y && !N;
        return {
          isiPad: it(c),
          isiPhone: it(u),
          isTablet: it(y),
          isPhone: it(E),
          isTouch: it(b),
          isAndroid: e.isAndroid,
          isiOS: e.isiOS,
          isWebView: it(N),
          isDesktop: it(M)
        };
      }, Wn = (e, n) => {
        for (let o = 0; o < e.length; o++) {
          const r = e[o];
          if (r.test(n))
            return r;
        }
      }, _o = (e, n) => {
        const o = Wn(e, n);
        if (!o)
          return {
            major: 0,
            minor: 0
          };
        const r = (c) => Number(n.replace(o, "$" + c));
        return go(r(1), r(2));
      }, Fs = (e, n) => {
        const o = String(n).toLowerCase();
        return e.length === 0 ? ve() : _o(e, o);
      }, ve = () => go(0, 0), go = (e, n) => ({
        major: e,
        minor: n
      }), ue = {
        nu: go,
        detect: Fs,
        unknown: ve
      }, he = (e, n) => Gs(n.brands, (o) => {
        const r = o.brand.toLowerCase();
        return hn(e, (c) => {
          var u;
          return r === ((u = c.brand) === null || u === void 0 ? void 0 : u.toLowerCase());
        }).map((c) => ({
          current: c.name,
          version: ue.nu(parseInt(o.version, 10), 0)
        }));
      }), dt = (e, n) => {
        const o = String(n).toLowerCase();
        return hn(e, (r) => r.search(o));
      }, wt = (e, n) => dt(e, n).map((o) => {
        const r = ue.detect(o.versionRegexes, n);
        return {
          current: o.name,
          version: r
        };
      }), on = (e, n) => dt(e, n).map((o) => {
        const r = ue.detect(o.versionRegexes, n);
        return {
          current: o.name,
          version: r
        };
      }), Ln = (e, n) => e.substring(n), On = (e, n, o) => n === "" || e.length >= n.length && e.substr(o, o + n.length) === n, Dn = (e, n) => Kn(e, n) ? Ln(e, n.length) : e, Mn = (e, n, o = 0, r) => {
        const c = e.indexOf(n, o);
        return c !== -1 ? Ht(r) ? !0 : c + n.length <= r : !1;
      }, Kn = (e, n) => On(e, n, 0), zo = (e, n) => On(e, n, e.length - n.length), Ds = (e) => (n) => n.replace(e, ""), Ra = Ds(/^\s+|\s+$/g), ac = Ds(/^\s+/g), vc = Ds(/\s+$/g), lo = (e) => e.length > 0, Fo = (e) => !lo(e), ms = (e, n) => n <= 0 ? "" : new Array(n + 1).join(e), xa = (e, n = 10) => {
        const o = parseInt(e, n);
        return isNaN(o) ? F.none() : F.some(o);
      }, zr = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/, mr = (e) => (n) => Mn(n, e), Hs = [
        {
          name: "Edge",
          versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
          search: (e) => Mn(e, "edge/") && Mn(e, "chrome") && Mn(e, "safari") && Mn(e, "applewebkit")
        },
        {
          name: "Chromium",
          brand: "Chromium",
          versionRegexes: [
            /.*?chrome\/([0-9]+)\.([0-9]+).*/,
            zr
          ],
          search: (e) => Mn(e, "chrome") && !Mn(e, "chromeframe")
        },
        {
          name: "IE",
          versionRegexes: [
            /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
            /.*?rv:([0-9]+)\.([0-9]+).*/
          ],
          search: (e) => Mn(e, "msie") || Mn(e, "trident")
        },
        {
          name: "Opera",
          versionRegexes: [
            zr,
            /.*?opera\/([0-9]+)\.([0-9]+).*/
          ],
          search: mr("opera")
        },
        {
          name: "Firefox",
          versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
          search: mr("firefox")
        },
        {
          name: "Safari",
          versionRegexes: [
            zr,
            /.*?cpu os ([0-9]+)_([0-9]+).*/
          ],
          search: (e) => (Mn(e, "safari") || Mn(e, "mobile/")) && Mn(e, "applewebkit")
        }
      ], Fa = [
        {
          name: "Windows",
          search: mr("win"),
          versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
        },
        {
          name: "iOS",
          search: (e) => Mn(e, "iphone") || Mn(e, "ipad"),
          versionRegexes: [
            /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
            /.*cpu os ([0-9]+)_([0-9]+).*/,
            /.*cpu iphone os ([0-9]+)_([0-9]+).*/
          ]
        },
        {
          name: "Android",
          search: mr("android"),
          versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
        },
        {
          name: "macOS",
          search: mr("mac os x"),
          versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
        },
        {
          name: "Linux",
          search: mr("linux"),
          versionRegexes: []
        },
        {
          name: "Solaris",
          search: mr("sunos"),
          versionRegexes: []
        },
        {
          name: "FreeBSD",
          search: mr("freebsd"),
          versionRegexes: []
        },
        {
          name: "ChromeOS",
          search: mr("cros"),
          versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
        }
      ], nl = {
        browsers: it(Hs),
        oses: it(Fa)
      }, Rs = "Edge", ca = "Chromium", Ia = "IE", Pr = "Opera", yc = "Firefox", Uc = "Safari", Ta = () => Ac({
        current: void 0,
        version: ue.unknown()
      }), Ac = (e) => {
        const n = e.current, o = e.version, r = (c) => () => n === c;
        return {
          current: n,
          version: o,
          isEdge: r(Rs),
          isChromium: r(ca),
          isIE: r(Ia),
          isOpera: r(Pr),
          isFirefox: r(yc),
          isSafari: r(Uc)
        };
      }, Oc = {
        unknown: Ta,
        nu: Ac
      }, vu = "Windows", Dc = "iOS", yl = "Android", ja = "Linux", wi = "macOS", Bi = "Solaris", Cl = "FreeBSD", Ju = "ChromeOS", Z = () => fe({
        current: void 0,
        version: ue.unknown()
      }), fe = (e) => {
        const n = e.current, o = e.version, r = (c) => () => n === c;
        return {
          current: n,
          version: o,
          isWindows: r(vu),
          isiOS: r(Dc),
          isAndroid: r(yl),
          isMacOS: r(wi),
          isLinux: r(ja),
          isSolaris: r(Bi),
          isFreeBSD: r(Cl),
          isChromeOS: r(Ju)
        };
      }, _e = {
        unknown: Z,
        nu: fe
      }, Rt = { detect: (e, n, o) => {
        const r = nl.browsers(), c = nl.oses(), u = n.bind((y) => he(r, y)).orThunk(() => wt(r, e)).fold(Oc.unknown, Oc.nu), f = on(c, e).fold(_e.unknown, _e.nu), b = Nn(f, u, e, o);
        return {
          browser: u,
          os: f,
          deviceType: b
        };
      } }, eo = (e) => window.matchMedia(e).matches;
      let Ns = Je(() => Rt.detect(navigator.userAgent, F.from(navigator.userAgentData), eo));
      const Is = () => Ns(), Os = navigator.userAgent, Ys = Is(), qo = Ys.browser, fr = Ys.os, Na = Ys.deviceType, ol = Os.indexOf("Windows Phone") !== -1, sn = {
        transparentSrc: "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        documentMode: qo.isIE() ? document.documentMode || 7 : 10,
        cacheSuffix: null,
        container: null,
        canHaveCSP: !qo.isIE(),
        windowsPhone: ol,
        browser: {
          current: qo.current,
          version: qo.version,
          isChromium: qo.isChromium,
          isEdge: qo.isEdge,
          isFirefox: qo.isFirefox,
          isIE: qo.isIE,
          isOpera: qo.isOpera,
          isSafari: qo.isSafari
        },
        os: {
          current: fr.current,
          version: fr.version,
          isAndroid: fr.isAndroid,
          isChromeOS: fr.isChromeOS,
          isFreeBSD: fr.isFreeBSD,
          isiOS: fr.isiOS,
          isLinux: fr.isLinux,
          isMacOS: fr.isMacOS,
          isSolaris: fr.isSolaris,
          isWindows: fr.isWindows
        },
        deviceType: {
          isDesktop: Na.isDesktop,
          isiPad: Na.isiPad,
          isiPhone: Na.isiPhone,
          isPhone: Na.isPhone,
          isTablet: Na.isTablet,
          isTouch: Na.isTouch,
          isWebView: Na.isWebView
        }
      }, Ql = /^\s*|\s*$/g, rr = (e) => gn(e) ? "" : ("" + e).replace(Ql, ""), B = (e, n) => n ? n === "array" && sr(e) ? !0 : typeof e === n : e !== void 0, K = (e, n, o = {}) => {
        const r = J(e) ? e.split(n || ",") : e || [];
        let c = r.length;
        for (; c--; )
          o[r[c]] = {};
        return o;
      }, se = Zn, Ue = (e, ...n) => {
        for (let o = 0; o < n.length; o++) {
          const r = n[o];
          for (const c in r)
            if (Zn(r, c)) {
              const u = r[c];
              u !== void 0 && (e[c] = u);
            }
        }
        return e;
      }, en = function(e, n, o, r) {
        r = r || this, e && (o && (e = e[o]), Vs(e, (c, u) => n.call(r, c, u, o) === !1 ? !1 : (en(c, n, o, r), !0)));
      }, _t = {
        trim: rr,
        isArray: sr,
        is: B,
        toArray: Ks,
        makeMap: K,
        each: Vs,
        map: Sa,
        grep: rc,
        inArray: wr,
        hasOwn: se,
        extend: Ue,
        walk: en,
        resolve: (e, n = window) => {
          const o = e.split(".");
          for (let r = 0, c = o.length; r < c && (n = n[o[r]], !!n); r++)
            ;
          return n;
        },
        explode: (e, n) => ht(e) ? e : e === "" ? [] : Sa(e.split(n || ","), rr),
        _addCacheSuffix: (e) => {
          const n = sn.cacheSuffix;
          return n && (e += (e.indexOf("?") === -1 ? "?" : "&") + n), e;
        }
      }, Us = (e, n, o = rn) => e.exists((r) => o(r, n)), qa = (e, n, o = rn) => Zr(e, n, o).getOr(e.isNone() && n.isNone()), Xs = (e) => {
        const n = [], o = (r) => {
          n.push(r);
        };
        for (let r = 0; r < e.length; r++)
          e[r].each(o);
        return n;
      }, Zr = (e, n, o) => e.isSome() && n.isSome() ? F.some(o(e.getOrDie(), n.getOrDie())) : F.none(), ri = (e, n, o, r) => e.isSome() && n.isSome() && o.isSome() ? F.some(r(e.getOrDie(), n.getOrDie(), o.getOrDie())) : F.none(), Jo = (e, n) => e ? F.some(n) : F.none(), Ga = typeof window < "u" ? window : Function("return this;")(), ar = (e, n) => {
        let o = n ?? Ga;
        for (let r = 0; r < e.length && o !== void 0 && o !== null; ++r)
          o = o[e[r]];
        return o;
      }, $i = (e, n) => {
        const o = e.split(".");
        return ar(o, n);
      }, hr = (e, n) => $i(e, n), yu = (e, n) => {
        const o = hr(e, n);
        if (o == null)
          throw new Error(e + " not available on this browser");
        return o;
      }, um = Object.getPrototypeOf, Xm = (e) => yu("HTMLElement", e), Es = (e) => {
        const n = $i("ownerDocument.defaultView", e);
        return Qe(e) && (Xm(n).prototype.isPrototypeOf(e) || /^HTML\w*Element$/.test(um(e).constructor.name));
      }, ai = 8, Fi = 9, Cc = 11, Rc = 1, Qu = 3, Qo = (e) => e.dom.nodeName.toLowerCase(), j = (e) => e.dom.nodeType, oe = (e) => (n) => j(n) === e, Le = (e) => j(e) === ai || Qo(e) === "#comment", je = (e) => yn(e) && Es(e.dom), yn = oe(Rc), vo = oe(Qu), Dr = oe(Fi), Ka = oe(Cc), pr = (e) => (n) => yn(n) && Qo(n) === e, cc = (e, n, o) => {
        if (J(o) || Tt(o) || ho(o))
          e.setAttribute(n, o + "");
        else
          throw new Error("Attribute value was not simple");
      }, ks = (e, n, o) => {
        cc(e.dom, n, o);
      }, Br = (e, n) => {
        const o = e.dom;
        Dt(n, (r, c) => {
          cc(o, c, r);
        });
      }, ia = (e, n) => {
        const o = e.dom.getAttribute(n);
        return o === null ? void 0 : o;
      }, wc = (e, n) => F.from(ia(e, n)), ea = (e, n) => {
        const o = e.dom;
        return o && o.hasAttribute ? o.hasAttribute(n) : !1;
      }, _r = (e, n) => {
        e.dom.removeAttribute(n);
      }, Vr = (e) => {
        const n = e.dom.attributes;
        return n == null || n.length === 0;
      }, Nc = (e) => Xe(e.dom.attributes, (n, o) => (n[o.name] = o.value, n), {}), Ii = (e, n) => {
        const o = ia(e, n);
        return o === void 0 || o === "" ? [] : o.split(" ");
      }, Jm = (e, n, o) => {
        const c = Ii(e, n).concat([o]);
        return ks(e, n, c.join(" ")), !0;
      }, Qm = (e, n, o) => {
        const r = Yt(Ii(e, n), (c) => c !== o);
        return r.length > 0 ? ks(e, n, r.join(" ")) : _r(e, n), !1;
      }, Wc = (e) => e.dom.classList !== void 0, ef = (e) => Ii(e, "class"), Zc = (e, n) => Jm(e, "class", n), wl = (e, n) => Qm(e, "class", n), tf = (e, n) => ee(ef(e), n) ? wl(e, n) : Zc(e, n), Cu = (e, n) => {
        Wc(e) ? e.dom.classList.add(n) : Zc(e, n);
      }, dm = (e) => {
        (Wc(e) ? e.dom.classList : ef(e)).length === 0 && _r(e, "class");
      }, Sl = (e, n) => {
        Wc(e) ? e.dom.classList.remove(n) : wl(e, n), dm(e);
      }, oh = (e, n) => {
        const o = Wc(e) ? e.dom.classList.toggle(n) : tf(e, n);
        return dm(e), o;
      }, wu = (e, n) => Wc(e) && e.dom.classList.contains(n), sh = (e, n) => {
        const r = (n || document).createElement("div");
        if (r.innerHTML = e, !r.hasChildNodes() || r.childNodes.length > 1) {
          const c = "HTML does not have a single root node";
          throw new Error(c);
        }
        return Ad(r.childNodes[0]);
      }, rh = (e, n) => {
        const r = (n || document).createElement(e);
        return Ad(r);
      }, ah = (e, n) => {
        const r = (n || document).createTextNode(e);
        return Ad(r);
      }, Ad = (e) => {
        if (e == null)
          throw new Error("Node cannot be null or undefined");
        return { dom: e };
      }, le = {
        fromHtml: sh,
        fromTag: rh,
        fromText: ah,
        fromDom: Ad,
        fromPoint: (e, n, o) => F.from(e.dom.elementFromPoint(n, o)).map(Ad)
      }, Su = (e, n) => {
        const o = [], r = (u) => (o.push(u), n(u));
        let c = n(e);
        do
          c = c.bind(r);
        while (c.isSome());
        return o;
      }, Si = (e, n) => {
        const o = e.dom;
        if (o.nodeType !== Rc)
          return !1;
        {
          const r = o;
          if (r.matches !== void 0)
            return r.matches(n);
          if (r.msMatchesSelector !== void 0)
            return r.msMatchesSelector(n);
          if (r.webkitMatchesSelector !== void 0)
            return r.webkitMatchesSelector(n);
          if (r.mozMatchesSelector !== void 0)
            return r.mozMatchesSelector(n);
          throw new Error("Browser lacks native selectors");
        }
      }, Od = (e) => e.nodeType !== Rc && e.nodeType !== Fi && e.nodeType !== Cc || e.childElementCount === 0, tg = (e, n) => {
        const o = n === void 0 ? document : n.dom;
        return Od(o) ? [] : ye(o.querySelectorAll(e), le.fromDom);
      }, s1 = (e, n) => {
        const o = n === void 0 ? document : n.dom;
        return Od(o) ? F.none() : F.from(o.querySelector(e)).map(le.fromDom);
      }, fs = (e, n) => e.dom === n.dom, ic = (e, n) => {
        const o = e.dom, r = n.dom;
        return o === r ? !1 : o.contains(r);
      }, xl = (e) => le.fromDom(e.dom.ownerDocument), xi = (e) => Dr(e) ? e : xl(e), xu = (e) => le.fromDom(xi(e).dom.documentElement), sl = (e) => le.fromDom(xi(e).dom.defaultView), lc = (e) => F.from(e.dom.parentNode).map(le.fromDom), Tl = (e) => F.from(e.dom.parentElement).map(le.fromDom), ch = (e, n) => {
        const o = re(n) ? n : $e;
        let r = e.dom;
        const c = [];
        for (; r.parentNode !== null && r.parentNode !== void 0; ) {
          const u = r.parentNode, f = le.fromDom(u);
          if (c.push(f), o(f) === !0)
            break;
          r = u;
        }
        return c;
      }, r1 = (e) => {
        const n = (o) => Yt(o, (r) => !fs(e, r));
        return lc(e).map(Ea).map(n).getOr([]);
      }, Li = (e) => F.from(e.dom.previousSibling).map(le.fromDom), El = (e) => F.from(e.dom.nextSibling).map(le.fromDom), ng = (e) => Ao(Su(e, Li)), Sc = (e) => Su(e, El), Ea = (e) => ye(e.dom.childNodes, le.fromDom), ed = (e, n) => {
        const o = e.dom.childNodes;
        return F.from(o[n]).map(le.fromDom);
      }, mm = (e) => ed(e, 0), rl = (e) => ed(e, e.dom.childNodes.length - 1), Mc = (e) => e.dom.childNodes.length, ih = (e) => e.dom.hasChildNodes(), a1 = (e) => {
        const n = e.dom.head;
        if (n == null)
          throw new Error("Head is not available yet");
        return le.fromDom(n);
      }, nf = (e) => Ka(e) && De(e.dom.host), of = re(Element.prototype.attachShadow) && re(Node.prototype.getRootNode), Dd = it(of), kl = of ? (e) => le.fromDom(e.dom.getRootNode()) : xi, lh = (e) => nf(e) ? e : a1(xi(e)), Yb = (e) => nf(e) ? e : le.fromDom(xi(e).dom.body), og = (e) => {
        const n = kl(e);
        return nf(n) ? F.some(n) : F.none();
      }, c1 = (e) => le.fromDom(e.dom.host), Tu = (e) => {
        if (Dd() && De(e.target)) {
          const n = le.fromDom(e.target);
          if (yn(n) && sg(n) && e.composed && e.composedPath) {
            const o = e.composedPath();
            if (o)
              return qt(o);
          }
        }
        return F.from(e.target);
      }, sg = (e) => De(e.dom.shadowRoot), td = (e) => {
        const n = vo(e) ? e.dom.parentNode : e.dom;
        if (n == null || n.ownerDocument === null)
          return !1;
        const o = n.ownerDocument;
        return og(le.fromDom(n)).fold(() => o.body.contains(n), mn(td, c1));
      };
      var Rr = (e, n, o, r, c) => e(o, r) ? F.some(o) : re(c) && c(o) ? F.none() : n(o, r, c);
      const Ar = (e, n, o) => {
        let r = e.dom;
        const c = re(o) ? o : $e;
        for (; r.parentNode; ) {
          r = r.parentNode;
          const u = le.fromDom(r);
          if (n(u))
            return F.some(u);
          if (c(u))
            break;
        }
        return F.none();
      }, ci = (e, n, o) => Rr((c, u) => u(c), Ar, e, n, o), sf = (e, n) => {
        const o = e.dom;
        return o.parentNode ? uh(le.fromDom(o.parentNode), (r) => !fs(e, r) && n(r)) : F.none();
      }, uh = (e, n) => {
        const o = (c) => n(le.fromDom(c));
        return hn(e.dom.childNodes, o).map(le.fromDom);
      }, La = (e, n) => {
        const o = (r) => {
          for (let c = 0; c < r.childNodes.length; c++) {
            const u = le.fromDom(r.childNodes[c]);
            if (n(u))
              return F.some(u);
            const f = o(r.childNodes[c]);
            if (f.isSome())
              return f;
          }
          return F.none();
        };
        return o(e.dom);
      }, _l = (e, n, o) => Ar(e, (r) => Si(r, n), o), ii = (e, n) => s1(n, e), Hi = (e, n, o) => Rr((c, u) => Si(c, u), _l, e, n, o), dh = (e) => Hi(e, "[contenteditable]"), Mo = (e, n = !1) => td(e) ? e.dom.isContentEditable : dh(e).fold(it(n), (o) => jc(o) === "true"), jc = (e) => e.dom.contentEditable, Eu = (e) => e.style !== void 0 && re(e.style.getPropertyValue), nd = (e, n, o) => {
        if (!J(o))
          throw new Error("CSS value must be a string: " + o);
        Eu(e) && e.style.setProperty(n, o);
      }, rg = (e, n) => {
        Eu(e) && e.style.removeProperty(n);
      }, rf = (e, n, o) => {
        const r = e.dom;
        nd(r, n, o);
      }, Ya = (e, n) => {
        const o = e.dom;
        Dt(n, (r, c) => {
          nd(o, c, r);
        });
      }, ha = (e, n) => {
        const o = e.dom, c = window.getComputedStyle(o).getPropertyValue(n);
        return c === "" && !td(e) ? li(o, n) : c;
      }, li = (e, n) => Eu(e) ? e.style.getPropertyValue(n) : "", ta = (e, n) => {
        const o = e.dom, r = li(o, n);
        return F.from(r).filter((c) => c.length > 0);
      }, fm = (e) => {
        const n = {}, o = e.dom;
        if (Eu(o))
          for (let r = 0; r < o.style.length; r++) {
            const c = o.style.item(r);
            n[c] = o.style[c];
          }
        return n;
      }, od = (e, n) => {
        const o = e.dom;
        rg(o, n), Us(wc(e, "style").map(Ra), "") && _r(e, "style");
      }, na = (e) => e.dom.offsetWidth, ka = (e, n) => {
        lc(e).each((r) => {
          r.dom.insertBefore(n.dom, e.dom);
        });
      }, Ti = (e, n) => {
        El(e).fold(() => {
          lc(e).each((c) => {
            la(c, n);
          });
        }, (r) => {
          ka(r, n);
        });
      }, gm = (e, n) => {
        mm(e).fold(() => {
          la(e, n);
        }, (r) => {
          e.dom.insertBefore(n.dom, r.dom);
        });
      }, la = (e, n) => {
        e.dom.appendChild(n.dom);
      }, ag = (e, n) => {
        ka(e, n), la(n, e);
      }, af = (e, n) => {
        ae(n, (o, r) => {
          const c = r === 0 ? e : n[r - 1];
          Ti(c, o);
        });
      }, Ms = (e, n) => {
        ae(n, (o) => {
          la(e, o);
        });
      }, Ei = (e) => {
        e.dom.textContent = "", ae(Ea(e), (n) => {
          bs(n);
        });
      }, bs = (e) => {
        const n = e.dom;
        n.parentNode !== null && n.parentNode.removeChild(n);
      }, qc = (e) => {
        const n = Ea(e);
        n.length > 0 && af(e, n), bs(e);
      }, ku = (e, n) => {
        const r = (n || document).createElement("div");
        return r.innerHTML = e, Ea(le.fromDom(r));
      }, _u = (e) => ye(e, le.fromDom), Wo = (e) => e.dom.innerHTML, sd = (e, n) => {
        const r = xl(e).dom, c = le.fromDom(r.createDocumentFragment()), u = ku(n, r);
        Ms(c, u), Ei(e), la(e, c);
      }, mh = (e) => {
        const n = le.fromTag("div"), o = le.fromDom(e.dom.cloneNode(!0));
        return la(n, o), Wo(n);
      }, cg = (e, n, o, r, c, u, f) => ({
        target: e,
        x: n,
        y: o,
        stop: r,
        prevent: c,
        kill: u,
        raw: f
      }), fh = (e) => {
        const n = le.fromDom(Tu(e).getOr(e.target)), o = () => e.stopPropagation(), r = () => e.preventDefault(), c = A(r, o);
        return cg(n, e.clientX, e.clientY, o, r, c, e);
      }, ig = (e, n) => (o) => {
        e(o) && n(fh(o));
      }, i1 = (e, n, o, r, c) => {
        const u = ig(o, r);
        return e.dom.addEventListener(n, u, c), { unbind: Ye(lg, e, n, u, c) };
      }, Rd = (e, n, o, r) => i1(e, n, o, r, !1), lg = (e, n, o, r) => {
        e.dom.removeEventListener(n, o, r);
      }, x = (e, n) => ({
        left: e,
        top: n,
        translate: (r, c) => x(e + r, n + c)
      }), R = x, z = (e) => {
        const n = e.getBoundingClientRect();
        return R(n.left, n.top);
      }, ce = (e, n) => e !== void 0 ? e : n !== void 0 ? n : 0, be = (e) => {
        const n = e.dom.ownerDocument, o = n.body, r = n.defaultView, c = n.documentElement;
        if (o === e.dom)
          return R(o.offsetLeft, o.offsetTop);
        const u = ce(r?.pageYOffset, c.scrollTop), f = ce(r?.pageXOffset, c.scrollLeft), b = ce(c.clientTop, o.clientTop), y = ce(c.clientLeft, o.clientLeft);
        return At(e).translate(f - y, u - b);
      }, At = (e) => {
        const n = e.dom, r = n.ownerDocument.body;
        return r === n ? R(r.offsetLeft, r.offsetTop) : td(e) ? z(n) : R(0, 0);
      }, Bn = (e) => {
        const n = e !== void 0 ? e.dom : document, o = n.body.scrollLeft || n.documentElement.scrollLeft, r = n.body.scrollTop || n.documentElement.scrollTop;
        return R(o, r);
      }, To = (e, n, o) => {
        const c = (o !== void 0 ? o.dom : document).defaultView;
        c && c.scrollTo(e, n);
      }, Co = (e, n) => {
        Is().browser.isSafari() && re(e.dom.scrollIntoViewIfNeeded) ? e.dom.scrollIntoViewIfNeeded(!1) : e.dom.scrollIntoView(n);
      }, ao = (e) => {
        const n = e === void 0 ? window : e;
        return Is().browser.isFirefox() ? F.none() : F.from(n.visualViewport);
      }, Nr = (e, n, o, r) => ({
        x: e,
        y: n,
        width: o,
        height: r,
        right: e + o,
        bottom: n + r
      }), Ma = (e) => {
        const n = e === void 0 ? window : e, o = n.document, r = Bn(le.fromDom(o));
        return ao(n).fold(() => {
          const c = n.document.documentElement, u = c.clientWidth, f = c.clientHeight;
          return Nr(r.left, r.top, u, f);
        }, (c) => Nr(Math.max(c.pageLeft, r.left), Math.max(c.pageTop, r.top), c.width, c.height));
      }, ki = (e, n) => Yt(Ea(e), n), eu = (e, n) => {
        let o = [];
        return ae(Ea(e), (r) => {
          n(r) && (o = o.concat([r])), o = o.concat(eu(r, n));
        }), o;
      }, uc = (e, n) => tg(n, e), by = (e, n, o) => _l(e, n, o).isSome();
      class br {
        constructor(n, o) {
          this.node = n, this.rootNode = o, this.current = this.current.bind(this), this.next = this.next.bind(this), this.prev = this.prev.bind(this), this.prev2 = this.prev2.bind(this);
        }
        current() {
          return this.node;
        }
        next(n) {
          return this.node = this.findSibling(this.node, "firstChild", "nextSibling", n), this.node;
        }
        prev(n) {
          return this.node = this.findSibling(this.node, "lastChild", "previousSibling", n), this.node;
        }
        prev2(n) {
          return this.node = this.findPreviousNode(this.node, n), this.node;
        }
        findSibling(n, o, r, c) {
          if (n) {
            if (!c && n[o])
              return n[o];
            if (n !== this.rootNode) {
              let u = n[r];
              if (u)
                return u;
              for (let f = n.parentNode; f && f !== this.rootNode; f = f.parentNode)
                if (u = f[r], u)
                  return u;
            }
          }
        }
        findPreviousNode(n, o) {
          if (n) {
            const r = n.previousSibling;
            if (this.rootNode && r === this.rootNode)
              return;
            if (r) {
              if (!o) {
                for (let u = r.lastChild; u; u = u.lastChild)
                  if (!u.lastChild)
                    return u;
              }
              return r;
            }
            const c = n.parentNode;
            if (c && c !== this.rootNode)
              return c;
          }
        }
      }
      const jn = (e) => (n) => !!n && n.nodeType === e, tu = (e) => !!e && !Object.getPrototypeOf(e), xn = jn(1), Au = (e) => xn(e) && je(le.fromDom(e)), vy = (e) => xn(e) && e.namespaceURI === "http://www.w3.org/2000/svg", Ou = (e) => {
        const n = e.toLowerCase();
        return (o) => De(o) && o.nodeName.toLowerCase() === n;
      }, ua = (e) => {
        const n = e.map((o) => o.toLowerCase());
        return (o) => {
          if (o && o.nodeName) {
            const r = o.nodeName.toLowerCase();
            return ee(n, r);
          }
          return !1;
        };
      }, hm = (e, n) => {
        const o = n.toLowerCase().split(" ");
        return (r) => {
          if (xn(r)) {
            const c = r.ownerDocument.defaultView;
            if (c)
              for (let u = 0; u < o.length; u++) {
                const f = c.getComputedStyle(r, null);
                if ((f ? f.getPropertyValue(e) : null) === o[u])
                  return !0;
              }
          }
          return !1;
        };
      }, ug = (e) => (n) => xn(n) && n.hasAttribute(e), Xa = (e, n) => (o) => xn(o) && o.getAttribute(e) === n, nu = (e) => xn(e) && e.hasAttribute("data-mce-bogus"), gh = (e) => xn(e) && e.getAttribute("data-mce-bogus") === "all", Du = (e) => xn(e) && e.tagName === "TABLE", l1 = (e) => (n) => !!(Au(n) && (n.contentEditable === e || n.getAttribute("data-mce-contenteditable") === e)), hh = ua([
        "textarea",
        "input"
      ]), Mt = jn(3), Xb = jn(4), Nd = jn(7), rd = jn(8), dg = jn(9), $r = jn(11), Js = Ou("br"), Gc = Ou("img"), Kc = l1("true"), es = l1("false"), mg = ua([
        "td",
        "th"
      ]), dc = ua([
        "td",
        "th",
        "caption"
      ]), oa = ua([
        "video",
        "audio",
        "object",
        "embed"
      ]), ph = Ou("li"), gt = Ou("details"), _i = Ou("summary"), fg = "\uFEFF", _s = " ", Al = (e) => e === fg, yy = (e) => e.replace(/\uFEFF/g, ""), bh = ((e, n) => {
        const o = (u) => {
          if (!e(u))
            throw new Error("Can only get " + n + " value of a " + n + " node");
          return r(u).getOr("");
        }, r = (u) => e(u) ? F.from(u.dom.nodeValue) : F.none();
        return {
          get: o,
          getOption: r,
          set: (u, f) => {
            if (!e(u))
              throw new Error("Can only set raw " + n + " value of a " + n + " node");
            u.dom.nodeValue = f;
          }
        };
      })(vo, "text"), su = (e) => bh.get(e), u1 = (e) => bh.getOption(e), zi = (e, n) => bh.set(e, n), $s = [
        "td",
        "th"
      ], Ru = [
        "thead",
        "tbody",
        "tfoot"
      ], pm = [
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "p",
        "div",
        "address",
        "pre",
        "form",
        "blockquote",
        "center",
        "dir",
        "fieldset",
        "header",
        "footer",
        "article",
        "section",
        "hgroup",
        "aside",
        "nav",
        "figure"
      ], mc = [
        "li",
        "dd",
        "dt"
      ], d1 = [
        "ul",
        "ol",
        "dl"
      ], bm = [
        "pre",
        "script",
        "textarea",
        "style"
      ], Md = (e) => {
        let n;
        return (o) => (n = n || Ie(e, ot), Zn(n, Qo(o)));
      }, ui = (e) => Qo(e) === "table", Pd = (e) => yn(e) && Qo(e) === "br", Ne = Md(pm), Pc = Md(d1), al = Md(mc), ru = Md(Ru), Ai = Md($s), Pa = Md(bm), _a = (e) => {
        const n = [];
        let o = e.dom;
        for (; o; )
          n.push(le.fromDom(o)), o = o.lastChild;
        return n;
      }, Nw = (e) => {
        const n = uc(e, "br"), o = Yt(_a(e).slice(-1), Pd);
        n.length === o.length && ae(o, bs);
      }, di = () => {
        const e = le.fromTag("br");
        return ks(e, "data-mce-bogus", "1"), e;
      }, Nu = (e) => {
        Ei(e), la(e, di());
      }, w = (e, n) => {
        rl(e).each((o) => {
          Li(o).each((r) => {
            n.isBlock(Qo(e)) && Pd(o) && n.isBlock(Qo(r)) && bs(o);
          });
        });
      }, k = fg, H = Al, q = yy, we = (e) => e.insertContent(k, { preserve_zwsp: !0 }), rt = xn, $t = Mt, pn = (e) => ($t(e) && (e = e.parentNode), rt(e) && e.hasAttribute("data-mce-caret")), oo = (e) => $t(e) && H(e.data), Jn = (e) => pn(e) || oo(e), Fr = (e) => e.firstChild !== e.lastChild || !Js(e.firstChild), Sr = (e, n) => {
        var o;
        const c = ((o = e.ownerDocument) !== null && o !== void 0 ? o : document).createTextNode(k), u = e.parentNode;
        if (n) {
          const f = e.previousSibling;
          if ($t(f)) {
            if (Jn(f))
              return f;
            if (Ol(f))
              return f.splitText(f.data.length - 1);
          }
          u?.insertBefore(c, e);
        } else {
          const f = e.nextSibling;
          if ($t(f)) {
            if (Jn(f))
              return f;
            if (Vi(f))
              return f.splitText(1), f;
          }
          e.nextSibling ? u?.insertBefore(c, e.nextSibling) : u?.appendChild(c);
        }
        return c;
      }, Ws = (e) => {
        const n = e.container();
        return Mt(n) ? n.data.charAt(e.offset()) === k || e.isAtStart() && oo(n.previousSibling) : !1;
      }, Yc = (e) => {
        const n = e.container();
        return Mt(n) ? n.data.charAt(e.offset() - 1) === k || e.isAtEnd() && oo(n.nextSibling) : !1;
      }, au = (e, n, o) => {
        var r;
        const u = ((r = n.ownerDocument) !== null && r !== void 0 ? r : document).createElement(e);
        u.setAttribute("data-mce-caret", o ? "before" : "after"), u.setAttribute("data-mce-bogus", "all"), u.appendChild(di().dom);
        const f = n.parentNode;
        return o ? f?.insertBefore(u, n) : n.nextSibling ? f?.insertBefore(u, n.nextSibling) : f?.appendChild(u), u;
      }, Vi = (e) => $t(e) && e.data[0] === k, Ol = (e) => $t(e) && e.data[e.data.length - 1] === k, vh = (e) => {
        var n;
        const o = e.getElementsByTagName("br"), r = o[o.length - 1];
        nu(r) && ((n = r.parentNode) === null || n === void 0 || n.removeChild(r));
      }, Dl = (e) => e && e.hasAttribute("data-mce-caret") ? (vh(e), e.removeAttribute("data-mce-caret"), e.removeAttribute("data-mce-bogus"), e.removeAttribute("style"), e.removeAttribute("data-mce-style"), e.removeAttribute("_moz_abspos"), e) : null, cf = (e) => pn(e.startContainer), lf = Kc, gg = es, uf = Js, Aa = Mt, Mu = ua([
        "script",
        "style",
        "textarea"
      ]), df = ua([
        "img",
        "input",
        "textarea",
        "hr",
        "iframe",
        "video",
        "audio",
        "object",
        "embed"
      ]), as = ua(["table"]), Ur = Jn, Zs = (e) => Ur(e) ? !1 : Aa(e) ? !Mu(e.parentNode) : df(e) || uf(e) || as(e) || mf(e), Bc = (e) => xn(e) && e.getAttribute("unselectable") === "true", mf = (e) => !Bc(e) && gg(e), m1 = (e, n) => {
        for (let o = e.parentNode; o && o !== n; o = o.parentNode) {
          if (mf(o))
            return !1;
          if (lf(o))
            return !0;
        }
        return !0;
      }, Rl = (e) => mf(e) ? !Xe(rs(e.getElementsByTagName("*")), (n, o) => n || lf(o), !1) : !1, $c = (e) => df(e) || Rl(e), Jb = (e, n) => Zs(e) && m1(e, n), Pu = /^[ \t\r\n]*$/, ff = (e) => Pu.test(e), hg = (e) => {
        for (const n of e)
          if (!Al(n))
            return !1;
        return !0;
      }, yh = (e) => " \f	\v".indexOf(e) !== -1, vm = (e) => e === `
` || e === "\r", vk = (e, n) => n < e.length && n >= 0 ? vm(e[n]) : !1, pg = (e, n = 4, o = !0, r = !0) => {
        const c = ms(" ", n), u = e.replace(/\t/g, c);
        return Xe(u, (b, y) => yh(y) || y === _s ? b.pcIsSpace || b.str === "" && o || b.str.length === u.length - 1 && r || vk(u, b.str.length + 1) ? {
          pcIsSpace: !1,
          str: b.str + _s
        } : {
          pcIsSpace: !0,
          str: b.str + " "
        } : {
          pcIsSpace: vm(y),
          str: b.str + y
        }, {
          pcIsSpace: !1,
          str: ""
        }).str;
      }, Cy = (e, n) => {
        const o = le.fromDom(n), r = le.fromDom(e);
        return by(r, "pre,code", Ye(fs, o));
      }, Mw = (e, n) => Mt(e) && ff(e.data) && !Cy(e, n), pa = (e) => xn(e) && e.nodeName === "A" && !e.hasAttribute("href") && (e.hasAttribute("name") || e.hasAttribute("id")), Ch = (e, n) => Zs(e) && !Mw(e, n) || pa(e) || ym(e), ym = ug("data-mce-bookmark"), gf = ug("data-mce-bogus"), bg = Xa("data-mce-bogus", "all"), vg = (e) => Tl(le.fromDom(e)).exists((n) => !Mo(n)), cl = (e, n) => {
        let o = 0;
        if (Ch(e, e))
          return !1;
        {
          let r = e.firstChild;
          if (!r)
            return !0;
          const c = new br(r, e);
          do {
            if (n) {
              if (bg(r)) {
                r = c.next(!0);
                continue;
              }
              if (gf(r)) {
                r = c.next();
                continue;
              }
            }
            if (Kc(r) && vg(r))
              return !1;
            if (Js(r)) {
              o++, r = c.next();
              continue;
            }
            if (Ch(r, e))
              return !1;
            r = c.next();
          } while (r);
          return o <= 1;
        }
      }, sa = (e, n = !0) => cl(e.dom, n), ad = (e) => e.toLowerCase() === "svg", wy = (e) => ad(e.nodeName), f1 = (e) => e?.nodeName === "svg" ? "svg" : "html", Qb = ["svg"], hf = () => {
        let e = [];
        const n = () => e[e.length - 1];
        return {
          track: (u) => {
            wy(u) && e.push(u);
            let f = n();
            return f && !f.contains(u) && (e.pop(), f = n()), f1(f);
          },
          current: () => f1(n()),
          reset: () => {
            e = [];
          }
        };
      }, g1 = "data-mce-block", e0 = (e) => Yt(Ss(e), (n) => !/[A-Z]/.test(n)), Bd = (e) => ye(e0(e), (n) => `${n}:` + ye(Qb, (o) => `not(${o} ${n})`).join(":")).join(","), cd = (e, n) => De(n.querySelector(e)) ? (n.setAttribute(g1, "true"), n.getAttribute("data-mce-selected") === "inline-boundary" && n.removeAttribute("data-mce-selected"), !0) : (n.removeAttribute(g1), !1), Nl = (e, n) => {
        const o = Bd(e.getTransparentElements()), r = Bd(e.getBlockElements());
        return Yt(n.querySelectorAll(o), (c) => cd(r, c));
      }, pf = (e, n) => {
        var o;
        const r = n ? "lastChild" : "firstChild";
        for (let c = e[r]; c; c = c[r])
          if (sa(le.fromDom(c))) {
            (o = c.parentNode) === null || o === void 0 || o.removeChild(c);
            return;
          }
      }, bf = (e, n) => {
        const o = document.createRange(), r = e.parentNode;
        if (r) {
          o.setStartBefore(e), o.setEndBefore(n);
          const c = o.extractContents();
          pf(c, !0), o.setStartAfter(n), o.setEndAfter(e);
          const u = o.extractContents();
          pf(u, !1), sa(le.fromDom(c)) || r.insertBefore(c, e), sa(le.fromDom(n)) || r.insertBefore(n, e), sa(le.fromDom(u)) || r.insertBefore(u, e), r.removeChild(e);
        }
      }, Pw = (e, n, o) => {
        const r = e.getBlockElements(), c = le.fromDom(n), u = (b) => Qo(b) in r, f = (b) => fs(b, c);
        ae(_u(o), (b) => {
          Ar(b, u, f).each((y) => {
            const E = ki(b, (N) => u(N) && !e.isValidChild(Qo(y), Qo(N)));
            if (E.length > 0) {
              const N = Tl(y);
              ae(E, (M) => {
                Ar(M, u, f).each((I) => {
                  bf(I.dom, M.dom);
                });
              }), N.each((M) => Nl(e, M.dom));
            }
          });
        });
      }, t0 = (e, n, o) => {
        ae([
          ...o,
          ...cs(e, n) ? [n] : []
        ], (r) => ae(uc(le.fromDom(r), r.nodeName.toLowerCase()), (c) => {
          to(e, c.dom) && qc(c);
        }));
      }, h1 = (e, n) => {
        const o = Nl(e, n);
        Pw(e, n, o), t0(e, n, o);
      }, n0 = (e, n) => {
        if (b1(e, n)) {
          const o = Bd(e.getBlockElements());
          cd(o, n);
        }
      }, Bw = (e, n, o) => {
        const r = (u) => fs(u, le.fromDom(n)), c = ch(le.fromDom(o), r);
        nn(c, c.length - 2).filter(yn).fold(() => h1(e, n), (u) => h1(e, u.dom));
      }, o0 = (e) => e.hasAttribute(g1), p1 = (e, n) => Zn(e.getTransparentElements(), n), b1 = (e, n) => xn(n) && p1(e, n.nodeName), cs = (e, n) => b1(e, n) && o0(n), to = (e, n) => b1(e, n) && !o0(n), Cm = (e, n) => n.type === 1 && p1(e, n.name) && J(n.attr(g1)), s0 = Is().browser, v1 = (e) => hn(e, yn), yk = (e) => s0.isFirefox() && Qo(e) === "table" ? v1(Ea(e)).filter((n) => Qo(n) === "caption").bind((n) => v1(Sc(n)).map((o) => {
        const r = o.dom.offsetTop, c = n.dom.offsetTop, u = n.dom.offsetHeight;
        return r <= c ? -u : 0;
      })).getOr(0) : 0, Sy = (e, n) => e.children && ee(e.children, n), vr = (e, n, o) => {
        let r = 0, c = 0;
        const u = e.ownerDocument;
        if (o = o || e, n) {
          if (o === e && n.getBoundingClientRect && ha(le.fromDom(e), "position") === "static") {
            const b = n.getBoundingClientRect();
            return r = b.left + (u.documentElement.scrollLeft || e.scrollLeft) - u.documentElement.clientLeft, c = b.top + (u.documentElement.scrollTop || e.scrollTop) - u.documentElement.clientTop, {
              x: r,
              y: c
            };
          }
          let f = n;
          for (; f && f !== o && f.nodeType && !Sy(f, o); ) {
            const b = f;
            r += b.offsetLeft || 0, c += b.offsetTop || 0, f = b.offsetParent;
          }
          for (f = n.parentNode; f && f !== o && f.nodeType && !Sy(f, o); )
            r -= f.scrollLeft || 0, c -= f.scrollTop || 0, f = f.parentNode;
          c += yk(le.fromDom(n));
        }
        return {
          x: r,
          y: c
        };
      }, xy = (e, n = {}) => {
        let o = 0;
        const r = {}, c = le.fromDom(e), u = xi(c), f = (Se) => {
          n.referrerPolicy = Se;
        }, b = (Se) => {
          n.contentCssCors = Se;
        }, y = (Se) => {
          la(lh(c), Se);
        }, E = (Se) => {
          const ke = lh(c);
          ii(ke, "#" + Se).each(bs);
        }, N = (Se) => Ts(r, Se).getOrThunk(() => ({
          id: "mce-u" + o++,
          passed: [],
          failed: [],
          count: 0
        })), M = (Se) => new Promise((ke, Ae) => {
          let Me;
          const pt = _t._addCacheSuffix(Se), It = N(pt);
          r[pt] = It, It.count++;
          const un = (bn, Yn) => {
            ae(bn, kn), It.status = Yn, It.passed = [], It.failed = [], Me && (Me.onload = null, Me.onerror = null, Me = null);
          }, nt = () => un(It.passed, 2), qe = () => un(It.failed, 3);
          if (ke && It.passed.push(ke), Ae && It.failed.push(Ae), It.status === 1)
            return;
          if (It.status === 2) {
            nt();
            return;
          }
          if (It.status === 3) {
            qe();
            return;
          }
          It.status = 1;
          const xt = le.fromTag("link", u.dom);
          Br(xt, {
            rel: "stylesheet",
            type: "text/css",
            id: It.id
          }), n.contentCssCors && ks(xt, "crossOrigin", "anonymous"), n.referrerPolicy && ks(xt, "referrerpolicy", n.referrerPolicy), Me = xt.dom, Me.onload = nt, Me.onerror = qe, y(xt), ks(xt, "href", pt);
        }), I = (Se, ke) => {
          const Ae = N(Se);
          r[Se] = Ae, Ae.count++;
          const Me = le.fromTag("style", u.dom);
          Br(Me, {
            rel: "stylesheet",
            type: "text/css",
            id: Ae.id
          }), Me.dom.innerHTML = ke, y(Me);
        }, X = (Se) => Promise.allSettled(ye(Se, (Ae) => M(Ae).then(it(Ae)))).then((Ae) => {
          const Me = Vn(Ae, (pt) => pt.status === "fulfilled");
          return Me.fail.length > 0 ? Promise.reject(ye(Me.fail, (pt) => pt.reason)) : ye(Me.pass, (pt) => pt.value);
        }), te = (Se) => {
          const ke = _t._addCacheSuffix(Se);
          Ts(r, ke).each((Ae) => {
            --Ae.count === 0 && (delete r[ke], E(Ae.id));
          });
        };
        return {
          load: M,
          loadRawCss: I,
          loadAll: X,
          unload: te,
          unloadRawCss: (Se) => {
            Ts(r, Se).each((ke) => {
              --ke.count === 0 && (delete r[Se], E(ke.id));
            });
          },
          unloadAll: (Se) => {
            ae(Se, (ke) => {
              te(ke);
            });
          },
          _setReferrerPolicy: f,
          _setContentCssCors: b
        };
      }, Ey = (() => {
        const e = /* @__PURE__ */ new WeakMap();
        return { forElement: (o, r) => {
          const u = kl(o).dom;
          return F.from(e.get(u)).getOrThunk(() => {
            const f = xy(u, r);
            return e.set(u, f), f;
          });
        } };
      })(), mt = (e) => e.nodeName.toLowerCase() === "span", r0 = (e, n, o) => De(e) && (Ch(e, n) || o.isInline(e.nodeName.toLowerCase())), Ck = (e, n, o) => {
        const r = new br(e, n).prev(!1), c = new br(e, n).next(!1), u = Ht(r) || r0(r, n, o), f = Ht(c) || r0(c, n, o);
        return u && f;
      }, y1 = (e) => mt(e) && e.getAttribute("data-mce-type") === "bookmark", wk = (e, n, o) => Mt(e) && e.data.length > 0 && Ck(e, n, o), wh = (e) => xn(e) ? e.childNodes.length > 0 : !1, ky = (e) => $r(e) || dg(e), wm = (e, n, o, r) => {
        var c;
        const u = r || n;
        if (xn(n) && y1(n))
          return n;
        const f = n.childNodes;
        for (let b = f.length - 1; b >= 0; b--)
          wm(e, f[b], o, u);
        if (xn(n)) {
          const b = n.childNodes;
          b.length === 1 && y1(b[0]) && ((c = n.parentNode) === null || c === void 0 || c.insertBefore(b[0], n));
        }
        return !ky(n) && !Ch(n, u) && !wh(n) && !wk(n, u, o) && e.remove(n), n;
      }, Sk = _t.makeMap, $d = /[&<>\"\u0060\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, cr = /[<>&\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, Fd = /[<>&\"\']/g, _y = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi, Bu = {
        128: "€",
        130: "‚",
        131: "ƒ",
        132: "„",
        133: "…",
        134: "†",
        135: "‡",
        136: "ˆ",
        137: "‰",
        138: "Š",
        139: "‹",
        140: "Œ",
        142: "Ž",
        145: "‘",
        146: "’",
        147: "“",
        148: "”",
        149: "•",
        150: "–",
        151: "—",
        152: "˜",
        153: "™",
        154: "š",
        155: "›",
        156: "œ",
        158: "ž",
        159: "Ÿ"
      }, Sm = {
        '"': "&quot;",
        "'": "&#39;",
        "<": "&lt;",
        ">": "&gt;",
        "&": "&amp;",
        "`": "&#96;"
      }, Ay = {
        "&lt;": "<",
        "&gt;": ">",
        "&amp;": "&",
        "&quot;": '"',
        "&apos;": "'"
      }, yg = (e) => {
        const n = le.fromTag("div").dom;
        return n.innerHTML = e, n.textContent || n.innerText || e;
      }, $w = (e, n) => {
        const o = {};
        if (e) {
          const r = e.split(",");
          n = n || 10;
          for (let c = 0; c < r.length; c += 2) {
            const u = String.fromCharCode(parseInt(r[c], n));
            if (!Sm[u]) {
              const f = "&" + r[c + 1] + ";";
              o[u] = f, o[f] = u;
            }
          }
          return o;
        } else
          return;
      }, a0 = $w("50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,t9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro", 32), Oy = (e, n) => e.replace(n ? $d : cr, (o) => Sm[o] || o), xk = (e) => ("" + e).replace(Fd, (n) => Sm[n] || n), Dy = (e, n) => e.replace(n ? $d : cr, (o) => o.length > 1 ? "&#" + ((o.charCodeAt(0) - 55296) * 1024 + (o.charCodeAt(1) - 56320) + 65536) + ";" : Sm[o] || "&#" + o.charCodeAt(0) + ";"), Cg = (e, n, o) => {
        const r = o || a0;
        return e.replace(n ? $d : cr, (c) => Sm[c] || r[c] || c);
      }, wg = {
        encodeRaw: Oy,
        encodeAllRaw: xk,
        encodeNumeric: Dy,
        encodeNamed: Cg,
        getEncodeFunc: (e, n) => {
          const o = $w(n) || a0, r = (f, b) => f.replace(b ? $d : cr, (y) => Sm[y] !== void 0 ? Sm[y] : o[y] !== void 0 ? o[y] : y.length > 1 ? "&#" + ((y.charCodeAt(0) - 55296) * 1024 + (y.charCodeAt(1) - 56320) + 65536) + ";" : "&#" + y.charCodeAt(0) + ";"), c = (f, b) => Cg(f, b, o), u = Sk(e.replace(/\+/g, ","));
          return u.named && u.numeric ? r : u.named ? n ? c : Cg : u.numeric ? Dy : Oy;
        },
        decode: (e) => e.replace(_y, (n, o) => o ? (o.charAt(0).toLowerCase() === "x" ? o = parseInt(o.substr(1), 16) : o = parseInt(o, 10), o > 65535 ? (o -= 65536, String.fromCharCode(55296 + (o >> 10), 56320 + (o & 1023))) : Bu[o] || String.fromCharCode(o)) : Ay[n] || a0[n] || yg(n))
      }, Fc = (e, n) => (e = _t.trim(e), e ? e.split(n || " ") : []), An = (e) => new RegExp("^" + e.replace(/([?+*])/g, ".$1") + "$"), Tk = (e) => {
        const n = /^(~)?(.+)$/;
        return ds(Fc(e, ","), (o) => {
          const r = n.exec(o);
          if (r) {
            const c = r[1] === "~", u = c ? "span" : "div", f = r[2];
            return [{
              inline: c,
              cloneName: u,
              name: f
            }];
          } else
            return [];
        });
      }, Ny = (e) => {
        let n, o, r;
        if (n = "id accesskey class dir lang style tabindex title role", o = "address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul", r = "a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd label map noscript object q s samp script select small span strong sub sup textarea u var #text #comment", e !== "html4") {
          const u = "a ins del canvas map";
          n += " contenteditable contextmenu draggable dropzone hidden spellcheck translate", o += " article aside details dialog figure main header footer hgroup section nav " + u, r += " audio canvas command datalist mark meter output picture progress time wbr video ruby bdi keygen svg";
        }
        e !== "html5-strict" && (n += " xml:lang", r = [
          r,
          "acronym applet basefont big font strike tt"
        ].join(" "), o = [
          o,
          "center dir isindex noframes"
        ].join(" "));
        const c = [
          o,
          r
        ].join(" ");
        return {
          globalAttributes: n,
          blockContent: o,
          phrasingContent: r,
          flowContent: c
        };
      }, Ek = (e) => {
        const { globalAttributes: n, phrasingContent: o, flowContent: r } = Ny(e), c = {}, u = (y, E, N) => {
          c[y] = {
            attributes: Ie(E, it({})),
            attributesOrder: E,
            children: Ie(N, it({}))
          };
        }, f = (y, E = "", N = "") => {
          const M = Fc(N), I = Fc(y);
          let X = I.length;
          const te = Fc([
            n,
            E
          ].join(" "));
          for (; X--; )
            u(I[X], te.slice(), M);
        }, b = (y, E) => {
          const N = Fc(y), M = Fc(E);
          let I = N.length;
          for (; I--; ) {
            const X = c[N[I]];
            for (let te = 0, G = M.length; te < G; te++)
              X.attributes[M[te]] = {}, X.attributesOrder.push(M[te]);
          }
        };
        return e !== "html5-strict" && (ae(Fc("acronym applet basefont big font strike tt"), (N) => {
          f(N, "", o);
        }), ae(Fc("center dir isindex noframes"), (N) => {
          f(N, "", r);
        })), f("html", "manifest", "head body"), f("head", "", "base command link meta noscript script style title"), f("title hr noscript br"), f("base", "href target"), f("link", "href rel media hreflang type sizes hreflang"), f("meta", "name http-equiv content charset"), f("style", "media type scoped"), f("script", "src async defer type charset"), f("body", "onafterprint onbeforeprint onbeforeunload onblur onerror onfocus onhashchange onload onmessage onoffline ononline onpagehide onpageshow onpopstate onresize onscroll onstorage onunload", r), f("dd div", "", r), f("address dt caption", "", e === "html4" ? o : r), f("h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn", "", o), f("blockquote", "cite", r), f("ol", "reversed start type", "li"), f("ul", "", "li"), f("li", "value", r), f("dl", "", "dt dd"), f("a", "href target rel media hreflang type", e === "html4" ? o : r), f("q", "cite", o), f("ins del", "cite datetime", r), f("img", "src sizes srcset alt usemap ismap width height"), f("iframe", "src name width height", r), f("embed", "src type width height"), f("object", "data type typemustmatch name usemap form width height", [
          r,
          "param"
        ].join(" ")), f("param", "name value"), f("map", "name", [
          r,
          "area"
        ].join(" ")), f("area", "alt coords shape href target rel media hreflang type"), f("table", "border", "caption colgroup thead tfoot tbody tr" + (e === "html4" ? " col" : "")), f("colgroup", "span", "col"), f("col", "span"), f("tbody thead tfoot", "", "tr"), f("tr", "", "td th"), f("td", "colspan rowspan headers", r), f("th", "colspan rowspan headers scope abbr", r), f("form", "accept-charset action autocomplete enctype method name novalidate target", r), f("fieldset", "disabled form name", [
          r,
          "legend"
        ].join(" ")), f("label", "form for", o), f("input", "accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate formtarget height list max maxlength min multiple name pattern readonly required size src step type value width"), f("button", "disabled form formaction formenctype formmethod formnovalidate formtarget name type value", e === "html4" ? r : o), f("select", "disabled form multiple name required size", "option optgroup"), f("optgroup", "disabled label", "option"), f("option", "disabled label selected value"), f("textarea", "cols dirname disabled form maxlength name readonly required rows wrap"), f("menu", "type label", [
          r,
          "li"
        ].join(" ")), f("noscript", "", r), e !== "html4" && (f("wbr"), f("ruby", "", [
          o,
          "rt rp"
        ].join(" ")), f("figcaption", "", r), f("mark rt rp bdi", "", o), f("summary", "", [
          o,
          "h1 h2 h3 h4 h5 h6"
        ].join(" ")), f("canvas", "width height", r), f("video", "src crossorigin poster preload autoplay mediagroup loop muted controls width height buffered", [
          r,
          "track source"
        ].join(" ")), f("audio", "src crossorigin preload autoplay mediagroup loop muted controls buffered volume", [
          r,
          "track source"
        ].join(" ")), f("picture", "", "img source"), f("source", "src srcset type media sizes"), f("track", "kind src srclang label default"), f("datalist", "", [
          o,
          "option"
        ].join(" ")), f("article section nav aside main header footer", "", r), f("hgroup", "", "h1 h2 h3 h4 h5 h6"), f("figure", "", [
          r,
          "figcaption"
        ].join(" ")), f("time", "datetime", o), f("dialog", "open", r), f("command", "type label icon disabled checked radiogroup command"), f("output", "for form name", o), f("progress", "value max", o), f("meter", "value min max low high optimum", o), f("details", "open", [
          r,
          "summary"
        ].join(" ")), f("keygen", "autofocus challenge disabled form keytype name"), u("svg", "id tabindex lang xml:space class style x y width height viewBox preserveAspectRatio zoomAndPan transform".split(" "), [])), e !== "html5-strict" && (b("script", "language xml:space"), b("style", "xml:space"), b("object", "declare classid code codebase codetype archive standby align border hspace vspace"), b("embed", "align name hspace vspace"), b("param", "valuetype type"), b("a", "charset name rev shape coords"), b("br", "clear"), b("applet", "codebase archive code object alt name width height align hspace vspace"), b("img", "name longdesc align border hspace vspace"), b("iframe", "longdesc frameborder marginwidth marginheight scrolling align"), b("font basefont", "size color face"), b("input", "usemap align"), b("select"), b("textarea"), b("h1 h2 h3 h4 h5 h6 div p legend caption", "align"), b("ul", "type compact"), b("li", "type"), b("ol dl menu dir", "compact"), b("pre", "width xml:space"), b("hr", "align noshade size width"), b("isindex", "prompt"), b("table", "summary width frame rules cellspacing cellpadding align bgcolor"), b("col", "width align char charoff valign"), b("colgroup", "width align char charoff valign"), b("thead", "align char charoff valign"), b("tr", "align char charoff valign bgcolor"), b("th", "axis align char charoff valign nowrap bgcolor width height"), b("form", "accept"), b("td", "abbr axis scope align char charoff valign nowrap bgcolor width height"), b("tfoot", "align char charoff valign"), b("tbody", "align char charoff valign"), b("area", "nohref"), b("body", "background bgcolor text link vlink alink")), e !== "html4" && (b("input button select textarea", "autofocus"), b("input textarea", "placeholder"), b("a", "download"), b("link script img", "crossorigin"), b("img", "loading"), b("iframe", "sandbox seamless allow allowfullscreen loading")), e !== "html4" && ae([
          c.video,
          c.audio
        ], (y) => {
          delete y.children.audio, delete y.children.video;
        }), ae(Fc("a form meter progress dfn"), (y) => {
          c[y] && delete c[y].children[y];
        }), delete c.caption.children.table, delete c.script, c;
      }, Fw = (e) => e === "-" ? "remove" : "add", Sg = (e) => {
        const n = /^([+\-]?)([A-Za-z0-9_\-.\u00b7\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u037d\u037f-\u1fff\u200c-\u200d\u203f-\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]+)\[([^\]]+)]$/;
        return ds(Fc(e, ","), (o) => {
          const r = n.exec(o);
          if (r) {
            const c = r[1], u = c ? Fw(c) : "replace", f = r[2], b = Fc(r[3], "|");
            return [{
              operation: u,
              name: f,
              validChildren: b
            }];
          } else
            return [];
        });
      }, Sh = (e, n) => {
        const o = /^([!\-])?(\w+[\\:]:\w+|[^=~<]+)?(?:([=~<])(.*))?$/, r = /[*?+]/, { attributes: c, attributesOrder: u } = n;
        return ae(Fc(e, "|"), (f) => {
          const b = o.exec(f);
          if (b) {
            const y = {}, E = b[1], N = b[2].replace(/[\\:]:/g, ":"), M = b[3], I = b[4];
            if (E === "!" && (n.attributesRequired = n.attributesRequired || [], n.attributesRequired.push(N), y.required = !0), E === "-") {
              delete c[N], u.splice(_t.inArray(u, N), 1);
              return;
            }
            if (M && (M === "=" ? (n.attributesDefault = n.attributesDefault || [], n.attributesDefault.push({
              name: N,
              value: I
            }), y.defaultValue = I) : M === "~" ? (n.attributesForced = n.attributesForced || [], n.attributesForced.push({
              name: N,
              value: I
            }), y.forcedValue = I) : M === "<" && (y.validValues = _t.makeMap(I, "?"))), r.test(N)) {
              const X = y;
              n.attributePatterns = n.attributePatterns || [], X.pattern = An(N), n.attributePatterns.push(X);
            } else
              c[N] || u.push(N), c[N] = y;
          }
        });
      }, C1 = (e, n) => {
        Dt(e.attributes, (o, r) => {
          n.attributes[r] = o;
        }), n.attributesOrder.push(...e.attributesOrder);
      }, xh = (e, n) => {
        const o = /^([#+\-])?([^\[!\/]+)(?:\/([^\[!]+))?(?:(!?)\[([^\]]+)])?$/;
        return ds(Fc(n, ","), (r) => {
          const c = o.exec(r);
          if (c) {
            const u = c[1], f = c[2], b = c[3], y = c[4], E = c[5], N = {
              attributes: {},
              attributesOrder: []
            };
            if (e.each((M) => C1(M, N)), u === "#" ? N.paddEmpty = !0 : u === "-" && (N.removeEmpty = !0), y === "!" && (N.removeEmptyAttrs = !0), E && Sh(E, N), b && (N.outputName = f), f === "@")
              if (e.isNone())
                e = F.some(N);
              else
                return [];
            return [b ? {
              name: f,
              element: N,
              aliasName: b
            } : {
              name: f,
              element: N
            }];
          } else
            return [];
        });
      }, c0 = {}, xm = _t.makeMap, id = _t.each, w1 = _t.extend, cu = _t.explode, i0 = (e, n = {}) => {
        const o = xm(e, " ", xm(e.toUpperCase(), " "));
        return w1(o, n);
      }, Iw = (e) => i0("td th li dt dd figcaption caption details summary", e.getTextBlockElements()), Th = (e, n) => {
        if (e) {
          const o = {};
          return J(e) && (e = { "*": e }), id(e, (r, c) => {
            o[c] = o[c.toUpperCase()] = n === "map" ? xm(r, /[, ]/) : cu(r, /[, ]/);
          }), o;
        } else
          return;
      }, Tm = (e = {}) => {
        var n;
        const o = {}, r = {};
        let c = [];
        const u = {}, f = {}, b = (Do, ps, Ls) => {
          const Gr = e[Do];
          if (Gr)
            return xm(Gr, /[, ]/, xm(Gr.toUpperCase(), /[, ]/));
          {
            let ra = c0[Do];
            return ra || (ra = i0(ps, Ls), c0[Do] = ra), ra;
          }
        }, y = (n = e.schema) !== null && n !== void 0 ? n : "html5", E = Ek(y);
        e.verify_html === !1 && (e.valid_elements = "*[*]");
        const N = Th(e.valid_styles), M = Th(e.invalid_styles, "map"), I = Th(e.valid_classes, "map"), X = b("whitespace_elements", "pre script noscript style textarea video audio iframe object code"), te = b("self_closing_elements", "colgroup dd dt li option p td tfoot th thead tr"), G = b("void_elements", "area base basefont br col frame hr img input isindex link meta param embed source wbr track"), ne = b("boolean_attributes", "checked compact declare defer disabled ismap multiple nohref noresize noshade nowrap readonly selected autoplay loop controls allowfullscreen"), Se = "td th iframe video audio object script code", ke = b("non_empty_elements", Se + " pre svg", G), Ae = b("move_caret_before_on_enter_elements", Se + " table", G), Me = "h1 h2 h3 h4 h5 h6", pt = b("text_block_elements", Me + " p div address pre form blockquote center dir fieldset header footer article section hgroup aside main nav figure"), It = b("block_elements", "hr table tbody thead tfoot th tr td li ol ul caption dl dt dd noscript menu isindex option datalist select optgroup figcaption details summary html body multicol listing", pt), un = b("text_inline_elements", "span strong b em i font s strike u var cite dfn code mark q sup sub samp"), nt = b("transparent_elements", "a ins del canvas map"), qe = b("wrap_block_elements", "pre " + Me);
        id("script noscript iframe noframes noembed title style textarea xmp plaintext".split(" "), (Do) => {
          f[Do] = new RegExp("</" + Do + "[^>]*>", "gi");
        });
        const xt = (Do) => {
          const ps = F.from(o["@"]), Ls = /[*?+]/;
          ae(xh(ps, Do ?? ""), ({ name: Gr, element: ra, aliasName: _d }) => {
            if (_d && (o[_d] = ra), Ls.test(Gr)) {
              const iy = ra;
              iy.pattern = An(Gr), c.push(iy);
            } else
              o[Gr] = ra;
          });
        }, bn = (Do) => {
          c = [], ae(Ss(o), (ps) => {
            delete o[ps];
          }), xt(Do);
        }, Yn = (Do) => {
          delete c0.text_block_elements, delete c0.block_elements, ae(Tk(Do ?? ""), ({ inline: ps, name: Ls, cloneName: Gr }) => {
            if (r[Ls] = r[Gr], u[Ls] = Gr, ke[Ls.toUpperCase()] = {}, ke[Ls] = {}, ps || (It[Ls.toUpperCase()] = {}, It[Ls] = {}), !o[Ls]) {
              let ra = o[Gr];
              ra = w1({}, ra), delete ra.removeEmptyAttrs, delete ra.removeEmpty, o[Ls] = ra;
            }
            Dt(r, (ra, _d) => {
              ra[Gr] && (r[_d] = ra = w1({}, r[_d]), ra[Ls] = ra[Gr]);
            });
          });
        }, Po = (Do) => {
          ae(Sg(Do ?? ""), ({ operation: ps, name: Ls, validChildren: Gr }) => {
            const ra = ps === "replace" ? { "#comment": {} } : r[Ls];
            ae(Gr, (_d) => {
              ps === "remove" ? delete ra[_d] : ra[_d] = {};
            }), r[Ls] = ra;
          });
        }, Ko = (Do) => {
          const ps = o[Do];
          if (ps)
            return ps;
          let Ls = c.length;
          for (; Ls--; ) {
            const Gr = c[Ls];
            if (Gr.pattern.test(Do))
              return Gr;
          }
        };
        e.valid_elements ? (bn(e.valid_elements), id(E, (Do, ps) => {
          r[ps] = Do.children;
        })) : (id(E, (Do, ps) => {
          o[ps] = {
            attributes: Do.attributes,
            attributesOrder: Do.attributesOrder
          }, r[ps] = Do.children;
        }), id(Fc("strong/b em/i"), (Do) => {
          const ps = Fc(Do, "/");
          o[ps[1]].outputName = ps[0];
        }), id(un, (Do, ps) => {
          o[ps] && (e.padd_empty_block_inline_children && (o[ps].paddInEmptyBlock = !0), o[ps].removeEmpty = !0);
        }), id(Fc("ol ul blockquote a table tbody"), (Do) => {
          o[Do] && (o[Do].removeEmpty = !0);
        }), id(Fc("p h1 h2 h3 h4 h5 h6 th td pre div address caption li summary"), (Do) => {
          o[Do] && (o[Do].paddEmpty = !0);
        }), id(Fc("span"), (Do) => {
          o[Do].removeEmptyAttrs = !0;
        })), delete o.svg, Yn(e.custom_elements), Po(e.valid_children), xt(e.extended_valid_elements), Po("+ol[ul|ol],+ul[ul|ol]"), id({
          dd: "dl",
          dt: "dl",
          li: "ul ol",
          td: "tr",
          th: "tr",
          tr: "tbody thead tfoot",
          tbody: "table",
          thead: "table",
          tfoot: "table",
          legend: "fieldset",
          area: "map",
          param: "video audio object"
        }, (Do, ps) => {
          o[ps] && (o[ps].parentsRequired = Fc(Do));
        }), e.invalid_elements && id(cu(e.invalid_elements), (Do) => {
          o[Do] && delete o[Do];
        }), Ko("span") || xt("span[!data-mce-type|*]");
        const er = it(N), Er = it(M), wa = it(I), si = it(ne), kc = it(It), Gt = it(pt), vn = it(un), As = it(Object.seal(G)), vs = it(te), zn = it(ke), Un = it(Ae), zt = it(X), Eo = it(nt), hs = it(qe), nr = it(Object.seal(f)), kr = (Do, ps) => {
          const Ls = r[Do.toLowerCase()];
          return !!(Ls && Ls[ps.toLowerCase()]);
        }, Qi = (Do, ps) => {
          const Ls = Ko(Do);
          if (Ls)
            if (ps) {
              if (Ls.attributes[ps])
                return !0;
              const Gr = Ls.attributePatterns;
              if (Gr) {
                let ra = Gr.length;
                for (; ra--; )
                  if (Gr[ra].pattern.test(ps))
                    return !0;
              }
            } else
              return !0;
          return !1;
        }, hu = (Do) => Zn(kc(), Do), Yf = (Do) => !Kn(Do, "#") && Qi(Do) && !hu(Do), el = (Do) => Zn(hs(), Do) || Yf(Do), rm = it(u);
        return {
          type: y,
          children: r,
          elements: o,
          getValidStyles: er,
          getValidClasses: wa,
          getBlockElements: kc,
          getInvalidStyles: Er,
          getVoidElements: As,
          getTextBlockElements: Gt,
          getTextInlineElements: vn,
          getBoolAttrs: si,
          getElementRule: Ko,
          getSelfClosingElements: vs,
          getNonEmptyElements: zn,
          getMoveCaretBeforeOnEnterElements: Un,
          getWhitespaceElements: zt,
          getTransparentElements: Eo,
          getSpecialElements: nr,
          isValidChild: kr,
          isValid: Qi,
          isBlock: hu,
          isInline: Yf,
          isWrapper: el,
          getCustomElements: rm,
          addValidElements: xt,
          setValidElements: bn,
          addCustomElements: Yn,
          addValidChildren: Po
        };
      }, kk = (e) => ({ value: Eh(e) }), Eh = (e) => Dn(e, "#").toUpperCase(), xg = (e) => {
        const n = e.toString(16);
        return (n.length === 1 ? "0" + n : n).toUpperCase();
      }, $u = (e) => {
        const n = xg(e.red) + xg(e.green) + xg(e.blue);
        return kk(n);
      }, il = /^\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/i, _k = /^\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?(?:\.\d+)?)\s*\)\s*$/i, Lw = (e, n, o, r) => ({
        red: e,
        green: n,
        blue: o,
        alpha: r
      }), Hw = (e, n, o, r) => {
        const c = parseInt(e, 10), u = parseInt(n, 10), f = parseInt(o, 10), b = parseFloat(r);
        return Lw(c, u, f, b);
      }, My = (e) => {
        if (e === "transparent")
          return F.some(Lw(0, 0, 0, 0));
        const n = il.exec(e);
        if (n !== null)
          return F.some(Hw(n[1], n[2], n[3], "1"));
        const o = _k.exec(e);
        return o !== null ? F.some(Hw(o[1], o[2], o[3], o[4])) : F.none();
      }, ll = (e) => `rgba(${e.red},${e.green},${e.blue},${e.alpha})`, kh = (e) => My(e).map($u).map((n) => "#" + n.value).getOr(e), l0 = (e = {}, n) => {
        const o = /(?:url(?:(?:\(\s*\"([^\"]+)\"\s*\))|(?:\(\s*\'([^\']+)\'\s*\))|(?:\(\s*([^)\s]+)\s*\))))|(?:\'([^\']+)\')|(?:\"([^\"]+)\")/gi, r = /\s*([^:]+):\s*([^;]+);?/g, c = /\s+$/, u = {};
        let f, b;
        const y = fg;
        n && (f = n.getValidStyles(), b = n.getInvalidStyles());
        const E = (`\\" \\' \\; \\: ; : ` + y).split(" ");
        for (let M = 0; M < E.length; M++)
          u[E[M]] = y + M, u[y + M] = E[M];
        const N = {
          parse: (M) => {
            const I = {};
            let X = !1;
            const te = e.url_converter, G = e.url_converter_scope || N, ne = (nt, qe, xt) => {
              const bn = I[nt + "-top" + qe];
              if (!bn)
                return;
              const Yn = I[nt + "-right" + qe];
              if (!Yn)
                return;
              const Po = I[nt + "-bottom" + qe];
              if (!Po)
                return;
              const Ko = I[nt + "-left" + qe];
              if (!Ko)
                return;
              const er = [
                bn,
                Yn,
                Po,
                Ko
              ];
              let Er = er.length - 1;
              for (; Er-- && er[Er] === er[Er + 1]; )
                ;
              Er > -1 && xt || (I[nt + qe] = Er === -1 ? er[0] : er.join(" "), delete I[nt + "-top" + qe], delete I[nt + "-right" + qe], delete I[nt + "-bottom" + qe], delete I[nt + "-left" + qe]);
            }, Se = (nt) => {
              const qe = I[nt];
              if (!qe)
                return;
              const xt = qe.indexOf(",") > -1 ? [qe] : qe.split(" ");
              let bn = xt.length;
              for (; bn--; )
                if (xt[bn] !== xt[0])
                  return !1;
              return I[nt] = xt[0], !0;
            }, ke = (nt, qe, xt, bn) => {
              Se(qe) && Se(xt) && Se(bn) && (I[nt] = I[qe] + " " + I[xt] + " " + I[bn], delete I[qe], delete I[xt], delete I[bn]);
            }, Ae = (nt) => (X = !0, u[nt]), Me = (nt, qe) => (X && (nt = nt.replace(/\uFEFF[0-9]/g, (xt) => u[xt])), qe || (nt = nt.replace(/\\([\'\";:])/g, "$1")), nt), pt = (nt) => String.fromCharCode(parseInt(nt.slice(1), 16)), It = (nt) => nt.replace(/\\[0-9a-f]+/gi, pt), un = (nt, qe, xt, bn, Yn, Po) => {
              if (Yn = Yn || Po, Yn)
                return Yn = Me(Yn), "'" + Yn.replace(/\'/g, "\\'") + "'";
              if (qe = Me(qe || xt || bn || ""), !e.allow_script_urls) {
                const Ko = qe.replace(/[\s\r\n]+/g, "");
                if (/(java|vb)script:/i.test(Ko) || !e.allow_svg_data_urls && /^data:image\/svg/i.test(Ko))
                  return "";
              }
              return te && (qe = te.call(G, qe, "style")), "url('" + qe.replace(/\'/g, "\\'") + "')";
            };
            if (M) {
              M = M.replace(/[\u0000-\u001F]/g, ""), M = M.replace(/\\[\"\';:\uFEFF]/g, Ae).replace(/\"[^\"]+\"|\'[^\']+\'/g, (qe) => qe.replace(/[;:]/g, Ae));
              let nt;
              for (; nt = r.exec(M); ) {
                r.lastIndex = nt.index + nt[0].length;
                let qe = nt[1].replace(c, "").toLowerCase(), xt = nt[2].replace(c, "");
                if (qe && xt) {
                  if (qe = It(qe), xt = It(xt), qe.indexOf(y) !== -1 || qe.indexOf('"') !== -1 || !e.allow_script_urls && (qe === "behavior" || /expression\s*\(|\/\*|\*\//.test(xt)))
                    continue;
                  qe === "font-weight" && xt === "700" ? xt = "bold" : (qe === "color" || qe === "background-color") && (xt = xt.toLowerCase()), J(e.force_hex_color) && e.force_hex_color !== "off" && My(xt).each((bn) => {
                    (e.force_hex_color === "always" || bn.alpha === 1) && (xt = kh(ll(bn)));
                  }), xt = xt.replace(o, un), I[qe] = X ? Me(xt, !0) : xt;
                }
              }
              ne("border", "", !0), ne("border", "-width"), ne("border", "-color"), ne("border", "-style"), ne("padding", ""), ne("margin", ""), ke("border", "border-width", "border-style", "border-color"), I.border === "medium none" && delete I.border, I["border-image"] === "none" && delete I["border-image"];
            }
            return I;
          },
          serialize: (M, I) => {
            let X = "";
            const te = (ne, Se) => {
              const ke = Se[ne];
              if (ke)
                for (let Ae = 0, Me = ke.length; Ae < Me; Ae++) {
                  const pt = ke[Ae], It = M[pt];
                  It && (X += (X.length > 0 ? " " : "") + pt + ": " + It + ";");
                }
            }, G = (ne, Se) => {
              if (!b || !Se)
                return !0;
              let ke = b["*"];
              return ke && ke[ne] ? !1 : (ke = b[Se], !(ke && ke[ne]));
            };
            return I && f ? (te("*", f), te(I, f)) : Dt(M, (ne, Se) => {
              ne && G(Se, I) && (X += (X.length > 0 ? " " : "") + Se + ": " + ne + ";");
            }), X;
          }
        };
        return N;
      }, u0 = {
        keyLocation: !0,
        layerX: !0,
        layerY: !0,
        returnValue: !0,
        webkitMovementX: !0,
        webkitMovementY: !0,
        keyIdentifier: !0,
        mozPressure: !0
      }, Ak = (e) => e instanceof Event || re(e.initEvent), zw = (e) => e.isDefaultPrevented === ot || e.isDefaultPrevented === $e, Py = (e) => gn(e.preventDefault) || Ak(e), _h = (e, n) => {
        const o = n ?? {};
        for (const r in e)
          Zn(u0, r) || (o[r] = e[r]);
        return De(e.composedPath) && (o.composedPath = () => e.composedPath()), De(e.getModifierState) && (o.getModifierState = (r) => e.getModifierState(r)), De(e.getTargetRanges) && (o.getTargetRanges = () => e.getTargetRanges()), o;
      }, Ah = (e, n, o, r) => {
        var c;
        const u = _h(n, r);
        return u.type = e, gn(u.target) && (u.target = (c = u.srcElement) !== null && c !== void 0 ? c : o), Py(n) && (u.preventDefault = () => {
          u.defaultPrevented = !0, u.isDefaultPrevented = ot, re(n.preventDefault) && n.preventDefault();
        }, u.stopPropagation = () => {
          u.cancelBubble = !0, u.isPropagationStopped = ot, re(n.stopPropagation) && n.stopPropagation();
        }, u.stopImmediatePropagation = () => {
          u.isImmediatePropagationStopped = ot, u.stopPropagation();
        }, zw(u) || (u.isDefaultPrevented = u.defaultPrevented === !0 ? ot : $e, u.isPropagationStopped = u.cancelBubble === !0 ? ot : $e, u.isImmediatePropagationStopped = $e)), u;
      }, d0 = "mce-data-", Ok = /^(?:mouse|contextmenu)|click/, m0 = (e, n, o, r) => {
        e.addEventListener(n, o, r || !1);
      }, Oh = (e, n, o, r) => {
        e.removeEventListener(n, o, r || !1);
      }, Dk = (e) => De(e) && Ok.test(e.type), S1 = (e, n) => {
        const o = Ah(e.type, e, document, n);
        if (Dk(e) && Ht(e.pageX) && !Ht(e.clientX)) {
          const r = o.target.ownerDocument || document, c = r.documentElement, u = r.body, f = o;
          f.pageX = e.clientX + (c && c.scrollLeft || u && u.scrollLeft || 0) - (c && c.clientLeft || u && u.clientLeft || 0), f.pageY = e.clientY + (c && c.scrollTop || u && u.scrollTop || 0) - (c && c.clientTop || u && u.clientTop || 0);
        }
        return o;
      }, By = (e, n, o) => {
        const r = e.document, c = { type: "ready" };
        if (o.domLoaded) {
          n(c);
          return;
        }
        const u = () => r.readyState === "complete" || r.readyState === "interactive" && r.body, f = () => {
          Oh(e, "DOMContentLoaded", f), Oh(e, "load", f), o.domLoaded || (o.domLoaded = !0, n(c)), e = null;
        };
        u() ? f() : m0(e, "DOMContentLoaded", f), o.domLoaded || m0(e, "load", f);
      };
      class ul {
        constructor() {
          this.domLoaded = !1, this.events = {}, this.count = 1, this.expando = d0 + (+/* @__PURE__ */ new Date()).toString(32), this.hasFocusIn = "onfocusin" in document.documentElement, this.count = 1;
        }
        bind(n, o, r, c) {
          const u = this;
          let f;
          const b = window, y = (I) => {
            u.executeHandlers(S1(I || b.event), E);
          };
          if (!n || Mt(n) || rd(n))
            return r;
          let E;
          n[u.expando] ? E = n[u.expando] : (E = u.count++, n[u.expando] = E, u.events[E] = {}), c = c || n;
          const N = o.split(" ");
          let M = N.length;
          for (; M--; ) {
            let I = N[M], X = y, te = !1, G = !1;
            if (I === "DOMContentLoaded" && (I = "ready"), u.domLoaded && I === "ready" && n.readyState === "complete") {
              r.call(c, S1({ type: I }));
              continue;
            }
            !u.hasFocusIn && (I === "focusin" || I === "focusout") && (te = !0, G = I === "focusin" ? "focus" : "blur", X = (ne) => {
              const Se = S1(ne || b.event);
              Se.type = Se.type === "focus" ? "focusin" : "focusout", u.executeHandlers(Se, E);
            }), f = u.events[E][I], f ? I === "ready" && u.domLoaded ? r(S1({ type: I })) : f.push({
              func: r,
              scope: c
            }) : (u.events[E][I] = f = [{
              func: r,
              scope: c
            }], f.fakeName = G, f.capture = te, f.nativeHandler = X, I === "ready" ? By(n, X, u) : m0(n, G || I, X, te));
          }
          return n = f = null, r;
        }
        unbind(n, o, r) {
          if (!n || Mt(n) || rd(n))
            return this;
          const c = n[this.expando];
          if (c) {
            let u = this.events[c];
            if (o) {
              const f = o.split(" ");
              let b = f.length;
              for (; b--; ) {
                const y = f[b], E = u[y];
                if (E) {
                  if (r) {
                    let N = E.length;
                    for (; N--; )
                      if (E[N].func === r) {
                        const M = E.nativeHandler, I = E.fakeName, X = E.capture, te = E.slice(0, N).concat(E.slice(N + 1));
                        te.nativeHandler = M, te.fakeName = I, te.capture = X, u[y] = te;
                      }
                  }
                  (!r || E.length === 0) && (delete u[y], Oh(n, E.fakeName || y, E.nativeHandler, E.capture));
                }
              }
            } else
              Dt(u, (f, b) => {
                Oh(n, f.fakeName || b, f.nativeHandler, f.capture);
              }), u = {};
            for (const f in u)
              if (Zn(u, f))
                return this;
            delete this.events[c];
            try {
              delete n[this.expando];
            } catch {
              n[this.expando] = null;
            }
          }
          return this;
        }
        fire(n, o, r) {
          return this.dispatch(n, o, r);
        }
        dispatch(n, o, r) {
          if (!n || Mt(n) || rd(n))
            return this;
          const c = S1({
            type: o,
            target: n
          }, r);
          do {
            const u = n[this.expando];
            u && this.executeHandlers(c, u), n = n.parentNode || n.ownerDocument || n.defaultView || n.parentWindow;
          } while (n && !c.isPropagationStopped());
          return this;
        }
        clean(n) {
          if (!n || Mt(n) || rd(n))
            return this;
          if (n[this.expando] && this.unbind(n), n.getElementsByTagName || (n = n.document), n && n.getElementsByTagName) {
            this.unbind(n);
            const o = n.getElementsByTagName("*");
            let r = o.length;
            for (; r--; )
              n = o[r], n[this.expando] && this.unbind(n);
          }
          return this;
        }
        destroy() {
          this.events = {};
        }
        cancel(n) {
          return n && (n.preventDefault(), n.stopImmediatePropagation()), !1;
        }
        executeHandlers(n, o) {
          const r = this.events[o], c = r && r[n.type];
          if (c)
            for (let u = 0, f = c.length; u < f; u++) {
              const b = c[u];
              if (b && b.func.call(b.scope, n) === !1 && n.preventDefault(), n.isImmediatePropagationStopped())
                return;
            }
        }
      }
      ul.Event = new ul();
      const f0 = _t.each, Vw = _t.grep, g0 = "data-mce-style", j4 = _t.makeMap("fill-opacity font-weight line-height opacity orphans widows z-index zoom", " "), h0 = (e, n, o) => {
        gn(o) || o === "" ? _r(e, n) : ks(e, n, o);
      }, vf = (e) => e.replace(/[A-Z]/g, (n) => "-" + n.toLowerCase()), Id = (e, n) => {
        let o = 0;
        if (e)
          for (let r = e.nodeType, c = e.previousSibling; c; c = c.previousSibling) {
            const u = c.nodeType;
            n && Mt(c) && (u === r || !c.data.length) || (o++, r = u);
          }
        return o;
      }, $y = (e, n) => {
        const o = ia(n, "style"), r = e.serialize(e.parse(o), Qo(n));
        h0(n, g0, r);
      }, Dh = (e, n) => ho(e) ? Zn(j4, n) ? e + "" : e + "px" : e, p0 = (e, n, o) => {
        const r = vf(n);
        gn(o) || o === "" ? od(e, r) : rf(e, r, Dh(o, r));
      }, Uw = (e, n, o) => {
        const r = n.keep_values, c = {
          set: (f, b, y) => {
            const E = le.fromDom(f);
            re(n.url_converter) && De(b) && (b = n.url_converter.call(n.url_converter_scope || o(), String(b), y, f));
            const N = "data-mce-" + y;
            h0(E, N, b), h0(E, y, b);
          },
          get: (f, b) => {
            const y = le.fromDom(f);
            return ia(y, "data-mce-" + b) || ia(y, b);
          }
        }, u = {
          style: {
            set: (f, b) => {
              const y = le.fromDom(f);
              r && h0(y, g0, b), _r(y, "style"), J(b) && Ya(y, e.parse(b));
            },
            get: (f) => {
              const b = le.fromDom(f), y = ia(b, g0) || ia(b, "style");
              return e.serialize(e.parse(y), Qo(b));
            }
          }
        };
        return r && (u.href = u.src = c), u;
      }, xr = (e, n = {}) => {
        const o = {}, r = window, c = {};
        let u = 0;
        const f = !0, b = !0, y = Ey.forElement(le.fromDom(e), {
          contentCssCors: n.contentCssCors,
          referrerPolicy: n.referrerPolicy
        }), E = [], N = n.schema ? n.schema : Tm({}), M = l0({
          url_converter: n.url_converter,
          url_converter_scope: n.url_converter_scope,
          force_hex_color: n.force_hex_color
        }, n.schema), I = n.ownEvents ? new ul() : ul.Event, X = N.getBlockElements(), te = (He) => J(He) ? Zn(X, He) : xn(He) && (Zn(X, He.nodeName) || cs(N, He)), G = (He) => He && e && J(He) ? e.getElementById(He) : He, ne = (He) => {
          const Ze = G(He);
          return De(Ze) ? le.fromDom(Ze) : null;
        }, Se = (He, Ze, jt = "") => {
          let Lt;
          const so = ne(He);
          if (De(so) && yn(so)) {
            const us = Dw[Ze];
            us && us.get ? Lt = us.get(so.dom, Ze) : Lt = ia(so, Ze);
          }
          return De(Lt) ? Lt : jt;
        }, ke = (He) => {
          const Ze = G(He);
          return gn(Ze) ? [] : Ze.attributes;
        }, Ae = (He, Ze, jt) => {
          vn(He, (Lt) => {
            if (xn(Lt)) {
              const so = le.fromDom(Lt), us = jt === "" ? null : jt, Kr = ia(so, Ze), Ua = Dw[Ze];
              Ua && Ua.set ? Ua.set(so.dom, us, Ze) : h0(so, Ze, us), Kr !== us && n.onSetAttrib && n.onSetAttrib({
                attrElm: so.dom,
                attrName: Ze,
                attrValue: us
              });
            }
          });
        }, Me = (He, Ze) => He.cloneNode(Ze), pt = () => n.root_element || e.body, It = (He) => {
          const Ze = Ma(He);
          return {
            x: Ze.x,
            y: Ze.y,
            w: Ze.width,
            h: Ze.height
          };
        }, un = (He, Ze) => vr(e.body, G(He), Ze), nt = (He, Ze, jt) => {
          vn(He, (Lt) => {
            const so = le.fromDom(Lt);
            p0(so, Ze, jt), n.update_styles && $y(M, so);
          });
        }, qe = (He, Ze) => {
          vn(He, (jt) => {
            const Lt = le.fromDom(jt);
            Dt(Ze, (so, us) => {
              p0(Lt, us, so);
            }), n.update_styles && $y(M, Lt);
          });
        }, xt = (He, Ze, jt) => {
          const Lt = G(He);
          if (!(gn(Lt) || !Au(Lt) && !vy(Lt)))
            return jt ? ha(le.fromDom(Lt), vf(Ze)) : (Ze = Ze.replace(/-(\D)/g, (so, us) => us.toUpperCase()), Ze === "float" && (Ze = "cssFloat"), Lt.style ? Lt.style[Ze] : void 0);
        }, bn = (He) => {
          const Ze = G(He);
          if (!Ze)
            return {
              w: 0,
              h: 0
            };
          let jt = xt(Ze, "width"), Lt = xt(Ze, "height");
          return (!jt || jt.indexOf("px") === -1) && (jt = "0"), (!Lt || Lt.indexOf("px") === -1) && (Lt = "0"), {
            w: parseInt(jt, 10) || Ze.offsetWidth || Ze.clientWidth,
            h: parseInt(Lt, 10) || Ze.offsetHeight || Ze.clientHeight
          };
        }, Yn = (He) => {
          const Ze = G(He), jt = un(Ze), Lt = bn(Ze);
          return {
            x: jt.x,
            y: jt.y,
            w: Lt.w,
            h: Lt.h
          };
        }, Po = (He, Ze) => {
          if (!He)
            return !1;
          const jt = ht(He) ? He : [He];
          return pe(jt, (Lt) => Si(le.fromDom(Lt), Ze));
        }, Ko = (He, Ze, jt, Lt) => {
          const so = [];
          let us = G(He);
          Lt = Lt === void 0;
          const Kr = jt || (pt().nodeName !== "BODY" ? pt().parentNode : null);
          if (J(Ze))
            if (Ze === "*")
              Ze = xn;
            else {
              const Ua = Ze;
              Ze = (sc) => Po(sc, Ua);
            }
          for (; us && !(us === Kr || gn(us.nodeType) || dg(us) || $r(us)); ) {
            if (!Ze || Ze(us))
              if (Lt)
                so.push(us);
              else
                return [us];
            us = us.parentNode;
          }
          return Lt ? so : null;
        }, er = (He, Ze, jt) => {
          const Lt = Ko(He, Ze, jt, !1);
          return Lt && Lt.length > 0 ? Lt[0] : null;
        }, Er = (He, Ze, jt) => {
          let Lt = Ze;
          if (He) {
            J(Ze) && (Lt = (so) => Po(so, Ze));
            for (let so = He[jt]; so; so = so[jt])
              if (re(Lt) && Lt(so))
                return so;
          }
          return null;
        }, wa = (He, Ze) => Er(He, Ze, "nextSibling"), si = (He, Ze) => Er(He, Ze, "previousSibling"), kc = (He) => re(He.querySelectorAll), Gt = (He, Ze) => {
          var jt, Lt;
          const so = (Lt = (jt = G(Ze)) !== null && jt !== void 0 ? jt : n.root_element) !== null && Lt !== void 0 ? Lt : e;
          return kc(so) ? rs(so.querySelectorAll(He)) : [];
        }, vn = function(He, Ze, jt) {
          const Lt = jt ?? this;
          if (ht(He)) {
            const so = [];
            return f0(He, (us, Kr) => {
              const Ua = G(us);
              Ua && so.push(Ze.call(Lt, Ua, Kr));
            }), so;
          } else {
            const so = G(He);
            return so ? Ze.call(Lt, so) : !1;
          }
        }, As = (He, Ze) => {
          vn(He, (jt) => {
            Dt(Ze, (Lt, so) => {
              Ae(jt, so, Lt);
            });
          });
        }, vs = (He, Ze) => {
          vn(He, (jt) => {
            const Lt = le.fromDom(jt);
            sd(Lt, Ze);
          });
        }, zn = (He, Ze, jt, Lt, so) => vn(He, (us) => {
          const Kr = J(Ze) ? e.createElement(Ze) : Ze;
          return De(jt) && As(Kr, jt), Lt && (!J(Lt) && Lt.nodeType ? Kr.appendChild(Lt) : J(Lt) && vs(Kr, Lt)), so ? Kr : us.appendChild(Kr);
        }), Un = (He, Ze, jt) => zn(e.createElement(He), He, Ze, jt, !0), zt = wg.decode, Eo = wg.encodeAllRaw, hs = (He, Ze, jt = "") => {
          let Lt = "<" + He;
          for (const so in Ze)
            dr(Ze, so) && (Lt += " " + so + '="' + Eo(Ze[so]) + '"');
          return Fo(jt) && Zn(N.getVoidElements(), He) ? Lt + " />" : Lt + ">" + jt + "</" + He + ">";
        }, nr = (He) => {
          const Ze = e.createElement("div"), jt = e.createDocumentFragment();
          jt.appendChild(Ze), He && (Ze.innerHTML = He);
          let Lt;
          for (; Lt = Ze.firstChild; )
            jt.appendChild(Lt);
          return jt.removeChild(Ze), jt;
        }, kr = (He, Ze) => vn(He, (jt) => {
          const Lt = le.fromDom(jt);
          return Ze && ae(Ea(Lt), (so) => {
            vo(so) && so.dom.length === 0 ? bs(so) : ka(Lt, so);
          }), bs(Lt), Lt.dom;
        }), Qi = (He) => vn(He, (Ze) => {
          const jt = Ze.attributes;
          for (let Lt = jt.length - 1; Lt >= 0; Lt--)
            Ze.removeAttributeNode(jt.item(Lt));
        }), hu = (He) => M.parse(He), Yf = (He, Ze) => M.serialize(He, Ze), el = (He) => {
          if (nh !== xr.DOM && e === document) {
            if (o[He])
              return;
            o[He] = !0;
          }
          let Ze = e.getElementById("mceDefaultStyles");
          if (!Ze) {
            Ze = e.createElement("style"), Ze.id = "mceDefaultStyles", Ze.type = "text/css";
            const jt = e.head;
            jt.firstChild ? jt.insertBefore(Ze, jt.firstChild) : jt.appendChild(Ze);
          }
          Ze.styleSheet ? Ze.styleSheet.cssText += He : Ze.appendChild(e.createTextNode(He));
        }, rm = (He) => {
          He || (He = ""), ae(He.split(","), (Ze) => {
            c[Ze] = !0, y.load(Ze).catch(Oe);
          });
        }, Do = (He, Ze, jt) => {
          vn(He, (Lt) => {
            if (xn(Lt)) {
              const so = le.fromDom(Lt), us = Ze.split(" ");
              ae(us, (Kr) => {
                De(jt) ? (jt ? Cu : Sl)(so, Kr) : oh(so, Kr);
              });
            }
          });
        }, ps = (He, Ze) => {
          Do(He, Ze, !0);
        }, Ls = (He, Ze) => {
          Do(He, Ze, !1);
        }, Gr = (He, Ze) => {
          const jt = ne(He), Lt = Ze.split(" ");
          return De(jt) && No(Lt, (so) => wu(jt, so));
        }, ra = (He) => {
          vn(He, (Ze) => od(le.fromDom(Ze), "display"));
        }, _d = (He) => {
          vn(He, (Ze) => rf(le.fromDom(Ze), "display", "none"));
        }, iy = (He) => {
          const Ze = ne(He);
          return De(Ze) && Us(ta(Ze, "display"), "none");
        }, ly = (He) => (He || "mce_") + u++, Xf = (He) => {
          const Ze = ne(He);
          return De(Ze) ? xn(Ze.dom) ? Ze.dom.outerHTML : mh(Ze) : "";
        }, Jf = (He, Ze) => {
          vn(He, (jt) => {
            xn(jt) && (jt.outerHTML = Ze);
          });
        }, Kp = (He, Ze) => {
          const jt = G(Ze);
          return vn(He, (Lt) => {
            const so = jt?.parentNode, us = jt?.nextSibling;
            return so && (us ? so.insertBefore(Lt, us) : so.appendChild(Lt)), Lt;
          });
        }, uy = (He, Ze, jt) => vn(Ze, (Lt) => {
          var so;
          const us = ht(Ze) ? He.cloneNode(!0) : He;
          return jt && f0(Vw(Lt.childNodes), (Kr) => {
            us.appendChild(Kr);
          }), (so = Lt.parentNode) === null || so === void 0 || so.replaceChild(us, Lt), Lt;
        }), Aw = (He, Ze) => {
          if (He.nodeName !== Ze.toUpperCase()) {
            const jt = Un(Ze);
            return f0(ke(He), (Lt) => {
              Ae(jt, Lt.nodeName, Se(He, Lt.nodeName));
            }), uy(jt, He, !0), jt;
          } else
            return He;
        }, ik = (He, Ze) => {
          let jt = He;
          for (; jt; ) {
            let Lt = Ze;
            for (; Lt && jt !== Lt; )
              Lt = Lt.parentNode;
            if (jt === Lt)
              break;
            jt = jt.parentNode;
          }
          return !jt && He.ownerDocument ? He.ownerDocument.documentElement : jt;
        }, Wb = (He) => {
          if (xn(He)) {
            const Ze = He.nodeName.toLowerCase() === "a" && !Se(He, "href") && Se(He, "id");
            if (Se(He, "name") || Se(He, "data-mce-bookmark") || Ze)
              return !0;
          }
          return !1;
        }, lk = (He, Ze, jt) => {
          let Lt = 0;
          if (Wb(He))
            return !1;
          const so = He.firstChild;
          if (so) {
            const us = new br(so, He), Kr = N ? N.getWhitespaceElements() : {}, Ua = Ze || (N ? N.getNonEmptyElements() : null);
            let sc = so;
            do {
              if (xn(sc)) {
                const gy = sc.getAttribute("data-mce-bogus");
                if (gy) {
                  sc = us.next(gy === "all");
                  continue;
                }
                const hy = sc.nodeName.toLowerCase();
                if (Ua && Ua[hy]) {
                  if (hy === "br") {
                    Lt++, sc = us.next();
                    continue;
                  }
                  return !1;
                }
                if (Wb(sc))
                  return !1;
              }
              if (rd(sc) || Mt(sc) && !ff(sc.data) && (!jt?.includeZwsp || !hg(sc.data)) || Mt(sc) && sc.parentNode && Kr[sc.parentNode.nodeName] && ff(sc.data))
                return !1;
              sc = us.next();
            } while (sc);
          }
          return Lt <= 1;
        }, Yp = () => e.createRange(), dy = (He, Ze, jt) => {
          let Lt = Yp(), so, us;
          if (He && Ze && He.parentNode && Ze.parentNode) {
            const Kr = He.parentNode;
            return Lt.setStart(Kr, Id(He)), Lt.setEnd(Ze.parentNode, Id(Ze)), so = Lt.extractContents(), Lt = Yp(), Lt.setStart(Ze.parentNode, Id(Ze) + 1), Lt.setEnd(Kr, Id(He) + 1), us = Lt.extractContents(), Kr.insertBefore(wm(nh, so, N), He), jt ? Kr.insertBefore(jt, He) : Kr.insertBefore(Ze, He), Kr.insertBefore(wm(nh, us, N), He), kr(He), jt || Ze;
          } else
            return;
        }, am = (He, Ze, jt, Lt) => {
          if (ht(He)) {
            let so = He.length;
            const us = [];
            for (; so--; )
              us[so] = am(He[so], Ze, jt, Lt);
            return us;
          } else
            return n.collect && (He === e || He === r) && E.push([
              He,
              Ze,
              jt,
              Lt
            ]), I.bind(He, Ze, jt, Lt || nh);
        }, Qf = (He, Ze, jt) => {
          if (ht(He)) {
            let Lt = He.length;
            const so = [];
            for (; Lt--; )
              so[Lt] = Qf(He[Lt], Ze, jt);
            return so;
          } else {
            if (E.length > 0 && (He === e || He === r)) {
              let Lt = E.length;
              for (; Lt--; ) {
                const [so, us, Kr] = E[Lt];
                He === so && (!Ze || Ze === us) && (!jt || jt === Kr) && I.unbind(so, us, Kr);
              }
            }
            return I.unbind(He, Ze, jt);
          }
        }, my = (He, Ze, jt) => I.dispatch(He, Ze, jt), fy = (He, Ze, jt) => I.dispatch(He, Ze, jt), Ow = (He) => {
          if (He && Au(He)) {
            const Ze = He.getAttribute("data-mce-contenteditable");
            return Ze && Ze !== "inherit" ? Ze : He.contentEditable !== "inherit" ? He.contentEditable : null;
          } else
            return null;
        }, nh = {
          doc: e,
          settings: n,
          win: r,
          files: c,
          stdMode: f,
          boxModel: b,
          styleSheetLoader: y,
          boundEvents: E,
          styles: M,
          schema: N,
          events: I,
          isBlock: te,
          root: null,
          clone: Me,
          getRoot: pt,
          getViewPort: It,
          getRect: Yn,
          getSize: bn,
          getParent: er,
          getParents: Ko,
          get: G,
          getNext: wa,
          getPrev: si,
          select: Gt,
          is: Po,
          add: zn,
          create: Un,
          createHTML: hs,
          createFragment: nr,
          remove: kr,
          setStyle: nt,
          getStyle: xt,
          setStyles: qe,
          removeAllAttribs: Qi,
          setAttrib: Ae,
          setAttribs: As,
          getAttrib: Se,
          getPos: un,
          parseStyle: hu,
          serializeStyle: Yf,
          addStyle: el,
          loadCSS: rm,
          addClass: ps,
          removeClass: Ls,
          hasClass: Gr,
          toggleClass: Do,
          show: ra,
          hide: _d,
          isHidden: iy,
          uniqueId: ly,
          setHTML: vs,
          getOuterHTML: Xf,
          setOuterHTML: Jf,
          decode: zt,
          encode: Eo,
          insertAfter: Kp,
          replace: uy,
          rename: Aw,
          findCommonAncestor: ik,
          run: vn,
          getAttribs: ke,
          isEmpty: lk,
          createRng: Yp,
          nodeIndex: Id,
          split: dy,
          bind: am,
          unbind: Qf,
          fire: fy,
          dispatch: my,
          getContentEditable: Ow,
          getContentEditableParent: (He) => {
            const Ze = pt();
            let jt = null;
            for (let Lt = He; Lt && Lt !== Ze && (jt = Ow(Lt), jt === null); Lt = Lt.parentNode)
              ;
            return jt;
          },
          isEditable: (He) => {
            if (De(He)) {
              const Ze = xn(He) ? He : He.parentElement;
              return De(Ze) && Au(Ze) && Mo(le.fromDom(Ze));
            } else
              return !1;
          },
          destroy: () => {
            if (E.length > 0) {
              let He = E.length;
              for (; He--; ) {
                const [Ze, jt, Lt] = E[He];
                I.unbind(Ze, jt, Lt);
              }
            }
            Dt(c, (He, Ze) => {
              y.unload(Ze), delete c[Ze];
            });
          },
          isChildOf: (He, Ze) => He === Ze || Ze.contains(He),
          dumpRng: (He) => "startContainer: " + He.startContainer.nodeName + ", startOffset: " + He.startOffset + ", endContainer: " + He.endContainer.nodeName + ", endOffset: " + He.endOffset
        }, Dw = Uw(M, n, it(nh));
        return nh;
      };
      xr.DOM = xr(document), xr.nodeIndex = Id;
      const Rk = xr.DOM, ba = 0, Ww = 1, Wr = 2, Rh = 3;
      class Ha {
        constructor(n = {}) {
          this.states = {}, this.queue = [], this.scriptLoadedCallbacks = {}, this.queueLoadedCallbacks = [], this.loading = !1, this.settings = n;
        }
        _setReferrerPolicy(n) {
          this.settings.referrerPolicy = n;
        }
        loadScript(n) {
          return new Promise((o, r) => {
            const c = Rk;
            let u;
            const f = () => {
              c.remove(E), u && (u.onerror = u.onload = u = null);
            }, b = () => {
              f(), o();
            }, y = () => {
              f(), r("Failed to load script: " + n);
            }, E = c.uniqueId();
            u = document.createElement("script"), u.id = E, u.type = "text/javascript", u.src = _t._addCacheSuffix(n), this.settings.referrerPolicy && c.setAttrib(u, "referrerpolicy", this.settings.referrerPolicy), u.onload = b, u.onerror = y, (document.getElementsByTagName("head")[0] || document.body).appendChild(u);
          });
        }
        isDone(n) {
          return this.states[n] === Wr;
        }
        markDone(n) {
          this.states[n] = Wr;
        }
        add(n) {
          const o = this;
          return o.queue.push(n), o.states[n] === void 0 && (o.states[n] = ba), new Promise((c, u) => {
            o.scriptLoadedCallbacks[n] || (o.scriptLoadedCallbacks[n] = []), o.scriptLoadedCallbacks[n].push({
              resolve: c,
              reject: u
            });
          });
        }
        load(n) {
          return this.add(n);
        }
        remove(n) {
          delete this.states[n], delete this.scriptLoadedCallbacks[n];
        }
        loadQueue() {
          const n = this.queue;
          return this.queue = [], this.loadScripts(n);
        }
        loadScripts(n) {
          const o = this, r = (y, E) => {
            Ts(o.scriptLoadedCallbacks, E).each((N) => {
              ae(N, (M) => M[y](E));
            }), delete o.scriptLoadedCallbacks[E];
          }, c = (y) => {
            const E = Yt(y, (N) => N.status === "rejected");
            return E.length > 0 ? Promise.reject(ds(E, ({ reason: N }) => ht(N) ? N : [N])) : Promise.resolve();
          }, u = (y) => Promise.allSettled(ye(y, (E) => o.states[E] === Wr ? (r("resolve", E), Promise.resolve()) : o.states[E] === Rh ? (r("reject", E), Promise.reject(E)) : (o.states[E] = Ww, o.loadScript(E).then(() => {
            o.states[E] = Wr, r("resolve", E);
            const N = o.queue;
            return N.length > 0 ? (o.queue = [], u(N).then(c)) : Promise.resolve();
          }, () => (o.states[E] = Rh, r("reject", E), Promise.reject(E)))))), f = (y) => (o.loading = !0, u(y).then((E) => {
            o.loading = !1;
            const N = o.queueLoadedCallbacks.shift();
            return F.from(N).each(kn), c(E);
          })), b = Za(n);
          return o.loading ? new Promise((y, E) => {
            o.queueLoadedCallbacks.push(() => {
              f(b).then(y, E);
            });
          }) : f(b);
        }
      }
      Ha.ScriptLoader = new Ha();
      const jr = (e) => {
        let n = e;
        return {
          get: () => n,
          set: (c) => {
            n = c;
          }
        };
      }, Ml = (e, n) => {
        const o = e.indexOf(n);
        return o !== -1 && e.indexOf(n, o + 1) > o;
      }, Fy = (e) => Qe(e) && Zn(e, "raw"), Ic = (e) => ht(e) && e.length > 1, x1 = {}, Nh = jr("en"), Ld = () => Ts(x1, Nh.get()), Fu = {
        getData: () => Lo(x1, (e) => ({ ...e })),
        setCode: (e) => {
          e && Nh.set(e);
        },
        getCode: () => Nh.get(),
        add: (e, n) => {
          let o = x1[e];
          o || (x1[e] = o = {});
          const r = ye(Ss(n), (c) => c.toLowerCase());
          Dt(n, (c, u) => {
            const f = u.toLowerCase();
            f !== u && Ml(r, f) ? (Zn(n, f) || (o[f] = c), o[u] = c) : o[f] = c;
          });
        },
        translate: (e) => {
          const n = Ld().getOr({}), o = (f) => re(f) ? Object.prototype.toString.call(f) : r(f) ? "" : "" + f, r = (f) => f === "" || f === null || f === void 0, c = (f) => {
            const b = o(f);
            return Zn(n, b) ? o(n[b]) : Ts(n, b.toLowerCase()).map(o).getOr(b);
          }, u = (f) => f.replace(/{context:\w+}$/, "");
          if (r(e))
            return "";
          if (Fy(e))
            return o(e.raw);
          if (Ic(e)) {
            const f = e.slice(1), b = c(e[0]).replace(/\{([0-9]+)\}/g, (y, E) => Zn(f, E) ? o(f[E]) : y);
            return u(b);
          }
          return u(c(e));
        },
        isRtl: () => Ld().bind((e) => Ts(e, "_dir")).exists((e) => e === "rtl"),
        hasCode: (e) => Zn(x1, e)
      }, mi = () => {
        const e = [], n = {}, o = {}, r = [], c = (G, ne) => {
          const Se = Yt(r, (ke) => ke.name === G && ke.state === ne);
          ae(Se, (ke) => ke.resolve());
        }, u = (G) => Zn(n, G), f = (G) => Zn(o, G), b = (G) => {
          if (o[G])
            return o[G].instance;
        }, y = (G, ne) => {
          const Se = Fu.getCode(), ke = "," + (ne || "") + ",";
          !Se || ne && ke.indexOf("," + Se + ",") === -1 || Ha.ScriptLoader.add(n[G] + "/langs/" + Se + ".js");
        }, E = (G, ne) => {
          mi.languageLoad !== !1 && (u(G) ? y(G, ne) : te(G, "loaded").then(() => y(G, ne)));
        }, N = (G, ne) => (e.push(ne), o[G] = { instance: ne }, c(G, "added"), ne), M = (G) => {
          delete n[G], delete o[G];
        }, I = (G, ne) => J(ne) ? J(G) ? {
          prefix: "",
          resource: ne,
          suffix: ""
        } : {
          prefix: G.prefix,
          resource: ne,
          suffix: G.suffix
        } : ne, X = (G, ne) => {
          if (n[G])
            return Promise.resolve();
          let Se = J(ne) ? ne : ne.prefix + ne.resource + ne.suffix;
          Se.indexOf("/") !== 0 && Se.indexOf("://") === -1 && (Se = mi.baseURL + "/" + Se), n[G] = Se.substring(0, Se.lastIndexOf("/"));
          const ke = () => (c(G, "loaded"), Promise.resolve());
          return o[G] ? ke() : Ha.ScriptLoader.add(Se).then(ke);
        }, te = (G, ne = "added") => ne === "added" && f(G) || ne === "loaded" && u(G) ? Promise.resolve() : new Promise((Se) => {
          r.push({
            name: G,
            state: ne,
            resolve: Se
          });
        });
        return {
          items: e,
          urls: n,
          lookup: o,
          get: b,
          requireLangPack: E,
          add: N,
          remove: M,
          createUrl: I,
          load: X,
          waitFor: te
        };
      };
      mi.languageLoad = !0, mi.baseURL = "", mi.PluginManager = mi(), mi.ThemeManager = mi(), mi.ModelManager = mi();
      const Mk = (e) => {
        const n = jr(F.none()), o = () => n.get().each(e);
        return {
          clear: () => {
            o(), n.set(F.none());
          },
          isSet: () => n.get().isSome(),
          get: () => n.get(),
          set: (b) => {
            o(), n.set(F.some(b));
          }
        };
      }, Pk = (e) => {
        const n = jr(F.none()), o = () => n.get().each((b) => clearInterval(b));
        return {
          clear: () => {
            o(), n.set(F.none());
          },
          isSet: () => n.get().isSome(),
          get: () => n.get(),
          set: (b) => {
            o(), n.set(F.some(setInterval(b, e)));
          }
        };
      }, Cf = () => {
        const e = Mk(Oe);
        return {
          ...e,
          on: (o) => e.get().each(o)
        };
      }, T1 = (e, n) => {
        let o = null;
        return {
          cancel: () => {
            U(o) || (clearTimeout(o), o = null);
          },
          throttle: (...u) => {
            U(o) && (o = setTimeout(() => {
              o = null, e.apply(null, u);
            }, n));
          }
        };
      }, b0 = (e, n) => {
        let o = null;
        const r = () => {
          U(o) || (clearTimeout(o), o = null);
        };
        return {
          cancel: r,
          throttle: (...u) => {
            r(), o = setTimeout(() => {
              o = null, e.apply(null, u);
            }, n);
          }
        };
      }, v0 = it("mce-annotation"), Hd = it("data-mce-annotation"), Ph = it("data-mce-annotation-uid"), Bh = it("data-mce-annotation-active"), $h = it("data-mce-annotation-classes"), Tg = it("data-mce-annotation-attrs"), jw = (e) => (n) => fs(n, e), da = (e, n) => {
        const o = e.selection.getRng(), r = le.fromDom(o.startContainer), c = le.fromDom(e.getBody()), u = n.fold(() => "." + v0(), (y) => `[${Hd()}="${y}"]`), f = ed(r, o.startOffset).getOr(r);
        return Hi(f, u, jw(c)).bind((y) => wc(y, `${Ph()}`).bind((E) => wc(y, `${Hd()}`).map((N) => {
          const M = Gw(e, E);
          return {
            uid: E,
            name: N,
            elements: M
          };
        })));
      }, qw = (e) => yn(e) && wu(e, v0()), Fh = (e, n) => ea(e, "data-mce-bogus") || by(e, '[data-mce-bogus="all"]', jw(n)), Gw = (e, n) => {
        const o = le.fromDom(e.getBody()), r = uc(o, `[${Ph()}="${n}"]`);
        return Yt(r, (c) => !Fh(c, o));
      }, y0 = (e, n) => {
        const o = le.fromDom(e.getBody()), r = uc(o, `[${Hd()}="${n}"]`), c = {};
        return ae(r, (u) => {
          if (!Fh(u, o)) {
            const f = ia(u, Ph()), b = Ts(c, f).getOr([]);
            c[f] = b.concat([u]);
          }
        }), c;
      }, Xc = (e, n) => {
        const o = jr({}), r = () => ({
          listeners: [],
          previous: Cf()
        }), c = (M, I) => {
          u(M, (X) => (I(X), X));
        }, u = (M, I) => {
          const X = o.get(), te = Ts(X, M).getOrThunk(r), G = I(te);
          X[M] = G, o.set(X);
        }, f = (M, I, X) => {
          c(M, (te) => {
            ae(te.listeners, (G) => G(!0, M, {
              uid: I,
              nodes: ye(X, (ne) => ne.dom)
            }));
          });
        }, b = (M) => {
          c(M, (I) => {
            ae(I.listeners, (X) => X(!1, M));
          });
        }, y = (M, I) => {
          ae(Gw(e, M), (X) => {
            I ? ks(X, Bh(), "true") : _r(X, Bh());
          });
        }, E = b0(() => {
          const M = et(n.getNames());
          ae(M, (I) => {
            u(I, (X) => {
              const te = X.previous.get();
              return da(e, F.some(I)).fold(() => {
                te.each((G) => {
                  b(I), X.previous.clear(), y(G, !1);
                });
              }, ({ uid: G, name: ne, elements: Se }) => {
                Us(te, G) || (te.each((ke) => y(ke, !1)), f(ne, G, Se), X.previous.set(G), y(G, !0));
              }), {
                previous: X.previous,
                listeners: X.listeners
              };
            });
          });
        }, 30);
        return e.on("remove", () => {
          E.cancel();
        }), e.on("NodeChange", () => {
          E.throttle();
        }), { addListener: (M, I) => {
          u(M, (X) => ({
            previous: X.previous,
            listeners: X.listeners.concat([I])
          }));
        } };
      }, Pl = (e, n) => {
        const o = Hd(), r = (u) => F.from(u.attr(o)).bind(n.lookup), c = (u) => {
          var f, b;
          u.attr(Ph(), null), u.attr(Hd(), null), u.attr(Bh(), null);
          const y = F.from(u.attr(Tg())).map((I) => I.split(",")).getOr([]), E = F.from(u.attr($h())).map((I) => I.split(",")).getOr([]);
          ae(y, (I) => u.attr(I, null));
          const N = (b = (f = u.attr("class")) === null || f === void 0 ? void 0 : f.split(" ")) !== null && b !== void 0 ? b : [], M = Cs(N, [v0()].concat(E));
          u.attr("class", M.length > 0 ? M.join(" ") : null), u.attr($h(), null), u.attr(Tg(), null);
        };
        e.serializer.addTempAttr(Bh()), e.serializer.addAttributeFilter(o, (u) => {
          for (const f of u)
            r(f).each((b) => {
              b.persistent === !1 && (f.name === "span" ? f.unwrap() : c(f));
            });
        });
      }, Kw = () => {
        const e = {};
        return {
          register: (c, u) => {
            e[c] = {
              name: c,
              settings: u
            };
          },
          lookup: (c) => Ts(e, c).map((u) => u.settings),
          getNames: () => Ss(e)
        };
      };
      let C0 = 0;
      const Eg = (e) => {
        const o = (/* @__PURE__ */ new Date()).getTime(), r = Math.floor(Math.random() * 1e9);
        return C0++, e + "_" + r + C0 + String(o);
      }, Bk = (e, n) => {
        ae(n, (o) => {
          Cu(e, o);
        });
      }, Yw = (e, n) => {
        ae(n, (o) => {
          Sl(e, o);
        });
      }, Iy = (e, n) => le.fromDom(e.dom.cloneNode(n)), dl = (e) => Iy(e, !1), w0 = (e) => Iy(e, !0), va = (e, n) => {
        const o = le.fromTag(n), r = Nc(e);
        return Br(o, r), o;
      }, ld = (e, n) => {
        const o = va(e, n);
        Ti(e, o);
        const r = Ea(e);
        return Ms(o, r), bs(e), o;
      }, Ih = (e, n, o = $e) => {
        const r = new br(e, n), c = (u) => {
          let f;
          do
            f = r[u]();
          while (f && !Mt(f) && !o(f));
          return F.from(f).filter(Mt);
        };
        return {
          current: () => F.from(r.current()).filter(Mt),
          next: () => c("next"),
          prev: () => c("prev"),
          prev2: () => c("prev2")
        };
      }, wf = (e, n) => {
        const o = n || ((f) => e.isBlock(f) || Js(f) || es(f)), r = (f, b, y, E) => {
          if (Mt(f)) {
            const N = E(f, b, f.data);
            if (N !== -1)
              return F.some({
                container: f,
                offset: N
              });
          }
          return y().bind((N) => r(N.container, N.offset, y, E));
        };
        return {
          backwards: (f, b, y, E) => {
            const N = Ih(f, E ?? e.getRoot(), o);
            return r(f, b, () => N.prev().map((M) => ({
              container: M,
              offset: M.length
            })), y).getOrNull();
          },
          forwards: (f, b, y, E) => {
            const N = Ih(f, E ?? e.getRoot(), o);
            return r(f, b, () => N.next().map((M) => ({
              container: M,
              offset: 0
            })), y).getOrNull();
          }
        };
      }, kg = Math.round, _g = (e) => e ? {
        left: kg(e.left),
        top: kg(e.top),
        bottom: kg(e.bottom),
        right: kg(e.right),
        width: kg(e.width),
        height: kg(e.height)
      } : {
        left: 0,
        top: 0,
        bottom: 0,
        right: 0,
        width: 0,
        height: 0
      }, km = (e, n) => (e = _g(e), n || (e.left = e.left + e.width), e.right = e.left, e.width = 0, e), Xw = (e, n) => e.left === n.left && e.top === n.top && e.bottom === n.bottom && e.right === n.right, Ag = (e, n, o) => e >= 0 && e <= Math.min(n.height, o.height) / 2, Sf = (e, n) => {
        const o = Math.min(n.height / 2, e.height / 2);
        return e.bottom - o < n.top ? !0 : e.top > n.bottom ? !1 : Ag(n.top - e.bottom, e, n);
      }, Og = (e, n) => e.top > n.bottom ? !0 : e.bottom < n.top ? !1 : Ag(n.bottom - e.top, e, n), Jw = (e, n, o) => n >= e.left && n <= e.right && o >= e.top && o <= e.bottom, $k = (e) => Xe(e, (n, o) => n.fold(() => F.some(o), (r) => {
        const c = Math.min(o.left, r.left), u = Math.min(o.top, r.top), f = Math.max(o.right, r.right), b = Math.max(o.bottom, r.bottom);
        return F.some({
          top: u,
          right: f,
          bottom: b,
          left: c,
          width: f - c,
          height: b - u
        });
      }), F.none()), Ly = (e, n, o) => {
        const r = Math.max(Math.min(n, e.left + e.width), e.left), c = Math.max(Math.min(o, e.top + e.height), e.top);
        return Math.sqrt((n - r) * (n - r) + (o - c) * (o - c));
      }, Fk = (e, n) => Math.max(0, Math.min(e.bottom, n.bottom) - Math.max(e.top, n.top)), S0 = (e, n, o) => Math.min(Math.max(e, n), o), Hy = (e) => {
        const n = e.startContainer, o = e.startOffset;
        return n === e.endContainer && n.hasChildNodes() && e.endOffset === o + 1 ? n.childNodes[o] : null;
      }, ml = (e, n) => {
        if (xn(e) && e.hasChildNodes()) {
          const o = e.childNodes, r = S0(n, 0, o.length - 1);
          return o[r];
        } else
          return e;
      }, Qw = (e, n) => {
        if (!(n < 0 && xn(e) && e.hasChildNodes()))
          return ml(e, n);
      }, Lh = new RegExp("[̀-ͯ҃-҇҈-҉֑-ֽֿׁ-ׂׄ-ׇׅؐ-ًؚ-ٰٟۖ-ۜ۟-ۤۧ-۪ۨ-ܑۭܰ-݊ަ-ް߫-߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࣣ-ंऺ़ु-ै्॑-ॗॢ-ॣঁ়াু-ৄ্ৗৢ-ৣਁ-ਂ਼ੁ-ੂੇ-ੈੋ-੍ੑੰ-ੱੵઁ-ં઼ુ-ૅે-ૈ્ૢ-ૣଁ଼ାିୁ-ୄ୍ୖୗୢ-ୣஂாீ்ௗఀా-ీె-ైొ-్ౕ-ౖౢ-ౣಁ಼ಿೂೆೌ-್ೕ-ೖೢ-ೣഁാു-ൄ്ൗൢ-ൣ්ාි-ුූෟัิ-ฺ็-๎ັິ-ູົ-ຼ່-ໍ༘-ཱ༹༙༵༷-ཾྀ-྄྆-྇ྍ-ྗྙ-ྼ࿆ိ-ူဲ-့္-်ွ-ှၘ-ၙၞ-ၠၱ-ၴႂႅ-ႆႍႝ፝-፟ᜒ-᜔ᜲ-᜴ᝒ-ᝓᝲ-ᝳ឴-឵ិ-ួំ៉-៓៝᠋-᠍ᢩᤠ-ᤢᤧ-ᤨᤲ᤹-᤻ᨗ-ᨘᨛᩖᩘ-ᩞ᩠ᩢᩥ-ᩬᩳ-᩿᩼᪰-᪽᪾ᬀ-ᬃ᬴ᬶ-ᬺᬼᭂ᭫-᭳ᮀ-ᮁᮢ-ᮥᮨ-ᮩ᮫-ᮭ᯦ᯨ-ᯩᯭᯯ-ᯱᰬ-ᰳᰶ-᰷᳐-᳔᳒-᳢᳠-᳨᳭᳴᳸-᳹᷀-᷵᷼-᷿‌-‍⃐-⃜⃝-⃠⃡⃢-⃤⃥-⃰⳯-⵿⳱ⷠ-〪ⷿ-〭〮-゙〯-゚꙯꙰-꙲ꙴ-꙽ꚞ-ꚟ꛰-꛱ꠂ꠆ꠋꠥ-ꠦ꣄꣠-꣱ꤦ-꤭ꥇ-ꥑꦀ-ꦂ꦳ꦶ-ꦹꦼꧥꨩ-ꨮꨱ-ꨲꨵ-ꨶꩃꩌꩼꪰꪲ-ꪴꪷ-ꪸꪾ-꪿꫁ꫬ-ꫭ꫶ꯥꯨ꯭ﬞ︀-️︠-︯ﾞ-ﾟ]"), eS = (e) => J(e) && e.charCodeAt(0) >= 768 && Lh.test(e), Ik = (...e) => (n) => {
        for (let o = 0; o < e.length; o++)
          if (e[o](n))
            return !0;
        return !1;
      }, E1 = (...e) => (n) => {
        for (let o = 0; o < e.length; o++)
          if (!e[o](n))
            return !1;
        return !0;
      }, xf = xn, x0 = Zs, gs = hm("display", "block table"), fl = hm("float", "left right"), ud = E1(xf, x0, io(fl)), zy = io(hm("white-space", "pre pre-line pre-wrap")), Qs = Mt, k1 = Js, Vy = xr.nodeIndex, Ja = Qw, zd = (e) => e ? e.createRange() : xr.DOM.createRng(), Tf = (e) => J(e) && /[\r\n\t ]/.test(e), Uy = (e) => !!e.setStart && !!e.setEnd, T0 = (e) => {
        const n = e.startContainer, o = e.startOffset;
        if (Tf(e.toString()) && zy(n.parentNode) && Mt(n)) {
          const r = n.data;
          if (Tf(r[o - 1]) || Tf(r[o + 1]))
            return !0;
        }
        return !1;
      }, _1 = (e) => {
        const n = e.ownerDocument, o = zd(n), r = n.createTextNode(_s), c = e.parentNode;
        c.insertBefore(r, e), o.setStart(r, 0), o.setEnd(r, 1);
        const u = _g(o.getBoundingClientRect());
        return c.removeChild(r), u;
      }, Wy = (e) => {
        const n = e.startContainer, o = e.endContainer, r = e.startOffset, c = e.endOffset;
        if (n === o && Mt(o) && r === 0 && c === 1) {
          const u = e.cloneRange();
          return u.setEndAfter(o), Vd(u);
        } else
          return null;
      }, E0 = (e) => e.left === 0 && e.right === 0 && e.top === 0 && e.bottom === 0, Vd = (e) => {
        var n;
        let o;
        const r = e.getClientRects();
        return r.length > 0 ? o = _g(r[0]) : o = _g(e.getBoundingClientRect()), !Uy(e) && k1(e) && E0(o) ? _1(e) : E0(o) && Uy(e) && (n = Wy(e)) !== null && n !== void 0 ? n : o;
      }, _m = (e, n) => {
        const o = km(e, n);
        return o.width = 1, o.right = o.left + 1, o;
      }, Lk = (e) => {
        const n = [], o = (f) => {
          f.height !== 0 && (n.length > 0 && Xw(f, n[n.length - 1]) || n.push(f));
        }, r = (f, b) => {
          const y = zd(f.ownerDocument);
          if (b < f.data.length) {
            if (eS(f.data[b]))
              return;
            if (eS(f.data[b - 1]) && (y.setStart(f, b), y.setEnd(f, b + 1), !T0(y))) {
              o(_m(Vd(y), !1));
              return;
            }
          }
          b > 0 && (y.setStart(f, b - 1), y.setEnd(f, b), T0(y) || o(_m(Vd(y), !1))), b < f.data.length && (y.setStart(f, b), y.setEnd(f, b + 1), T0(y) || o(_m(Vd(y), !0)));
        }, c = e.container(), u = e.offset();
        if (Qs(c))
          return r(c, u), n;
        if (xf(c))
          if (e.isAtEnd()) {
            const f = Ja(c, u);
            Qs(f) && r(f, f.data.length), ud(f) && !k1(f) && o(_m(Vd(f), !1));
          } else {
            const f = Ja(c, u);
            if (Qs(f) && r(f, 0), ud(f) && e.isAtEnd())
              return o(_m(Vd(f), !1)), n;
            const b = Ja(e.container(), e.offset() - 1);
            ud(b) && !k1(b) && (gs(b) || gs(f) || !ud(f)) && o(_m(Vd(b), !1)), ud(f) && o(_m(Vd(f), !0));
          }
        return n;
      }, We = (e, n, o) => {
        const r = () => (Qs(e), n === 0), c = () => Qs(e) ? n >= e.data.length : n >= e.childNodes.length, u = () => {
          const N = zd(e.ownerDocument);
          return N.setStart(e, n), N.setEnd(e, n), N;
        }, f = () => (o || (o = Lk(We(e, n))), o), b = () => f().length > 0, y = (N) => N && e === N.container() && n === N.offset(), E = (N) => Ja(e, N ? n - 1 : n);
        return {
          container: it(e),
          offset: it(n),
          toRange: u,
          getClientRects: f,
          isVisible: b,
          isAtStart: r,
          isAtEnd: c,
          isEqual: y,
          getNode: E
        };
      };
      We.fromRangeStart = (e) => We(e.startContainer, e.startOffset), We.fromRangeEnd = (e) => We(e.endContainer, e.endOffset), We.after = (e) => We(e.parentNode, Vy(e) + 1), We.before = (e) => We(e.parentNode, Vy(e)), We.isAbove = (e, n) => Zr(qt(n.getClientRects()), ko(e.getClientRects()), Sf).getOr(!1), We.isBelow = (e, n) => Zr(ko(n.getClientRects()), qt(e.getClientRects()), Og).getOr(!1), We.isAtStart = (e) => e ? e.isAtStart() : !1, We.isAtEnd = (e) => e ? e.isAtEnd() : !1, We.isTextPosition = (e) => e ? Mt(e.container()) : !1, We.isElementPosition = (e) => !We.isTextPosition(e);
      const A1 = (e, n) => {
        Mt(n) && n.data.length === 0 && e.remove(n);
      }, Hh = (e, n, o) => {
        n.insertNode(o), A1(e, o.previousSibling), A1(e, o.nextSibling);
      }, Bl = (e, n, o) => {
        const r = F.from(o.firstChild), c = F.from(o.lastChild);
        n.insertNode(o), r.each((u) => A1(e, u.previousSibling)), c.each((u) => A1(e, u.nextSibling));
      }, Zy = (e, n, o) => {
        $r(o) ? Bl(e, n, o) : Hh(e, n, o);
      }, Ir = Mt, k0 = nu, Am = xr.nodeIndex, jy = (e) => {
        const n = e.parentNode;
        return k0(n) ? jy(n) : n;
      }, _0 = (e) => e ? de(e.childNodes, (n, o) => (k0(o) && o.nodeName !== "BR" ? n = n.concat(_0(o)) : n.push(o), n), []) : [], qy = (e, n) => {
        let o = e;
        for (; (o = o.previousSibling) && Ir(o); )
          n += o.data.length;
        return n;
      }, O1 = (e) => (n) => e === n, zh = (e) => {
        let n, o;
        n = _0(jy(e)), o = ie(n, O1(e), e), n = n.slice(0, o + 1);
        const r = de(n, (c, u, f) => (Ir(u) && Ir(n[f - 1]) && c++, c), 0);
        return n = rc(n, ua([e.nodeName])), o = ie(n, O1(e), e), o - r;
      }, Gy = (e) => (Ir(e) ? "text()" : e.nodeName.toLowerCase()) + "[" + zh(e) + "]", Hk = (e, n, o) => {
        const r = [];
        for (let c = n.parentNode; c && c !== e; c = c.parentNode)
          r.push(c);
        return r;
      }, Oi = (e, n) => {
        let o = [], r = n.container(), c = n.offset(), u;
        if (Ir(r))
          u = qy(r, c);
        else {
          const b = r.childNodes;
          c >= b.length ? (u = "after", c = b.length - 1) : u = "before", r = b[c];
        }
        o.push(Gy(r));
        let f = Hk(e, r);
        return f = rc(f, io(nu)), o = o.concat(Sa(f, (b) => Gy(b))), o.reverse().join("/") + "," + u;
      }, Qa = (e, n, o) => {
        let r = _0(e);
        return r = rc(r, (c, u) => !Ir(c) || !Ir(r[u - 1])), r = rc(r, ua([n])), r[o];
      }, Lc = (e, n) => {
        let o = e, r = 0;
        for (; Ir(o); ) {
          const c = o.data.length;
          if (n >= r && n <= r + c) {
            e = o, n = n - r;
            break;
          }
          if (!Ir(o.nextSibling)) {
            e = o, n = c;
            break;
          }
          r += c, o = o.nextSibling;
        }
        return Ir(e) && n > e.data.length && (n = e.data.length), We(e, n);
      }, Di = (e, n) => {
        if (!n)
          return null;
        const o = n.split(","), r = o[0].split("/"), c = o.length > 1 ? o[1] : "before", u = de(r, (f, b) => {
          const y = /([\w\-\(\)]+)\[([0-9]+)\]/.exec(b);
          return y ? (y[1] === "text()" && (y[1] = "#text"), Qa(f, y[1], parseInt(y[2], 10))) : null;
        }, e);
        if (!u)
          return null;
        if (!Ir(u) && u.parentNode) {
          let f;
          return c === "after" ? f = Am(u) + 1 : f = Am(u), We(u.parentNode, f);
        }
        return Lc(u, parseInt(c, 10));
      }, Jc = es, fi = (e, n, o) => {
        let r = e(n.data.slice(0, o)).length;
        for (let c = n.previousSibling; c && Mt(c); c = c.previousSibling)
          r += e(c.data).length;
        return r;
      }, ec = (e, n, o, r, c) => {
        const u = c ? r.startContainer : r.endContainer;
        let f = c ? r.startOffset : r.endOffset;
        const b = [], y = e.getRoot();
        if (Mt(u))
          b.push(o ? fi(n, u, f) : f);
        else {
          let E = 0;
          const N = u.childNodes;
          f >= N.length && N.length && (E = 1, f = Math.max(0, N.length - 1)), b.push(e.nodeIndex(N[f], o) + E);
        }
        for (let E = u; E && E !== y; E = E.parentNode)
          b.push(e.nodeIndex(E, o));
        return b;
      }, Ky = (e, n, o, r) => {
        const c = n.dom, u = ec(c, e, o, r, !0), f = n.isForward(), b = cf(r) ? { isFakeCaret: !0 } : {};
        if (n.isCollapsed())
          return {
            start: u,
            forward: f,
            ...b
          };
        {
          const y = ec(c, e, o, r, !1);
          return {
            start: u,
            end: y,
            forward: f,
            ...b
          };
        }
      }, D1 = (e, n, o) => {
        let r = 0;
        return _t.each(e.select(n), (c) => {
          if (c.getAttribute("data-mce-bogus") !== "all") {
            if (c === o)
              return !1;
            r++;
            return;
          }
        }), r;
      }, Yy = (e, n) => {
        let o = n ? e.startContainer : e.endContainer, r = n ? e.startOffset : e.endOffset;
        if (xn(o) && o.nodeName === "TR") {
          const c = o.childNodes;
          o = c[Math.min(n ? r : r - 1, c.length - 1)], o && (r = n ? 0 : o.childNodes.length, n ? e.setStart(o, r) : e.setEnd(o, r));
        }
      }, R1 = (e) => (Yy(e, !0), Yy(e, !1), e), Xy = (e, n) => {
        if (xn(e) && (e = ml(e, n), Jc(e)))
          return e;
        if (Jn(e)) {
          Mt(e) && pn(e) && (e = e.parentNode);
          let o = e.previousSibling;
          if (Jc(o) || (o = e.nextSibling, Jc(o)))
            return o;
        }
      }, tS = (e) => Xy(e.startContainer, e.startOffset) || Xy(e.endContainer, e.endOffset), A0 = (e, n, o) => {
        const r = o.getNode(), c = o.getRng();
        if (r.nodeName === "IMG" || Jc(r)) {
          const f = r.nodeName;
          return {
            name: f,
            index: D1(o.dom, f, r)
          };
        }
        const u = tS(c);
        if (u) {
          const f = u.tagName;
          return {
            name: f,
            index: D1(o.dom, f, u)
          };
        }
        return Ky(e, o, n, c);
      }, Jy = (e) => {
        const n = e.getRng();
        return {
          start: Oi(e.dom.getRoot(), We.fromRangeStart(n)),
          end: Oi(e.dom.getRoot(), We.fromRangeEnd(n)),
          forward: e.isForward()
        };
      }, zk = (e) => ({
        rng: e.getRng(),
        forward: e.isForward()
      }), Vk = (e, n, o) => {
        const r = {
          "data-mce-type": "bookmark",
          id: n,
          style: "overflow:hidden;line-height:0px"
        };
        return o ? e.create("span", r, "&#xFEFF;") : e.create("span", r);
      }, nS = (e, n) => {
        const o = e.dom;
        let r = e.getRng();
        const c = o.uniqueId(), u = e.isCollapsed(), f = e.getNode(), b = f.nodeName, y = e.isForward();
        if (b === "IMG")
          return {
            name: b,
            index: D1(o, b, f)
          };
        const E = R1(r.cloneRange());
        if (!u) {
          E.collapse(!1);
          const M = Vk(o, c + "_end", n);
          Zy(o, E, M);
        }
        r = R1(r), r.collapse(!0);
        const N = Vk(o, c + "_start", n);
        return Zy(o, r, N), e.moveToBookmark({
          id: c,
          keep: !0,
          forward: y
        }), {
          id: c,
          forward: y
        };
      }, Uk = (e, n, o = !1) => n === 2 ? A0(q, o, e) : n === 3 ? Jy(e) : n ? zk(e) : nS(e, !1), Vh = Ye(A0, Gn, !0), O0 = (e) => {
        const n = (u) => u(e), o = it(e), r = () => c, c = {
          tag: !0,
          inner: e,
          fold: (u, f) => f(e),
          isValue: ot,
          isError: $e,
          map: (u) => Ui.value(u(e)),
          mapError: r,
          bind: n,
          exists: n,
          forall: n,
          getOr: o,
          or: r,
          getOrThunk: o,
          orThunk: r,
          getOrDie: o,
          each: (u) => {
            u(e);
          },
          toOptional: () => F.some(e)
        };
        return c;
      }, oS = (e) => {
        const n = () => o, o = {
          tag: !1,
          inner: e,
          fold: (r, c) => r(e),
          isValue: $e,
          isError: ot,
          map: n,
          mapError: (r) => Ui.error(r(e)),
          bind: n,
          exists: $e,
          forall: ot,
          getOr: Gn,
          or: Gn,
          getOrThunk: bt,
          orThunk: bt,
          getOrDie: jo(String(e)),
          each: Oe,
          toOptional: F.none
        };
        return o;
      }, Ui = {
        value: O0,
        error: oS,
        fromOption: (e, n) => e.fold(() => oS(n), O0)
      }, dd = { generate: (e) => {
        if (!ht(e))
          throw new Error("cases must be an array");
        if (e.length === 0)
          throw new Error("there must be at least one case");
        const n = [], o = {};
        return ae(e, (r, c) => {
          const u = Ss(r);
          if (u.length !== 1)
            throw new Error("one and only one name per case");
          const f = u[0], b = r[f];
          if (o[f] !== void 0)
            throw new Error("duplicate key detected:" + f);
          if (f === "cata")
            throw new Error("cannot have a case named cata (sorry)");
          if (!ht(b))
            throw new Error("case arguments must be an array");
          n.push(f), o[f] = (...y) => {
            const E = y.length;
            if (E !== b.length)
              throw new Error("Wrong number of arguments to case " + f + ". Expected " + b.length + " (" + b + "), got " + E);
            return {
              fold: (...M) => {
                if (M.length !== e.length)
                  throw new Error("Wrong number of arguments to fold. Expected " + e.length + ", got " + M.length);
                return M[c].apply(null, y);
              },
              match: (M) => {
                const I = Ss(M);
                if (n.length !== I.length)
                  throw new Error("Wrong number of arguments to match. Expected: " + n.join(",") + `
Actual: ` + I.join(","));
                if (!No(n, (te) => ee(I, te)))
                  throw new Error("Not all branches were specified when using match. Specified: " + I.join(", ") + `
Required: ` + n.join(", "));
                return M[f].apply(null, y);
              },
              log: (M) => {
              }
            };
          };
        }), o;
      } };
      dd.generate([
        {
          bothErrors: [
            "error1",
            "error2"
          ]
        },
        {
          firstError: [
            "error1",
            "value2"
          ]
        },
        {
          secondError: [
            "value1",
            "error2"
          ]
        },
        {
          bothValues: [
            "value1",
            "value2"
          ]
        }
      ]);
      const Ut = (e) => {
        const n = [], o = [];
        return ae(e, (r) => {
          r.fold((c) => {
            n.push(c);
          }, (c) => {
            o.push(c);
          });
        }), {
          errors: n,
          values: o
        };
      }, Qy = (e) => e.type === "inline-command" || e.type === "inline-format", tc = (e) => e.type === "block-command" || e.type === "block-format", sS = (e) => {
        const n = (r) => Ui.error({
          message: r,
          pattern: e
        }), o = (r, c, u) => {
          if (e.format !== void 0) {
            let f;
            if (ht(e.format)) {
              if (!No(e.format, J))
                return n(r + " pattern has non-string items in the `format` array");
              f = e.format;
            } else if (J(e.format))
              f = [e.format];
            else
              return n(r + " pattern has non-string `format` parameter");
            return Ui.value(c(f));
          } else return e.cmd !== void 0 ? J(e.cmd) ? Ui.value(u(e.cmd, e.value)) : n(r + " pattern has non-string `cmd` parameter") : n(r + " pattern is missing both `format` and `cmd` parameters");
        };
        if (!Qe(e))
          return n("Raw pattern is not an object");
        if (!J(e.start))
          return n("Raw pattern is missing `start` parameter");
        if (e.end !== void 0) {
          if (!J(e.end))
            return n("Inline pattern has non-string `end` parameter");
          if (e.start.length === 0 && e.end.length === 0)
            return n("Inline pattern has empty `start` and `end` parameters");
          let r = e.start, c = e.end;
          return c.length === 0 && (c = r, r = ""), o("Inline", (u) => ({
            type: "inline-format",
            start: r,
            end: c,
            format: u
          }), (u, f) => ({
            type: "inline-command",
            start: r,
            end: c,
            cmd: u,
            value: f
          }));
        } else return e.replacement !== void 0 ? J(e.replacement) ? e.start.length === 0 ? n("Replacement pattern has empty `start` parameter") : Ui.value({
          type: "inline-command",
          start: "",
          end: e.start,
          cmd: "mceInsertContent",
          value: e.replacement
        }) : n("Replacement pattern has non-string `replacement` parameter") : e.start.length === 0 ? n("Block pattern has empty `start` parameter") : o("Block", (r) => ({
          type: "block-format",
          start: e.start,
          format: r[0]
        }), (r, c) => ({
          type: "block-command",
          start: e.start,
          cmd: r,
          value: c
        }));
      }, D0 = (e) => Yt(e, tc), eC = (e) => Yt(e, Qy), Wi = (e, n) => ({
        inlinePatterns: eC(e),
        blockPatterns: D0(e),
        dynamicPatternsLookup: n
      }), Wk = (e) => {
        const n = Ut(ye(e, sS));
        return ae(n.errors, (o) => {
        }), n.values;
      }, rS = (e) => (n) => {
        const o = e(n);
        return Wk(o);
      }, Zi = Is().deviceType, Uh = Zi.isTouch(), N1 = xr.DOM, Ud = (e) => {
        const n = e.indexOf("=") > 0 ? e.split(/[;,](?![^=;,]*(?:[;,]|$))/) : e.split(",");
        return Xe(n, (o, r) => {
          const c = r.split("="), u = c[0], f = c.length > 1 ? c[1] : u;
          return o[Ra(u)] = Ra(f), o;
        }, {});
      }, Iu = (e) => Kt(e, RegExp), Cn = (e) => (n) => n.options.get(e), $l = (e) => J(e) || Qe(e), aS = (e, n = "") => (o) => {
        const r = J(o);
        if (r)
          if (o.indexOf("=") !== -1) {
            const c = Ud(o);
            return {
              value: Ts(c, e.id).getOr(n),
              valid: r
            };
          } else
            return {
              value: o,
              valid: r
            };
        else
          return {
            valid: !1,
            message: "Must be a string."
          };
      }, cS = (e) => {
        const n = e.options.register;
        n("id", {
          processor: "string",
          default: e.id
        }), n("selector", { processor: "string" }), n("target", { processor: "object" }), n("suffix", { processor: "string" }), n("cache_suffix", { processor: "string" }), n("base_url", { processor: "string" }), n("referrer_policy", {
          processor: "string",
          default: ""
        }), n("language_load", {
          processor: "boolean",
          default: !0
        }), n("inline", {
          processor: "boolean",
          default: !1
        }), n("iframe_attrs", {
          processor: "object",
          default: {}
        }), n("doctype", {
          processor: "string",
          default: "<!DOCTYPE html>"
        }), n("document_base_url", {
          processor: "string",
          default: e.documentBaseUrl
        }), n("body_id", {
          processor: aS(e, "tinymce"),
          default: "tinymce"
        }), n("body_class", {
          processor: aS(e),
          default: ""
        }), n("content_security_policy", {
          processor: "string",
          default: ""
        }), n("br_in_pre", {
          processor: "boolean",
          default: !0
        }), n("forced_root_block", {
          processor: (o) => {
            const r = J(o) && lo(o);
            return r ? {
              value: o,
              valid: r
            } : {
              valid: !1,
              message: "Must be a non-empty string."
            };
          },
          default: "p"
        }), n("forced_root_block_attrs", {
          processor: "object",
          default: {}
        }), n("newline_behavior", {
          processor: (o) => {
            const r = ee([
              "block",
              "linebreak",
              "invert",
              "default"
            ], o);
            return r ? {
              value: o,
              valid: r
            } : {
              valid: !1,
              message: "Must be one of: block, linebreak, invert or default."
            };
          },
          default: "default"
        }), n("br_newline_selector", {
          processor: "string",
          default: ".mce-toc h2,figcaption,caption"
        }), n("no_newline_selector", {
          processor: "string",
          default: ""
        }), n("keep_styles", {
          processor: "boolean",
          default: !0
        }), n("end_container_on_empty_block", {
          processor: (o) => Tt(o) ? {
            valid: !0,
            value: o
          } : J(o) ? {
            valid: !0,
            value: o
          } : {
            valid: !1,
            message: "Must be boolean or a string"
          },
          default: "blockquote"
        }), n("font_size_style_values", {
          processor: "string",
          default: "xx-small,x-small,small,medium,large,x-large,xx-large"
        }), n("font_size_legacy_values", {
          processor: "string",
          default: "xx-small,small,medium,large,x-large,xx-large,300%"
        }), n("font_size_classes", {
          processor: "string",
          default: ""
        }), n("automatic_uploads", {
          processor: "boolean",
          default: !0
        }), n("images_reuse_filename", {
          processor: "boolean",
          default: !1
        }), n("images_replace_blob_uris", {
          processor: "boolean",
          default: !0
        }), n("icons", {
          processor: "string",
          default: ""
        }), n("icons_url", {
          processor: "string",
          default: ""
        }), n("images_upload_url", {
          processor: "string",
          default: ""
        }), n("images_upload_base_path", {
          processor: "string",
          default: ""
        }), n("images_upload_credentials", {
          processor: "boolean",
          default: !1
        }), n("images_upload_handler", { processor: "function" }), n("language", {
          processor: "string",
          default: "en"
        }), n("language_url", {
          processor: "string",
          default: ""
        }), n("entity_encoding", {
          processor: "string",
          default: "named"
        }), n("indent", {
          processor: "boolean",
          default: !0
        }), n("indent_before", {
          processor: "string",
          default: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist"
        }), n("indent_after", {
          processor: "string",
          default: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist"
        }), n("indent_use_margin", {
          processor: "boolean",
          default: !1
        }), n("indentation", {
          processor: "string",
          default: "40px"
        }), n("content_css", {
          processor: (o) => {
            const r = o === !1 || J(o) || Te(o, J);
            return r ? J(o) ? {
              value: ye(o.split(","), Ra),
              valid: r
            } : ht(o) ? {
              value: o,
              valid: r
            } : o === !1 ? {
              value: [],
              valid: r
            } : {
              value: o,
              valid: r
            } : {
              valid: !1,
              message: "Must be false, a string or an array of strings."
            };
          },
          default: mC(e) ? [] : ["default"]
        }), n("content_style", { processor: "string" }), n("content_css_cors", {
          processor: "boolean",
          default: !1
        }), n("font_css", {
          processor: (o) => {
            const r = J(o) || Te(o, J);
            return r ? {
              value: ht(o) ? o : ye(o.split(","), Ra),
              valid: r
            } : {
              valid: !1,
              message: "Must be a string or an array of strings."
            };
          },
          default: []
        }), n("inline_boundaries", {
          processor: "boolean",
          default: !0
        }), n("inline_boundaries_selector", {
          processor: "string",
          default: "a[href],code,span.mce-annotation"
        }), n("object_resizing", {
          processor: (o) => {
            const r = Tt(o) || J(o);
            return r ? o === !1 || Zi.isiPhone() || Zi.isiPad() ? {
              value: "",
              valid: r
            } : {
              value: o === !0 ? "table,img,figure.image,div,video,iframe" : o,
              valid: r
            } : {
              valid: !1,
              message: "Must be boolean or a string"
            };
          },
          default: !Uh
        }), n("resize_img_proportional", {
          processor: "boolean",
          default: !0
        }), n("event_root", { processor: "object" }), n("service_message", { processor: "string" }), n("theme", {
          processor: (o) => o === !1 || J(o) || re(o),
          default: "silver"
        }), n("theme_url", { processor: "string" }), n("formats", { processor: "object" }), n("format_empty_lines", {
          processor: "boolean",
          default: !1
        }), n("format_noneditable_selector", {
          processor: "string",
          default: ""
        }), n("preview_styles", {
          processor: (o) => {
            const r = o === !1 || J(o);
            return r ? {
              value: o === !1 ? "" : o,
              valid: r
            } : {
              valid: !1,
              message: "Must be false or a string"
            };
          },
          default: "font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow"
        }), n("custom_ui_selector", {
          processor: "string",
          default: ""
        }), n("hidden_input", {
          processor: "boolean",
          default: !0
        }), n("submit_patch", {
          processor: "boolean",
          default: !0
        }), n("encoding", { processor: "string" }), n("add_form_submit_trigger", {
          processor: "boolean",
          default: !0
        }), n("add_unload_trigger", {
          processor: "boolean",
          default: !0
        }), n("custom_undo_redo_levels", {
          processor: "number",
          default: 0
        }), n("disable_nodechange", {
          processor: "boolean",
          default: !1
        }), n("readonly", {
          processor: "boolean",
          default: !1
        }), n("editable_root", {
          processor: "boolean",
          default: !0
        }), n("plugins", {
          processor: "string[]",
          default: []
        }), n("external_plugins", { processor: "object" }), n("forced_plugins", { processor: "string[]" }), n("model", {
          processor: "string",
          default: e.hasPlugin("rtc") ? "plugin" : "dom"
        }), n("model_url", { processor: "string" }), n("block_unsupported_drop", {
          processor: "boolean",
          default: !0
        }), n("visual", {
          processor: "boolean",
          default: !0
        }), n("visual_table_class", {
          processor: "string",
          default: "mce-item-table"
        }), n("visual_anchor_class", {
          processor: "string",
          default: "mce-item-anchor"
        }), n("iframe_aria_text", {
          processor: "string",
          default: "Rich Text Area. Press ALT-0 for help."
        }), n("setup", { processor: "function" }), n("init_instance_callback", { processor: "function" }), n("url_converter", {
          processor: "function",
          default: e.convertURL
        }), n("url_converter_scope", {
          processor: "object",
          default: e
        }), n("urlconverter_callback", { processor: "function" }), n("allow_conditional_comments", {
          processor: "boolean",
          default: !1
        }), n("allow_html_data_urls", {
          processor: "boolean",
          default: !1
        }), n("allow_svg_data_urls", { processor: "boolean" }), n("allow_html_in_named_anchor", {
          processor: "boolean",
          default: !1
        }), n("allow_script_urls", {
          processor: "boolean",
          default: !1
        }), n("allow_unsafe_link_target", {
          processor: "boolean",
          default: !1
        }), n("convert_fonts_to_spans", {
          processor: "boolean",
          default: !0,
          deprecated: !0
        }), n("fix_list_elements", {
          processor: "boolean",
          default: !1
        }), n("preserve_cdata", {
          processor: "boolean",
          default: !1
        }), n("remove_trailing_brs", {
          processor: "boolean",
          default: !0
        }), n("pad_empty_with_br", {
          processor: "boolean",
          default: !1
        }), n("inline_styles", {
          processor: "boolean",
          default: !0,
          deprecated: !0
        }), n("element_format", {
          processor: "string",
          default: "html"
        }), n("entities", { processor: "string" }), n("schema", {
          processor: "string",
          default: "html5"
        }), n("convert_urls", {
          processor: "boolean",
          default: !0
        }), n("relative_urls", {
          processor: "boolean",
          default: !0
        }), n("remove_script_host", {
          processor: "boolean",
          default: !0
        }), n("custom_elements", { processor: "string" }), n("extended_valid_elements", { processor: "string" }), n("invalid_elements", { processor: "string" }), n("invalid_styles", { processor: $l }), n("valid_children", { processor: "string" }), n("valid_classes", { processor: $l }), n("valid_elements", { processor: "string" }), n("valid_styles", { processor: $l }), n("verify_html", {
          processor: "boolean",
          default: !0
        }), n("auto_focus", { processor: (o) => J(o) || o === !0 }), n("browser_spellcheck", {
          processor: "boolean",
          default: !1
        }), n("protect", { processor: "array" }), n("images_file_types", {
          processor: "string",
          default: "jpeg,jpg,jpe,jfi,jif,jfif,png,gif,bmp,webp"
        }), n("deprecation_warnings", {
          processor: "boolean",
          default: !0
        }), n("a11y_advanced_options", {
          processor: "boolean",
          default: !1
        }), n("api_key", { processor: "string" }), n("paste_block_drop", {
          processor: "boolean",
          default: !1
        }), n("paste_data_images", {
          processor: "boolean",
          default: !0
        }), n("paste_preprocess", { processor: "function" }), n("paste_postprocess", { processor: "function" }), n("paste_webkit_styles", {
          processor: "string",
          default: "none"
        }), n("paste_remove_styles_if_webkit", {
          processor: "boolean",
          default: !0
        }), n("paste_merge_formats", {
          processor: "boolean",
          default: !0
        }), n("smart_paste", {
          processor: "boolean",
          default: !0
        }), n("paste_as_text", {
          processor: "boolean",
          default: !1
        }), n("paste_tab_spaces", {
          processor: "number",
          default: 4
        }), n("text_patterns", {
          processor: (o) => Te(o, Qe) || o === !1 ? {
            value: Wk(o === !1 ? [] : o),
            valid: !0
          } : {
            valid: !1,
            message: "Must be an array of objects or false."
          },
          default: [
            {
              start: "*",
              end: "*",
              format: "italic"
            },
            {
              start: "**",
              end: "**",
              format: "bold"
            },
            {
              start: "#",
              format: "h1"
            },
            {
              start: "##",
              format: "h2"
            },
            {
              start: "###",
              format: "h3"
            },
            {
              start: "####",
              format: "h4"
            },
            {
              start: "#####",
              format: "h5"
            },
            {
              start: "######",
              format: "h6"
            },
            {
              start: "1. ",
              cmd: "InsertOrderedList"
            },
            {
              start: "* ",
              cmd: "InsertUnorderedList"
            },
            {
              start: "- ",
              cmd: "InsertUnorderedList"
            }
          ]
        }), n("text_patterns_lookup", {
          processor: (o) => re(o) ? {
            value: rS(o),
            valid: !0
          } : {
            valid: !1,
            message: "Must be a single function"
          },
          default: (o) => []
        }), n("noneditable_class", {
          processor: "string",
          default: "mceNonEditable"
        }), n("editable_class", {
          processor: "string",
          default: "mceEditable"
        }), n("noneditable_regexp", {
          processor: (o) => Te(o, Iu) ? {
            value: o,
            valid: !0
          } : Iu(o) ? {
            value: [o],
            valid: !0
          } : {
            valid: !1,
            message: "Must be a RegExp or an array of RegExp."
          },
          default: []
        }), n("table_tab_navigation", {
          processor: "boolean",
          default: !0
        }), n("highlight_on_focus", {
          processor: "boolean",
          default: !1
        }), n("xss_sanitization", {
          processor: "boolean",
          default: !0
        }), n("details_initial_state", {
          processor: (o) => {
            const r = ee([
              "inherited",
              "collapsed",
              "expanded"
            ], o);
            return r ? {
              value: o,
              valid: r
            } : {
              valid: !1,
              message: "Must be one of: inherited, collapsed, or expanded."
            };
          },
          default: "inherited"
        }), n("details_serialized_state", {
          processor: (o) => {
            const r = ee([
              "inherited",
              "collapsed",
              "expanded"
            ], o);
            return r ? {
              value: o,
              valid: r
            } : {
              valid: !1,
              message: "Must be one of: inherited, collapsed, or expanded."
            };
          },
          default: "inherited"
        }), n("init_content_sync", {
          processor: "boolean",
          default: !1
        }), n("newdocument_content", {
          processor: "string",
          default: ""
        }), n("force_hex_color", {
          processor: (o) => {
            const r = [
              "always",
              "rgb_only",
              "off"
            ], c = ee(r, o);
            return c ? {
              value: o,
              valid: c
            } : {
              valid: !1,
              message: `Must be one of: ${r.join(", ")}.`
            };
          },
          default: "off"
        }), n("sandbox_iframes", {
          processor: "boolean",
          default: !1
        }), n("convert_unsafe_embeds", {
          processor: "boolean",
          default: !1
        }), e.on("ScriptsLoaded", () => {
          n("directionality", {
            processor: "string",
            default: Fu.isRtl() ? "rtl" : void 0
          }), n("placeholder", {
            processor: "string",
            default: N1.getAttrib(e.getElement(), "placeholder")
          });
        });
      }, tC = Cn("iframe_attrs"), iS = Cn("doctype"), nC = Cn("document_base_url"), oC = Cn("body_id"), Zk = Cn("body_class"), sC = Cn("content_security_policy"), jk = Cn("br_in_pre"), gi = Cn("forced_root_block"), M1 = Cn("forced_root_block_attrs"), qk = Cn("newline_behavior"), Gk = Cn("br_newline_selector"), rC = Cn("no_newline_selector"), Kk = Cn("keep_styles"), lS = Cn("end_container_on_empty_block"), uS = Cn("automatic_uploads"), P1 = Cn("images_reuse_filename"), dS = Cn("images_replace_blob_uris"), aC = Cn("icons"), Dg = Cn("icons_url"), Yk = Cn("images_upload_url"), Xk = Cn("images_upload_base_path"), cC = Cn("images_upload_credentials"), Jk = Cn("images_upload_handler"), Om = Cn("content_css_cors"), Go = Cn("referrer_policy"), iC = Cn("language"), hi = Cn("language_url"), R0 = Cn("indent_use_margin"), lC = Cn("indentation"), uC = Cn("content_css"), N0 = Cn("content_style"), mS = Cn("font_css"), Qk = Cn("directionality"), e_ = Cn("inline_boundaries_selector"), Wh = Cn("object_resizing"), fS = Cn("resize_img_proportional"), X4 = Cn("placeholder"), Ef = Cn("event_root"), t_ = Cn("service_message"), Zh = Cn("theme"), n_ = Cn("theme_url"), dC = Cn("model"), gS = Cn("model_url"), Rg = Cn("inline_boundaries"), o_ = Cn("formats"), hS = Cn("preview_styles"), pS = Cn("format_empty_lines"), jh = Cn("format_noneditable_selector"), bS = Cn("custom_ui_selector"), mC = Cn("inline"), s_ = Cn("hidden_input"), vS = Cn("submit_patch"), Wd = Cn("add_form_submit_trigger"), B1 = Cn("add_unload_trigger"), $1 = Cn("custom_undo_redo_levels"), M0 = Cn("disable_nodechange"), F1 = Cn("readonly"), iu = Cn("editable_root"), qh = Cn("content_css_cors"), I1 = Cn("plugins"), kf = Cn("external_plugins"), P0 = Cn("block_unsupported_drop"), r_ = Cn("visual"), a_ = Cn("visual_table_class"), yS = Cn("visual_anchor_class"), c_ = Cn("iframe_aria_text"), fC = Cn("setup"), i_ = Cn("init_instance_callback"), l_ = Cn("urlconverter_callback"), CS = Cn("auto_focus"), u_ = Cn("browser_spellcheck"), wS = Cn("protect"), d_ = Cn("paste_block_drop"), B0 = Cn("paste_data_images"), m_ = Cn("paste_preprocess"), SS = Cn("paste_postprocess"), Gh = Cn("newdocument_content"), gC = Cn("paste_webkit_styles"), hC = Cn("paste_remove_styles_if_webkit"), pC = Cn("paste_merge_formats"), xS = Cn("smart_paste"), bC = Cn("paste_as_text"), f_ = Cn("paste_tab_spaces"), $0 = Cn("allow_html_data_urls"), F0 = Cn("text_patterns"), g_ = Cn("text_patterns_lookup"), vC = Cn("noneditable_class"), TS = Cn("editable_class"), h_ = Cn("noneditable_regexp"), yC = Cn("preserve_cdata"), p_ = Cn("highlight_on_focus"), Kh = Cn("xss_sanitization"), b_ = Cn("init_content_sync"), CC = (e) => e.options.isSet("text_patterns_lookup"), v_ = (e) => _t.explode(e.options.get("font_size_style_values")), y_ = (e) => _t.explode(e.options.get("font_size_classes")), C_ = (e) => e.options.get("encoding") === "xml", ES = (e) => _t.explode(e.options.get("images_file_types")), w_ = Cn("table_tab_navigation"), xc = Cn("details_initial_state"), J4 = Cn("details_serialized_state"), Yh = Cn("force_hex_color"), I0 = Cn("sandbox_iframes"), kS = xn, wC = Mt, _S = (e) => {
        const n = e.parentNode;
        n && n.removeChild(e);
      }, AS = (e) => {
        const n = q(e);
        return {
          count: e.length - n.length,
          text: n
        };
      }, Ng = (e) => {
        let n;
        for (; (n = e.data.lastIndexOf(k)) !== -1; )
          e.deleteData(n, 1);
      }, L1 = (e, n) => (nc(e), n), S_ = (e, n) => {
        const o = AS(e.data.substr(0, n.offset())), r = AS(e.data.substr(n.offset()));
        return (o.text + r.text).length > 0 ? (Ng(e), We(e, n.offset() - o.count)) : n;
      }, x_ = (e, n) => {
        const o = n.container(), r = Rn(rs(o.childNodes), e).map((c) => c < n.offset() ? We(o, n.offset() - 1) : n).getOr(n);
        return nc(e), r;
      }, H1 = (e, n) => wC(e) && n.container() === e ? S_(e, n) : L1(e, n), SC = (e, n) => n.container() === e.parentNode ? x_(e, n) : L1(e, n), OS = (e, n) => We.isTextPosition(n) ? H1(e, n) : SC(e, n), nc = (e) => {
        kS(e) && Jn(e) && (Fr(e) ? e.removeAttribute("data-mce-caret") : _S(e)), wC(e) && (Ng(e), e.data.length === 0 && _S(e));
      }, DS = es, xC = oa, Q4 = mg, Xh = "*[contentEditable=false],video,audio,embed,object", T_ = (e, n, o) => {
        const r = km(n.getBoundingClientRect(), o);
        let c, u;
        if (e.tagName === "BODY") {
          const b = e.ownerDocument.documentElement;
          c = e.scrollLeft || b.scrollLeft, u = e.scrollTop || b.scrollTop;
        } else {
          const b = e.getBoundingClientRect();
          c = e.scrollLeft - b.left, u = e.scrollTop - b.top;
        }
        r.left += c, r.right += c, r.top += u, r.bottom += u, r.width = 1;
        let f = n.offsetWidth - n.clientWidth;
        return f > 0 && (o && (f *= -1), r.left += f, r.right += f), r;
      }, RS = (e) => {
        var n, o;
        const r = uc(le.fromDom(e), Xh);
        for (let c = 0; c < r.length; c++) {
          const u = r[c].dom;
          let f = u.previousSibling;
          if (Ol(f)) {
            const b = f.data;
            b.length === 1 ? (n = f.parentNode) === null || n === void 0 || n.removeChild(f) : f.deleteData(b.length - 1, 1);
          }
          f = u.nextSibling, Vi(f) && (f.data.length === 1 ? (o = f.parentNode) === null || o === void 0 || o.removeChild(f) : f.deleteData(0, 1));
        }
      }, TC = (e, n, o, r) => {
        const c = Cf();
        let u, f;
        const b = gi(e), y = e.dom, E = (G, ne) => {
          let Se;
          if (N(), Q4(ne))
            return null;
          if (o(ne)) {
            const ke = au(b, ne, G), Ae = T_(n, ne, G);
            y.setStyle(ke, "top", Ae.top), f = ke;
            const Me = y.create("div", {
              class: "mce-visual-caret",
              "data-mce-bogus": "all"
            });
            y.setStyles(Me, { ...Ae }), y.add(n, Me), c.set({
              caret: Me,
              element: ne,
              before: G
            }), G && y.addClass(Me, "mce-visual-caret-before"), M(), Se = ne.ownerDocument.createRange(), Se.setStart(ke, 0), Se.setEnd(ke, 0);
          } else
            return f = Sr(ne, G), Se = ne.ownerDocument.createRange(), L0(f.nextSibling) ? (Se.setStart(f, 0), Se.setEnd(f, 0)) : (Se.setStart(f, 1), Se.setEnd(f, 1)), Se;
          return Se;
        }, N = () => {
          RS(n), f && (nc(f), f = null), c.on((G) => {
            y.remove(G.caret), c.clear();
          }), u && (clearInterval(u), u = void 0);
        }, M = () => {
          u = setInterval(() => {
            c.on((G) => {
              r() ? y.toggleClass(G.caret, "mce-visual-caret-hidden") : y.addClass(G.caret, "mce-visual-caret-hidden");
            });
          }, 500);
        };
        return {
          show: E,
          hide: N,
          getCss: () => ".mce-visual-caret {position: absolute;background-color: black;background-color: currentcolor;}.mce-visual-caret-hidden {display: none;}*[data-mce-caret] {position: absolute;left: -1000px;right: auto;top: 0;margin: 0;padding: 0;}",
          reposition: () => {
            c.on((G) => {
              const ne = T_(n, G.element, G.before);
              y.setStyles(G.caret, { ...ne });
            });
          },
          destroy: () => clearInterval(u)
        };
      }, z1 = () => sn.browser.isFirefox(), L0 = (e) => DS(e) || xC(e), Jh = (e) => (L0(e) || Du(e) && z1()) && Tl(le.fromDom(e)).exists(Mo), E_ = Kc, _f = es, NS = oa, Af = hm("display", "block table table-cell table-caption list-item"), Of = Jn, EC = pn, MS = xn, eR = Mt, kC = Zs, Df = (e) => e > 0, Zd = (e) => e < 0, V1 = (e, n) => {
        let o;
        for (; o = e(n); )
          if (!EC(o))
            return o;
        return null;
      }, Qh = (e, n, o, r, c) => {
        const u = new br(e, r), f = _f(e) || EC(e);
        let b;
        if (Zd(n)) {
          if (f && (b = V1(u.prev.bind(u), !0), o(b)))
            return b;
          for (; b = V1(u.prev.bind(u), c); )
            if (o(b))
              return b;
        }
        if (Df(n)) {
          if (f && (b = V1(u.next.bind(u), !0), o(b)))
            return b;
          for (; b = V1(u.next.bind(u), c); )
            if (o(b))
              return b;
        }
        return null;
      }, _C = (e, n) => {
        const o = (c) => E_(c.dom), r = (c) => c.dom === n;
        return Ar(le.fromDom(e), o, r).map((c) => c.dom).getOr(n);
      }, Dm = (e, n) => {
        for (; e && e !== n; ) {
          if (Af(e))
            return e;
          e = e.parentNode;
        }
        return null;
      }, md = (e, n, o) => Dm(e.container(), o) === Dm(n.container(), o), U1 = (e, n) => {
        if (!n)
          return F.none();
        const o = n.container(), r = n.offset();
        return MS(o) ? F.from(o.childNodes[r + e]) : F.none();
      }, H0 = (e, n) => {
        var o;
        const c = ((o = n.ownerDocument) !== null && o !== void 0 ? o : document).createRange();
        return e ? (c.setStartBefore(n), c.setEndBefore(n)) : (c.setStartAfter(n), c.setEndAfter(n)), c;
      }, W1 = (e, n, o) => Dm(n, e) === Dm(o, e), AC = (e, n, o) => {
        const r = e ? "previousSibling" : "nextSibling";
        let c = o;
        for (; c && c !== n; ) {
          let u = c[r];
          if (u && Of(u) && (u = u[r]), _f(u) || NS(u)) {
            if (W1(n, u, c))
              return u;
            break;
          }
          if (kC(u))
            break;
          c = c.parentNode;
        }
        return null;
      }, ep = Ye(H0, !0), Z1 = Ye(H0, !1), OC = (e, n, o) => {
        let r;
        const c = Ye(AC, !0, n), u = Ye(AC, !1, n), f = o.startContainer, b = o.startOffset;
        if (pn(f)) {
          const y = eR(f) ? f.parentNode : f, E = y.getAttribute("data-mce-caret");
          if (E === "before" && (r = y.nextSibling, Jh(r)))
            return ep(r);
          if (E === "after" && (r = y.previousSibling, Jh(r)))
            return Z1(r);
        }
        if (!o.collapsed)
          return o;
        if (Mt(f)) {
          if (Of(f)) {
            if (e === 1) {
              if (r = u(f), r)
                return ep(r);
              if (r = c(f), r)
                return Z1(r);
            }
            if (e === -1) {
              if (r = c(f), r)
                return Z1(r);
              if (r = u(f), r)
                return ep(r);
            }
            return o;
          }
          if (Ol(f) && b >= f.data.length - 1)
            return e === 1 && (r = u(f), r) ? ep(r) : o;
          if (Vi(f) && b <= 1)
            return e === -1 && (r = c(f), r) ? Z1(r) : o;
          if (b === f.data.length)
            return r = u(f), r ? ep(r) : o;
          if (b === 0)
            return r = c(f), r ? Z1(r) : o;
        }
        return o;
      }, PS = (e, n) => U1(e ? 0 : -1, n).filter(_f), Rf = (e, n, o) => {
        const r = OC(e, n, o);
        return e === -1 ? We.fromRangeStart(r) : We.fromRangeEnd(r);
      }, z0 = (e) => F.from(e.getNode()).map(le.fromDom), k_ = (e) => F.from(e.getNode(!0)).map(le.fromDom), BS = (e, n) => {
        let o = n;
        for (; o = e(o); )
          if (o.isVisible())
            return o;
        return o;
      }, DC = (e, n) => {
        const o = md(e, n);
        return !o && Js(e.getNode()) ? !0 : o;
      };
      var ya;
      (function(e) {
        e[e.Backwards = -1] = "Backwards", e[e.Forwards = 1] = "Forwards";
      })(ya || (ya = {}));
      const tR = es, Rm = Mt, $S = xn, V0 = Js, Nf = Zs, Qc = $c, tp = Jb, j1 = (e, n) => {
        const o = [];
        let r = e;
        for (; r && r !== n; )
          o.push(r), r = r.parentNode;
        return o;
      }, np = (e, n) => e.hasChildNodes() && n < e.childNodes.length ? e.childNodes[n] : null, RC = (e, n) => {
        if (Df(e)) {
          if (Nf(n.previousSibling) && !Rm(n.previousSibling))
            return We.before(n);
          if (Rm(n))
            return We(n, 0);
        }
        if (Zd(e)) {
          if (Nf(n.nextSibling) && !Rm(n.nextSibling))
            return We.after(n);
          if (Rm(n))
            return We(n, n.data.length);
        }
        return Zd(e) ? V0(n) ? We.before(n) : We.after(n) : We.before(n);
      }, op = (e, n) => {
        const o = n.nextSibling;
        return o && Nf(o) ? Rm(o) ? We(o, 0) : We.before(o) : Mg(ya.Forwards, We.after(n), e);
      }, Mg = (e, n, o) => {
        let r, c, u, f;
        if (!$S(o) || !n)
          return null;
        if (n.isEqual(We.after(o)) && o.lastChild) {
          if (f = We.after(o.lastChild), Zd(e) && Nf(o.lastChild) && $S(o.lastChild))
            return V0(o.lastChild) ? We.before(o.lastChild) : f;
        } else
          f = n;
        const b = f.container();
        let y = f.offset();
        if (Rm(b)) {
          if (Zd(e) && y > 0)
            return We(b, --y);
          if (Df(e) && y < b.length)
            return We(b, ++y);
          r = b;
        } else {
          if (Zd(e) && y > 0 && (c = np(b, y - 1), Nf(c)))
            return !Qc(c) && (u = Qh(c, e, tp, c), u) ? Rm(u) ? We(u, u.data.length) : We.after(u) : Rm(c) ? We(c, c.data.length) : We.before(c);
          if (Df(e) && y < b.childNodes.length && (c = np(b, y), Nf(c)))
            return V0(c) ? op(o, c) : !Qc(c) && (u = Qh(c, e, tp, c), u) ? Rm(u) ? We(u, 0) : We.before(u) : Rm(c) ? We(c, 0) : We.after(c);
          r = c || f.getNode();
        }
        if (r && (Df(e) && f.isAtEnd() || Zd(e) && f.isAtStart()) && (r = Qh(r, e, ot, o, !0), tp(r, o)))
          return RC(e, r);
        c = r && Qh(r, e, tp, o);
        const E = ze(Yt(j1(b, o), tR));
        return E && (!c || !E.contains(c)) ? (Df(e) ? f = We.after(E) : f = We.before(E), f) : c ? RC(e, c) : null;
      }, fd = (e) => ({
        next: (n) => Mg(ya.Forwards, n, e),
        prev: (n) => Mg(ya.Backwards, n, e)
      }), __ = (e, n, o) => {
        const r = e ? We.before(o) : We.after(o);
        return Tc(e, n, r);
      }, A_ = (e) => Js(e) ? We.before(e) : We.after(e), Mf = (e) => We.isTextPosition(e) ? e.offset() === 0 : Zs(e.getNode()), sp = (e) => {
        if (We.isTextPosition(e)) {
          const n = e.container();
          return e.offset() === n.data.length;
        } else
          return Zs(e.getNode(!0));
      }, U0 = (e, n) => !We.isTextPosition(e) && !We.isTextPosition(n) && e.getNode() === n.getNode(!0), jd = (e) => !We.isTextPosition(e) && Js(e.getNode()), NC = (e, n, o) => e ? !U0(n, o) && !jd(n) && sp(n) && Mf(o) : !U0(o, n) && Mf(n) && sp(o), Tc = (e, n, o) => {
        const r = fd(n);
        return F.from(e ? r.next(o) : r.prev(o));
      }, Nm = (e, n, o) => Tc(e, n, o).bind((r) => md(o, r, n) && NC(e, o, r) ? Tc(e, n, r) : F.some(r)), Lu = (e, n, o, r) => Nm(e, n, o).bind((c) => r(c) ? Lu(e, n, c, r) : F.some(c)), rp = (e, n) => {
        const o = e ? n.firstChild : n.lastChild;
        return Mt(o) ? F.some(We(o, e ? 0 : o.data.length)) : o ? Zs(o) ? F.some(e ? We.before(o) : A_(o)) : __(e, n, o) : F.none();
      }, pi = Ye(Tc, !0), ji = Ye(Tc, !1), Ri = Ye(rp, !0), Hu = Ye(rp, !1), W0 = "_mce_caret", Fl = (e) => xn(e) && e.id === W0, Pg = (e, n) => {
        let o = n;
        for (; o && o !== e; ) {
          if (Fl(o))
            return o;
          o = o.parentNode;
        }
        return null;
      }, MC = (e) => J(e.start), O_ = (e) => Zn(e, "rng"), FS = (e) => Zn(e, "id"), q1 = (e) => Zn(e, "name"), IS = (e) => _t.isArray(e.start), G1 = (e) => !q1(e) && Tt(e.forward) ? e.forward : !0, Z0 = (e, n) => (xn(n) && e.isBlock(n) && !n.innerHTML && (n.innerHTML = '<br data-mce-bogus="1" />'), n), D_ = (e, n) => {
        const o = F.from(Di(e.getRoot(), n.start)), r = F.from(Di(e.getRoot(), n.end));
        return Zr(o, r, (c, u) => {
          const f = e.createRng();
          return f.setStart(c.container(), c.offset()), f.setEnd(u.container(), u.offset()), {
            range: f,
            forward: G1(n)
          };
        });
      }, LS = (e, n) => {
        var o;
        const c = ((o = e.ownerDocument) !== null && o !== void 0 ? o : document).createTextNode(k);
        e.appendChild(c), n.setStart(c, 0), n.setEnd(c, 0);
      }, R_ = (e) => !e.hasChildNodes(), nR = (e, n) => Hu(e).fold($e, (o) => (n.setStart(o.container(), o.offset()), n.setEnd(o.container(), o.offset()), !0)), HS = (e, n, o) => R_(n) && Pg(e, n) ? (LS(n, o), !0) : !1, is = (e, n, o, r) => {
        const c = o[n ? "start" : "end"], u = e.getRoot();
        if (c) {
          let f = u, b = c[0];
          for (let y = c.length - 1; f && y >= 1; y--) {
            const E = f.childNodes;
            if (HS(u, f, r))
              return !0;
            if (c[y] > E.length - 1)
              return HS(u, f, r) ? !0 : nR(f, r);
            f = E[c[y]];
          }
          Mt(f) && (b = Math.min(c[0], f.data.length)), xn(f) && (b = Math.min(c[0], f.childNodes.length)), n ? r.setStart(f, b) : r.setEnd(f, b);
        }
        return !0;
      }, gd = (e) => Mt(e) && e.data.length > 0, Bg = (e, n, o) => {
        const r = e.get(o.id + "_" + n), c = r?.parentNode, u = o.keep;
        if (r && c) {
          let f, b;
          if (n === "start" ? u ? r.hasChildNodes() ? (f = r.firstChild, b = 1) : gd(r.nextSibling) ? (f = r.nextSibling, b = 0) : gd(r.previousSibling) ? (f = r.previousSibling, b = r.previousSibling.data.length) : (f = c, b = e.nodeIndex(r) + 1) : (f = c, b = e.nodeIndex(r)) : u ? r.hasChildNodes() ? (f = r.firstChild, b = 1) : gd(r.previousSibling) ? (f = r.previousSibling, b = r.previousSibling.data.length) : (f = c, b = e.nodeIndex(r)) : (f = c, b = e.nodeIndex(r)), !u) {
            const y = r.previousSibling, E = r.nextSibling;
            _t.each(_t.grep(r.childNodes), (M) => {
              Mt(M) && (M.data = M.data.replace(/\uFEFF/g, ""));
            });
            let N;
            for (; N = e.get(o.id + "_" + n); )
              e.remove(N, !0);
            if (Mt(E) && Mt(y) && !sn.browser.isOpera()) {
              const M = y.data.length;
              y.appendData(E.data), e.remove(E), f = y, b = M;
            }
          }
          return F.some(We(f, b));
        } else
          return F.none();
      }, PC = (e, n) => {
        const o = e.createRng();
        return is(e, !0, n, o) && is(e, !1, n, o) ? F.some({
          range: o,
          forward: G1(n)
        }) : F.none();
      }, zS = (e, n) => {
        const o = Bg(e, "start", n), r = Bg(e, "end", n);
        return Zr(o, r.or(o), (c, u) => {
          const f = e.createRng();
          return f.setStart(Z0(e, c.container()), c.offset()), f.setEnd(Z0(e, u.container()), u.offset()), {
            range: f,
            forward: G1(n)
          };
        });
      }, K1 = (e, n) => F.from(e.select(n.name)[n.index]).map((o) => {
        const r = e.createRng();
        return r.selectNode(o), {
          range: r,
          forward: !0
        };
      }), N_ = (e, n) => {
        const o = e.dom;
        if (n) {
          if (IS(n))
            return PC(o, n);
          if (MC(n))
            return D_(o, n);
          if (FS(n))
            return zS(o, n);
          if (q1(n))
            return K1(o, n);
          if (O_(n))
            return F.some({
              range: n.rng,
              forward: G1(n)
            });
        }
        return F.none();
      }, ap = (e, n, o) => Uk(e, n, o), j0 = (e, n) => {
        N_(e, n).each(({ range: o, forward: r }) => {
          e.setRng(o, r);
        });
      }, Il = (e) => xn(e) && e.tagName === "SPAN" && e.getAttribute("data-mce-type") === "bookmark", q0 = ((e) => (n) => e === n)(_s), cp = (e) => e !== "" && ` \f
\r	\v`.indexOf(e) !== -1, Pf = (e) => !cp(e) && !q0(e) && !Al(e), G0 = (e) => {
        const n = [];
        if (e)
          for (let o = 0; o < e.rangeCount; o++)
            n.push(e.getRangeAt(o));
        return n;
      }, K0 = (e) => ds(e, (n) => {
        const o = Hy(n);
        return o ? [le.fromDom(o)] : [];
      }), $g = (e) => G0(e).length > 1, M_ = (e) => Yt(K0(e), Ai), VS = (e) => uc(e, "td[data-mce-selected],th[data-mce-selected]"), P_ = (e, n) => {
        const o = VS(n);
        return o.length > 0 ? o : M_(e);
      }, ip = (e) => P_(G0(e.selection.getSel()), le.fromDom(e.getBody())), Mm = (e, n) => _l(e, "table", n), B_ = (e) => {
        const n = e.startContainer, o = e.startOffset;
        return Mt(n) ? o === 0 ? F.some(le.fromDom(n)) : F.none() : F.from(n.childNodes[o]).map(le.fromDom);
      }, $_ = (e) => {
        const n = e.endContainer, o = e.endOffset;
        return Mt(n) ? o === n.data.length ? F.some(le.fromDom(n)) : F.none() : F.from(n.childNodes[o - 1]).map(le.fromDom);
      }, US = (e) => mm(e).fold(it([e]), (n) => [e].concat(US(n))), BC = (e) => rl(e).fold(it([e]), (n) => Qo(n) === "br" ? Li(n).map((o) => [e].concat(BC(o))).getOr([]) : [e].concat(BC(n))), $C = (e, n) => Zr(B_(n), $_(n), (o, r) => {
        const c = hn(US(e), Ye(fs, o)), u = hn(BC(e), Ye(fs, r));
        return c.isSome() && u.isSome();
      }).getOr(!1), FC = (e, n, o, r) => {
        const c = o, u = new br(o, c), f = xs(e.schema.getMoveCaretBeforeOnEnterElements(), (y, E) => !ee([
          "td",
          "th",
          "table"
        ], E.toLowerCase()));
        let b = o;
        do {
          if (Mt(b) && _t.trim(b.data).length !== 0) {
            r ? n.setStart(b, 0) : n.setEnd(b, b.data.length);
            return;
          }
          if (f[b.nodeName]) {
            r ? n.setStartBefore(b) : b.nodeName === "BR" ? n.setEndBefore(b) : n.setEndAfter(b);
            return;
          }
        } while (b = r ? u.next() : u.prev());
        c.nodeName === "BODY" && (r ? n.setStart(c, 0) : n.setEnd(c, c.childNodes.length));
      }, Y0 = (e) => {
        const n = e.selection.getSel();
        return De(n) && n.rangeCount > 0;
      }, Bf = (e, n) => {
        const o = ip(e);
        o.length > 0 ? ae(o, (r) => {
          const c = r.dom, u = e.dom.createRng();
          u.setStartBefore(c), u.setEndAfter(c), n(u, !0);
        }) : n(e.selection.getRng(), !1);
      }, WS = (e, n, o) => {
        const r = nS(e, n);
        o(r), e.moveToBookmark(r);
      }, Y1 = (e) => ho(e?.nodeType), IC = (e) => xn(e) && !Il(e) && !Fl(e) && !nu(e), F_ = (e, n) => {
        if (IC(n) && !/^(TD|TH)$/.test(n.nodeName)) {
          const o = e.getAttrib(n, "data-mce-selected"), r = parseInt(o, 10);
          return !isNaN(r) && r > 0;
        } else
          return !1;
      }, X1 = (e, n, o) => {
        const { selection: r, dom: c } = e, u = r.getNode(), f = es(u);
        WS(r, !0, () => {
          n();
        }), f && es(u) && c.isChildOf(u, e.getBody()) ? e.selection.select(u) : o(r.getStart()) && I_(c, r);
      }, I_ = (e, n) => {
        var o, r;
        const c = n.getRng(), { startContainer: u, startOffset: f } = c, b = n.getNode();
        if (!F_(e, b) && xn(u)) {
          const y = u.childNodes, E = e.getRoot();
          let N;
          if (f < y.length) {
            const M = y[f];
            N = new br(M, (o = e.getParent(M, e.isBlock)) !== null && o !== void 0 ? o : E);
          } else {
            const M = y[y.length - 1];
            N = new br(M, (r = e.getParent(M, e.isBlock)) !== null && r !== void 0 ? r : E), N.next(!0);
          }
          for (let M = N.current(); M; M = N.next()) {
            if (e.getContentEditable(M) === "false")
              return;
            if (Mt(M) && !Oa(M)) {
              c.setStart(M, 0), n.setRng(c);
              return;
            }
          }
        }
      }, ln = (e, n, o) => {
        if (e) {
          const r = n ? "nextSibling" : "previousSibling";
          for (e = e[r]; e; e = e[r])
            if (xn(e) || !Oa(e))
              return e;
        }
      }, za = (e, n) => !!e.getTextBlockElements()[n.nodeName.toLowerCase()] || cs(e, n), Pm = (e, n, o) => e.schema.isValidChild(n, o), Oa = (e, n = !1) => {
        if (De(e) && Mt(e)) {
          const o = n ? e.data.replace(/ /g, " ") : e.data;
          return ff(o);
        } else
          return !1;
      }, lu = (e) => De(e) && Mt(e) && e.length === 0, X0 = (e, n) => {
        const o = "[data-mce-cef-wrappable]", r = jh(e), c = Fo(r) ? o : `${o},${r}`;
        return Si(le.fromDom(n), c);
      }, J1 = (e, n) => {
        const o = e.dom;
        return IC(n) && o.getContentEditable(n) === "false" && X0(e, n) && o.select('[contenteditable="true"]', n).length === 0;
      }, hd = (e, n) => re(e) ? e(n) : (De(n) && (e = e.replace(/%(\w+)/g, (o, r) => n[r] || o)), e), J0 = (e, n) => (e = e || "", n = n || "", e = "" + (e.nodeName || e), n = "" + (n.nodeName || n), e.toLowerCase() === n.toLowerCase()), Q0 = (e, n) => {
        if (gn(e))
          return null;
        {
          let o = String(e);
          return (n === "color" || n === "backgroundColor") && (o = kh(o)), n === "fontWeight" && e === 700 && (o = "bold"), n === "fontFamily" && (o = o.replace(/[\'\"]/g, "").replace(/,\s+/g, ",")), o;
        }
      }, lp = (e, n, o) => {
        const r = e.getStyle(n, o);
        return Q0(r, o);
      }, ZS = (e, n) => {
        let o;
        return e.getParent(n, (r) => xn(r) ? (o = e.getStyle(r, "text-decoration"), !!o && o !== "none") : !1), o;
      }, Q1 = (e, n, o) => e.getParents(n, o, e.getRoot()), LC = (e, n, o) => {
        const r = e.formatter.get(n);
        return De(r) && pe(r, o);
      }, HC = (e, n) => LC(e, n, (r) => {
        const c = (u) => re(u) || u.length > 1 && u.charAt(0) === "%";
        return pe([
          "styles",
          "attributes"
        ], (u) => Ts(r, u).exists((f) => {
          const b = ht(f) ? f : Qr(f);
          return pe(b, c);
        }));
      }), L_ = (e, n, o) => {
        const r = [
          "inline",
          "block",
          "selector",
          "attributes",
          "styles",
          "classes"
        ], c = (u) => xs(u, (f, b) => pe(r, (y) => y === b));
        return LC(e, n, (u) => {
          const f = c(u);
          return LC(e, o, (b) => {
            const y = c(b);
            return ga(f, y);
          });
        });
      }, pd = (e) => dr(e, "block"), ev = (e) => pd(e) && e.wrapper === !0, up = (e) => pd(e) && e.wrapper !== !0, Hc = (e) => dr(e, "selector"), Ba = (e) => dr(e, "inline"), tv = (e) => Hc(e) && Ba(e) && Us(Ts(e, "mixed"), !0), eb = (e) => Hc(e) && e.expand !== !1 && !Ba(e), nv = (e) => {
        const n = [];
        let o = e;
        for (; o; ) {
          if (Mt(o) && o.data !== k || o.childNodes.length > 1)
            return [];
          xn(o) && n.push(o), o = o.firstChild;
        }
        return n;
      }, tb = (e) => nv(e).length > 0, nb = (e) => Fl(e.dom) && tb(e.dom), dp = Il, jS = Q1, ob = Oa, qS = za, GS = (e) => Js(e) && e.getAttribute("data-mce-bogus") && !e.nextSibling, KS = (e, n) => {
        let o = n;
        for (; o; ) {
          if (xn(o) && e.getContentEditable(o))
            return e.getContentEditable(o) === "false" ? o : n;
          o = o.parentNode;
        }
        return n;
      }, uu = (e, n, o, r) => {
        const c = n.data;
        if (e) {
          for (let u = o; u > 0; u--)
            if (r(c.charAt(u - 1)))
              return u;
        } else
          for (let u = o; u < c.length; u++)
            if (r(c.charAt(u)))
              return u;
        return -1;
      }, ei = (e, n, o) => uu(e, n, o, (r) => q0(r) || cp(r)), zu = (e, n, o) => uu(e, n, o, Pf), qi = (e, n, o, r, c, u) => {
        let f;
        const b = e.getParent(o, e.isBlock) || n, y = (N, M, I) => {
          const X = wf(e), te = c ? X.backwards : X.forwards;
          return F.from(te(N, M, (G, ne) => dp(G.parentNode) ? -1 : (f = G, I(c, G, ne)), b));
        };
        return y(o, r, ei).bind((N) => u ? y(N.container, N.offset + (c ? -1 : 0), zu) : F.some(N)).orThunk(() => f ? F.some({
          container: f,
          offset: c ? 0 : f.length
        }) : F.none());
      }, sb = (e, n, o, r, c) => {
        const u = r[c];
        Mt(r) && Fo(r.data) && u && (r = u);
        const f = jS(e, r);
        for (let b = 0; b < f.length; b++)
          for (let y = 0; y < n.length; y++) {
            const E = n[y];
            if (!(De(E.collapsed) && E.collapsed !== o.collapsed) && Hc(E) && e.is(f[b], E.selector))
              return f[b];
          }
        return r;
      }, ov = (e, n, o, r) => {
        var c;
        let u = o;
        const f = e.getRoot(), b = n[0];
        if (pd(b) && (u = b.wrapper ? null : e.getParent(o, b.block, f)), !u) {
          const y = (c = e.getParent(o, "LI,TD,TH,SUMMARY")) !== null && c !== void 0 ? c : f;
          u = e.getParent(Mt(o) ? o.parentNode : o, (E) => E !== f && qS(e.schema, E), y);
        }
        if (u && pd(b) && b.wrapper && (u = jS(e, u, "ul,ol").reverse()[0] || u), !u)
          for (u = o; u && u[r] && !e.isBlock(u[r]) && (u = u[r], !J0(u, "br")); )
            ;
        return u || o;
      }, YS = (e, n, o, r) => {
        const c = o.parentNode;
        return De(o[r]) ? !1 : c === n || gn(c) || e.isBlock(c) ? !0 : YS(e, n, c, r);
      }, rb = (e, n, o, r, c) => {
        let u = o;
        const f = c ? "previousSibling" : "nextSibling", b = e.getRoot();
        if (Mt(o) && !ob(o) && (c ? r > 0 : r < o.data.length))
          return o;
        for (; u; ) {
          if (!n[0].block_expand && e.isBlock(u))
            return u;
          for (let y = u[f]; y; y = y[f]) {
            const E = Mt(y) && !YS(e, b, y, f);
            if (!dp(y) && !GS(y) && !ob(y, E))
              return u;
          }
          if (u === b || u.parentNode === b) {
            o = u;
            break;
          }
          u = u.parentNode;
        }
        return o;
      }, H_ = (e) => dp(e.parentNode) || dp(e), Bm = (e, n, o, r = !1) => {
        let { startContainer: c, startOffset: u, endContainer: f, endOffset: b } = n;
        const y = o[0];
        return xn(c) && c.hasChildNodes() && (c = ml(c, u), Mt(c) && (u = 0)), xn(f) && f.hasChildNodes() && (f = ml(f, n.collapsed ? b : b - 1), Mt(f) && (b = f.data.length)), c = KS(e, c), f = KS(e, f), H_(c) && (c = dp(c) ? c : c.parentNode, n.collapsed ? c = c.previousSibling || c : c = c.nextSibling || c, Mt(c) && (u = n.collapsed ? c.length : 0)), H_(f) && (f = dp(f) ? f : f.parentNode, n.collapsed ? f = f.nextSibling || f : f = f.previousSibling || f, Mt(f) && (b = n.collapsed ? 0 : f.length)), n.collapsed && (qi(e, e.getRoot(), c, u, !0, r).each(({ container: M, offset: I }) => {
          c = M, u = I;
        }), qi(e, e.getRoot(), f, b, !1, r).each(({ container: M, offset: I }) => {
          f = M, b = I;
        })), (Ba(y) || y.block_expand) && ((!Ba(y) || !Mt(c) || u === 0) && (c = rb(e, o, c, u, !0)), (!Ba(y) || !Mt(f) || b === f.data.length) && (f = rb(e, o, f, b, !1))), eb(y) && (c = sb(e, o, n, c, "previousSibling"), f = sb(e, o, n, f, "nextSibling")), (pd(y) || Hc(y)) && (c = ov(e, o, c, "previousSibling"), f = ov(e, o, f, "nextSibling"), pd(y) && (e.isBlock(c) || (c = rb(e, o, c, u, !0)), e.isBlock(f) || (f = rb(e, o, f, b, !1)))), xn(c) && c.parentNode && (u = e.nodeIndex(c), c = c.parentNode), xn(f) && f.parentNode && (b = e.nodeIndex(f) + 1, f = f.parentNode), {
          startContainer: c,
          startOffset: u,
          endContainer: f,
          endOffset: b
        };
      }, ab = (e, n, o) => {
        var r;
        const c = n.startOffset, u = ml(n.startContainer, c), f = n.endOffset, b = ml(n.endContainer, f - 1), y = (ne) => {
          const Se = ne[0];
          Mt(Se) && Se === u && c >= Se.data.length && ne.splice(0, 1);
          const ke = ne[ne.length - 1];
          return f === 0 && ne.length > 0 && ke === b && Mt(ke) && ne.splice(ne.length - 1, 1), ne;
        }, E = (ne, Se, ke) => {
          const Ae = [];
          for (; ne && ne !== ke; ne = ne[Se])
            Ae.push(ne);
          return Ae;
        }, N = (ne, Se) => e.getParent(ne, (ke) => ke.parentNode === Se, Se), M = (ne, Se, ke) => {
          const Ae = ke ? "nextSibling" : "previousSibling";
          for (let Me = ne, pt = Me.parentNode; Me && Me !== Se; Me = pt) {
            pt = Me.parentNode;
            const It = E(Me === ne ? Me : Me[Ae], Ae);
            It.length && (ke || It.reverse(), o(y(It)));
          }
        };
        if (u === b)
          return o(y([u]));
        const I = (r = e.findCommonAncestor(u, b)) !== null && r !== void 0 ? r : e.getRoot();
        if (e.isChildOf(u, b))
          return M(u, I, !0);
        if (e.isChildOf(b, u))
          return M(b, I);
        const X = N(u, I) || u, te = N(b, I) || b;
        M(u, X, !0);
        const G = E(X === u ? X : X.nextSibling, "nextSibling", te === b ? te.nextSibling : te);
        G.length && o(y(G)), M(b, te);
      }, zC = [
        'pre[class*=language-][contenteditable="false"]',
        "figure.image",
        "div[data-ephox-embed-iri]",
        "div.tiny-pageembed",
        "div.mce-toc",
        "div[data-mce-toc]"
      ], XS = (e) => vo(e) && su(e) === k, JS = (e, n, o, r) => lc(n).fold(() => "skipping", (c) => r === "br" || XS(n) ? "valid" : qw(n) ? "existing" : Fl(n.dom) ? "caret" : pe(zC, (u) => Si(n, u)) ? "valid-block" : !Pm(e, o, r) || !Pm(e, Qo(c), o) ? "invalid-child" : "valid"), VC = (e, n) => {
        const o = Bm(e.dom, n, [{ inline: "span" }]);
        n.setStart(o.startContainer, o.startOffset), n.setEnd(o.endContainer, o.endOffset), e.selection.setRng(n);
      }, sv = (e, n, o, r, c, u) => {
        const { uid: f = n, ...b } = o;
        Cu(e, v0()), ks(e, `${Ph()}`, f), ks(e, `${Hd()}`, r);
        const { attributes: y = {}, classes: E = [] } = c(f, b);
        if (Br(e, y), Bk(e, E), u) {
          E.length > 0 && ks(e, `${$h()}`, E.join(","));
          const N = Ss(y);
          N.length > 0 && ks(e, `${Tg()}`, N.join(","));
        }
      }, ir = (e) => {
        Sl(e, v0()), _r(e, `${Ph()}`), _r(e, `${Hd()}`), _r(e, `${Bh()}`);
        const n = wc(e, `${Tg()}`).map((r) => r.split(",")).getOr([]), o = wc(e, `${$h()}`).map((r) => r.split(",")).getOr([]);
        ae(n, (r) => _r(e, r)), Yw(e, o), _r(e, `${$h()}`), _r(e, `${Tg()}`);
      }, $m = (e, n, o, r, c) => {
        const u = le.fromTag("span", e);
        return sv(u, n, o, r, c, !1), u;
      }, QS = (e, n, o, r, c, u) => {
        const f = [], b = $m(e.getDoc(), o, u, r, c), y = Cf(), E = () => {
          y.clear();
        }, N = () => y.get().getOrThunk(() => {
          const te = dl(b);
          return f.push(te), y.set(te), te;
        }), M = (te) => {
          ae(te, I);
        }, I = (te) => {
          switch (JS(e, te, "span", Qo(te))) {
            case "invalid-child": {
              E();
              const ne = Ea(te);
              M(ne), E();
              break;
            }
            case "valid-block": {
              E(), sv(te, o, u, r, c, !0);
              break;
            }
            case "valid": {
              const ne = N();
              ag(te, ne);
              break;
            }
          }
        }, X = (te) => {
          const G = ye(te, le.fromDom);
          M(G);
        };
        return ab(e.dom, n, (te) => {
          E(), X(te);
        }), f;
      }, UC = (e, n, o, r) => {
        e.undoManager.transact(() => {
          const c = e.selection, u = c.getRng(), f = ip(e).length > 0, b = Eg("mce-annotation");
          if (u.collapsed && !f && VC(e, u), c.getRng().collapsed && !f) {
            const y = $m(e.getDoc(), b, r, n, o.decorate);
            sd(y, _s), c.getRng().insertNode(y.dom), c.select(y.dom);
          } else
            WS(c, !1, () => {
              Bf(e, (y) => {
                QS(e, y, b, n, o.decorate, r);
              });
            });
        });
      }, WC = (e) => {
        const n = Kw();
        Pl(e, n);
        const o = Xc(e, n), r = pr("span"), c = (u) => {
          ae(u, (f) => {
            r(f) ? qc(f) : ir(f);
          });
        };
        return {
          register: (u, f) => {
            n.register(u, f);
          },
          annotate: (u, f) => {
            n.lookup(u).each((b) => {
              UC(e, u, b, f);
            });
          },
          annotationChanged: (u, f) => {
            o.addListener(u, f);
          },
          remove: (u) => {
            da(e, F.some(u)).each(({ elements: f }) => {
              const b = e.selection.getBookmark();
              c(f), e.selection.moveToBookmark(b);
            });
          },
          removeAll: (u) => {
            const f = e.selection.getBookmark();
            Dt(y0(e, u), (b, y) => {
              c(b);
            }), e.selection.moveToBookmark(f);
          },
          getAll: (u) => {
            const f = y0(e, u);
            return Lo(f, (b) => ye(b, (y) => y.dom));
          }
        };
      }, Fg = (e) => ({
        getBookmark: Ye(ap, e),
        moveToBookmark: Ye(j0, e)
      });
      Fg.isBookmarkNode = Il;
      const ZC = (e, n, o) => o.collapsed ? !1 : pe(o.getClientRects(), (r) => Jw(r, e, n)), jC = (e, n) => e.dispatch("PreProcess", n), z_ = (e, n) => e.dispatch("PostProcess", n), mp = (e) => {
        e.dispatch("remove");
      }, fp = (e) => {
        e.dispatch("detach");
      }, qC = (e, n) => {
        e.dispatch("SwitchMode", { mode: n });
      }, GC = (e, n, o, r, c) => {
        e.dispatch("ObjectResizeStart", {
          target: n,
          width: o,
          height: r,
          origin: c
        });
      }, Vu = (e, n, o, r, c) => {
        e.dispatch("ObjectResized", {
          target: n,
          width: o,
          height: r,
          origin: c
        });
      }, $f = (e) => {
        e.dispatch("PreInit");
      }, V_ = (e) => {
        e.dispatch("PostRender");
      }, cb = (e) => {
        e.dispatch("Init");
      }, U_ = (e, n) => {
        e.dispatch("PlaceholderToggle", { state: n });
      }, gl = (e, n, o) => {
        e.dispatch(n, o);
      }, ti = (e, n, o, r) => {
        e.dispatch("FormatApply", {
          format: n,
          node: o,
          vars: r
        });
      }, Ig = (e, n, o, r) => {
        e.dispatch("FormatRemove", {
          format: n,
          node: o,
          vars: r
        });
      }, oR = (e, n) => e.dispatch("BeforeSetContent", n), ex = (e, n) => e.dispatch("SetContent", n), W_ = (e, n) => e.dispatch("BeforeGetContent", n), ts = (e, n) => e.dispatch("GetContent", n), KC = (e, n) => {
        e.dispatch("AutocompleterStart", n);
      }, tx = (e, n) => {
        e.dispatch("AutocompleterUpdate", n);
      }, YC = (e) => {
        e.dispatch("AutocompleterEnd");
      }, Z_ = (e, n, o) => e.dispatch("PastePreProcess", {
        content: n,
        internal: o
      }), j_ = (e, n, o) => e.dispatch("PastePostProcess", {
        node: n,
        internal: o
      }), nx = (e, n) => e.dispatch("PastePlainTextToggle", { state: n }), q_ = (e, n) => e.dispatch("EditableRootStateChange", { state: n }), Tn = {
        BACKSPACE: 8,
        DELETE: 46,
        DOWN: 40,
        ENTER: 13,
        ESC: 27,
        LEFT: 37,
        RIGHT: 39,
        SPACEBAR: 32,
        TAB: 9,
        UP: 38,
        PAGE_UP: 33,
        PAGE_DOWN: 34,
        END: 35,
        HOME: 36,
        modifierPressed: (e) => e.shiftKey || e.ctrlKey || e.altKey || Tn.metaKeyPressed(e),
        metaKeyPressed: (e) => sn.os.isMacOS() || sn.os.isiOS() ? e.metaKey : e.ctrlKey && !e.altKey
      }, Ff = "data-mce-selected", ox = "table,img,figure.image,hr,video,span.mce-preview-object,details", ib = Math.abs, lb = Math.round, G_ = {
        nw: [
          0,
          0,
          -1,
          -1
        ],
        ne: [
          1,
          0,
          1,
          -1
        ],
        se: [
          1,
          1,
          1,
          1
        ],
        sw: [
          0,
          1,
          -1,
          1
        ]
      }, sR = (e) => e.type === "longpress" || e.type.indexOf("touch") === 0, rR = (e, n) => {
        const o = n.dom, r = n.getDoc(), c = document, u = n.getBody();
        let f, b, y, E, N, M, I, X, te, G, ne, Se, ke, Ae, Me, pt, It;
        const un = (zt) => De(zt) && (Gc(zt) || o.is(zt, "figure.image")), nt = (zt) => oa(zt) || o.hasClass(zt, "mce-preview-object"), qe = (zt, Eo) => {
          if (sR(zt)) {
            const hs = zt.touches[0];
            return un(zt.target) && !ZC(hs.clientX, hs.clientY, Eo);
          } else
            return un(zt.target) && !ZC(zt.clientX, zt.clientY, Eo);
        }, xt = (zt) => {
          const Eo = zt.target;
          qe(zt, n.selection.getRng()) && !zt.isDefaultPrevented() && n.selection.select(Eo);
        }, bn = (zt) => o.hasClass(zt, "mce-preview-object") && De(zt.firstElementChild) ? [
          zt,
          zt.firstElementChild
        ] : o.is(zt, "figure.image") ? [zt.querySelector("img")] : [zt], Yn = (zt) => {
          const Eo = Wh(n);
          return !Eo || zt.getAttribute("data-mce-resize") === "false" || zt === n.getBody() ? !1 : o.hasClass(zt, "mce-preview-object") && De(zt.firstElementChild) ? Si(le.fromDom(zt.firstElementChild), Eo) : Si(le.fromDom(zt), Eo);
        }, Po = (zt) => nt(zt) ? o.create("img", { src: sn.transparentSrc }) : zt.cloneNode(!0), Ko = (zt, Eo, hs) => {
          if (De(hs)) {
            const nr = bn(zt);
            ae(nr, (kr) => {
              kr.style[Eo] || !n.schema.isValid(kr.nodeName.toLowerCase(), Eo) ? o.setStyle(kr, Eo, hs) : o.setAttrib(kr, Eo, "" + hs);
            });
          }
        }, er = (zt, Eo, hs) => {
          Ko(zt, "width", Eo), Ko(zt, "height", hs);
        }, Er = (zt) => {
          let Eo, hs, nr, kr, Qi;
          Eo = zt.screenX - M, hs = zt.screenY - I, Ae = Eo * E[2] + G, Me = hs * E[3] + ne, Ae = Ae < 5 ? 5 : Ae, Me = Me < 5 ? 5 : Me, (un(f) || nt(f)) && fS(n) !== !1 ? nr = !Tn.modifierPressed(zt) : nr = Tn.modifierPressed(zt), nr && (ib(Eo) > ib(hs) ? (Me = lb(Ae * Se), Ae = lb(Me / Se)) : (Ae = lb(Me / Se), Me = lb(Ae * Se))), er(b, Ae, Me), kr = E.startPos.x + Eo, Qi = E.startPos.y + hs, kr = kr > 0 ? kr : 0, Qi = Qi > 0 ? Qi : 0, o.setStyles(y, {
            left: kr,
            top: Qi,
            display: "block"
          }), y.innerHTML = Ae + " &times; " + Me, E[2] < 0 && b.clientWidth <= Ae && o.setStyle(b, "left", X + (G - Ae)), E[3] < 0 && b.clientHeight <= Me && o.setStyle(b, "top", te + (ne - Me)), Eo = u.scrollWidth - pt, hs = u.scrollHeight - It, Eo + hs !== 0 && o.setStyles(y, {
            left: kr - Eo,
            top: Qi - hs
          }), ke || (GC(n, f, G, ne, "corner-" + E.name), ke = !0);
        }, wa = () => {
          const zt = ke;
          ke = !1, zt && (Ko(f, "width", Ae), Ko(f, "height", Me)), o.unbind(r, "mousemove", Er), o.unbind(r, "mouseup", wa), c !== r && (o.unbind(c, "mousemove", Er), o.unbind(c, "mouseup", wa)), o.remove(b), o.remove(y), o.remove(N), si(f), zt && (Vu(n, f, Ae, Me, "corner-" + E.name), o.setAttrib(f, "style", o.getAttrib(f, "style"))), n.nodeChanged();
        }, si = (zt) => {
          vs();
          const Eo = o.getPos(zt, u), hs = Eo.x, nr = Eo.y, kr = zt.getBoundingClientRect(), Qi = kr.width || kr.right - kr.left, hu = kr.height || kr.bottom - kr.top;
          f !== zt && (Gt(), f = zt, Ae = Me = 0);
          const Yf = n.dispatch("ObjectSelected", { target: zt });
          Yn(zt) && !Yf.isDefaultPrevented() ? Dt(G_, (el, rm) => {
            const Do = (Ls) => {
              const Gr = bn(f)[0];
              M = Ls.screenX, I = Ls.screenY, G = Gr.clientWidth, ne = Gr.clientHeight, Se = ne / G, E = el, E.name = rm, E.startPos = {
                x: Qi * el[0] + hs,
                y: hu * el[1] + nr
              }, pt = u.scrollWidth, It = u.scrollHeight, N = o.add(u, "div", {
                class: "mce-resize-backdrop",
                "data-mce-bogus": "all"
              }), o.setStyles(N, {
                position: "fixed",
                left: "0",
                top: "0",
                width: "100%",
                height: "100%"
              }), b = Po(f), o.addClass(b, "mce-clonedresizable"), o.setAttrib(b, "data-mce-bogus", "all"), b.contentEditable = "false", o.setStyles(b, {
                left: hs,
                top: nr,
                margin: 0
              }), er(b, Qi, hu), b.removeAttribute(Ff), u.appendChild(b), o.bind(r, "mousemove", Er), o.bind(r, "mouseup", wa), c !== r && (o.bind(c, "mousemove", Er), o.bind(c, "mouseup", wa)), y = o.add(u, "div", {
                class: "mce-resize-helper",
                "data-mce-bogus": "all"
              }, G + " &times; " + ne);
            };
            let ps = o.get("mceResizeHandle" + rm);
            ps && o.remove(ps), ps = o.add(u, "div", {
              id: "mceResizeHandle" + rm,
              "data-mce-bogus": "all",
              class: "mce-resizehandle",
              unselectable: !0,
              style: "cursor:" + rm + "-resize; margin:0; padding:0"
            }), o.bind(ps, "mousedown", (Ls) => {
              Ls.stopImmediatePropagation(), Ls.preventDefault(), Do(Ls);
            }), el.elm = ps, o.setStyles(ps, {
              left: Qi * el[0] + hs - ps.offsetWidth / 2,
              top: hu * el[1] + nr - ps.offsetHeight / 2
            });
          }) : Gt(!1);
        }, kc = T1(si, 0), Gt = (zt = !0) => {
          kc.cancel(), vs(), f && zt && f.removeAttribute(Ff), Dt(G_, (Eo, hs) => {
            const nr = o.get("mceResizeHandle" + hs);
            nr && (o.unbind(nr), o.remove(nr));
          });
        }, vn = (zt, Eo) => o.isChildOf(zt, Eo), As = (zt) => {
          if (ke || n.removed || n.composing)
            return;
          const Eo = zt.type === "mousedown" ? zt.target : e.getNode(), hs = Hi(le.fromDom(Eo), ox).map((kr) => kr.dom).filter((kr) => o.isEditable(kr.parentElement) || kr.nodeName === "IMG" && o.isEditable(kr)).getOrUndefined(), nr = De(hs) ? o.getAttrib(hs, Ff, "1") : "1";
          if (ae(o.select(`img[${Ff}],hr[${Ff}]`), (kr) => {
            kr.removeAttribute(Ff);
          }), De(hs) && vn(hs, u) && n.hasFocus()) {
            zn();
            const kr = e.getStart(!0);
            if (vn(kr, hs) && vn(e.getEnd(!0), hs)) {
              o.setAttrib(hs, Ff, nr), kc.throttle(hs);
              return;
            }
          }
          Gt();
        }, vs = () => {
          Dt(G_, (zt) => {
            zt.elm && (o.unbind(zt.elm), delete zt.elm);
          });
        }, zn = () => {
          try {
            n.getDoc().execCommand("enableObjectResizing", !1, "false");
          } catch {
          }
        };
        return n.on("init", () => {
          zn(), n.on("NodeChange ResizeEditor ResizeWindow ResizeContent drop", As), n.on("keyup compositionend", (zt) => {
            f && f.nodeName === "TABLE" && As(zt);
          }), n.on("hide blur", Gt), n.on("contextmenu longpress", xt, !0);
        }), n.on("remove", vs), {
          isResizable: Yn,
          showResizeRect: si,
          hideResizeRect: Gt,
          updateResizeRect: As,
          destroy: () => {
            kc.cancel(), f = b = N = null;
          }
        };
      }, qI = (e, n) => {
        n.fold((o) => {
          e.setStartBefore(o.dom);
        }, (o, r) => {
          e.setStart(o.dom, r);
        }, (o) => {
          e.setStartAfter(o.dom);
        });
      }, K_ = (e, n) => {
        n.fold((o) => {
          e.setEndBefore(o.dom);
        }, (o, r) => {
          e.setEnd(o.dom, r);
        }, (o) => {
          e.setEndAfter(o.dom);
        });
      }, sx = (e, n, o) => {
        const r = e.document.createRange();
        return qI(r, n), K_(r, o), r;
      }, mo = (e, n, o, r, c) => {
        const u = e.document.createRange();
        return u.setStart(n.dom, o), u.setEnd(r.dom, c), u;
      }, Fm = dd.generate([
        {
          ltr: [
            "start",
            "soffset",
            "finish",
            "foffset"
          ]
        },
        {
          rtl: [
            "start",
            "soffset",
            "finish",
            "foffset"
          ]
        }
      ]), rx = (e, n, o) => n(le.fromDom(o.startContainer), o.startOffset, le.fromDom(o.endContainer), o.endOffset), Y_ = (e, n) => n.match({
        domRange: (o) => ({
          ltr: it(o),
          rtl: F.none
        }),
        relative: (o, r) => ({
          ltr: Je(() => sx(e, o, r)),
          rtl: Je(() => F.some(sx(e, r, o)))
        }),
        exact: (o, r, c, u) => ({
          ltr: Je(() => mo(e, o, r, c, u)),
          rtl: Je(() => F.some(mo(e, c, u, o, r)))
        })
      }), ub = (e, n) => {
        const o = n.ltr();
        return o.collapsed ? n.rtl().filter((c) => c.collapsed === !1).map((c) => Fm.rtl(le.fromDom(c.endContainer), c.endOffset, le.fromDom(c.startContainer), c.startOffset)).getOrThunk(() => rx(e, Fm.ltr, o)) : rx(e, Fm.ltr, o);
      }, X_ = (e, n) => {
        const o = Y_(e, n);
        return ub(e, o);
      };
      Fm.ltr, Fm.rtl;
      const XC = { create: (e, n, o, r) => ({
        start: e,
        soffset: n,
        finish: o,
        foffset: r
      }) }, cx = (e, n, o) => {
        var r, c;
        return F.from((c = (r = e.dom).caretPositionFromPoint) === null || c === void 0 ? void 0 : c.call(r, n, o)).bind((u) => {
          if (u.offsetNode === null)
            return F.none();
          const f = e.dom.createRange();
          return f.setStart(u.offsetNode, u.offset), f.collapse(), F.some(f);
        });
      }, rv = (e, n, o) => {
        var r, c;
        return F.from((c = (r = e.dom).caretRangeFromPoint) === null || c === void 0 ? void 0 : c.call(r, n, o));
      }, J_ = document.caretPositionFromPoint ? cx : document.caretRangeFromPoint ? rv : F.none, Q_ = (e, n, o) => {
        const r = le.fromDom(e.document);
        return J_(r, n, o).map((c) => XC.create(le.fromDom(c.startContainer), c.startOffset, le.fromDom(c.endContainer), c.endOffset));
      }, gp = dd.generate([
        { before: ["element"] },
        {
          on: [
            "element",
            "offset"
          ]
        },
        { after: ["element"] }
      ]), JC = (e, n, o, r) => e.fold(n, o, r), ix = (e) => e.fold(Gn, Gn, Gn), eA = gp.before, tA = gp.on, av = gp.after, qd = {
        before: eA,
        on: tA,
        after: av,
        cata: JC,
        getStart: ix
      }, cv = dd.generate([
        { domRange: ["rng"] },
        {
          relative: [
            "startSitu",
            "finishSitu"
          ]
        },
        {
          exact: [
            "start",
            "soffset",
            "finish",
            "foffset"
          ]
        }
      ]), Ps = (e) => cv.exact(e.start, e.soffset, e.finish, e.foffset), nA = (e) => e.match({
        domRange: (n) => le.fromDom(n.startContainer),
        relative: (n, o) => qd.getStart(n),
        exact: (n, o, r, c) => n
      }), Im = cv.domRange, Gd = cv.relative, iv = cv.exact, Ll = (e) => {
        const n = nA(e);
        return sl(n);
      }, lv = XC.create, Lm = {
        domRange: Im,
        relative: Gd,
        exact: iv,
        exactFromRange: Ps,
        getWin: Ll,
        range: lv
      }, hp = (e, n) => {
        const o = Qo(e);
        return o === "input" ? qd.after(e) : ee([
          "br",
          "img"
        ], o) ? n === 0 ? qd.before(e) : qd.after(e) : qd.on(e, n);
      }, db = (e, n) => {
        const o = e.fold(qd.before, hp, qd.after), r = n.fold(qd.before, hp, qd.after);
        return Lm.relative(o, r);
      }, QC = (e, n, o, r) => {
        const c = hp(e, n), u = hp(o, r);
        return Lm.relative(c, u);
      }, oA = (e) => e.match({
        domRange: (n) => {
          const o = le.fromDom(n.startContainer), r = le.fromDom(n.endContainer);
          return QC(o, n.startOffset, r, n.endOffset);
        },
        relative: db,
        exact: QC
      }), e2 = (e, n) => {
        const r = document.createDocumentFragment();
        return ae(e, (c) => {
          r.appendChild(c.dom);
        }), le.fromDom(r);
      }, sA = (e) => {
        const n = Lm.getWin(e).dom, o = (c, u, f, b) => mo(n, c, u, f, b), r = oA(e);
        return X_(n, r).match({
          ltr: o,
          rtl: o
        });
      }, ls = (e, n, o) => Q_(e, n, o), Hl = (e, n, o) => {
        const r = sl(le.fromDom(o));
        return ls(r.dom, e, n).map((c) => {
          const u = o.createRange();
          return u.setStart(c.start.dom, c.soffset), u.setEnd(c.finish.dom, c.foffset), u;
        }).getOrUndefined();
      }, Hm = (e, n) => De(e) && De(n) && e.startContainer === n.startContainer && e.startOffset === n.startOffset && e.endContainer === n.endContainer && e.endOffset === n.endOffset, rA = (e, n, o) => {
        let r = e;
        for (; r && r !== n; ) {
          if (o(r))
            return r;
          r = r.parentNode;
        }
        return null;
      }, pp = (e, n, o) => rA(e, n, o) !== null, ws = (e, n, o) => pp(e, n, (r) => r.nodeName === o), aA = (e, n) => Jn(e) && !pp(e, n, Fl), t2 = (e, n, o) => {
        const r = n.parentNode;
        if (r) {
          const c = new br(n, e.getParent(r, e.isBlock) || e.getRoot());
          let u;
          for (; u = c[o ? "prev" : "next"](); )
            if (Js(u))
              return !0;
        }
        return !1;
      }, l = (e, n) => {
        var o;
        return ((o = e.previousSibling) === null || o === void 0 ? void 0 : o.nodeName) === n;
      }, m = (e, n) => {
        let o = n;
        for (; o && o !== e; ) {
          if (es(o))
            return !0;
          o = o.parentNode;
        }
        return !1;
      }, h = (e, n, o, r, c) => {
        const u = e.getRoot(), f = e.schema.getNonEmptyElements(), b = c.parentNode;
        let y, E;
        if (!b)
          return F.none();
        const N = e.getParent(b, e.isBlock) || u;
        if (r && Js(c) && n && e.isEmpty(N))
          return F.some(We(b, e.nodeIndex(c)));
        const M = new br(c, N);
        for (; E = M[r ? "prev" : "next"](); ) {
          if (e.getContentEditableParent(E) === "false" || aA(E, u))
            return F.none();
          if (Mt(E) && E.data.length > 0)
            return ws(E, u, "A") ? F.none() : F.some(We(E, r ? E.data.length : 0));
          if (e.isBlock(E) || f[E.nodeName.toLowerCase()])
            return F.none();
          y = E;
        }
        return rd(y) ? F.none() : o && y ? F.some(We(y, 0)) : F.none();
      }, v = (e, n, o, r) => {
        const c = e.getRoot();
        let u, f = !1, b = o ? r.startContainer : r.endContainer, y = o ? r.startOffset : r.endOffset;
        const E = xn(b) && y === b.childNodes.length, N = e.schema.getNonEmptyElements();
        let M = o;
        if (Jn(b))
          return F.none();
        if (xn(b) && y > b.childNodes.length - 1 && (M = !1), dg(b) && (b = c, y = 0), b === c) {
          if (M && (u = b.childNodes[y > 0 ? y - 1 : 0], u && (Jn(u) || N[u.nodeName] || Du(u))))
            return F.none();
          if (b.hasChildNodes()) {
            if (y = Math.min(!M && y > 0 ? y - 1 : y, b.childNodes.length - 1), b = b.childNodes[y], y = Mt(b) && E ? b.data.length : 0, !n && b === c.lastChild && Du(b) || m(c, b) || Jn(b) || gt(b))
              return F.none();
            if (b.hasChildNodes() && !Du(b)) {
              u = b;
              const I = new br(b, c);
              do {
                if (es(u) || Jn(u)) {
                  f = !1;
                  break;
                }
                if (Mt(u) && u.data.length > 0) {
                  y = M ? 0 : u.data.length, b = u, f = !0;
                  break;
                }
                if (N[u.nodeName.toLowerCase()] && !dc(u)) {
                  y = e.nodeIndex(u), b = u.parentNode, M || y++, f = !0;
                  break;
                }
              } while (u = M ? I.next() : I.prev());
            }
          }
        }
        return n && (Mt(b) && y === 0 && h(e, E, n, !0, b).each((I) => {
          b = I.container(), y = I.offset(), f = !0;
        }), xn(b) && (u = b.childNodes[y], u || (u = b.childNodes[y - 1]), u && Js(u) && !l(u, "A") && !t2(e, u, !1) && !t2(e, u, !0) && h(e, E, n, !0, u).each((I) => {
          b = I.container(), y = I.offset(), f = !0;
        }))), M && !n && Mt(b) && y === b.data.length && h(e, E, n, !1, b).each((I) => {
          b = I.container(), y = I.offset(), f = !0;
        }), f && b ? F.some(We(b, y)) : F.none();
      }, T = (e, n) => {
        const o = n.collapsed, r = n.cloneRange(), c = We.fromRangeStart(n);
        return v(e, o, !0, r).each((u) => {
          (!o || !We.isAbove(c, u)) && r.setStart(u.container(), u.offset());
        }), o || v(e, o, !1, r).each((u) => {
          r.setEnd(u.container(), u.offset());
        }), o && r.collapse(!0), Hm(n, r) ? F.none() : F.some(r);
      }, O = (e, n) => e.splitText(n), $ = (e) => {
        let n = e.startContainer, o = e.startOffset, r = e.endContainer, c = e.endOffset;
        if (n === r && Mt(n)) {
          if (o > 0 && o < n.data.length)
            if (r = O(n, o), n = r.previousSibling, c > o) {
              c = c - o;
              const u = O(r, c).previousSibling;
              n = r = u, c = u.data.length, o = 0;
            } else
              c = 0;
        } else if (Mt(n) && o > 0 && o < n.data.length && (n = O(n, o), o = 0), Mt(r) && c > 0 && c < r.data.length) {
          const u = O(r, c).previousSibling;
          r = u, c = u.data.length;
        }
        return {
          startContainer: n,
          startOffset: o,
          endContainer: r,
          endOffset: c
        };
      }, W = (e) => ({
        walk: (u, f) => ab(e, u, f),
        split: $,
        expand: (u, f = { type: "word" }) => {
          if (f.type === "word") {
            const b = Bm(e, u, [{ inline: "span" }]), y = e.createRng();
            return y.setStart(b.startContainer, b.startOffset), y.setEnd(b.endContainer, b.endOffset), y;
          }
          return u;
        },
        normalize: (u) => T(e, u).fold($e, (f) => (u.setStart(f.startContainer, f.startOffset), u.setEnd(f.endContainer, f.endOffset), !0))
      });
      W.compareRanges = Hm, W.getCaretRangeFromPoint = Hl, W.getSelectedNode = Hy, W.getNode = ml;
      const ge = ((e, n) => {
        const o = (b, y) => {
          if (!ho(y) && !y.match(/^[0-9]+$/))
            throw new Error(e + ".set accepts only positive integer values. Value was " + y);
          const E = b.dom;
          Eu(E) && (E.style[e] = y + "px");
        }, r = (b) => {
          const y = n(b);
          if (y <= 0 || y === null) {
            const E = ha(b, e);
            return parseFloat(E) || 0;
          }
          return y;
        }, c = r, u = (b, y) => Xe(y, (E, N) => {
          const M = ha(b, N), I = M === void 0 ? 0 : parseInt(M, 10);
          return isNaN(I) ? E : E + I;
        }, 0);
        return {
          set: o,
          get: r,
          getOuter: c,
          aggregate: u,
          max: (b, y, E) => {
            const N = u(b, E);
            return y > N ? y - N : 0;
          }
        };
      })("height", (e) => {
        const n = e.dom;
        return td(e) ? n.getBoundingClientRect().height : n.offsetHeight;
      }), Re = (e) => ge.get(e), Et = () => le.fromDom(document), an = (e, n) => e.view(n).fold(it([]), (r) => {
        const c = e.owner(r), u = an(e, c);
        return [r].concat(u);
      }), tn = (e, n) => {
        const o = n.owner(e);
        return an(n, o);
      };
      var ut = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        view: (e) => {
          var n;
          return (e.dom === document ? F.none() : F.from((n = e.dom.defaultView) === null || n === void 0 ? void 0 : n.frameElement)).map(le.fromDom);
        },
        owner: (e) => xi(e)
      });
      const $n = (e) => {
        const n = Et(), o = Bn(n), r = tn(e, ut), c = At(e), u = Ct(r, (f, b) => {
          const y = At(b);
          return {
            left: f.left + y.left,
            top: f.top + y.top
          };
        }, {
          left: 0,
          top: 0
        });
        return R(u.left + c.left + o.left, u.top + c.top + o.top);
      }, wo = (e) => Qo(e) === "textarea", Ho = (e, n) => e.dispatch("ScrollIntoView", n).isDefaultPrevented(), Mr = (e, n) => {
        e.dispatch("AfterScrollIntoView", n);
      }, oc = (e, n) => {
        const o = Ea(e);
        if (o.length === 0 || wo(e))
          return {
            element: e,
            offset: n
          };
        if (n < o.length && !wo(o[n]))
          return {
            element: o[n],
            offset: 0
          };
        {
          const r = o[o.length - 1];
          return wo(r) ? {
            element: e,
            offset: n
          } : Qo(r) === "img" ? {
            element: r,
            offset: 1
          } : vo(r) ? {
            element: r,
            offset: su(r).length
          } : {
            element: r,
            offset: Ea(r).length
          };
        }
      }, ma = (e, n) => {
        const o = be(e), r = Re(e);
        return {
          element: e,
          bottom: o.top + r,
          height: r,
          pos: o,
          cleanup: n
        };
      }, Gi = (e, n) => {
        const o = oc(e, n), r = le.fromHtml('<span data-mce-bogus="all" style="display: inline-block;">' + k + "</span>");
        return ka(o.element, r), ma(r, () => bs(r));
      }, Lg = (e) => ma(le.fromDom(e), Oe), Hg = (e, n, o, r) => {
        bi(e, (c, u) => uv(e, n, o, r), o);
      }, n2 = (e, n, o, r, c) => {
        const u = {
          elm: r.element.dom,
          alignToTop: c
        };
        if (Ho(e, u))
          return;
        const f = Bn(n).top;
        o(e, n, f, r, c), Mr(e, u);
      }, uv = (e, n, o, r) => {
        const c = le.fromDom(e.getBody()), u = le.fromDom(e.getDoc());
        na(c);
        const f = Gi(le.fromDom(o.startContainer), o.startOffset);
        n2(e, u, n, f, r), f.cleanup();
      }, tr = (e, n, o, r) => {
        const c = le.fromDom(e.getDoc());
        n2(e, c, o, Lg(n), r);
      }, bi = (e, n, o) => {
        const r = o.startContainer, c = o.startOffset, u = o.endContainer, f = o.endOffset;
        n(le.fromDom(r), le.fromDom(u));
        const b = e.dom.createRng();
        b.setStart(r, c), b.setEnd(u, f), e.selection.setRng(o);
      }, zc = (e, n, o, r, c) => {
        const u = n.pos;
        if (r)
          To(u.left, u.top, c);
        else {
          const f = u.top - o + n.height;
          To(-e.getBody().getBoundingClientRect().left, f, c);
        }
      }, zl = (e, n, o, r, c, u) => {
        const f = r + o, b = c.pos.top, y = c.bottom, E = y - b >= r;
        b < o ? zc(e, c, r, u !== !1, n) : b > f ? zc(e, c, r, E ? u !== !1 : u === !0, n) : y > f && !E && zc(e, c, r, u === !0, n);
      }, hl = (e, n, o, r, c) => {
        const u = sl(n).dom.innerHeight;
        zl(e, n, o, u, r, c);
      }, If = (e, n, o, r, c) => {
        const u = sl(n).dom.innerHeight;
        zl(e, n, o, u, r, c);
        const f = $n(r.element), b = Ma(window);
        f.top < b.y ? Co(r.element, c !== !1) : f.top > b.bottom && Co(r.element, c === !0);
      }, Ni = (e, n, o) => Hg(e, hl, n, o), o2 = (e, n, o) => tr(e, n, hl, o), mb = (e, n, o) => Hg(e, If, n, o), Kd = (e, n, o) => tr(e, n, If, o), ni = (e, n, o) => {
        (e.inline ? o2 : Kd)(e, n, o);
      }, fb = (e, n, o) => {
        (e.inline ? Ni : mb)(e, n, o);
      }, lx = (e, n = !1) => e.dom.focus({ preventScroll: n }), ux = (e) => {
        const n = kl(e).dom;
        return e.dom === n.activeElement;
      }, bp = (e = Et()) => F.from(e.dom.activeElement).map(le.fromDom), dx = (e) => bp(kl(e)).filter((n) => e.dom.contains(n.dom)), dv = (e, n) => {
        const o = vo(n) ? su(n).length : Ea(n).length + 1;
        return e > o ? o : e < 0 ? 0 : e;
      }, mx = (e) => Lm.range(e.start, dv(e.soffset, e.start), e.finish, dv(e.foffset, e.finish)), zg = (e, n) => !tu(n.dom) && (ic(e, n) || fs(e, n)), aR = (e) => (n) => zg(e, n.start) && zg(e, n.finish), GI = (e) => e.inline || sn.browser.isFirefox(), KI = (e) => Lm.range(le.fromDom(e.startContainer), e.startOffset, le.fromDom(e.endContainer), e.endOffset), YI = (e) => {
        const n = e.getSelection();
        return (!n || n.rangeCount === 0 ? F.none() : F.from(n.getRangeAt(0))).map(KI);
      }, XI = (e) => {
        const n = sl(e);
        return YI(n.dom).filter(aR(e));
      }, cR = (e, n) => F.from(n).filter(aR(e)).map(mx), iR = (e) => {
        const n = document.createRange();
        try {
          return n.setStart(e.start.dom, e.soffset), n.setEnd(e.finish.dom, e.foffset), F.some(n);
        } catch {
          return F.none();
        }
      }, mv = (e) => {
        const n = GI(e) ? XI(le.fromDom(e.getBody())) : F.none();
        e.bookmark = n.isSome() ? n : e.bookmark;
      }, cA = (e) => (e.bookmark ? e.bookmark : F.none()).bind((o) => cR(le.fromDom(e.getBody()), o)).bind(iR), JI = (e) => {
        cA(e).each((n) => e.selection.setRng(n));
      }, uR = { isEditorUIElement: (e) => {
        const n = e.className.toString();
        return n.indexOf("tox-") !== -1 || n.indexOf("mce-") !== -1;
      } }, dR = (e, n) => (ho(n) || (n = 0), setTimeout(e, n)), mR = (e, n) => (ho(n) || (n = 0), setInterval(e, n)), Uu = {
        setEditorTimeout: (e, n, o) => dR(() => {
          e.removed || n();
        }, o),
        setEditorInterval: (e, n, o) => {
          const r = mR(() => {
            e.removed ? clearInterval(r) : n();
          }, o);
          return r;
        }
      }, QI = (e) => e.type === "nodechange" && e.selectionChange, eL = (e, n) => {
        const o = () => {
          n.throttle();
        };
        xr.DOM.bind(document, "mouseup", o), e.on("remove", () => {
          xr.DOM.unbind(document, "mouseup", o);
        });
      }, tL = (e, n) => {
        e.on("mouseup touchend", (o) => {
          n.throttle();
        });
      }, nL = (e, n) => {
        tL(e, n), e.on("keyup NodeChange AfterSetSelectionRange", (o) => {
          QI(o) || mv(e);
        });
      }, fx = (e) => {
        const n = T1(() => {
          mv(e);
        }, 0);
        e.on("init", () => {
          e.inline && eL(e, n), nL(e, n);
        }), e.on("remove", () => {
          n.cancel();
        });
      };
      let gb;
      const gx = xr.DOM, fR = (e) => xn(e) && uR.isEditorUIElement(e), hx = (e) => {
        const n = e.classList;
        return n !== void 0 ? n.contains("tox-edit-area") || n.contains("tox-edit-area__iframe") || n.contains("mce-content-body") : !1;
      }, px = (e, n) => {
        const o = bS(e);
        return gx.getParent(n, (c) => fR(c) || (o ? e.dom.is(c, o) : !1)) !== null;
      }, iA = (e) => {
        try {
          const n = kl(le.fromDom(e.getElement()));
          return bp(n).fold(() => document.body, (o) => o.dom);
        } catch {
          return document.body;
        }
      }, oL = (e, n) => {
        const o = n.editor;
        fx(o);
        const r = (c, u) => {
          if (p_(c) && c.inline !== !0) {
            const f = le.fromDom(c.getContainer());
            u(f, "tox-edit-focus");
          }
        };
        o.on("focusin", () => {
          const c = e.focusedEditor;
          hx(iA(o)) && r(o, Cu), c !== o && (c && c.dispatch("blur", { focusedEditor: o }), e.setActive(o), e.focusedEditor = o, o.dispatch("focus", { blurredEditor: c }), o.focus(!0));
        }), o.on("focusout", () => {
          Uu.setEditorTimeout(o, () => {
            const c = e.focusedEditor;
            (!hx(iA(o)) || c !== o) && r(o, Sl), !px(o, iA(o)) && c === o && (o.dispatch("blur", { focusedEditor: null }), e.focusedEditor = null);
          });
        }), gb || (gb = (c) => {
          const u = e.activeEditor;
          u && Tu(c).each((f) => {
            const b = f;
            b.ownerDocument === document && b !== document.body && !px(u, b) && e.focusedEditor === u && (u.dispatch("blur", { focusedEditor: null }), e.focusedEditor = null);
          });
        }, gx.bind(document, "focusin", gb));
      }, sL = (e, n) => {
        e.focusedEditor === n.editor && (e.focusedEditor = null), !e.activeEditor && gb && (gx.unbind(document, "focusin", gb), gb = null);
      }, rL = (e) => {
        e.on("AddEditor", Ye(oL, e)), e.on("RemoveEditor", Ye(sL, e));
      }, aL = (e, n) => e.dom.getParent(n, (o) => e.dom.getContentEditable(o) === "true"), cL = (e) => e.collapsed ? F.from(ml(e.startContainer, e.startOffset)).map(le.fromDom) : F.none(), iL = (e, n) => cL(n).bind((o) => ru(o) ? F.some(o) : ic(e, o) ? F.none() : F.some(e)), gR = (e, n) => {
        iL(le.fromDom(e.getBody()), n).bind((o) => Ri(o.dom)).fold(() => {
          e.selection.normalize();
        }, (o) => e.selection.setRng(o.toRange()));
      }, lA = (e) => {
        if (e.setActive)
          try {
            e.setActive();
          } catch {
            e.focus();
          }
        else
          e.focus();
      }, lL = (e) => ux(e) || dx(e).isSome(), uL = (e) => De(e.iframeElement) && ux(le.fromDom(e.iframeElement)), bx = (e) => {
        const n = e.getBody();
        return n && lL(le.fromDom(n));
      }, hR = (e) => {
        const n = kl(le.fromDom(e.getElement()));
        return bp(n).filter((o) => !hx(o.dom) && px(e, o.dom)).isSome();
      }, vp = (e) => e.inline ? bx(e) : uL(e), pR = (e) => vp(e) || hR(e), dL = (e) => {
        const n = e.selection, o = e.getBody();
        let r = n.getRng();
        e.quirks.refreshContentEditable(), De(e.bookmark) && !vp(e) && cA(e).each((u) => {
          e.selection.setRng(u), r = u;
        });
        const c = aL(e, n.getNode());
        if (c && e.dom.isChildOf(c, o)) {
          lA(c), gR(e, r), uA(e);
          return;
        }
        e.inline || (sn.browser.isOpera() || lA(o), e.getWin().focus()), (sn.browser.isFirefox() || e.inline) && (lA(o), gR(e, r)), uA(e);
      }, uA = (e) => e.editorManager.setActive(e), mL = (e, n) => {
        e.removed || (n ? uA(e) : dL(e));
      }, bR = (e, n) => n.collapsed ? e.isEditable(n.startContainer) : e.isEditable(n.startContainer) && e.isEditable(n.endContainer), vR = (e, n, o, r, c) => {
        const u = o ? n.startContainer : n.endContainer, f = o ? n.startOffset : n.endOffset;
        return F.from(u).map(le.fromDom).map((b) => !r || !n.collapsed ? ed(b, c(b, f)).getOr(b) : b).bind((b) => yn(b) ? F.some(b) : lc(b).filter(yn)).map((b) => b.dom).getOr(e);
      }, dA = (e, n, o = !1) => vR(e, n, !0, o, (r, c) => Math.min(Mc(r), c)), yR = (e, n, o = !1) => vR(e, n, !1, o, (r, c) => c > 0 ? c - 1 : c), mA = (e, n) => {
        const o = e;
        for (; e && Mt(e) && e.length === 0; )
          e = n ? e.nextSibling : e.previousSibling;
        return e || o;
      }, CR = (e, n) => {
        if (!n)
          return e;
        let o = n.startContainer, r = n.endContainer;
        const c = n.startOffset, u = n.endOffset;
        let f = n.commonAncestorContainer;
        n.collapsed || (o === r && u - c < 2 && o.hasChildNodes() && (f = o.childNodes[c]), Mt(o) && Mt(r) && (o.length === c ? o = mA(o.nextSibling, !0) : o = o.parentNode, u === 0 ? r = mA(r.previousSibling, !1) : r = r.parentNode, o && o === r && (f = o)));
        const b = Mt(f) ? f.parentNode : f;
        return Au(b) ? b : e;
      }, fL = (e, n, o, r) => {
        const c = [], u = e.getRoot(), f = e.getParent(o || dA(u, n, n.collapsed), e.isBlock), b = e.getParent(r || yR(u, n, n.collapsed), e.isBlock);
        if (f && f !== u && c.push(f), f && b && f !== b) {
          let y;
          const E = new br(f, u);
          for (; (y = E.next()) && y !== b; )
            e.isBlock(y) && c.push(y);
        }
        return b && f !== b && b !== u && c.push(b), c;
      }, gL = (e, n, o) => F.from(n).bind((r) => F.from(r.parentNode).map((c) => {
        const u = e.nodeIndex(r), f = e.createRng();
        return f.setStart(c, u), f.setEnd(c, u + 1), o && (FC(e, f, r, !0), FC(e, f, r, !1)), f;
      })), fA = (e, n) => ye(n, (o) => {
        const r = e.dispatch("GetSelectionRange", { range: o });
        return r.range !== o ? r.range : o;
      }), hL = (e) => Qo(e) === "img" ? 1 : u1(e).fold(() => Ea(e).length, (n) => n.length), pL = (e) => u1(e).filter((n) => n.trim().length !== 0 || n.indexOf(_s) > -1).isSome(), bL = (e) => je(e) && ia(e, "contenteditable") === "false", vL = [
        "img",
        "br"
      ], wR = (e) => pL(e) || ee(vL, Qo(e)) || bL(e), yL = (e) => La(e, wR), CL = (e) => wL(e, wR), wL = (e, n) => {
        const o = (r) => {
          const c = Ea(r);
          for (let u = c.length - 1; u >= 0; u--) {
            const f = c[u];
            if (n(f))
              return F.some(f);
            const b = o(f);
            if (b.isSome())
              return b;
          }
          return F.none();
        };
        return o(e);
      }, SR = "[data-mce-autocompleter]", SL = (e, n) => {
        if (xR(le.fromDom(e.getBody())).isNone()) {
          const o = le.fromHtml('<span data-mce-autocompleter="1" data-mce-bogus="1"></span>', e.getDoc());
          la(o, le.fromDom(n.extractContents())), n.insertNode(o.dom), lc(o).each((r) => r.dom.normalize()), CL(o).map((r) => {
            e.selection.setCursorLocation(r.dom, hL(r));
          });
        }
      }, xL = (e) => Hi(e, SR), xR = (e) => ii(e, SR), TL = (e, n) => xR(n).each((o) => {
        const r = e.selection.getBookmark();
        qc(o), e.selection.moveToBookmark(r);
      }), EL = {
        "#text": 3,
        "#comment": 8,
        "#cdata": 4,
        "#pi": 7,
        "#doctype": 10,
        "#document-fragment": 11
      }, vx = (e, n, o) => {
        const r = o ? "lastChild" : "firstChild", c = o ? "prev" : "next";
        if (e[r])
          return e[r];
        if (e !== n) {
          let u = e[c];
          if (u)
            return u;
          for (let f = e.parent; f && f !== n; f = f.parent)
            if (u = f[c], u)
              return u;
        }
      }, kL = (e) => {
        var n;
        const o = (n = e.value) !== null && n !== void 0 ? n : "";
        if (!ff(o))
          return !1;
        const r = e.parent;
        return !(r && (r.name !== "span" || r.attr("style")) && /^[ ]+$/.test(o));
      }, no = (e) => {
        const n = e.name === "a" && !e.attr("href") && e.attr("id");
        return e.attr("name") || e.attr("id") && !e.firstChild || e.attr("data-mce-bookmark") || n;
      };
      class Ki {
        static create(n, o) {
          const r = new Ki(n, EL[n] || 1);
          return o && Dt(o, (c, u) => {
            r.attr(u, c);
          }), r;
        }
        constructor(n, o) {
          this.name = n, this.type = o, o === 1 && (this.attributes = [], this.attributes.map = {});
        }
        replace(n) {
          const o = this;
          return n.parent && n.remove(), o.insert(n, o), o.remove(), o;
        }
        attr(n, o) {
          const r = this;
          if (!J(n))
            return De(n) && Dt(n, (u, f) => {
              r.attr(f, u);
            }), r;
          const c = r.attributes;
          if (c) {
            if (o !== void 0) {
              if (o === null) {
                if (n in c.map) {
                  delete c.map[n];
                  let u = c.length;
                  for (; u--; )
                    if (c[u].name === n)
                      return c.splice(u, 1), r;
                }
                return r;
              }
              if (n in c.map) {
                let u = c.length;
                for (; u--; )
                  if (c[u].name === n) {
                    c[u].value = o;
                    break;
                  }
              } else
                c.push({
                  name: n,
                  value: o
                });
              return c.map[n] = o, r;
            }
            return c.map[n];
          }
        }
        clone() {
          const n = this, o = new Ki(n.name, n.type), r = n.attributes;
          if (r) {
            const c = [];
            c.map = {};
            for (let u = 0, f = r.length; u < f; u++) {
              const b = r[u];
              b.name !== "id" && (c[c.length] = {
                name: b.name,
                value: b.value
              }, c.map[b.name] = b.value);
            }
            o.attributes = c;
          }
          return o.value = n.value, o;
        }
        wrap(n) {
          const o = this;
          return o.parent && (o.parent.insert(n, o), n.append(o)), o;
        }
        unwrap() {
          const n = this;
          for (let o = n.firstChild; o; ) {
            const r = o.next;
            n.insert(o, n, !0), o = r;
          }
          n.remove();
        }
        remove() {
          const n = this, o = n.parent, r = n.next, c = n.prev;
          return o && (o.firstChild === n ? (o.firstChild = r, r && (r.prev = null)) : c && (c.next = r), o.lastChild === n ? (o.lastChild = c, c && (c.next = null)) : r && (r.prev = c), n.parent = n.next = n.prev = null), n;
        }
        append(n) {
          const o = this;
          n.parent && n.remove();
          const r = o.lastChild;
          return r ? (r.next = n, n.prev = r, o.lastChild = n) : o.lastChild = o.firstChild = n, n.parent = o, n;
        }
        insert(n, o, r) {
          n.parent && n.remove();
          const c = o.parent || this;
          return r ? (o === c.firstChild ? c.firstChild = n : o.prev && (o.prev.next = n), n.prev = o.prev, n.next = o, o.prev = n) : (o === c.lastChild ? c.lastChild = n : o.next && (o.next.prev = n), n.next = o.next, n.prev = o, o.next = n), n.parent = c, n;
        }
        getAll(n) {
          const o = this, r = [];
          for (let c = o.firstChild; c; c = vx(c, o))
            c.name === n && r.push(c);
          return r;
        }
        children() {
          const n = this, o = [];
          for (let r = n.firstChild; r; r = r.next)
            o.push(r);
          return o;
        }
        empty() {
          const n = this;
          if (n.firstChild) {
            const o = [];
            for (let c = n.firstChild; c; c = vx(c, n))
              o.push(c);
            let r = o.length;
            for (; r--; ) {
              const c = o[r];
              c.parent = c.firstChild = c.lastChild = c.next = c.prev = null;
            }
          }
          return n.firstChild = n.lastChild = null, n;
        }
        isEmpty(n, o = {}, r) {
          var c;
          const u = this;
          let f = u.firstChild;
          if (no(u))
            return !1;
          if (f)
            do {
              if (f.type === 1) {
                if (f.attr("data-mce-bogus"))
                  continue;
                if (n[f.name] || no(f))
                  return !1;
              }
              if (f.type === 8 || f.type === 3 && !kL(f) || f.type === 3 && f.parent && o[f.parent.name] && ff((c = f.value) !== null && c !== void 0 ? c : "") || r && r(f))
                return !1;
            } while (f = vx(f, u));
          return !0;
        }
        walk(n) {
          return vx(this, null, n);
        }
      }
      const TR = _t.makeMap("NOSCRIPT STYLE SCRIPT XMP IFRAME NOEMBED NOFRAMES PLAINTEXT", " "), ER = (e) => J(e.nodeValue) && e.nodeValue.includes(k), yx = (e) => `${e.length === 0 ? "" : `${ye(e, (n) => `[${n}]`).join(",")},`}[data-mce-bogus="all"]`, _L = (e, n) => n.querySelectorAll(yx(e)), kR = (e) => document.createTreeWalker(e, NodeFilter.SHOW_COMMENT, (n) => ER(n) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP), _R = (e) => document.createTreeWalker(e, NodeFilter.SHOW_TEXT, (n) => {
        if (ER(n)) {
          const o = n.parentNode;
          return o && Zn(TR, o.nodeName) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
        } else
          return NodeFilter.FILTER_SKIP;
      }), AL = (e) => kR(e).nextNode() !== null, OL = (e) => _R(e).nextNode() !== null, Cx = (e, n) => n.querySelector(yx(e)) !== null, AR = (e, n) => {
        ae(_L(e, n), (o) => {
          const r = le.fromDom(o);
          ia(r, "data-mce-bogus") === "all" ? bs(r) : ae(e, (c) => {
            ea(r, c) && _r(r, c);
          });
        });
      }, DL = (e) => {
        let n = e.nextNode();
        for (; n !== null; )
          n.nodeValue = null, n = e.nextNode();
      }, RL = A(DL, kR), Oo = A(DL, _R), OR = (e, n) => {
        const o = [
          {
            condition: Ye(Cx, n),
            action: Ye(AR, n)
          },
          {
            condition: AL,
            action: RL
          },
          {
            condition: OL,
            action: Oo
          }
        ];
        let r = e, c = !1;
        return ae(o, ({ condition: u, action: f }) => {
          u(r) && (c || (r = e.cloneNode(!0), c = !0), f(r));
        }), r;
      }, Bo = (e) => {
        const n = uc(e, "[data-mce-bogus]");
        ae(n, (o) => {
          ia(o, "data-mce-bogus") === "all" ? bs(o) : Pd(o) ? (ka(o, le.fromText(fg)), bs(o)) : qc(o);
        });
      }, gA = (e) => {
        const n = uc(e, "input");
        ae(n, (o) => {
          _r(o, "name");
        });
      }, xj = (e, n) => {
        const o = gi(e), r = new RegExp(`^(<${o}[^>]*>(&nbsp;|&#160;|\\s| |<br \\/>|)<\\/${o}>[\r
]*|<br \\/>[\r
]*)$`);
        return n.replace(r, "");
      }, Tj = (e, n) => {
        const o = e.getDoc(), r = kl(le.fromDom(e.getBody())), c = le.fromTag("div", o);
        ks(c, "data-mce-bogus", "all"), Ya(c, {
          position: "fixed",
          left: "-9999999px",
          top: "0"
        }), sd(c, n.innerHTML), Bo(c), gA(c);
        const u = Yb(r);
        la(u, c);
        const f = q(c.dom.innerText);
        return bs(c), f;
      }, NL = (e, n, o) => {
        let r;
        return n.format === "raw" ? r = _t.trim(q(OR(o, e.serializer.getTempAttrs()).innerHTML)) : n.format === "text" ? r = Tj(e, o) : n.format === "tree" ? r = e.serializer.serialize(o, n) : r = xj(e, e.serializer.serialize(o, n)), n.format !== "text" && !Pa(le.fromDom(o)) && J(r) ? _t.trim(r) : r;
      }, Ej = (e, n) => F.from(e.getBody()).fold(it(n.format === "tree" ? new Ki("body", 11) : ""), (o) => NL(e, n, o)), ML = _t.makeMap, DR = (e) => {
        const n = [];
        e = e || {};
        const o = e.indent, r = ML(e.indent_before || ""), c = ML(e.indent_after || ""), u = wg.getEncodeFunc(e.entity_encoding || "raw", e.entities), f = e.element_format !== "xhtml";
        return {
          start: (b, y, E) => {
            if (o && r[b] && n.length > 0) {
              const N = n[n.length - 1];
              N.length > 0 && N !== `
` && n.push(`
`);
            }
            if (n.push("<", b), y)
              for (let N = 0, M = y.length; N < M; N++) {
                const I = y[N];
                n.push(" ", I.name, '="', u(I.value, !0), '"');
              }
            if (!E || f ? n[n.length] = ">" : n[n.length] = " />", E && o && c[b] && n.length > 0) {
              const N = n[n.length - 1];
              N.length > 0 && N !== `
` && n.push(`
`);
            }
          },
          end: (b) => {
            let y;
            n.push("</", b, ">"), o && c[b] && n.length > 0 && (y = n[n.length - 1], y.length > 0 && y !== `
` && n.push(`
`));
          },
          text: (b, y) => {
            b.length > 0 && (n[n.length] = y ? b : u(b));
          },
          cdata: (b) => {
            n.push("<![CDATA[", b, "]]>");
          },
          comment: (b) => {
            n.push("<!--", b, "-->");
          },
          pi: (b, y) => {
            y ? n.push("<?", b, " ", u(y), "?>") : n.push("<?", b, "?>"), o && n.push(`
`);
          },
          doctype: (b) => {
            n.push("<!DOCTYPE", b, ">", o ? `
` : "");
          },
          reset: () => {
            n.length = 0;
          },
          getContent: () => n.join("").replace(/\n$/, "")
        };
      }, yp = (e = {}, n = Tm()) => {
        const o = DR(e);
        return e.validate = "validate" in e ? e.validate : !0, { serialize: (c) => {
          const u = e.validate, f = {
            3: (y) => {
              var E;
              o.text((E = y.value) !== null && E !== void 0 ? E : "", y.raw);
            },
            8: (y) => {
              var E;
              o.comment((E = y.value) !== null && E !== void 0 ? E : "");
            },
            7: (y) => {
              o.pi(y.name, y.value);
            },
            10: (y) => {
              var E;
              o.doctype((E = y.value) !== null && E !== void 0 ? E : "");
            },
            4: (y) => {
              var E;
              o.cdata((E = y.value) !== null && E !== void 0 ? E : "");
            },
            11: (y) => {
              let E = y;
              if (E = E.firstChild)
                do
                  b(E);
                while (E = E.next);
            }
          };
          o.reset();
          const b = (y) => {
            var E;
            const N = f[y.type];
            if (N)
              N(y);
            else {
              const M = y.name, I = M in n.getVoidElements();
              let X = y.attributes;
              if (u && X && X.length > 1) {
                const te = [];
                te.map = {};
                const G = n.getElementRule(y.name);
                if (G) {
                  for (let ne = 0, Se = G.attributesOrder.length; ne < Se; ne++) {
                    const ke = G.attributesOrder[ne];
                    if (ke in X.map) {
                      const Ae = X.map[ke];
                      te.map[ke] = Ae, te.push({
                        name: ke,
                        value: Ae
                      });
                    }
                  }
                  for (let ne = 0, Se = X.length; ne < Se; ne++) {
                    const ke = X[ne].name;
                    if (!(ke in te.map)) {
                      const Ae = X.map[ke];
                      te.map[ke] = Ae, te.push({
                        name: ke,
                        value: Ae
                      });
                    }
                  }
                  X = te;
                }
              }
              if (o.start(M, X, I), ad(M))
                J(y.value) && o.text(y.value, !0), o.end(M);
              else if (!I) {
                let te = y.firstChild;
                if (te) {
                  (M === "pre" || M === "textarea") && te.type === 3 && ((E = te.value) === null || E === void 0 ? void 0 : E[0]) === `
` && o.text(`
`, !0);
                  do
                    b(te);
                  while (te = te.next);
                }
                o.end(M);
              }
            }
          };
          return c.type === 1 && !e.inner ? b(c) : c.type === 3 ? f[3](c) : f[11](c), o.getContent();
        } };
      }, po = /* @__PURE__ */ new Set();
      ae([
        "margin",
        "margin-left",
        "margin-right",
        "margin-top",
        "margin-bottom",
        "padding",
        "padding-left",
        "padding-right",
        "padding-top",
        "padding-bottom",
        "border",
        "border-width",
        "border-style",
        "border-color",
        "background",
        "background-attachment",
        "background-clip",
        "background-color",
        "background-image",
        "background-origin",
        "background-position",
        "background-repeat",
        "background-size",
        "float",
        "position",
        "left",
        "right",
        "top",
        "bottom",
        "z-index",
        "display",
        "transform",
        "width",
        "max-width",
        "min-width",
        "height",
        "max-height",
        "min-height",
        "overflow",
        "overflow-x",
        "overflow-y",
        "text-overflow",
        "vertical-align",
        "transition",
        "transition-delay",
        "transition-duration",
        "transition-property",
        "transition-timing-function"
      ], (n) => {
        po.add(n);
      });
      const RR = [
        "font",
        "text-decoration",
        "text-emphasis"
      ], hA = (e, n) => Ss(e.parseStyle(e.getAttrib(n, "style"))), PL = (e) => po.has(e), s2 = (e, n) => No(hA(e, n), (o) => !PL(o)), NR = (e) => Yt(e, (n) => pe(RR, (o) => Kn(n, o))), BL = (e, n, o) => {
        const r = hA(e, n), c = hA(e, o), u = (f) => {
          var b, y;
          const E = (b = e.getStyle(n, f)) !== null && b !== void 0 ? b : "", N = (y = e.getStyle(o, f)) !== null && y !== void 0 ? y : "";
          return lo(E) && lo(N) && E !== N;
        };
        return pe(r, (f) => {
          const b = (y) => pe(y, (E) => E === f);
          if (!b(c) && b(RR)) {
            const y = NR(c);
            return pe(y, u);
          } else
            return u(f);
        });
      }, MR = (e, n, o) => F.from(o.container()).filter(Mt).exists((r) => {
        const c = e ? 0 : -1;
        return n(r.data.charAt(o.offset() + c));
      }), pA = Ye(MR, !0, cp), wx = Ye(MR, !1, cp), $L = (e) => {
        const n = e.container();
        return Mt(n) && (n.data.length === 0 || H(n.data) && Fg.isBookmarkNode(n.parentNode));
      }, hb = (e, n) => (o) => U1(e ? 0 : -1, o).filter(n).isSome(), FL = (e) => Gc(e) && ha(le.fromDom(e), "display") === "block", PR = (e) => es(e) && !gh(e), IL = hb(!0, FL), LL = hb(!1, FL), r2 = hb(!0, oa), fv = hb(!1, oa), BR = hb(!0, Du), Vo = hb(!1, Du), Vg = hb(!0, PR), zm = hb(!1, PR), $R = (e) => e.slice(0, -1), FR = (e, n, o) => ic(n, e) ? $R(ch(e, (r) => o(r) || fs(r, n))) : [], bA = (e, n) => FR(e, n, $e), Lf = (e, n) => [e].concat(bA(e, n)), Sx = (e, n, o) => Lu(e, n, o, $L), HL = (e) => (n) => e.isBlock(Qo(n)), vA = (e, n, o) => hn(Lf(le.fromDom(n.container()), e), HL(o)), IR = (e, n, o, r) => Sx(e, n.dom, o).forall((c) => vA(n, o, r).fold(() => !md(c, o, n.dom), (u) => !md(c, o, n.dom) && ic(u, le.fromDom(c.container())))), LR = (e, n, o, r) => vA(n, o, r).fold(() => Sx(e, n.dom, o).forall((c) => !md(c, o, n.dom)), (c) => Sx(e, c.dom, o).isNone()), yA = Ye(LR, !1), HR = Ye(LR, !0), zL = Ye(IR, !1), VL = Ye(IR, !0), UL = (e) => z0(e).exists(Pd), xx = (e, n, o, r) => {
        const c = Yt(Lf(le.fromDom(o.container()), n), (f) => r.isBlock(Qo(f))), u = qt(c).getOr(n);
        return Tc(e, u.dom, o).filter(UL);
      }, a2 = (e, n, o) => z0(n).exists(Pd) || xx(!0, e, n, o).isSome(), c2 = (e, n, o) => k_(n).exists(Pd) || xx(!1, e, n, o).isSome(), WL = Ye(xx, !1), ZL = Ye(xx, !0), zR = (e) => We.isTextPosition(e) && !e.isAtStart() && !e.isAtEnd(), VR = (e, n, o) => {
        const r = Yt(Lf(le.fromDom(n.container()), e), (c) => o.isBlock(Qo(c)));
        return qt(r).getOr(e);
      }, UR = (e, n, o) => zR(n) ? wx(n) : wx(n) || ji(VR(e, n, o).dom, n).exists(wx), WR = (e, n, o) => zR(n) ? pA(n) : pA(n) || pi(VR(e, n, o).dom, n).exists(pA), jL = (e) => ee([
        "pre",
        "pre-wrap"
      ], e), CA = (e) => z0(e).bind((n) => ci(n, yn)).exists((n) => jL(ha(n, "white-space"))), ZR = (e, n) => ji(e.dom, n).isNone(), qL = (e, n) => pi(e.dom, n).isNone(), GL = (e, n, o) => ZR(e, n) || qL(e, n) || yA(e, n, o) || HR(e, n, o) || c2(e, n, o) || a2(e, n, o), pb = (e) => De(e) && es(e) && Af(e), jR = (e, n) => (o) => pb(new br(o, e)[n]()), qR = (e, n) => {
        const o = pi(e.dom, n).getOr(n), r = jR(e.dom, "next");
        return n.isAtEnd() && (r(n.container()) || r(o.container()));
      }, KL = (e, n) => {
        const o = ji(e.dom, n).getOr(n), r = jR(e.dom, "prev");
        return n.isAtStart() && (r(n.container()) || r(o.container()));
      }, GR = (e, n, o) => CA(n) ? !1 : GL(e, n, o) || UR(e, n, o) || WR(e, n, o), gv = (e, n, o) => CA(n) ? !1 : yA(e, n, o) || zL(e, n, o) || c2(e, n, o) || UR(e, n, o) || KL(e, n), KR = (e) => {
        const n = e.container(), o = e.offset();
        return Mt(n) && o < n.data.length ? We(n, o + 1) : e;
      }, hv = (e, n, o) => CA(n) ? !1 : HR(e, n, o) || VL(e, n, o) || a2(e, n, o) || WR(e, n, o) || qR(e, n), Tx = (e, n, o) => gv(e, n, o) || hv(e, KR(n), o), Yi = (e, n) => q0(e.charAt(n)), YR = (e, n) => cp(e.charAt(n)), YL = (e) => {
        const n = e.container();
        return Mt(n) && Mn(n.data, _s);
      }, XL = (e) => {
        const n = e.split("");
        return ye(n, (o, r) => q0(o) && r > 0 && r < n.length - 1 && Pf(n[r - 1]) && Pf(n[r + 1]) ? " " : o).join("");
      }, XR = (e, n, o, r) => {
        const c = n.data, u = We(n, 0);
        return !o && Yi(c, 0) && !Tx(e, u, r) ? (n.data = " " + c.slice(1), !0) : o && YR(c, 0) && gv(e, u, r) ? (n.data = _s + c.slice(1), !0) : !1;
      }, JL = (e) => {
        const n = e.data, o = XL(n);
        return o !== n ? (e.data = o, !0) : !1;
      }, Cp = (e, n, o, r) => {
        const c = n.data, u = We(n, c.length - 1);
        return !o && Yi(c, c.length - 1) && !Tx(e, u, r) ? (n.data = c.slice(0, -1) + " ", !0) : o && YR(c, c.length - 1) && hv(e, u, r) ? (n.data = c.slice(0, -1) + _s, !0) : !1;
      }, QL = (e, n, o) => {
        const r = n.container();
        if (!Mt(r))
          return F.none();
        if (YL(n)) {
          const c = XR(e, r, !1, o) || JL(r) || Cp(e, r, !1, o);
          return Jo(c, n);
        } else if (Tx(e, n, o)) {
          const c = XR(e, r, !0, o) || Cp(e, r, !0, o);
          return Jo(c, n);
        } else
          return F.none();
      }, e6 = (e) => {
        const n = le.fromDom(e.getBody());
        e.selection.isCollapsed() && QL(n, We.fromRangeStart(e.selection.getRng()), e.schema).each((o) => {
          e.selection.setRng(o.toRange());
        });
      }, qr = (e, n, o, r) => {
        if (o === 0)
          return;
        const c = le.fromDom(e), u = Ar(c, (E) => r.isBlock(Qo(E))).getOr(c), f = e.data.slice(n, n + o), b = n + o >= e.data.length && hv(u, We(e, e.data.length), r), y = n === 0 && gv(u, We(e, 0), r);
        e.replaceData(n, o, pg(f, 4, y, b));
      }, bb = (e, n, o) => {
        const r = e.data.slice(n), c = r.length - ac(r).length;
        qr(e, n, c, o);
      }, JR = (e, n, o) => {
        const r = e.data.slice(0, n), c = r.length - vc(r).length;
        qr(e, n - c, c, o);
      }, Ec = (e, n, o, r, c = !0) => {
        const u = vc(e.data).length, f = c ? e : n, b = c ? n : e;
        return c ? f.appendData(b.data) : f.insertData(0, b.data), bs(le.fromDom(b)), r && bb(f, u, o), f;
      }, t6 = (e, n) => {
        const o = e.container(), r = e.offset();
        return !We.isTextPosition(e) && o === n.parentNode && r > We.before(n).offset();
      }, n6 = (e, n) => t6(n, e) ? We(n.container(), n.offset() - 1) : n, Ug = (e) => Mt(e) ? We(e, 0) : We.before(e), js = (e) => Mt(e) ? We(e, e.data.length) : We.after(e), wA = (e) => Zs(e.previousSibling) ? F.some(js(e.previousSibling)) : e.previousSibling ? Hu(e.previousSibling) : F.none(), SA = (e) => Zs(e.nextSibling) ? F.some(Ug(e.nextSibling)) : e.nextSibling ? Ri(e.nextSibling) : F.none(), o6 = (e, n) => F.from(n.previousSibling ? n.previousSibling : n.parentNode).bind((o) => ji(e, We.before(o))).orThunk(() => pi(e, We.after(n))), s6 = (e, n) => pi(e, We.after(n)).orThunk(() => ji(e, We.before(n))), r6 = (e, n) => wA(n).orThunk(() => SA(n)).orThunk(() => o6(e, n)), du = (e, n) => SA(n).orThunk(() => wA(n)).orThunk(() => s6(e, n)), Yd = (e, n, o) => e ? du(n, o) : r6(n, o), QR = (e, n, o) => Yd(e, n, o).map(Ye(n6, o)), Ex = (e, n, o) => {
        o.fold(() => {
          e.focus();
        }, (r) => {
          e.selection.setRng(r.toRange(), n);
        });
      }, xA = (e) => (n) => n.dom === e, kx = (e, n) => n && Zn(e.schema.getBlockElements(), Qo(n)), eN = (e, n) => {
        if (sa(e)) {
          const o = le.fromHtml('<br data-mce-bogus="1">');
          return n ? ae(Ea(e), (r) => {
            nb(r) || bs(r);
          }) : Ei(e), la(e, o), F.some(We.before(o.dom));
        } else
          return F.none();
      }, i2 = (e, n, o, r) => {
        const c = Li(e).filter(vo), u = El(e).filter(vo);
        return bs(e), ri(c, u, n, (f, b, y) => {
          const E = f.dom, N = b.dom, M = E.data.length;
          return Ec(E, N, o, r), y.container() === N ? We(E, M) : y;
        }).orThunk(() => (r && (c.each((f) => JR(f.dom, f.dom.length, o)), u.each((f) => bb(f.dom, 0, o))), n));
      }, _x = (e, n) => Zn(e.schema.getTextInlineElements(), Qo(n)), Wg = (e, n, o, r = !0, c = !1) => {
        const u = QR(n, e.getBody(), o.dom), f = Ar(o, Ye(kx, e), xA(e.getBody())), b = i2(o, u, e.schema, _x(e, o));
        e.dom.isEmpty(e.getBody()) ? (e.setContent(""), e.selection.setCursorLocation()) : f.bind((y) => eN(y, c)).fold(() => {
          r && Ex(e, n, b);
        }, (y) => {
          r && Ex(e, n, F.some(y));
        });
      }, tN = /[\u0591-\u07FF\uFB1D-\uFDFF\uFE70-\uFEFC]/, l2 = (e) => tN.test(e), vb = (e, n) => Si(le.fromDom(n), e_(e)) && !cs(e.schema, n) && e.dom.isEditable(n), nN = (e) => {
        var n;
        return xr.DOM.getStyle(e, "direction", !0) === "rtl" || l2((n = e.textContent) !== null && n !== void 0 ? n : "");
      }, Vm = (e, n, o) => Yt(xr.DOM.getParents(o.container(), "*", n), e), Vc = (e, n, o) => {
        const r = Vm(e, n, o);
        return F.from(r[r.length - 1]);
      }, u2 = (e, n, o) => {
        const r = Dm(n, e), c = Dm(o, e);
        return De(r) && r === c;
      }, bd = (e) => Ws(e) || Yc(e), vd = (e, n) => {
        const o = n.container(), r = n.offset();
        return e ? oo(o) ? Mt(o.nextSibling) ? We(o.nextSibling, 0) : We.after(o) : Ws(n) ? We(o, r + 1) : n : oo(o) ? Mt(o.previousSibling) ? We(o.previousSibling, o.previousSibling.data.length) : We.before(o) : Yc(n) ? We(o, r - 1) : n;
      }, yr = Ye(vd, !0), oN = Ye(vd, !1), wp = (e, n) => {
        const o = (r) => r.stopImmediatePropagation();
        e.on("beforeinput input", o, !0), e.getDoc().execCommand(n), e.off("beforeinput input", o);
      }, d2 = (e) => {
        e.execCommand("delete");
      }, Ax = (e) => wp(e, "Delete"), TA = (e) => wp(e, "ForwardDelete"), EA = (e) => (n) => Us(lc(n), e, fs), a6 = (e) => Ne(e) || al(e), pv = (e, n) => ic(e, n) ? ci(n, a6, EA(e)) : F.none(), kA = (e, n = !0) => {
        e.dom.isEmpty(e.getBody()) && e.setContent("", { no_selection: !n });
      }, _A = (e, n, o) => Zr(Ri(o), Hu(o), (r, c) => {
        const u = vd(!0, r), f = vd(!1, c), b = vd(!1, n);
        return e ? pi(o, b).exists((y) => y.isEqual(f) && n.isEqual(u)) : ji(o, b).exists((y) => y.isEqual(u) && n.isEqual(f));
      }).getOr(!0), AA = (e) => (Le(e) ? Li(e) : rl(e)).bind(AA).orThunk(() => F.some(e)), Ox = (e, n, o, r = !0) => {
        var c;
        n.deleteContents();
        const u = AA(o).getOr(o), f = le.fromDom((c = e.dom.getParent(u.dom, e.dom.isBlock)) !== null && c !== void 0 ? c : o.dom);
        if (f.dom === e.getBody() ? kA(e, r) : sa(f) && (Nu(f), r && e.selection.setCursorLocation(f.dom, 0)), !fs(o, f)) {
          const b = Us(lc(f), o) ? [] : r1(f);
          ae(b.concat(Ea(o)), (y) => {
            !fs(y, f) && !ic(y, f) && sa(y) && bs(y);
          });
        }
      }, sN = (e, n, o) => Ar(e, n, o).isSome(), Dx = (e, n) => sf(e, n).isSome(), rN = (e, n) => La(e, n).isSome(), c6 = (e) => (n) => fs(e, n), OA = (e) => uc(e, "td,th"), aN = (e, n) => Mm(le.fromDom(e), n), i6 = (e) => Zr(e.startTable, e.endTable, (n, o) => {
        const r = rN(n, (u) => fs(u, o)), c = rN(o, (u) => fs(u, n));
        return !r && !c ? e : {
          ...e,
          startTable: r ? F.none() : e.startTable,
          endTable: c ? F.none() : e.endTable,
          isSameTable: !1,
          isMultiTable: !1
        };
      }).getOr(e), cN = (e) => i6(e), l6 = (e, n) => {
        const o = aN(e.startContainer, n), r = aN(e.endContainer, n), c = o.isSome(), u = r.isSome(), f = Zr(o, r, fs).getOr(!1);
        return cN({
          startTable: o,
          endTable: r,
          isStartInTable: c,
          isEndInTable: u,
          isSameTable: f,
          isMultiTable: !f && c && u
        });
      }, DA = (e, n) => ({
        start: e,
        end: n
      }), iN = (e, n, o) => ({
        rng: e,
        table: n,
        cells: o
      }), m2 = dd.generate([
        {
          singleCellTable: [
            "rng",
            "cell"
          ]
        },
        { fullTable: ["table"] },
        {
          partialTable: [
            "cells",
            "outsideDetails"
          ]
        },
        {
          multiTable: [
            "startTableCells",
            "endTableCells",
            "betweenRng"
          ]
        }
      ]), f2 = (e, n) => Hi(le.fromDom(e), "td,th", n), bv = (e) => !fs(e.start, e.end), lN = (e, n) => Mm(e.start, n).bind((o) => Mm(e.end, n).bind((r) => Jo(fs(o, r), o))), u6 = (e, n) => !bv(e) && lN(e, n).exists((o) => {
        const r = o.dom.rows;
        return r.length === 1 && r[0].cells.length === 1;
      }), uN = (e, n) => {
        const o = f2(e.startContainer, n), r = f2(e.endContainer, n);
        return Zr(o, r, DA);
      }, d6 = (e) => (n) => Mm(n, e).bind((o) => ko(OA(o)).map((r) => DA(n, r))), dN = (e) => (n) => Mm(n, e).bind((o) => qt(OA(o)).map((r) => DA(r, n))), Vl = (e) => (n) => lN(n, e).map((o) => iN(n, o, OA(o))), mN = (e, n, o, r) => {
        if (o.collapsed || !e.forall(bv))
          return F.none();
        if (n.isSameTable) {
          const c = e.bind(Vl(r));
          return F.some({
            start: c,
            end: c
          });
        } else {
          const c = f2(o.startContainer, r), u = f2(o.endContainer, r), f = c.bind(d6(r)).bind(Vl(r)), b = u.bind(dN(r)).bind(Vl(r));
          return F.some({
            start: f,
            end: b
          });
        }
      }, RA = (e, n) => Xn(e, (o) => fs(o, n)), g2 = (e) => Zr(RA(e.cells, e.rng.start), RA(e.cells, e.rng.end), (n, o) => e.cells.slice(n, o + 1)), NA = (e, n, o) => e.exists((r) => u6(r, o) && $C(r.start, n)), MA = (e, n) => {
        const { startTable: o, endTable: r } = n, c = e.cloneRange();
        return o.each((u) => c.setStartAfter(u.dom)), r.each((u) => c.setEndBefore(u.dom)), c;
      }, fN = (e, n, o, r) => mN(e, n, o, r).bind(({ start: c, end: u }) => c.or(u)).bind((c) => {
        const { isSameTable: u } = n, f = g2(c).getOr([]);
        if (u && c.cells.length === f.length)
          return F.some(m2.fullTable(c.table));
        if (f.length > 0) {
          if (u)
            return F.some(m2.partialTable(f, F.none()));
          {
            const b = MA(o, n);
            return F.some(m2.partialTable(f, F.some({
              ...n,
              rng: b
            })));
          }
        } else
          return F.none();
      }), m6 = (e, n, o, r) => mN(e, n, o, r).bind(({ start: c, end: u }) => {
        const f = c.bind(g2).getOr([]), b = u.bind(g2).getOr([]);
        if (f.length > 0 && b.length > 0) {
          const y = MA(o, n);
          return F.some(m2.multiTable(f, b, y));
        } else
          return F.none();
      }), f6 = (e, n) => {
        const o = c6(e), r = uN(n, o), c = l6(n, o);
        return NA(r, n, o) ? r.map((u) => m2.singleCellTable(n, u.start)) : c.isMultiTable ? m6(r, c, n, o) : fN(r, c, n, o);
      }, Rx = (e) => ae(e, (n) => {
        _r(n, "contenteditable"), Nu(n);
      }), gN = (e, n) => F.from(e.dom.getParent(n, e.dom.isBlock)).map(le.fromDom), Xd = (e, n, o) => {
        o.each((r) => {
          n ? bs(r) : (Nu(r), e.selection.setCursorLocation(r.dom, 0));
        });
      }, PA = (e, n, o, r) => {
        const c = o.cloneRange();
        r ? (c.setStart(o.startContainer, o.startOffset), c.setEndAfter(n.dom.lastChild)) : (c.setStartBefore(n.dom.firstChild), c.setEnd(o.endContainer, o.endOffset)), $A(e, c, n, !1).each((u) => u());
      }, hN = (e) => {
        const n = ip(e), o = le.fromDom(e.selection.getNode());
        mg(o.dom) && sa(o) ? e.selection.setCursorLocation(o.dom, 0) : e.selection.collapse(!0), n.length > 1 && pe(n, (r) => fs(r, o)) && ks(o, "data-mce-selected", "1");
      }, g6 = (e, n, o) => F.some(() => {
        const r = e.selection.getRng(), c = o.bind(({ rng: u, isStartInTable: f }) => {
          const b = gN(e, f ? u.endContainer : u.startContainer);
          u.deleteContents(), Xd(e, f, b.filter(sa));
          const y = f ? n[0] : n[n.length - 1];
          return PA(e, y, r, f), sa(y) ? F.none() : F.some(f ? n.slice(1) : n.slice(0, -1));
        }).getOr(n);
        Rx(c), hN(e);
      }), BA = (e, n, o, r) => F.some(() => {
        const c = e.selection.getRng(), u = n[0], f = o[o.length - 1];
        PA(e, u, c, !0), PA(e, f, c, !1);
        const b = sa(u) ? n : n.slice(1), y = sa(f) ? o : o.slice(0, -1);
        Rx(b.concat(y)), r.deleteContents(), hN(e);
      }), $A = (e, n, o, r = !0) => F.some(() => {
        Ox(e, n, o, r);
      }), vv = (e, n) => F.some(() => Wg(e, !1, n)), h6 = (e, n, o) => f6(n, o).bind((r) => r.fold(Ye($A, e), Ye(vv, e), Ye(g6, e), Ye(BA, e))), yv = (e, n) => p2(e, n), yd = (e, n, o, r) => yb(n, r).fold(() => h6(e, n, o), (c) => yv(e, c)), h2 = (e, n, o) => {
        const r = le.fromDom(e.getBody()), c = e.selection.getRng();
        return o.length !== 0 ? g6(e, o, F.none()) : yd(e, r, c, n);
      }, lr = (e, n) => hn(Lf(n, e), Ai), yb = (e, n) => hn(Lf(n, e), pr("caption")), pN = (e, n, o, r, c) => Nm(o, e.getBody(), c).bind((u) => lr(n, le.fromDom(u.getNode())).bind((f) => fs(f, r) ? F.none() : F.some(Oe))), p2 = (e, n) => F.some(() => {
        Nu(n), e.selection.setCursorLocation(n.dom, 0);
      }), FA = (e, n, o, r) => Ri(e.dom).bind((c) => Hu(e.dom).map((u) => n ? o.isEqual(c) && r.isEqual(u) : o.isEqual(u) && r.isEqual(c))).getOr(!0), IA = (e, n) => p2(e, n), LA = (e, n, o) => yb(e, le.fromDom(o.getNode())).fold(() => F.some(Oe), (r) => Jo(!fs(r, n), Oe)), HA = (e, n, o, r, c) => Nm(o, e.getBody(), c).fold(() => F.some(Oe), (u) => FA(r, o, c, u) ? IA(e, r) : LA(n, r, u)), Nx = (e, n, o, r) => {
        const c = We.fromRangeStart(e.selection.getRng());
        return lr(o, r).bind((u) => sa(u) ? p2(e, u) : pN(e, o, n, u, c));
      }, zA = (e, n, o, r) => {
        const c = We.fromRangeStart(e.selection.getRng());
        return sa(r) ? p2(e, r) : HA(e, o, n, r, c);
      }, VA = (e, n) => e ? BR(n) : Vo(n), bN = (e, n) => {
        const o = We.fromRangeStart(e.selection.getRng());
        return VA(n, o) || Tc(n, e.getBody(), o).exists((r) => VA(n, r));
      }, vN = (e, n, o) => {
        const r = le.fromDom(e.getBody());
        return yb(r, o).fold(() => Nx(e, n, r, o).orThunk(() => Jo(bN(e, n), Oe)), (c) => zA(e, n, r, c));
      }, Mx = (e, n) => {
        const o = le.fromDom(e.selection.getStart(!0)), r = ip(e);
        return e.selection.isCollapsed() && r.length === 0 ? vN(e, n, o) : h2(e, o, r);
      }, Sp = (e, n) => {
        let o = n;
        for (; o && o !== e; ) {
          if (Kc(o) || es(o))
            return o;
          o = o.parentNode;
        }
        return null;
      }, Cv = [
        "data-ephox-",
        "data-mce-",
        "data-alloy-",
        "data-snooker-",
        "_"
      ], yN = _t.each, b2 = (e) => {
        const n = e.dom, o = new Set(e.serializer.getTempAttrs()), r = (u, f) => {
          if (u.nodeName !== f.nodeName || u.nodeType !== f.nodeType)
            return !1;
          const b = (E) => {
            const N = {};
            return yN(n.getAttribs(E), (M) => {
              const I = M.nodeName.toLowerCase();
              I !== "style" && !c(I) && (N[I] = n.getAttrib(E, I));
            }), N;
          }, y = (E, N) => {
            for (const M in E)
              if (Zn(E, M)) {
                const I = N[M];
                if (Ht(I) || E[M] !== I)
                  return !1;
                delete N[M];
              }
            for (const M in N)
              if (Zn(N, M))
                return !1;
            return !0;
          };
          return xn(u) && xn(f) && (!y(b(u), b(f)) || !y(n.parseStyle(n.getAttrib(u, "style")), n.parseStyle(n.getAttrib(f, "style")))) ? !1 : !Il(u) && !Il(f);
        }, c = (u) => pe(Cv, (f) => Kn(u, f)) || o.has(u);
        return {
          compare: r,
          isAttributeInternal: c
        };
      }, CN = (e) => [
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6"
      ].includes(e.name), p6 = (e) => e.name === "summary", wN = (e, n) => {
        let o = e;
        for (; o = o.walk(); )
          n(o);
      }, UA = (e, n, o, r) => {
        const c = o.name;
        for (let u = 0, f = e.length; u < f; u++) {
          const b = e[u];
          if (b.name === c) {
            const y = r.nodes[c];
            y ? y.nodes.push(o) : r.nodes[c] = {
              filter: b,
              nodes: [o]
            };
          }
        }
        if (o.attributes)
          for (let u = 0, f = n.length; u < f; u++) {
            const b = n[u], y = b.name;
            if (y in o.attributes.map) {
              const E = r.attributes[y];
              E ? E.nodes.push(o) : r.attributes[y] = {
                filter: b,
                nodes: [o]
              };
            }
          }
      }, SN = (e, n, o) => {
        const r = {
          nodes: {},
          attributes: {}
        };
        return o.firstChild && wN(o, (c) => {
          UA(e, n, c, r);
        }), r;
      }, v2 = (e, n) => {
        const o = (r, c) => {
          Dt(r, (u) => {
            const f = rs(u.nodes);
            ae(u.filter.callbacks, (b) => {
              for (let y = f.length - 1; y >= 0; y--) {
                const E = f[y];
                (!(c ? E.attr(u.filter.name) !== void 0 : E.name === u.filter.name) || gn(E.parent)) && f.splice(y, 1);
              }
              f.length > 0 && b(f, u.filter.name, n);
            });
          });
        };
        o(e.nodes, !1), o(e.attributes, !0);
      }, WA = (e, n, o, r = {}) => {
        const c = SN(e, n, o);
        v2(c, r);
      }, Px = (e, n, o, r) => {
        if ((e.pad_empty_with_br || n.insert) && o(r)) {
          const u = new Ki("br", 1);
          n.insert && u.attr("data-mce-bogus", "1"), r.empty().append(u);
        } else
          r.empty().append(new Ki("#text", 3)).value = _s;
      }, xN = (e) => {
        var n;
        return ZA(e, "#text") && ((n = e?.firstChild) === null || n === void 0 ? void 0 : n.value) === _s;
      }, ZA = (e, n) => {
        const o = e?.firstChild;
        return De(o) && o === e.lastChild && o.name === n;
      }, TN = (e, n) => {
        const o = e.getElementRule(n.name);
        return o?.paddEmpty === !0;
      }, wv = (e, n, o, r) => r.isEmpty(n, o, (c) => TN(e, c)), EN = (e, n) => De(e) && (n(e) || e.name === "br"), kN = (e) => {
        let n;
        for (let o = e; o; o = o.parent) {
          const r = o.attr("contenteditable");
          if (r === "false")
            break;
          r === "true" && (n = o);
        }
        return F.from(n);
      }, Bx = (e, n, o = e.parent) => {
        if (n.getSpecialElements()[e.name])
          e.empty().remove();
        else {
          const r = e.children();
          for (const c of r)
            o && !n.isValidChild(o.name, c.name) && Bx(c, n, o);
          e.unwrap();
        }
      }, $x = (e, n, o, r = Oe) => {
        const c = n.getTextBlockElements(), u = n.getNonEmptyElements(), f = n.getWhitespaceElements(), b = _t.makeMap("tr,td,th,tbody,thead,tfoot,table,summary"), y = /* @__PURE__ */ new Set(), E = (N) => N !== o && !b[N.name];
        for (let N = 0; N < e.length; N++) {
          const M = e[N];
          let I, X, te;
          if (!M.parent || y.has(M))
            continue;
          if (c[M.name] && M.parent.name === "li") {
            let ne = M.next;
            for (; ne && c[ne.name]; ) {
              ne.name = "li", y.add(ne), M.parent.insert(ne, M.parent);
              ne = ne.next;
            }
            M.unwrap();
            continue;
          }
          const G = [M];
          for (I = M.parent; I && !n.isValidChild(I.name, M.name) && E(I); I = I.parent)
            G.push(I);
          if (I && G.length > 1)
            if (Fx(n, M, I))
              Bx(M, n);
            else {
              G.reverse(), X = G[0].clone(), r(X);
              let ne = X;
              for (let Se = 0; Se < G.length - 1; Se++) {
                n.isValidChild(ne.name, G[Se].name) && Se > 0 ? (te = G[Se].clone(), r(te), ne.append(te)) : te = ne;
                for (let ke = G[Se].firstChild; ke && ke !== G[Se + 1]; ) {
                  const Ae = ke.next;
                  te.append(ke), ke = Ae;
                }
                ne = te;
              }
              wv(n, u, f, X) ? I.insert(M, G[0], !0) : (I.insert(X, G[0], !0), I.insert(M, X)), I = G[0], (wv(n, u, f, I) || ZA(I, "br")) && I.empty().remove();
            }
          else if (M.parent) {
            if (M.name === "li") {
              let ne = M.prev;
              if (ne && (ne.name === "ul" || ne.name === "ol")) {
                ne.append(M);
                continue;
              }
              if (ne = M.next, ne && (ne.name === "ul" || ne.name === "ol") && ne.firstChild) {
                ne.insert(M, ne.firstChild, !0);
                continue;
              }
              const Se = new Ki("ul", 1);
              r(Se), M.wrap(Se);
              continue;
            }
            if (n.isValidChild(M.parent.name, "div") && n.isValidChild("div", M.name)) {
              const ne = new Ki("div", 1);
              r(ne), M.wrap(ne);
            } else
              Bx(M, n);
          }
        }
      }, jA = (e, n) => {
        let o = e;
        for (; o; ) {
          if (o.name === n)
            return !0;
          o = o.parent;
        }
        return !1;
      }, Fx = (e, n, o = n.parent) => o ? e.children[n.name] && !e.isValidChild(o.name, n.name) || n.name === "a" && jA(o, "a") ? !0 : p6(o) && CN(n) ? !(o?.firstChild === n && o?.lastChild === n) : !1 : !1, _N = (e, n, o, r) => {
        const c = document.createRange();
        return c.setStart(e, n), c.setEnd(o, r), c;
      }, AN = (e) => {
        const n = We.fromRangeStart(e), o = We.fromRangeEnd(e), r = e.commonAncestorContainer;
        return Tc(!1, r, o).map((c) => !md(n, o, r) && md(n, c, r) ? _N(n.container(), n.offset(), c.container(), c.offset()) : e).getOr(e);
      }, Ix = (e) => e.collapsed ? e : AN(e), ON = (e) => De(e.firstChild) && e.firstChild === e.lastChild, DN = (e) => e.name === "br" || e.value === _s, qA = (e, n) => e.getBlockElements()[n.name] && ON(n) && DN(n.firstChild), Lx = (e, n) => {
        const o = e.getNonEmptyElements();
        return De(n) && (n.isEmpty(o) || qA(e, n));
      }, Hx = (e, n) => {
        let o = n.firstChild, r = n.lastChild;
        return o && o.name === "meta" && (o = o.next), r && r.attr("id") === "mce_marker" && (r = r.prev), Lx(e, r) && (r = r?.prev), !o || o !== r ? !1 : o.name === "ul" || o.name === "ol";
      }, zx = (e) => {
        var n, o;
        const r = e.firstChild, c = e.lastChild;
        return r && r.nodeName === "META" && ((n = r.parentNode) === null || n === void 0 || n.removeChild(r)), c && c.id === "mce_marker" && ((o = c.parentNode) === null || o === void 0 || o.removeChild(c)), e;
      }, RN = (e, n, o) => {
        const r = n.serialize(o), c = e.createFragment(r);
        return zx(c);
      }, Vx = (e) => {
        var n;
        return Yt((n = e?.childNodes) !== null && n !== void 0 ? n : [], (o) => o.nodeName === "LI");
      }, GA = (e) => e.data === _s || Js(e), y2 = (e) => De(e?.firstChild) && e.firstChild === e.lastChild && GA(e.firstChild), KA = (e) => !e.firstChild || y2(e), NN = (e) => e.length > 0 && KA(e[e.length - 1]) ? e.slice(0, -1) : e, xp = (e, n) => {
        const o = e.getParent(n, e.isBlock);
        return o && o.nodeName === "LI" ? o : null;
      }, YA = (e, n) => !!xp(e, n), XA = (e, n) => {
        const o = n.cloneRange(), r = n.cloneRange();
        return o.setStartBefore(e), r.setEndAfter(e), [
          o.cloneContents(),
          r.cloneContents()
        ];
      }, C2 = (e, n) => {
        const o = We.before(e), c = fd(n).next(o);
        return c ? c.toRange() : null;
      }, Zg = (e, n) => {
        const o = We.after(e), c = fd(n).prev(o);
        return c ? c.toRange() : null;
      }, MN = (e, n, o, r) => {
        const c = XA(e, r), u = e.parentNode;
        return u && (u.insertBefore(c[0], e), _t.each(n, (f) => {
          u.insertBefore(f, e);
        }), u.insertBefore(c[1], e), u.removeChild(e)), Zg(n[n.length - 1], o);
      }, b6 = (e, n, o) => {
        const r = e.parentNode;
        return r && _t.each(n, (c) => {
          r.insertBefore(c, e);
        }), C2(e, o);
      }, PN = (e, n, o, r) => (r.insertAfter(n.reverse(), e), Zg(n[0], o)), BN = (e, n, o, r) => {
        const c = RN(n, e, r), u = xp(n, o.startContainer), f = NN(Vx(c.firstChild)), b = 1, y = 2, E = n.getRoot(), N = (M) => {
          const I = We.fromRangeStart(o), X = fd(n.getRoot()), te = M === b ? X.prev(I) : X.next(I), G = te?.getNode();
          return G ? xp(n, G) !== u : !0;
        };
        return u ? N(b) ? b6(u, f, E) : N(y) ? PN(u, f, E, n) : MN(u, f, E, o) : null;
      }, v6 = ["pre"], kj = (e, n, o, r) => {
        var c;
        const u = n.firstChild, f = n.lastChild, b = f.attr("data-mce-type") === "bookmark" ? f.prev : f, y = u === b, E = ee(v6, u.name);
        if (y && E) {
          const N = u.attr("contenteditable") !== "false", M = ((c = e.getParent(o, e.isBlock)) === null || c === void 0 ? void 0 : c.nodeName.toLowerCase()) === u.name, I = F.from(Sp(r, o)).forall(Kc);
          return N && M && I;
        } else
          return !1;
      }, JA = mg, QA = (e, n, o) => {
        if (De(o)) {
          const r = e.getParent(n.endContainer, JA);
          return o === r && $C(le.fromDom(o), n);
        } else
          return !1;
      }, Um = (e, n, o) => {
        var r;
        if (o.getAttribute("data-mce-bogus") === "all")
          (r = o.parentNode) === null || r === void 0 || r.insertBefore(e.dom.createFragment(n), o);
        else {
          const c = o.firstChild, u = o.lastChild;
          !c || c === u && c.nodeName === "BR" ? e.dom.setHTML(o, n) : e.selection.setContent(n, { no_events: !0 });
        }
      }, e3 = (e, n, o) => {
        F.from(e.getParent(n, "td,th")).map(le.fromDom).each((r) => w(r, o));
      }, Ux = (e, n) => {
        const o = e.schema.getTextInlineElements(), r = e.dom;
        if (n) {
          const c = e.getBody(), u = b2(e);
          _t.each(r.select("*[data-mce-fragment]"), (f) => {
            if (De(o[f.nodeName.toLowerCase()]) && s2(r, f)) {
              for (let y = f.parentElement; De(y) && y !== c && !BL(r, f, y); y = y.parentElement)
                if (u.compare(y, f)) {
                  r.remove(f, !0);
                  break;
                }
            }
          });
        }
      }, t3 = (e) => {
        let n = e;
        for (; n = n.walk(); )
          n.type === 1 && n.attr("data-mce-fragment", "1");
      }, y6 = (e) => {
        _t.each(e.getElementsByTagName("*"), (n) => {
          n.removeAttribute("data-mce-fragment");
        });
      }, $N = (e) => !!e.getAttribute("data-mce-fragment"), C6 = (e, n) => De(n) && !e.schema.getVoidElements()[n.nodeName], FN = (e, n) => {
        var o, r, c;
        let u;
        const f = e.dom, b = e.selection;
        if (!n)
          return;
        b.scrollIntoView(n);
        const y = Sp(e.getBody(), n);
        if (y && f.getContentEditable(y) === "false") {
          f.remove(n), b.select(y);
          return;
        }
        let E = f.createRng();
        const N = n.previousSibling;
        if (Mt(N)) {
          E.setStart(N, (r = (o = N.nodeValue) === null || o === void 0 ? void 0 : o.length) !== null && r !== void 0 ? r : 0);
          const X = n.nextSibling;
          Mt(X) && (N.appendData(X.data), (c = X.parentNode) === null || c === void 0 || c.removeChild(X));
        } else
          E.setStartBefore(n), E.setEndBefore(n);
        const M = (X) => {
          let te = We.fromRangeStart(X);
          return te = fd(e.getBody()).next(te), te?.toRange();
        }, I = f.getParent(n, f.isBlock);
        if (f.remove(n), I && f.isEmpty(I)) {
          const X = JA(I);
          Ei(le.fromDom(I)), E.setStart(I, 0), E.setEnd(I, 0), !X && !$N(I) && (u = M(E)) ? (E = u, f.remove(I)) : f.add(I, f.create("br", X ? {} : { "data-mce-bogus": "1" }));
        }
        b.setRng(E);
      }, n3 = (e) => {
        const n = e.dom, o = Ix(e.selection.getRng());
        e.selection.setRng(o);
        const r = n.getParent(o.startContainer, JA);
        QA(n, o, r) ? $A(e, o, le.fromDom(r)) : o.startContainer === o.endContainer && o.endOffset - o.startOffset === 1 && Mt(o.startContainer.childNodes[o.startOffset]) ? o.deleteContents() : e.getDoc().execCommand("Delete", !1);
      }, w6 = (e) => {
        for (let n = e; n; n = n.walk())
          if (n.attr("id") === "mce_marker")
            return F.some(n);
        return F.none();
      }, IN = (e, n, o) => {
        var r;
        return pe(o.children(), CN) && ((r = e.getParent(n, e.isBlock)) === null || r === void 0 ? void 0 : r.nodeName) === "SUMMARY";
      }, S6 = (e, n, o) => {
        var r, c;
        const u = e.selection, f = e.dom, b = e.parser, y = o.merge, E = yp({ validate: !0 }, e.schema), N = '<span id="mce_marker" data-mce-type="bookmark">&#xFEFF;</span>';
        o.preserve_zwsp || (n = q(n)), n.indexOf("{$caret}") === -1 && (n += "{$caret}"), n = n.replace(/\{\$caret\}/, N);
        let M = u.getRng();
        const I = M.startContainer, X = e.getBody();
        I === X && u.isCollapsed() && f.isBlock(X.firstChild) && C6(e, X.firstChild) && f.isEmpty(X.firstChild) && (M = f.createRng(), M.setStart(X.firstChild, 0), M.setEnd(X.firstChild, 0), u.setRng(M)), u.isCollapsed() || n3(e);
        const te = u.getNode(), G = {
          context: te.nodeName.toLowerCase(),
          data: o.data,
          insert: !0
        }, ne = b.parse(n, G);
        if (o.paste === !0 && Hx(e.schema, ne) && YA(f, te))
          return M = BN(E, f, u.getRng(), ne), M && u.setRng(M), n;
        o.paste === !0 && kj(f, ne, te, e.getBody()) && ((r = ne.firstChild) === null || r === void 0 || r.unwrap()), t3(ne);
        let Se = ne.lastChild;
        if (Se && Se.attr("id") === "mce_marker") {
          const ke = Se;
          for (Se = Se.prev; Se; Se = Se.walk(!0))
            if (Se.type === 3 || !f.isBlock(Se.name)) {
              Se.parent && e.schema.isValidChild(Se.parent.name, "span") && Se.parent.insert(ke, Se, Se.name === "br");
              break;
            }
        }
        if (e._selectionOverrides.showBlockCaretContainer(te), !G.invalid && !IN(f, te, ne))
          n = E.serialize(ne), Um(e, n, te);
        else {
          e.selection.setContent(N);
          let ke = u.getNode(), Ae;
          const Me = e.getBody();
          for (dg(ke) ? ke = Ae = Me : Ae = ke; Ae && Ae !== Me; )
            ke = Ae, Ae = Ae.parentNode;
          n = ke === Me ? Me.innerHTML : f.getOuterHTML(ke);
          const pt = b.parse(n), It = w6(pt), un = It.bind(kN).getOr(pt);
          It.each((bn) => bn.replace(ne));
          const nt = ne.children(), qe = (c = ne.parent) !== null && c !== void 0 ? c : pt;
          ne.unwrap();
          const xt = Yt(nt, (bn) => Fx(e.schema, bn, qe));
          $x(xt, e.schema, un), WA(b.getNodeFilters(), b.getAttributeFilters(), pt), n = E.serialize(pt), ke === Me ? f.setHTML(Me, n) : f.setOuterHTML(ke, n);
        }
        return Ux(e, y), FN(e, f.get("mce_marker")), y6(e.getBody()), e3(f, u.getStart(), e.schema), Bw(e.schema, e.getBody(), u.getStart()), n;
      }, Tp = (e) => e instanceof Ki, LN = (e) => {
        vp(e) && Ri(e.getBody()).each((n) => {
          const o = n.getNode(), r = Du(o) ? Ri(o).getOr(n) : n;
          e.selection.setRng(r.toRange());
        });
      }, o3 = (e, n, o) => {
        e.dom.setHTML(e.getBody(), n), o !== !0 && LN(e);
      }, HN = (e, n, o, r) => {
        if (o = q(o), o.length === 0 || /^\s+$/.test(o)) {
          const c = '<br data-mce-bogus="1">';
          n.nodeName === "TABLE" ? o = "<tr><td>" + c + "</td></tr>" : /^(UL|OL)$/.test(n.nodeName) && (o = "<li>" + c + "</li>");
          const u = gi(e);
          return e.schema.isValidChild(n.nodeName.toLowerCase(), u.toLowerCase()) ? (o = c, o = e.dom.createHTML(u, M1(e), o)) : o || (o = c), o3(e, o, r.no_selection), {
            content: o,
            html: o
          };
        } else {
          r.format !== "raw" && (o = yp({ validate: !1 }, e.schema).serialize(e.parser.parse(o, {
            isRootContent: !0,
            insert: !0
          })));
          const c = Pa(le.fromDom(n)) ? o : _t.trim(o);
          return o3(e, c, r.no_selection), {
            content: c,
            html: c
          };
        }
      }, x6 = (e, n, o, r) => {
        WA(e.parser.getNodeFilters(), e.parser.getAttributeFilters(), o);
        const c = yp({ validate: !1 }, e.schema).serialize(o), u = q(Pa(le.fromDom(n)) ? c : _t.trim(c));
        return o3(e, u, r.no_selection), {
          content: o,
          html: u
        };
      }, T6 = (e, n, o) => F.from(e.getBody()).map((r) => Tp(n) ? x6(e, r, n, o) : HN(e, r, n, o)).getOr({
        content: n,
        html: Tp(o.content) ? "" : o.content
      }), zN = (e) => re(e) ? e : $e, E6 = (e, n, o) => {
        let r = e.dom;
        const c = zN(o);
        for (; r.parentNode; ) {
          r = r.parentNode;
          const u = le.fromDom(r), f = n(u);
          if (f.isSome())
            return f;
          if (c(u))
            break;
        }
        return F.none();
      }, s3 = (e, n, o) => {
        const r = n(e), c = zN(o);
        return r.orThunk(() => c(e) ? F.none() : E6(e, n, c));
      }, Wx = J0, VN = (e, n, o) => {
        const r = e.formatter.get(o);
        if (r)
          for (let c = 0; c < r.length; c++) {
            const u = r[c];
            if (Hc(u) && u.inherit === !1 && e.dom.is(n, u.selector))
              return !0;
          }
        return !1;
      }, w2 = (e, n, o, r, c) => {
        const u = e.dom.getRoot();
        if (n === u)
          return !1;
        const f = e.dom.getParent(n, (b) => VN(e, b, o) ? !0 : b.parentNode === u || !!zf(e, b, o, r, !0));
        return !!zf(e, f, o, r, c);
      }, Hf = (e, n, o) => Ba(o) && Wx(n, o.inline) || pd(o) && Wx(n, o.block) ? !0 : Hc(o) ? xn(n) && e.is(n, o.selector) : !1, UN = (e, n, o, r, c, u) => {
        const f = o[r], b = r === "attributes";
        if (re(o.onmatch))
          return o.onmatch(n, o, r);
        if (f) {
          if (_c(f)) {
            for (let y = 0; y < f.length; y++)
              if (b ? e.getAttrib(n, f[y]) : lp(e, n, f[y]))
                return !0;
          } else
            for (const y in f)
              if (Zn(f, y)) {
                const E = b ? e.getAttrib(n, y) : lp(e, n, y), N = hd(f[y], u), M = gn(E) || Fo(E);
                if (M && gn(N))
                  continue;
                if (c && M && !o.exact || (!c || o.exact) && !Wx(E, Q0(N, y)))
                  return !1;
              }
        }
        return !0;
      }, zf = (e, n, o, r, c) => {
        const u = e.formatter.get(o), f = e.dom;
        if (u && xn(n))
          for (let b = 0; b < u.length; b++) {
            const y = u[b];
            if (Hf(e.dom, n, y) && UN(f, n, y, "attributes", c, r) && UN(f, n, y, "styles", c, r)) {
              const E = y.classes;
              if (E) {
                for (let N = 0; N < E.length; N++)
                  if (!e.dom.hasClass(n, hd(E[N], r)))
                    return;
              }
              return y;
            }
          }
      }, Sv = (e, n, o, r, c) => {
        if (r)
          return w2(e, r, n, o, c);
        if (r = e.selection.getNode(), w2(e, r, n, o, c))
          return !0;
        const u = e.selection.getStart();
        return !!(u !== r && w2(e, u, n, o, c));
      }, WN = (e, n, o) => {
        const r = [], c = {}, u = e.selection.getStart();
        return e.dom.getParent(u, (f) => {
          for (let b = 0; b < n.length; b++) {
            const y = n[b];
            !c[y] && zf(e, f, y, o) && (c[y] = !0, r.push(y));
          }
        }, e.dom.getRoot()), r;
      }, ZN = (e, n) => {
        const o = (c) => fs(c, le.fromDom(e.getBody())), r = (c, u) => zf(e, c.dom, u) ? F.some(u) : F.none();
        return F.from(e.selection.getStart(!0)).bind((c) => s3(le.fromDom(c), (u) => Gs(n, (f) => r(u, f)), o)).getOrNull();
      }, k6 = (e, n) => {
        const o = e.formatter.get(n), r = e.dom;
        if (o && e.selection.isEditable()) {
          const c = e.selection.getStart(), u = Q1(r, c);
          for (let f = o.length - 1; f >= 0; f--) {
            const b = o[f];
            if (!Hc(b))
              return !0;
            for (let y = u.length - 1; y >= 0; y--)
              if (r.is(u[y], b.selector))
                return !0;
          }
        }
        return !1;
      }, jN = (e, n, o) => Xe(o, (r, c) => {
        const u = HC(e, c);
        return e.formatter.matchNode(n, c, {}, u) ? r.concat([c]) : r;
      }, []), S2 = k, Cb = (e, n) => e.importNode(n, !0), r3 = (e) => {
        if (e) {
          const n = new br(e, e);
          for (let o = n.current(); o; o = n.next())
            if (Mt(o))
              return o;
        }
        return null;
      }, Zx = (e) => {
        const n = le.fromTag("span");
        return Br(n, {
          id: W0,
          "data-mce-bogus": "1",
          "data-mce-type": "format-caret"
        }), e && la(n, le.fromText(S2)), n;
      }, qN = (e) => {
        const n = r3(e);
        return n && n.data.charAt(0) === S2 && n.deleteData(0, 1), n;
      }, xv = (e, n, o) => {
        const r = e.dom, c = e.selection;
        if (tb(n))
          Wg(e, !1, le.fromDom(n), o, !0);
        else {
          const u = c.getRng(), f = r.getParent(n, r.isBlock), b = u.startContainer, y = u.startOffset, E = u.endContainer, N = u.endOffset, M = qN(n);
          r.remove(n, !0), b === M && y > 0 && u.setStart(M, y - 1), E === M && N > 0 && u.setEnd(M, N - 1), f && r.isEmpty(f) && Nu(le.fromDom(f)), c.setRng(u);
        }
      }, jx = (e, n, o) => {
        const r = e.dom, c = e.selection;
        if (n)
          xv(e, n, o);
        else if (n = Pg(e.getBody(), c.getStart()), !n)
          for (; n = r.get(W0); )
            xv(e, n, o);
      }, _6 = (e, n, o) => {
        var r, c;
        const u = e.dom, f = u.getParent(o, Ye(za, e.schema));
        f && u.isEmpty(f) ? (r = o.parentNode) === null || r === void 0 || r.replaceChild(n, o) : (Nw(le.fromDom(o)), u.isEmpty(o) ? (c = o.parentNode) === null || c === void 0 || c.replaceChild(n, o) : u.insertAfter(n, o));
      }, a3 = (e, n) => (e.appendChild(n), n), GN = (e, n) => {
        var o;
        const r = Ct(e, (u, f) => a3(u, f.cloneNode(!1)), n), c = (o = r.ownerDocument) !== null && o !== void 0 ? o : document;
        return a3(r, c.createTextNode(S2));
      }, A6 = (e, n, o, r, c, u) => {
        const f = e.formatter, b = e.dom, y = Yt(Ss(f.get()), (M) => M !== r && !Mn(M, "removeformat")), E = jN(e, o, y);
        if (Yt(E, (M) => !L_(e, M, r)).length > 0) {
          const M = o.cloneNode(!1);
          return b.add(n, M), f.remove(r, c, M, u), b.remove(M), F.some(M);
        } else
          return F.none();
      }, qx = (e, n, o) => {
        let r;
        const c = e.selection, u = e.formatter.get(n);
        if (!u)
          return;
        const f = c.getRng();
        let b = f.startOffset;
        const E = f.startContainer.nodeValue;
        r = Pg(e.getBody(), c.getStart());
        const N = /[^\s\u00a0\u00ad\u200b\ufeff]/;
        if (E && b > 0 && b < E.length && N.test(E.charAt(b)) && N.test(E.charAt(b - 1))) {
          const M = c.getBookmark();
          f.collapse(!0);
          let I = Bm(e.dom, f, u);
          I = $(I), e.formatter.apply(n, o, I), c.moveToBookmark(M);
        } else {
          let M = r ? r3(r) : null;
          (!r || M?.data !== S2) && (r = Cb(e.getDoc(), Zx(!0).dom), M = r.firstChild, f.insertNode(r), b = 1), e.formatter.apply(n, o, r), c.setCursorLocation(M, b);
        }
      }, KN = (e, n, o, r) => {
        const c = e.dom, u = e.selection;
        let f = !1;
        const b = e.formatter.get(n);
        if (!b)
          return;
        const y = u.getRng(), E = y.startContainer, N = y.startOffset;
        let M = E;
        Mt(E) && (N !== E.data.length && (f = !0), M = M.parentNode);
        const I = [];
        let X;
        for (; M; ) {
          if (zf(e, M, n, o, r)) {
            X = M;
            break;
          }
          M.nextSibling && (f = !0), I.push(M), M = M.parentNode;
        }
        if (X)
          if (f) {
            const te = u.getBookmark();
            y.collapse(!0);
            let G = Bm(c, y, b, !0);
            G = $(G), e.formatter.remove(n, o, G, r), u.moveToBookmark(te);
          } else {
            const te = Pg(e.getBody(), X), G = De(te) ? c.getParents(X.parentNode, ot, te) : [], ne = Zx(!1).dom;
            _6(e, ne, te ?? X);
            const Se = A6(e, ne, X, n, o, r), ke = GN([
              ...I,
              ...Se.toArray(),
              ...G
            ], ne);
            te && xv(e, te, De(te)), u.setCursorLocation(ke, 1), c.isEmpty(X) && c.remove(X);
          }
      }, c3 = (e, n, o) => {
        const r = e.selection, c = e.getBody();
        jx(e, null, o), (n === 8 || n === 46) && r.isCollapsed() && r.getStart().innerHTML === S2 && jx(e, Pg(c, r.getStart()), !0), (n === 37 || n === 39) && jx(e, Pg(c, r.getStart()), !0);
      }, O6 = (e) => Mt(e) && zo(e.data, _s), D6 = (e) => {
        e.on("mouseup keydown", (n) => {
          c3(e, n.keyCode, O6(e.selection.getRng().endContainer));
        });
      }, i3 = (e) => {
        const n = Zx(!1), o = GN(e, n.dom);
        return {
          caretContainer: n,
          caretPosition: We(o, 0)
        };
      }, Gx = (e, n) => {
        const { caretContainer: o, caretPosition: r } = i3(n);
        return ka(le.fromDom(e), o), bs(le.fromDom(e)), r;
      }, YN = (e, n) => {
        const { caretContainer: o, caretPosition: r } = i3(n);
        return e.insertNode(o.dom), r;
      }, XN = (e, n) => {
        if (Fl(n.dom))
          return !1;
        const o = e.schema.getTextInlineElements();
        return Zn(o, Qo(n)) && !Fl(n.dom) && !nu(n.dom);
      }, x2 = {}, JN = ua(["pre"]), Kx = (e, n) => {
        x2[e] || (x2[e] = []), x2[e].push(n);
      }, jg = (e, n) => {
        Zn(x2, e) && ae(x2[e], (o) => {
          o(n);
        });
      };
      Kx("pre", (e) => {
        const n = e.selection.getRng(), o = (c) => (u) => {
          const f = u.previousSibling;
          return JN(f) && ee(c, f);
        }, r = (c, u) => {
          const f = le.fromDom(u), b = xi(f).dom;
          bs(f), Ms(le.fromDom(c), [
            le.fromTag("br", b),
            le.fromTag("br", b),
            ...Ea(f)
          ]);
        };
        if (!n.collapsed) {
          const c = e.selection.getSelectedBlocks(), u = Yt(Yt(c, JN), o(c));
          ae(u, (f) => {
            r(f.previousSibling, f);
          });
        }
      });
      const QN = [
        "fontWeight",
        "fontStyle",
        "color",
        "fontSize",
        "fontFamily"
      ], l3 = (e) => Qe(e.styles) && pe(Ss(e.styles), (n) => ee(QN, n)), $a = (e) => hn(e, (n) => Ba(n) && n.inline === "span" && l3(n)), Yx = (e, n) => {
        const o = e.get(n);
        return ht(o) ? $a(o) : F.none();
      }, Xx = (e, n) => ji(n, We.fromRangeStart(e)).isNone(), Vf = (e, n) => pi(n, We.fromRangeEnd(e)).exists((o) => !Js(o.getNode()) || pi(n, o).isSome()) === !1, u3 = (e) => (n) => ph(n) && e.isEditable(n), eM = (e) => {
        const n = e.getSelectedBlocks(), o = e.getRng();
        if (e.isCollapsed())
          return [];
        if (n.length === 1)
          return Xx(o, n[0]) && Vf(o, n[0]) ? n : [];
        {
          const r = qt(n).filter((f) => Xx(o, f)).toArray(), c = ko(n).filter((f) => Vf(o, f)).toArray(), u = n.slice(1, -1);
          return r.concat(u).concat(c);
        }
      }, T2 = (e) => Yt(eM(e), u3(e.dom)), tM = (e) => Yt(e.getSelectedBlocks(), u3(e.dom)), d3 = _t.each, Ep = (e) => xn(e) && !Il(e) && !Fl(e) && !nu(e), nM = (e, n) => {
        for (let o = e; o; o = o[n]) {
          if (Mt(o) && lo(o.data))
            return e;
          if (xn(o) && !Il(o))
            return o;
        }
        return e;
      }, kp = (e, n, o) => {
        const r = b2(e), c = Au(n) && e.dom.isEditable(n), u = Au(o) && e.dom.isEditable(o);
        if (c && u) {
          const f = nM(n, "previousSibling"), b = nM(o, "nextSibling");
          if (r.compare(f, b)) {
            for (let y = f.nextSibling; y && y !== b; ) {
              const E = y;
              y = y.nextSibling, f.appendChild(E);
            }
            return e.dom.remove(b), _t.each(_t.grep(b.childNodes), (y) => {
              f.appendChild(y);
            }), f;
          }
        }
        return o;
      }, oM = (e, n, o, r) => {
        var c;
        if (r && n.merge_siblings !== !1) {
          const u = (c = kp(e, ln(r), r)) !== null && c !== void 0 ? c : r;
          kp(e, u, ln(u, !0));
        }
      }, _p = (e, n, o) => {
        if (n.clear_child_styles) {
          const r = n.links ? "*:not(a)" : "*";
          d3(e.select(r, o), (c) => {
            Ep(c) && e.isEditable(c) && d3(n.styles, (u, f) => {
              e.setStyle(c, f, "");
            });
          });
        }
      }, mu = (e, n, o) => {
        d3(e.childNodes, (r) => {
          Ep(r) && (n(r) && o(r), r.hasChildNodes() && mu(r, n, o));
        });
      }, Jx = (e, n) => {
        n.nodeName === "SPAN" && e.getAttribs(n).length === 0 && e.remove(n, !0);
      }, Qx = (e, n) => (o) => !!(o && lp(e, o, n)), sM = (e, n, o) => (r) => {
        e.setStyle(r, n, o), r.getAttribute("style") === "" && r.removeAttribute("style"), Jx(e, r);
      }, wb = dd.generate([
        { keep: [] },
        { rename: ["name"] },
        { removed: [] }
      ]), eT = /^(src|href|style)$/, m3 = _t.each, fu = J0, tT = (e) => /^(TR|TH|TD)$/.test(e.nodeName), f3 = (e, n, o) => e.isChildOf(n, o) && n !== o && !e.isBlock(o), nT = (e, n, o) => {
        let r = n[o ? "startContainer" : "endContainer"], c = n[o ? "startOffset" : "endOffset"];
        if (xn(r)) {
          const u = r.childNodes.length - 1;
          !o && c && c--, r = r.childNodes[c > u ? u : c];
        }
        return Mt(r) && o && c >= r.data.length && (r = new br(r, e.getBody()).next() || r), Mt(r) && !o && c === 0 && (r = new br(r, e.getBody()).prev() || r), r;
      }, oT = (e, n) => {
        const o = n ? "firstChild" : "lastChild", r = e[o];
        return tT(e) && r ? e.nodeName === "TR" && r[o] || r : e;
      }, qg = (e, n, o, r) => {
        var c;
        const u = e.create(o, r);
        return (c = n.parentNode) === null || c === void 0 || c.insertBefore(u, n), u.appendChild(n), u;
      }, sT = (e, n, o, r, c) => {
        const u = le.fromDom(n), f = le.fromDom(e.create(r, c)), b = o ? Sc(u) : ng(u);
        return Ms(f, b), o ? (ka(u, f), gm(f, u)) : (Ti(u, f), la(f, u)), f.dom;
      }, R6 = (e, n) => n.links && e.nodeName === "A", g3 = (e, n, o) => {
        const r = n.parentNode;
        let c;
        const u = e.dom, f = gi(e);
        pd(o) && r === u.getRoot() && (!o.list_block || !fu(n, o.list_block)) && ae(rs(n.childNodes), (b) => {
          Pm(e, f, b.nodeName.toLowerCase()) ? c ? c.appendChild(b) : (c = qg(u, b, f), u.setAttribs(c, M1(e))) : c = null;
        }), !(tv(o) && !fu(o.inline, n)) && u.remove(n, !0);
      }, rM = (e, n, o) => ho(e) ? {
        name: n,
        value: null
      } : {
        name: e,
        value: hd(n, o)
      }, aM = (e, n) => {
        e.getAttrib(n, "style") === "" && (n.removeAttribute("style"), n.removeAttribute("data-mce-style"));
      }, cM = (e, n, o, r, c) => {
        let u = !1;
        m3(o.styles, (f, b) => {
          const {
            name: y,
            value: E
          } = rM(b, f, r), N = Q0(E, y);
          (o.remove_similar || U(E) || !xn(c) || fu(lp(e, c, y), N)) && e.setStyle(n, y, ""), u = !0;
        }), u && aM(e, n);
      }, N6 = (e, n, o) => {
        n === "removeformat" ? ae(tM(e.selection), (r) => {
          ae(QN, (c) => e.dom.setStyle(r, c, "")), aM(e.dom, r);
        }) : Yx(e.formatter, n).each((r) => {
          ae(tM(e.selection), (c) => cM(e.dom, c, r, o, null));
        });
      }, Tv = (e, n, o, r, c) => {
        const u = e.dom, f = b2(e), b = e.schema;
        if (Ba(n) && p1(b, n.inline) && cs(b, r) && r.parentElement === e.getBody())
          return g3(e, r, n), wb.removed();
        if (!n.ceFalseOverride && r && u.getContentEditableParent(r) === "false" || r && !Hf(u, r, n) && !R6(r, n))
          return wb.keep();
        const y = r, E = n.preserve_attributes;
        if (Ba(n) && n.remove === "all" && ht(E)) {
          const N = Yt(u.getAttribs(y), (M) => ee(E, M.name.toLowerCase()));
          if (u.removeAllAttribs(y), ae(N, (M) => u.setAttrib(y, M.name, M.value)), N.length > 0)
            return wb.rename("span");
        }
        if (n.remove !== "all") {
          cM(u, y, n, o, c), m3(n.attributes, (M, I) => {
            const {
              name: X,
              value: te
            } = rM(I, M, o);
            if (n.remove_similar || U(te) || !xn(c) || fu(u.getAttrib(c, X), te)) {
              if (X === "class") {
                const G = u.getAttrib(y, X);
                if (G) {
                  let ne = "";
                  if (ae(G.split(/\s+/), (Se) => {
                    /mce\-\w+/.test(Se) && (ne += (ne ? " " : "") + Se);
                  }), ne) {
                    u.setAttrib(y, X, ne);
                    return;
                  }
                }
              }
              if (eT.test(X) && y.removeAttribute("data-mce-" + X), X === "style" && ua(["li"])(y) && u.getStyle(y, "list-style-type") === "none") {
                y.removeAttribute(X), u.setStyle(y, "list-style-type", "none");
                return;
              }
              X === "class" && y.removeAttribute("className"), y.removeAttribute(X);
            }
          }), m3(n.classes, (M) => {
            M = hd(M, o), (!xn(c) || u.hasClass(c, M)) && u.removeClass(y, M);
          });
          const N = u.getAttribs(y);
          for (let M = 0; M < N.length; M++) {
            const I = N[M].nodeName;
            if (!f.isAttributeInternal(I))
              return wb.keep();
          }
        }
        return n.remove !== "none" ? (g3(e, y, n), wb.removed()) : wb.keep();
      }, M6 = (e, n, o, r, c) => {
        let u;
        return n.parentNode && ae(Q1(e.dom, n.parentNode).reverse(), (f) => {
          if (!u && xn(f) && f.id !== "_start" && f.id !== "_end") {
            const b = zf(e, f, o, r, c);
            b && b.split !== !1 && (u = f);
          }
        }), u;
      }, iM = (e, n, o, r) => Tv(e, n, o, r, r).fold(it(r), (c) => (e.dom.createFragment().appendChild(r), e.dom.rename(r, c)), it(null)), h3 = (e, n, o, r, c, u, f, b) => {
        var y, E;
        let N, M;
        const I = e.dom;
        if (o) {
          const X = o.parentNode;
          for (let te = r.parentNode; te && te !== X; te = te.parentNode) {
            let G = I.clone(te, !1);
            for (let ne = 0; ne < n.length && (G = iM(e, n[ne], b, G), G !== null); ne++)
              ;
            G && (N && G.appendChild(N), M || (M = G), N = G);
          }
          (!f.mixed || !I.isBlock(o)) && (r = (y = I.split(o, r)) !== null && y !== void 0 ? y : r), N && M && ((E = c.parentNode) === null || E === void 0 || E.insertBefore(N, c), M.appendChild(c), Ba(f) && oM(e, f, b, N));
        }
        return r;
      }, P6 = (e, n, o, r, c) => {
        const u = e.formatter.get(n), f = u[0], b = e.dom, y = e.selection, E = (G) => {
          const ne = M6(e, G, n, o, c);
          return h3(e, u, ne, G, G, !0, f, o);
        }, N = (G) => Il(G) && xn(G) && (G.id === "_start" || G.id === "_end"), M = (G) => pe(u, (ne) => Ev(e, ne, o, G, G)), I = (G) => {
          const ne = rs(G.childNodes), ke = M(G) || pe(u, (pt) => Hf(b, G, pt)), Ae = G.parentNode;
          if (!ke && De(Ae) && eb(f) && M(Ae), f.deep && ne.length)
            for (let pt = 0; pt < ne.length; pt++)
              I(ne[pt]);
          ae([
            "underline",
            "line-through",
            "overline"
          ], (pt) => {
            xn(G) && e.dom.getStyle(G, "text-decoration") === pt && G.parentNode && ZS(b, G.parentNode) === pt && Ev(e, {
              deep: !1,
              exact: !0,
              inline: "span",
              styles: { textDecoration: pt }
            }, void 0, G);
          });
        }, X = (G) => {
          const ne = b.get(G ? "_start" : "_end");
          if (ne) {
            let Se = ne[G ? "firstChild" : "lastChild"];
            return N(Se) && (Se = Se[G ? "firstChild" : "lastChild"]), Mt(Se) && Se.data.length === 0 && (Se = G ? ne.previousSibling || ne.nextSibling : ne.nextSibling || ne.previousSibling), b.remove(ne, !0), Se;
          } else
            return null;
        }, te = (G) => {
          let ne, Se, ke = Bm(b, G, u, G.collapsed);
          if (f.split) {
            if (ke = $(ke), ne = nT(e, ke, !0), Se = nT(e, ke), ne !== Se) {
              if (ne = oT(ne, !0), Se = oT(Se, !1), f3(b, ne, Se)) {
                const Me = F.from(ne.firstChild).getOr(ne);
                E(sT(b, Me, !0, "span", {
                  id: "_start",
                  "data-mce-type": "bookmark"
                })), X(!0);
                return;
              }
              if (f3(b, Se, ne)) {
                const Me = F.from(Se.lastChild).getOr(Se);
                E(sT(b, Me, !1, "span", {
                  id: "_end",
                  "data-mce-type": "bookmark"
                })), X(!1);
                return;
              }
              ne = qg(b, ne, "span", {
                id: "_start",
                "data-mce-type": "bookmark"
              }), Se = qg(b, Se, "span", {
                id: "_end",
                "data-mce-type": "bookmark"
              });
              const Ae = b.createRng();
              Ae.setStartAfter(ne), Ae.setEndBefore(Se), ab(b, Ae, (Me) => {
                ae(Me, (pt) => {
                  !Il(pt) && !Il(pt.parentNode) && E(pt);
                });
              }), E(ne), E(Se), ne = X(!0), Se = X();
            } else
              ne = Se = E(ne);
            ke.startContainer = ne.parentNode ? ne.parentNode : ne, ke.startOffset = b.nodeIndex(ne), ke.endContainer = Se.parentNode ? Se.parentNode : Se, ke.endOffset = b.nodeIndex(Se) + 1;
          }
          ab(b, ke, (Ae) => {
            ae(Ae, I);
          });
        };
        if (r) {
          if (Y1(r)) {
            const G = b.createRng();
            G.setStartBefore(r), G.setEndAfter(r), te(G);
          } else
            te(r);
          Ig(e, n, r, o);
          return;
        }
        !y.isCollapsed() || !Ba(f) || ip(e).length ? (X1(e, () => Bf(e, te), (G) => Ba(f) && Sv(e, n, o, G)), e.nodeChanged()) : KN(e, n, o, c), N6(e, n, o), Ig(e, n, r, o);
      }, p3 = (e, n, o, r, c) => {
        (r || e.selection.isEditable()) && P6(e, n, o, r, c);
      }, Ev = (e, n, o, r, c) => Tv(e, n, o, r, c).fold($e, (u) => (e.dom.rename(r, u), !0), ot), lM = _t.each, B6 = (e, n, o, r) => {
        const c = (u) => {
          if (Au(u) && xn(u.parentNode) && e.isEditable(u)) {
            const f = ZS(e, u.parentNode);
            e.getStyle(u, "color") && f ? e.setStyle(u, "text-decoration", f) : e.getStyle(u, "text-decoration") === f && e.setStyle(u, "text-decoration", null);
          }
        };
        n.styles && (n.styles.color || n.styles.textDecoration) && (_t.walk(r, c, "childNodes"), c(r));
      }, $6 = (e, n, o, r) => {
        if (n.styles && n.styles.backgroundColor) {
          const c = Qx(e, "fontSize");
          mu(r, (u) => c(u) && e.isEditable(u), sM(e, "backgroundColor", hd(n.styles.backgroundColor, o)));
        }
      }, F6 = (e, n, o, r) => {
        if (Ba(n) && (n.inline === "sub" || n.inline === "sup")) {
          const c = Qx(e, "fontSize");
          mu(r, (f) => c(f) && e.isEditable(f), sM(e, "fontSize", ""));
          const u = Yt(e.select(n.inline === "sup" ? "sub" : "sup", r), e.isEditable);
          e.remove(u, !0);
        }
      }, I6 = (e, n, o, r) => {
        lM(n, (c) => {
          Ba(c) && lM(e.dom.select(c.inline, r), (u) => {
            Ep(u) && Ev(e, c, o, u, c.exact ? u : null);
          }), _p(e.dom, c, r);
        });
      }, L6 = (e, n, o, r, c) => {
        const u = c.parentNode;
        zf(e, u, o, r) && Ev(e, n, r, c) || n.merge_with_parents && u && e.dom.getParent(u, (f) => zf(e, f, o, r) ? (Ev(e, n, r, c), !0) : !1);
      }, rT = _t.each, H6 = (e, n, o, r) => {
        if (pS(e) && Ba(n) && o.parentNode) {
          const c = Iw(e.schema), u = Dx(le.fromDom(o), (f) => Fl(f.dom));
          return dr(c, r) && sa(le.fromDom(o.parentNode), !1) && !u;
        } else
          return !1;
      }, uM = (e, n, o, r) => {
        if (rT(o.styles, (c, u) => {
          e.setStyle(n, u, hd(c, r));
        }), o.styles) {
          const c = e.getAttrib(n, "style");
          c && e.setAttrib(n, "data-mce-style", c);
        }
      }, z6 = (e, n, o, r) => {
        const c = e.formatter.get(n), u = c[0], f = !r && e.selection.isCollapsed(), b = e.dom, y = e.selection, E = (te, G = u) => {
          re(G.onformat) && G.onformat(te, G, o, r), uM(b, te, G, o), rT(G.attributes, (ne, Se) => {
            b.setAttrib(te, Se, hd(ne, o));
          }), rT(G.classes, (ne) => {
            const Se = hd(ne, o);
            b.hasClass(te, Se) || b.addClass(te, Se);
          });
        }, N = (te, G) => {
          let ne = !1;
          return rT(te, (Se) => Hc(Se) ? b.getContentEditable(G) === "false" && !Se.ceFalseOverride || De(Se.collapsed) && Se.collapsed !== f ? !0 : b.is(G, Se.selector) && !Fl(G) ? (E(G, Se), ne = !0, !1) : !0 : !1), ne;
        }, M = (te) => {
          if (J(te)) {
            const G = b.create(te);
            return E(G), G;
          } else
            return null;
        }, I = (te, G, ne) => {
          const Se = [];
          let ke = !0;
          const Ae = u.inline || u.block, Me = M(Ae), pt = (nt) => ev(u) && zf(e, nt, n, o), It = (nt, qe, xt) => {
            const bn = up(u) && za(e.schema, nt) && Pm(e, qe, Ae);
            return xt && bn;
          }, un = (nt, qe, xt, bn) => {
            const Yn = nt.nodeName.toLowerCase(), Po = Pm(e, Ae, Yn) && Pm(e, qe, Ae), Ko = !ne && Mt(nt) && H(nt.data), er = Fl(nt), Er = !Ba(u) || !te.isBlock(nt);
            return (xt || bn) && Po && !Ko && !er && Er;
          };
          ab(te, G, (nt) => {
            let qe;
            const xt = (bn) => {
              let Yn = !1, Po = ke, Ko = !1;
              const er = bn.parentNode, Er = er.nodeName.toLowerCase(), wa = te.getContentEditable(bn);
              De(wa) && (Po = ke, ke = wa === "true", Yn = !0, Ko = J1(e, bn));
              const si = ke && !Yn;
              if (Js(bn) && !H6(e, u, bn, Er)) {
                qe = null, pd(u) && te.remove(bn);
                return;
              }
              if (pt(bn)) {
                qe = null;
                return;
              }
              if (It(bn, Er, si)) {
                const kc = te.rename(bn, Ae);
                E(kc), Se.push(kc), qe = null;
                return;
              }
              if (Hc(u)) {
                let kc = N(c, bn);
                if (!kc && De(er) && eb(u) && (kc = N(c, er)), !Ba(u) || kc) {
                  qe = null;
                  return;
                }
              }
              De(Me) && un(bn, Er, si, Ko) ? (qe || (qe = te.clone(Me, !1), er.insertBefore(qe, bn), Se.push(qe)), Ko && Yn && (ke = Po), qe.appendChild(bn)) : (qe = null, ae(rs(bn.childNodes), xt), Yn && (ke = Po), qe = null);
            };
            ae(nt, xt);
          }), u.links === !0 && ae(Se, (nt) => {
            const qe = (xt) => {
              xt.nodeName === "A" && E(xt, u), ae(rs(xt.childNodes), qe);
            };
            qe(nt);
          }), ae(Se, (nt) => {
            const qe = (Yn) => {
              let Po = 0;
              return ae(Yn.childNodes, (Ko) => {
                !lu(Ko) && !Il(Ko) && Po++;
              }), Po;
            }, xt = (Yn) => hn(Yn.childNodes, IC).filter((Ko) => te.getContentEditable(Ko) !== "false" && Hf(te, Ko, u)).map((Ko) => {
              const er = te.clone(Ko, !1);
              return E(er), te.replace(er, Yn, !0), te.remove(Ko, !0), er;
            }).getOr(Yn), bn = qe(nt);
            if ((Se.length > 1 || !te.isBlock(nt)) && bn === 0) {
              te.remove(nt, !0);
              return;
            }
            (Ba(u) || pd(u) && u.wrapper) && (!u.exact && bn === 1 && (nt = xt(nt)), I6(e, c, o, nt), L6(e, u, n, o, nt), $6(te, u, o, nt), B6(te, u, o, nt), F6(te, u, o, nt), oM(e, u, o, nt));
          });
        }, X = Y1(r) ? r : y.getNode();
        if (b.getContentEditable(X) === "false" && !J1(e, X)) {
          r = X, N(c, r), ti(e, n, r, o);
          return;
        }
        if (u) {
          if (r)
            if (Y1(r)) {
              if (!N(c, r)) {
                const te = b.createRng();
                te.setStartBefore(r), te.setEndAfter(r), I(b, Bm(b, te, c), !0);
              }
            } else
              I(b, r, !0);
          else
            !f || !Ba(u) || ip(e).length ? (y.setRng(Ix(y.getRng())), X1(e, () => {
              Bf(e, (te, G) => {
                const ne = G ? te : Bm(b, te, c);
                I(b, ne, !1);
              });
            }, ot), e.nodeChanged()) : qx(e, n, o), Yx(e.formatter, n).each((te) => {
              ae(T2(e.selection), (G) => uM(b, G, te, o));
            });
          jg(n, e);
        }
        ti(e, n, r, o);
      }, dM = (e, n, o, r) => {
        (r || e.selection.isEditable()) && z6(e, n, o, r);
      }, mM = (e) => Zn(e, "vars"), V6 = (e, n) => {
        e.set({}), n.on("NodeChange", (o) => {
          gM(n, o.element, e.get());
        }), n.on("FormatApply FormatRemove", (o) => {
          const r = F.from(o.node).map((c) => Y1(c) ? c : c.startContainer).bind((c) => xn(c) ? F.some(c) : F.from(c.parentElement)).getOrThunk(() => b3(n));
          gM(n, r, e.get());
        });
      }, b3 = (e) => e.selection.getStart(), fM = (e, n, o, r, c) => In(n, (b) => {
        const y = e.formatter.matchNode(b, o, c ?? {}, r);
        return !Ht(y);
      }, (b) => VN(e, b, o) ? !0 : r ? !1 : De(e.formatter.matchNode(b, o, c, !0))), Sb = (e, n) => {
        const o = n ?? b3(e);
        return Yt(Q1(e.dom, o), (r) => xn(r) && !nu(r));
      }, gM = (e, n, o) => {
        const r = Sb(e, n);
        Dt(o, (c, u) => {
          const f = (b) => {
            const y = fM(e, r, u, b.similar, mM(b) ? b.vars : void 0), E = y.isSome();
            if (b.state.get() !== E) {
              b.state.set(E);
              const N = y.getOr(n);
              mM(b) ? b.callback(E, {
                node: N,
                format: u,
                parents: r
              }) : ae(b.callbacks, (M) => M(E, {
                node: N,
                format: u,
                parents: r
              }));
            }
          };
          ae([
            c.withSimilar,
            c.withoutSimilar
          ], f), ae(c.withVars, f);
        });
      }, U6 = (e, n, o, r, c, u) => {
        const f = n.get();
        ae(o.split(","), (b) => {
          const y = Ts(f, b).getOrThunk(() => {
            const N = {
              withSimilar: {
                state: jr(!1),
                similar: !0,
                callbacks: []
              },
              withoutSimilar: {
                state: jr(!1),
                similar: !1,
                callbacks: []
              },
              withVars: []
            };
            return f[b] = N, N;
          }), E = () => {
            const N = Sb(e);
            return fM(e, N, b, c, u).isSome();
          };
          if (Ht(u)) {
            const N = c ? y.withSimilar : y.withoutSimilar;
            N.callbacks.push(r), N.callbacks.length === 1 && N.state.set(E());
          } else
            y.withVars.push({
              state: jr(E()),
              similar: c,
              vars: u,
              callback: r
            });
        }), n.set(f);
      }, W6 = (e, n, o) => {
        const r = e.get();
        ae(n.split(","), (c) => Ts(r, c).each((u) => {
          r[c] = {
            withSimilar: {
              ...u.withSimilar,
              callbacks: Yt(u.withSimilar.callbacks, (f) => f !== o)
            },
            withoutSimilar: {
              ...u.withoutSimilar,
              callbacks: Yt(u.withoutSimilar.callbacks, (f) => f !== o)
            },
            withVars: Yt(u.withVars, (f) => f.callback !== o)
          };
        })), e.set(r);
      }, Z6 = (e, n, o, r, c, u) => (U6(e, n, o, r, c, u), { unbind: () => W6(n, o, r) }), hM = (e, n, o, r) => {
        const c = e.formatter.get(n);
        c && (Sv(e, n, o, r) && (!("toggle" in c[0]) || c[0].toggle) ? p3(e, n, o, r) : dM(e, n, o, r));
      }, pM = _t.explode, bM = () => {
        const e = {};
        return {
          addFilter: (c, u) => {
            ae(pM(c), (f) => {
              Zn(e, f) || (e[f] = {
                name: f,
                callbacks: []
              }), e[f].callbacks.push(u);
            });
          },
          getFilters: () => Qr(e),
          removeFilter: (c, u) => {
            ae(pM(c), (f) => {
              if (Zn(e, f))
                if (De(u)) {
                  const b = e[f], y = Yt(b.callbacks, (E) => E !== u);
                  y.length > 0 ? b.callbacks = y : delete e[f];
                } else
                  delete e[f];
            });
          }
        };
      }, j6 = (e, n) => {
        ae(n, (o) => {
          e.attr(o, null);
        });
      }, q6 = (e, n, o) => {
        e.addNodeFilter("font", (r) => {
          ae(r, (c) => {
            const u = n.parse(c.attr("style")), f = c.attr("color"), b = c.attr("face"), y = c.attr("size");
            f && (u.color = f), b && (u["font-family"] = b), y && xa(y).each((E) => {
              u["font-size"] = o[E - 1];
            }), c.name = "span", c.attr("style", n.serialize(u)), j6(c, [
              "color",
              "face",
              "size"
            ]);
          });
        });
      }, G6 = (e, n, o) => {
        e.addNodeFilter("strike", (r) => {
          const c = n.type !== "html4";
          ae(r, (u) => {
            if (c)
              u.name = "s";
            else {
              const f = o.parse(u.attr("style"));
              f["text-decoration"] = "line-through", u.name = "span", u.attr("style", o.serialize(f));
            }
          });
        });
      }, K6 = (e, n, o) => {
        var r;
        const c = l0();
        n.convert_fonts_to_spans && q6(e, c, _t.explode((r = n.font_size_legacy_values) !== null && r !== void 0 ? r : "")), G6(e, o, c);
      }, Y6 = (e, n, o) => {
        n.inline_styles && K6(e, n, o);
      }, vM = (e, n, o) => {
        n.addNodeFilter("br", (r, c, u) => {
          const f = _t.extend({}, o.getBlockElements()), b = o.getNonEmptyElements(), y = o.getWhitespaceElements();
          f.body = 1;
          const E = (N) => N.name in f || Cm(o, N);
          for (let N = 0, M = r.length; N < M; N++) {
            let I = r[N], X = I.parent;
            if (X && E(X) && I === X.lastChild) {
              let te = I.prev;
              for (; te; ) {
                const G = te.name;
                if (G !== "span" || te.attr("data-mce-type") !== "bookmark") {
                  G === "br" && (I = null);
                  break;
                }
                te = te.prev;
              }
              if (I && (I.remove(), wv(o, b, y, X))) {
                const G = o.getElementRule(X.name);
                G && (G.removeEmpty ? X.remove() : G.paddEmpty && Px(e, u, E, X));
              }
            } else {
              let te = I;
              for (; X && X.firstChild === te && X.lastChild === te && (te = X, !f[X.name]); )
                X = X.parent;
              if (te === X) {
                const G = new Ki("#text", 3);
                G.value = _s, I.replace(G);
              }
            }
          }
        });
      }, X6 = (e) => fetch(e).then((n) => n.ok ? n.blob() : Promise.reject()).catch(() => Promise.reject({
        message: `Cannot convert ${e} to Blob. Resource might not exist or is inaccessible.`,
        uriType: "blob"
      })), J6 = (e) => {
        const n = /([a-z0-9+\/=\s]+)/i.exec(e);
        return n ? n[1] : "";
      }, E2 = (e) => {
        const [n, ...o] = e.split(","), r = o.join(","), c = /data:([^/]+\/[^;]+)(;.+)?/.exec(n);
        if (c) {
          const u = c[2] === ";base64", f = u ? J6(r) : decodeURIComponent(r);
          return F.some({
            type: c[1],
            data: f,
            base64Encoded: u
          });
        } else
          return F.none();
      }, v3 = (e, n, o = !0) => {
        let r = n;
        if (o)
          try {
            r = atob(n);
          } catch {
            return F.none();
          }
        const c = new Uint8Array(r.length);
        for (let u = 0; u < c.length; u++)
          c[u] = r.charCodeAt(u);
        return F.some(new Blob([c], { type: e }));
      }, _j = (e) => new Promise((n, o) => {
        E2(e).bind(({ type: r, data: c, base64Encoded: u }) => v3(r, c, u)).fold(() => o("Invalid data URI"), n);
      }), k2 = (e) => Kn(e, "blob:") ? X6(e) : Kn(e, "data:") ? _j(e) : Promise.reject("Unknown URI format"), y3 = (e) => new Promise((n, o) => {
        const r = new FileReader();
        r.onloadend = () => {
          n(r.result);
        }, r.onerror = () => {
          var c;
          o((c = r.error) === null || c === void 0 ? void 0 : c.message);
        }, r.readAsDataURL(e);
      });
      let _2 = 0;
      const A2 = (e) => "blobid" + _2++, C3 = (e, n, o) => E2(e).bind(({ data: r, type: c, base64Encoded: u }) => {
        if (n && !u)
          return F.none();
        {
          const f = u ? r : btoa(r);
          return o(f, c);
        }
      }), Q6 = (e, n, o) => {
        const r = e.create(A2(), n, o);
        return e.add(r), r;
      }, yM = (e, n, o = !1) => C3(n, o, (r, c) => F.from(e.getByData(r, c)).orThunk(() => v3(c, r).map((u) => Q6(e, u, r)))), Aj = (e, n) => {
        const o = () => Promise.reject("Invalid data URI");
        if (Kn(n, "blob:")) {
          const r = e.getByUri(n);
          return De(r) ? Promise.resolve(r) : k2(n).then((c) => y3(c).then((u) => C3(u, !1, (f) => F.some(Q6(e, c, f))).getOrThunk(o)));
        } else return Kn(n, "data:") ? yM(e, n).fold(o, (r) => Promise.resolve(r)) : Promise.reject("Unknown image data format");
      }, e8 = (e) => De(e.attr("data-mce-bogus")), t8 = (e) => e.attr("src") === sn.transparentSrc || De(e.attr("data-mce-placeholder")), Oj = (e, n) => {
        const { blob_cache: o } = n;
        if (o) {
          const r = (c) => {
            const u = c.attr("src");
            t8(c) || e8(c) || gn(u) || yM(o, u, !0).each((f) => {
              c.attr("src", f.blobUri());
            });
          };
          e.addAttributeFilter("src", (c) => ae(c, r));
        }
      }, w3 = (e, n) => Kn(e, `${n}/`), CM = (e, n, o, r, c) => {
        let u;
        Ht(e) ? u = "iframe" : w3(e, "image") ? u = "img" : w3(e, "video") ? u = "video" : w3(e, "audio") ? u = "audio" : u = "iframe";
        const f = new Ki(u, 1);
        return f.attr(u === "audio" ? { src: n } : {
          src: n,
          width: o,
          height: r
        }), (u === "audio" || u === "video") && f.attr("controls", ""), u === "iframe" && c && f.attr("sandbox", ""), f;
      }, n8 = (e, n) => {
        const o = e.schema;
        n.remove_trailing_brs && vM(n, e, o), e.addAttributeFilter("href", (c) => {
          let u = c.length;
          const f = (y) => y.split(" ").filter((N) => N.length > 0).concat(["noopener"]).sort().join(" "), b = (y) => {
            const E = y ? _t.trim(y) : "";
            return /\b(noopener)\b/g.test(E) ? E : f(E);
          };
          if (!n.allow_unsafe_link_target)
            for (; u--; ) {
              const y = c[u];
              y.name === "a" && y.attr("target") === "_blank" && y.attr("rel", b(y.attr("rel")));
            }
        }), n.allow_html_in_named_anchor || e.addAttributeFilter("id,name", (c) => {
          let u = c.length, f, b, y, E;
          for (; u--; )
            if (E = c[u], E.name === "a" && E.firstChild && !E.attr("href"))
              for (y = E.parent, f = E.lastChild; f && y; )
                b = f.prev, y.insert(f, E), f = b;
        }), n.fix_list_elements && e.addNodeFilter("ul,ol", (c) => {
          let u = c.length, f, b;
          for (; u--; )
            if (f = c[u], b = f.parent, b && (b.name === "ul" || b.name === "ol"))
              if (f.prev && f.prev.name === "li")
                f.prev.append(f);
              else {
                const y = new Ki("li", 1);
                y.attr("style", "list-style-type: none"), f.wrap(y);
              }
        });
        const r = o.getValidClasses();
        n.validate && r && e.addAttributeFilter("class", (c) => {
          var u;
          let f = c.length;
          for (; f--; ) {
            const b = c[f], y = (u = b.attr("class")) !== null && u !== void 0 ? u : "", E = _t.explode(y, " ");
            let N = "";
            for (let M = 0; M < E.length; M++) {
              const I = E[M];
              let X = !1, te = r["*"];
              te && te[I] && (X = !0), te = r[b.name], !X && te && te[I] && (X = !0), X && (N && (N += " "), N += I);
            }
            N.length || (N = null), b.attr("class", N);
          }
        }), Oj(e, n), n.convert_unsafe_embeds && e.addNodeFilter("object,embed", (c) => ae(c, (u) => {
          u.replace(CM(u.attr("type"), u.name === "object" ? u.attr("data") : u.attr("src"), u.attr("width"), u.attr("height"), n.sandbox_iframes));
        })), n.sandbox_iframes && e.addNodeFilter("iframe", (c) => ae(c, (u) => u.attr("sandbox", "")));
      };
      /*! @license DOMPurify 3.1.7 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.1.7/LICENSE */
      const {
        entries: S3,
        setPrototypeOf: wM,
        isFrozen: aT,
        getPrototypeOf: SM,
        getOwnPropertyDescriptor: fc
      } = Object;
      let {
        freeze: Wu,
        seal: Wm,
        create: o8
      } = Object, {
        apply: xM,
        construct: Zu
      } = typeof Reflect < "u" && Reflect;
      Wu || (Wu = function(n) {
        return n;
      }), Wm || (Wm = function(n) {
        return n;
      }), xM || (xM = function(n, o, r) {
        return n.apply(o, r);
      }), Zu || (Zu = function(n, o) {
        return new n(...o);
      });
      const xb = wd(Array.prototype.forEach), Gg = wd(Array.prototype.pop), Jd = wd(Array.prototype.push), cT = wd(String.prototype.toLowerCase), x3 = wd(String.prototype.toString), Tb = wd(String.prototype.match), Uf = wd(String.prototype.replace), kv = wd(String.prototype.indexOf), TM = wd(String.prototype.trim), Cd = wd(Object.prototype.hasOwnProperty), Ul = wd(RegExp.prototype.test), _v = s8(TypeError);
      function wd(e) {
        return function(n) {
          for (var o = arguments.length, r = new Array(o > 1 ? o - 1 : 0), c = 1; c < o; c++)
            r[c - 1] = arguments[c];
          return xM(e, n, r);
        };
      }
      function s8(e) {
        return function() {
          for (var n = arguments.length, o = new Array(n), r = 0; r < n; r++)
            o[r] = arguments[r];
          return Zu(e, o);
        };
      }
      function Cr(e, n) {
        let o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : cT;
        wM && wM(e, null);
        let r = n.length;
        for (; r--; ) {
          let c = n[r];
          if (typeof c == "string") {
            const u = o(c);
            u !== c && (aT(n) || (n[r] = u), c = u);
          }
          e[c] = !0;
        }
        return e;
      }
      function r8(e) {
        for (let n = 0; n < e.length; n++)
          Cd(e, n) || (e[n] = null);
        return e;
      }
      function Eb(e) {
        const n = o8(null);
        for (const [o, r] of S3(e))
          Cd(e, o) && (Array.isArray(r) ? n[o] = r8(r) : r && typeof r == "object" && r.constructor === Object ? n[o] = Eb(r) : n[o] = r);
        return n;
      }
      function O2(e, n) {
        for (; e !== null; ) {
          const r = fc(e, n);
          if (r) {
            if (r.get)
              return wd(r.get);
            if (typeof r.value == "function")
              return wd(r.value);
          }
          e = SM(e);
        }
        function o() {
          return null;
        }
        return o;
      }
      const EM = Wu(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), T3 = Wu(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), iT = Wu(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), a8 = Wu(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), kb = Wu(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), kM = Wu(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), _M = Wu(["#text"]), E3 = Wu(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), k3 = Wu(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), _3 = Wu(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), lT = Wu(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), c8 = Wm(/\{\{[\w\W]*|[\w\W]*\}\}/gm), AM = Wm(/<%[\w\W]*|[\w\W]*%>/gm), OM = Wm(/\${[\w\W]*}/gm), DM = Wm(/^data-[\-\w.\u00B7-\uFFFF]/), RM = Wm(/^aria-[\-\w]+$/), A3 = Wm(
        /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
        // eslint-disable-line no-useless-escape
      ), NM = Wm(/^(?:\w+script|data):/i), i8 = Wm(
        /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
        // eslint-disable-line no-control-regex
      ), MM = Wm(/^html$/i), l8 = Wm(/^[a-z][.\w]*(-[.\w]+)+$/i);
      var uT = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        MUSTACHE_EXPR: c8,
        ERB_EXPR: AM,
        TMPLIT_EXPR: OM,
        DATA_ATTR: DM,
        ARIA_ATTR: RM,
        IS_ALLOWED_URI: A3,
        IS_SCRIPT_OR_DATA: NM,
        ATTR_WHITESPACE: i8,
        DOCTYPE_NAME: MM,
        CUSTOM_ELEMENT: l8
      });
      const Kg = {
        element: 1,
        text: 3,
        // Deprecated
        progressingInstruction: 7,
        comment: 8,
        document: 9
      }, PM = function() {
        return typeof window > "u" ? null : window;
      }, BM = function(n, o) {
        if (typeof n != "object" || typeof n.createPolicy != "function")
          return null;
        let r = null;
        const c = "data-tt-policy-suffix";
        o && o.hasAttribute(c) && (r = o.getAttribute(c));
        const u = "dompurify" + (r ? "#" + r : "");
        try {
          return n.createPolicy(u, {
            createHTML(f) {
              return f;
            },
            createScriptURL(f) {
              return f;
            }
          });
        } catch {
          return null;
        }
      };
      function D2() {
        let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : PM();
        const n = (Yo) => D2(Yo);
        if (n.version = "3.1.7", n.removed = [], !e || !e.document || e.document.nodeType !== Kg.document)
          return n.isSupported = !1, n;
        let {
          document: o
        } = e;
        const r = o, c = r.currentScript, {
          DocumentFragment: u,
          HTMLTemplateElement: f,
          Node: b,
          Element: y,
          NodeFilter: E,
          NamedNodeMap: N = e.NamedNodeMap || e.MozNamedAttrMap,
          HTMLFormElement: M,
          DOMParser: I,
          trustedTypes: X
        } = e, te = y.prototype, G = O2(te, "cloneNode"), ne = O2(te, "remove"), Se = O2(te, "nextSibling"), ke = O2(te, "childNodes"), Ae = O2(te, "parentNode");
        if (typeof f == "function") {
          const Yo = o.createElement("template");
          Yo.content && Yo.content.ownerDocument && (o = Yo.content.ownerDocument);
        }
        let Me, pt = "";
        const {
          implementation: It,
          createNodeIterator: un,
          createDocumentFragment: nt,
          getElementsByTagName: qe
        } = o, {
          importNode: xt
        } = r;
        let bn = {};
        n.isSupported = typeof S3 == "function" && typeof Ae == "function" && It && It.createHTMLDocument !== void 0;
        const {
          MUSTACHE_EXPR: Yn,
          ERB_EXPR: Po,
          TMPLIT_EXPR: Ko,
          DATA_ATTR: er,
          ARIA_ATTR: Er,
          IS_SCRIPT_OR_DATA: wa,
          ATTR_WHITESPACE: si,
          CUSTOM_ELEMENT: kc
        } = uT;
        let {
          IS_ALLOWED_URI: Gt
        } = uT, vn = null;
        const As = Cr({}, [...EM, ...T3, ...iT, ...kb, ..._M]);
        let vs = null;
        const zn = Cr({}, [...E3, ...k3, ..._3, ...lT]);
        let Un = Object.seal(o8(null, {
          tagNameCheck: {
            writable: !0,
            configurable: !1,
            enumerable: !0,
            value: null
          },
          attributeNameCheck: {
            writable: !0,
            configurable: !1,
            enumerable: !0,
            value: null
          },
          allowCustomizedBuiltInElements: {
            writable: !0,
            configurable: !1,
            enumerable: !0,
            value: !1
          }
        })), zt = null, Eo = null, hs = !0, nr = !0, kr = !1, Qi = !0, hu = !1, Yf = !0, el = !1, rm = !1, Do = !1, ps = !1, Ls = !1, Gr = !1, ra = !0, _d = !1;
        const iy = "user-content-";
        let ly = !0, Xf = !1, Jf = {}, Kp = null;
        const uy = Cr({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
        let Aw = null;
        const ik = Cr({}, ["audio", "video", "img", "source", "image", "track"]);
        let Wb = null;
        const lk = Cr({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), Yp = "http://www.w3.org/1998/Math/MathML", dy = "http://www.w3.org/2000/svg", am = "http://www.w3.org/1999/xhtml";
        let Qf = am, my = !1, fy = null;
        const Ow = Cr({}, [Yp, dy, am], x3);
        let Zb = null;
        const $4 = ["application/xhtml+xml", "text/html"], uk = "text/html";
        let Ci = null, Xp = null;
        const nh = o.createElement("form"), Dw = function(Ge) {
          return Ge instanceof RegExp || Ge instanceof Function;
        }, He = function() {
          let Ge = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          if (!(Xp && Xp === Ge)) {
            if ((!Ge || typeof Ge != "object") && (Ge = {}), Ge = Eb(Ge), Zb = // eslint-disable-next-line unicorn/prefer-includes
            $4.indexOf(Ge.PARSER_MEDIA_TYPE) === -1 ? uk : Ge.PARSER_MEDIA_TYPE, Ci = Zb === "application/xhtml+xml" ? x3 : cT, vn = Cd(Ge, "ALLOWED_TAGS") ? Cr({}, Ge.ALLOWED_TAGS, Ci) : As, vs = Cd(Ge, "ALLOWED_ATTR") ? Cr({}, Ge.ALLOWED_ATTR, Ci) : zn, fy = Cd(Ge, "ALLOWED_NAMESPACES") ? Cr({}, Ge.ALLOWED_NAMESPACES, x3) : Ow, Wb = Cd(Ge, "ADD_URI_SAFE_ATTR") ? Cr(
              Eb(lk),
              // eslint-disable-line indent
              Ge.ADD_URI_SAFE_ATTR,
              // eslint-disable-line indent
              Ci
              // eslint-disable-line indent
            ) : lk, Aw = Cd(Ge, "ADD_DATA_URI_TAGS") ? Cr(
              Eb(ik),
              // eslint-disable-line indent
              Ge.ADD_DATA_URI_TAGS,
              // eslint-disable-line indent
              Ci
              // eslint-disable-line indent
            ) : ik, Kp = Cd(Ge, "FORBID_CONTENTS") ? Cr({}, Ge.FORBID_CONTENTS, Ci) : uy, zt = Cd(Ge, "FORBID_TAGS") ? Cr({}, Ge.FORBID_TAGS, Ci) : {}, Eo = Cd(Ge, "FORBID_ATTR") ? Cr({}, Ge.FORBID_ATTR, Ci) : {}, Jf = Cd(Ge, "USE_PROFILES") ? Ge.USE_PROFILES : !1, hs = Ge.ALLOW_ARIA_ATTR !== !1, nr = Ge.ALLOW_DATA_ATTR !== !1, kr = Ge.ALLOW_UNKNOWN_PROTOCOLS || !1, Qi = Ge.ALLOW_SELF_CLOSE_IN_ATTR !== !1, hu = Ge.SAFE_FOR_TEMPLATES || !1, Yf = Ge.SAFE_FOR_XML !== !1, el = Ge.WHOLE_DOCUMENT || !1, ps = Ge.RETURN_DOM || !1, Ls = Ge.RETURN_DOM_FRAGMENT || !1, Gr = Ge.RETURN_TRUSTED_TYPE || !1, Do = Ge.FORCE_BODY || !1, ra = Ge.SANITIZE_DOM !== !1, _d = Ge.SANITIZE_NAMED_PROPS || !1, ly = Ge.KEEP_CONTENT !== !1, Xf = Ge.IN_PLACE || !1, Gt = Ge.ALLOWED_URI_REGEXP || A3, Qf = Ge.NAMESPACE || am, Un = Ge.CUSTOM_ELEMENT_HANDLING || {}, Ge.CUSTOM_ELEMENT_HANDLING && Dw(Ge.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (Un.tagNameCheck = Ge.CUSTOM_ELEMENT_HANDLING.tagNameCheck), Ge.CUSTOM_ELEMENT_HANDLING && Dw(Ge.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (Un.attributeNameCheck = Ge.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), Ge.CUSTOM_ELEMENT_HANDLING && typeof Ge.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (Un.allowCustomizedBuiltInElements = Ge.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), hu && (nr = !1), Ls && (ps = !0), Jf && (vn = Cr({}, _M), vs = [], Jf.html === !0 && (Cr(vn, EM), Cr(vs, E3)), Jf.svg === !0 && (Cr(vn, T3), Cr(vs, k3), Cr(vs, lT)), Jf.svgFilters === !0 && (Cr(vn, iT), Cr(vs, k3), Cr(vs, lT)), Jf.mathMl === !0 && (Cr(vn, kb), Cr(vs, _3), Cr(vs, lT))), Ge.ADD_TAGS && (vn === As && (vn = Eb(vn)), Cr(vn, Ge.ADD_TAGS, Ci)), Ge.ADD_ATTR && (vs === zn && (vs = Eb(vs)), Cr(vs, Ge.ADD_ATTR, Ci)), Ge.ADD_URI_SAFE_ATTR && Cr(Wb, Ge.ADD_URI_SAFE_ATTR, Ci), Ge.FORBID_CONTENTS && (Kp === uy && (Kp = Eb(Kp)), Cr(Kp, Ge.FORBID_CONTENTS, Ci)), ly && (vn["#text"] = !0), el && Cr(vn, ["html", "head", "body"]), vn.table && (Cr(vn, ["tbody"]), delete zt.tbody), Ge.TRUSTED_TYPES_POLICY) {
              if (typeof Ge.TRUSTED_TYPES_POLICY.createHTML != "function")
                throw _v('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
              if (typeof Ge.TRUSTED_TYPES_POLICY.createScriptURL != "function")
                throw _v('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
              Me = Ge.TRUSTED_TYPES_POLICY, pt = Me.createHTML("");
            } else
              Me === void 0 && (Me = BM(X, c)), Me !== null && typeof pt == "string" && (pt = Me.createHTML(""));
            Wu && Wu(Ge), Xp = Ge;
          }
        }, Ze = Cr({}, ["mi", "mo", "mn", "ms", "mtext"]), jt = Cr({}, ["annotation-xml"]), Lt = Cr({}, ["title", "style", "font", "a", "script"]), so = Cr({}, [...T3, ...iT, ...a8]), us = Cr({}, [...kb, ...kM]), Kr = function(Ge) {
          let qn = Ae(Ge);
          (!qn || !qn.tagName) && (qn = {
            namespaceURI: Qf,
            tagName: "template"
          });
          const Uo = cT(Ge.tagName), Wa = cT(qn.tagName);
          return fy[Ge.namespaceURI] ? Ge.namespaceURI === dy ? qn.namespaceURI === am ? Uo === "svg" : qn.namespaceURI === Yp ? Uo === "svg" && (Wa === "annotation-xml" || Ze[Wa]) : !!so[Uo] : Ge.namespaceURI === Yp ? qn.namespaceURI === am ? Uo === "math" : qn.namespaceURI === dy ? Uo === "math" && jt[Wa] : !!us[Uo] : Ge.namespaceURI === am ? qn.namespaceURI === dy && !jt[Wa] || qn.namespaceURI === Yp && !Ze[Wa] ? !1 : !us[Uo] && (Lt[Uo] || !so[Uo]) : !!(Zb === "application/xhtml+xml" && fy[Ge.namespaceURI]) : !1;
        }, Ua = function(Ge) {
          Jd(n.removed, {
            element: Ge
          });
          try {
            Ae(Ge).removeChild(Ge);
          } catch {
            ne(Ge);
          }
        }, sc = function(Ge, qn) {
          try {
            Jd(n.removed, {
              attribute: qn.getAttributeNode(Ge),
              from: qn
            });
          } catch {
            Jd(n.removed, {
              attribute: null,
              from: qn
            });
          }
          if (qn.removeAttribute(Ge), Ge === "is" && !vs[Ge])
            if (ps || Ls)
              try {
                Ua(qn);
              } catch {
              }
            else
              try {
                qn.setAttribute(Ge, "");
              } catch {
              }
        }, gy = function(Ge) {
          let qn = null, Uo = null;
          if (Do)
            Ge = "<remove></remove>" + Ge;
          else {
            const tl = Tb(Ge, /^[\r\n\t ]+/);
            Uo = tl && tl[0];
          }
          Zb === "application/xhtml+xml" && Qf === am && (Ge = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + Ge + "</body></html>");
          const Wa = Me ? Me.createHTML(Ge) : Ge;
          if (Qf === am)
            try {
              qn = new I().parseFromString(Wa, Zb);
            } catch {
            }
          if (!qn || !qn.documentElement) {
            qn = It.createDocument(Qf, "template", null);
            try {
              qn.documentElement.innerHTML = my ? pt : Wa;
            } catch {
            }
          }
          const bl = qn.body || qn.documentElement;
          return Ge && Uo && bl.insertBefore(o.createTextNode(Uo), bl.childNodes[0] || null), Qf === am ? qe.call(qn, el ? "html" : "body")[0] : el ? qn.documentElement : bl;
        }, hy = function(Ge) {
          return un.call(
            Ge.ownerDocument || Ge,
            Ge,
            // eslint-disable-next-line no-bitwise
            E.SHOW_ELEMENT | E.SHOW_COMMENT | E.SHOW_TEXT | E.SHOW_PROCESSING_INSTRUCTION | E.SHOW_CDATA_SECTION,
            null
          );
        }, dk = function(Ge) {
          return Ge instanceof M && (typeof Ge.nodeName != "string" || typeof Ge.textContent != "string" || typeof Ge.removeChild != "function" || !(Ge.attributes instanceof N) || typeof Ge.removeAttribute != "function" || typeof Ge.setAttribute != "function" || typeof Ge.namespaceURI != "string" || typeof Ge.insertBefore != "function" || typeof Ge.hasChildNodes != "function");
        }, F4 = function(Ge) {
          return typeof b == "function" && Ge instanceof b;
        }, eg = function(Ge, qn, Uo) {
          bn[Ge] && xb(bn[Ge], (Wa) => {
            Wa.call(n, qn, Uo, Xp);
          });
        }, PI = function(Ge) {
          let qn = null;
          if (eg("beforeSanitizeElements", Ge, null), dk(Ge))
            return Ua(Ge), !0;
          const Uo = Ci(Ge.nodeName);
          if (eg("uponSanitizeElement", Ge, {
            tagName: Uo,
            allowedTags: vn
          }), Ge.hasChildNodes() && !F4(Ge.firstElementChild) && Ul(/<[/\w]/g, Ge.innerHTML) && Ul(/<[/\w]/g, Ge.textContent) || Ge.nodeType === Kg.progressingInstruction || Yf && Ge.nodeType === Kg.comment && Ul(/<[/\w]/g, Ge.data))
            return Ua(Ge), !0;
          if (!vn[Uo] || zt[Uo]) {
            if (!zt[Uo] && BI(Uo) && (Un.tagNameCheck instanceof RegExp && Ul(Un.tagNameCheck, Uo) || Un.tagNameCheck instanceof Function && Un.tagNameCheck(Uo)))
              return !1;
            if (ly && !Kp[Uo]) {
              const Wa = Ae(Ge) || Ge.parentNode, bl = ke(Ge) || Ge.childNodes;
              if (bl && Wa) {
                const tl = bl.length;
                for (let pu = tl - 1; pu >= 0; --pu) {
                  const cm = G(bl[pu], !0);
                  cm.__removalCount = (Ge.__removalCount || 0) + 1, Wa.insertBefore(cm, Se(Ge));
                }
              }
            }
            return Ua(Ge), !0;
          }
          return Ge instanceof y && !Kr(Ge) || (Uo === "noscript" || Uo === "noembed" || Uo === "noframes") && Ul(/<\/no(script|embed|frames)/i, Ge.innerHTML) ? (Ua(Ge), !0) : (hu && Ge.nodeType === Kg.text && (qn = Ge.textContent, xb([Yn, Po, Ko], (Wa) => {
            qn = Uf(qn, Wa, " ");
          }), Ge.textContent !== qn && (Jd(n.removed, {
            element: Ge.cloneNode()
          }), Ge.textContent = qn)), eg("afterSanitizeElements", Ge, null), !1);
        }, I4 = function(Ge, qn, Uo) {
          if (ra && (qn === "id" || qn === "name") && (Uo in o || Uo in nh))
            return !1;
          if (!(nr && !Eo[qn] && Ul(er, qn))) {
            if (!(hs && Ul(Er, qn))) {
              if (!vs[qn] || Eo[qn]) {
                if (
                  // First condition does a very basic check if a) it's basically a valid custom element tagname AND
                  // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
                  // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
                  !(BI(Ge) && (Un.tagNameCheck instanceof RegExp && Ul(Un.tagNameCheck, Ge) || Un.tagNameCheck instanceof Function && Un.tagNameCheck(Ge)) && (Un.attributeNameCheck instanceof RegExp && Ul(Un.attributeNameCheck, qn) || Un.attributeNameCheck instanceof Function && Un.attributeNameCheck(qn)) || // Alternative, second condition checks if it's an `is`-attribute, AND
                  // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
                  qn === "is" && Un.allowCustomizedBuiltInElements && (Un.tagNameCheck instanceof RegExp && Ul(Un.tagNameCheck, Uo) || Un.tagNameCheck instanceof Function && Un.tagNameCheck(Uo)))
                ) return !1;
              } else if (!Wb[qn]) {
                if (!Ul(Gt, Uf(Uo, si, ""))) {
                  if (!((qn === "src" || qn === "xlink:href" || qn === "href") && Ge !== "script" && kv(Uo, "data:") === 0 && Aw[Ge])) {
                    if (!(kr && !Ul(wa, Uf(Uo, si, "")))) {
                      if (Uo)
                        return !1;
                    }
                  }
                }
              }
            }
          }
          return !0;
        }, BI = function(Ge) {
          return Ge !== "annotation-xml" && Tb(Ge, kc);
        }, $I = function(Ge) {
          eg("beforeSanitizeAttributes", Ge, null);
          const {
            attributes: qn
          } = Ge;
          if (!qn)
            return;
          const Uo = {
            attrName: "",
            attrValue: "",
            keepAttr: !0,
            allowedAttributes: vs
          };
          let Wa = qn.length;
          for (; Wa--; ) {
            const bl = qn[Wa], {
              name: tl,
              namespaceURI: pu,
              value: cm
            } = bl, Rw = Ci(tl);
            let vl = tl === "value" ? cm : TM(cm);
            const FI = vl;
            if (Uo.attrName = Rw, Uo.attrValue = vl, Uo.keepAttr = !0, Uo.forceKeepAttr = void 0, eg("uponSanitizeAttribute", Ge, Uo), vl = Uo.attrValue, Uo.forceKeepAttr)
              continue;
            if (!Uo.keepAttr) {
              sc(tl, Ge);
              continue;
            }
            if (!Qi && Ul(/\/>/i, vl)) {
              sc(tl, Ge);
              continue;
            }
            hu && xb([Yn, Po, Ko], (LI) => {
              vl = Uf(vl, LI, " ");
            });
            const II = Ci(Ge.nodeName);
            if (!I4(II, Rw, vl)) {
              sc(tl, Ge);
              continue;
            }
            if (_d && (Rw === "id" || Rw === "name") && (sc(tl, Ge), vl = iy + vl), Yf && Ul(/((--!?|])>)|<\/(style|title)/i, vl)) {
              sc(tl, Ge);
              continue;
            }
            if (Me && typeof X == "object" && typeof X.getAttributeType == "function" && !pu)
              switch (X.getAttributeType(II, Rw)) {
                case "TrustedHTML": {
                  vl = Me.createHTML(vl);
                  break;
                }
                case "TrustedScriptURL": {
                  vl = Me.createScriptURL(vl);
                  break;
                }
              }
            if (vl !== FI)
              try {
                pu ? Ge.setAttributeNS(pu, tl, vl) : Ge.setAttribute(tl, vl), dk(Ge) ? Ua(Ge) : Gg(n.removed);
              } catch {
              }
          }
          eg("afterSanitizeAttributes", Ge, null);
        }, cj = function Yo(Ge) {
          let qn = null;
          const Uo = hy(Ge);
          for (eg("beforeSanitizeShadowDOM", Ge, null); qn = Uo.nextNode(); )
            eg("uponSanitizeShadowNode", qn, null), !PI(qn) && (qn.content instanceof u && Yo(qn.content), $I(qn));
          eg("afterSanitizeShadowDOM", Ge, null);
        };
        return n.sanitize = function(Yo) {
          let Ge = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, qn = null, Uo = null, Wa = null, bl = null;
          if (my = !Yo, my && (Yo = "<!-->"), typeof Yo != "string" && !F4(Yo))
            if (typeof Yo.toString == "function") {
              if (Yo = Yo.toString(), typeof Yo != "string")
                throw _v("dirty is not a string, aborting");
            } else
              throw _v("toString is not a function");
          if (!n.isSupported)
            return Yo;
          if (rm || He(Ge), n.removed = [], typeof Yo == "string" && (Xf = !1), Xf) {
            if (Yo.nodeName) {
              const cm = Ci(Yo.nodeName);
              if (!vn[cm] || zt[cm])
                throw _v("root node is forbidden and cannot be sanitized in-place");
            }
          } else if (Yo instanceof b)
            qn = gy("<!---->"), Uo = qn.ownerDocument.importNode(Yo, !0), Uo.nodeType === Kg.element && Uo.nodeName === "BODY" || Uo.nodeName === "HTML" ? qn = Uo : qn.appendChild(Uo);
          else {
            if (!ps && !hu && !el && // eslint-disable-next-line unicorn/prefer-includes
            Yo.indexOf("<") === -1)
              return Me && Gr ? Me.createHTML(Yo) : Yo;
            if (qn = gy(Yo), !qn)
              return ps ? null : Gr ? pt : "";
          }
          qn && Do && Ua(qn.firstChild);
          const tl = hy(Xf ? Yo : qn);
          for (; Wa = tl.nextNode(); )
            PI(Wa) || (Wa.content instanceof u && cj(Wa.content), $I(Wa));
          if (Xf)
            return Yo;
          if (ps) {
            if (Ls)
              for (bl = nt.call(qn.ownerDocument); qn.firstChild; )
                bl.appendChild(qn.firstChild);
            else
              bl = qn;
            return (vs.shadowroot || vs.shadowrootmode) && (bl = xt.call(r, bl, !0)), bl;
          }
          let pu = el ? qn.outerHTML : qn.innerHTML;
          return el && vn["!doctype"] && qn.ownerDocument && qn.ownerDocument.doctype && qn.ownerDocument.doctype.name && Ul(MM, qn.ownerDocument.doctype.name) && (pu = "<!DOCTYPE " + qn.ownerDocument.doctype.name + `>
` + pu), hu && xb([Yn, Po, Ko], (cm) => {
            pu = Uf(pu, cm, " ");
          }), Me && Gr ? Me.createHTML(pu) : pu;
        }, n.setConfig = function() {
          let Yo = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          He(Yo), rm = !0;
        }, n.clearConfig = function() {
          Xp = null, rm = !1;
        }, n.isValidAttribute = function(Yo, Ge, qn) {
          Xp || He({});
          const Uo = Ci(Yo), Wa = Ci(Ge);
          return I4(Uo, Wa, qn);
        }, n.addHook = function(Yo, Ge) {
          typeof Ge == "function" && (bn[Yo] = bn[Yo] || [], Jd(bn[Yo], Ge));
        }, n.removeHook = function(Yo) {
          if (bn[Yo])
            return Gg(bn[Yo]);
        }, n.removeHooks = function(Yo) {
          bn[Yo] && (bn[Yo] = []);
        }, n.removeAllHooks = function() {
          bn = {};
        }, n;
      }
      var $M = D2();
      const FM = _t.each, Ap = _t.trim, O3 = [
        "source",
        "protocol",
        "authority",
        "userInfo",
        "user",
        "password",
        "host",
        "port",
        "relative",
        "path",
        "directory",
        "file",
        "query",
        "anchor"
      ], IM = {
        ftp: 21,
        http: 80,
        https: 443,
        mailto: 25
      }, R2 = [
        "img",
        "video"
      ], LM = (e, n) => De(e) ? !e : De(n) ? !ee(R2, n) : !0, D3 = (e) => {
        try {
          return decodeURIComponent(e);
        } catch {
          return unescape(e);
        }
      }, R3 = (e, n, o) => {
        const r = D3(n).replace(/\s/g, "");
        return e.allow_script_urls ? !1 : /((java|vb)script|mhtml):/i.test(r) ? !0 : e.allow_html_data_urls ? !1 : /^data:image\//i.test(r) ? LM(e.allow_svg_data_urls, o) && /^data:image\/svg\+xml/i.test(r) : /^data:/i.test(r);
      };
      class Sd {
        static parseDataUri(n) {
          let o;
          const r = decodeURIComponent(n).split(","), c = /data:([^;]+)/.exec(r[0]);
          return c && (o = c[1]), {
            type: o,
            data: r[1]
          };
        }
        static isDomSafe(n, o, r = {}) {
          if (r.allow_script_urls)
            return !0;
          {
            const c = wg.decode(n).replace(/[\s\u0000-\u001F]+/g, "");
            return !R3(r, c, o);
          }
        }
        static getDocumentBaseUrl(n) {
          var o;
          let r;
          return n.protocol.indexOf("http") !== 0 && n.protocol !== "file:" ? r = (o = n.href) !== null && o !== void 0 ? o : "" : r = n.protocol + "//" + n.host + n.pathname, /^[^:]+:\/\/\/?[^\/]+\//.test(r) && (r = r.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, ""), /[\/\\]$/.test(r) || (r += "/")), r;
        }
        constructor(n, o = {}) {
          this.path = "", this.directory = "", n = Ap(n), this.settings = o;
          const r = o.base_uri, c = this;
          if (/^([\w\-]+):([^\/]{2})/i.test(n) || /^\s*#/.test(n)) {
            c.source = n;
            return;
          }
          const u = n.indexOf("//") === 0;
          if (n.indexOf("/") === 0 && !u && (n = (r && r.protocol || "http") + "://mce_host" + n), !/^[\w\-]*:?\/\//.test(n)) {
            const b = r ? r.path : new Sd(document.location.href).directory;
            if (r?.protocol === "")
              n = "//mce_host" + c.toAbsPath(b, n);
            else {
              const y = /([^#?]*)([#?]?.*)/.exec(n);
              y && (n = (r && r.protocol || "http") + "://mce_host" + c.toAbsPath(b, y[1]) + y[2]);
            }
          }
          n = n.replace(/@@/g, "(mce_at)");
          const f = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@\/]*):?([^:@\/]*))?@)?(\[[a-zA-Z0-9:.%]+\]|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/.exec(n);
          f && FM(O3, (b, y) => {
            let E = f[y];
            E && (E = E.replace(/\(mce_at\)/g, "@@")), c[b] = E;
          }), r && (c.protocol || (c.protocol = r.protocol), c.userInfo || (c.userInfo = r.userInfo), !c.port && c.host === "mce_host" && (c.port = r.port), (!c.host || c.host === "mce_host") && (c.host = r.host), c.source = ""), u && (c.protocol = "");
        }
        setPath(n) {
          const o = /^(.*?)\/?(\w+)?$/.exec(n);
          o && (this.path = o[0], this.directory = o[1], this.file = o[2]), this.source = "", this.getURI();
        }
        toRelative(n) {
          if (n === "./")
            return n;
          const o = new Sd(n, { base_uri: this });
          if (o.host !== "mce_host" && this.host !== o.host && o.host || this.port !== o.port || this.protocol !== o.protocol && o.protocol !== "")
            return o.getURI();
          const r = this.getURI(), c = o.getURI();
          if (r === c || r.charAt(r.length - 1) === "/" && r.substr(0, r.length - 1) === c)
            return r;
          let u = this.toRelPath(this.path, o.path);
          return o.query && (u += "?" + o.query), o.anchor && (u += "#" + o.anchor), u;
        }
        toAbsolute(n, o) {
          const r = new Sd(n, { base_uri: this });
          return r.getURI(o && this.isSameOrigin(r));
        }
        isSameOrigin(n) {
          if (this.host == n.host && this.protocol == n.protocol) {
            if (this.port == n.port)
              return !0;
            const o = this.protocol ? IM[this.protocol] : null;
            if (o && (this.port || o) == (n.port || o))
              return !0;
          }
          return !1;
        }
        toRelPath(n, o) {
          let r = 0, c = "", u, f;
          const b = n.substring(0, n.lastIndexOf("/")).split("/"), y = o.split("/");
          if (b.length >= y.length) {
            for (u = 0, f = b.length; u < f; u++)
              if (u >= y.length || b[u] !== y[u]) {
                r = u + 1;
                break;
              }
          }
          if (b.length < y.length) {
            for (u = 0, f = y.length; u < f; u++)
              if (u >= b.length || b[u] !== y[u]) {
                r = u + 1;
                break;
              }
          }
          if (r === 1)
            return o;
          for (u = 0, f = b.length - (r - 1); u < f; u++)
            c += "../";
          for (u = r - 1, f = y.length; u < f; u++)
            u !== r - 1 ? c += "/" + y[u] : c += y[u];
          return c;
        }
        toAbsPath(n, o) {
          let r = 0;
          const c = /\/$/.test(o) ? "/" : "", u = n.split("/"), f = o.split("/"), b = [];
          FM(u, (M) => {
            M && b.push(M);
          });
          const y = [];
          for (let M = f.length - 1; M >= 0; M--)
            if (!(f[M].length === 0 || f[M] === ".")) {
              if (f[M] === "..") {
                r++;
                continue;
              }
              if (r > 0) {
                r--;
                continue;
              }
              y.push(f[M]);
            }
          const E = b.length - r;
          let N;
          return E <= 0 ? N = Ao(y).join("/") : N = b.slice(0, E).join("/") + "/" + Ao(y).join("/"), N.indexOf("/") !== 0 && (N = "/" + N), c && N.lastIndexOf("/") !== N.length - 1 && (N += c), N;
        }
        getURI(n = !1) {
          let o;
          return (!this.source || n) && (o = "", n || (this.protocol ? o += this.protocol + "://" : o += "//", this.userInfo && (o += this.userInfo + "@"), this.host && (o += this.host), this.port && (o += ":" + this.port)), this.path && (o += this.path), this.query && (o += "?" + this.query), this.anchor && (o += "#" + this.anchor), this.source = o), this.source;
        }
      }
      const u8 = _t.makeMap("src,href,data,background,action,formaction,poster,xlink:href"), N3 = "data-mce-type";
      let HM = 0;
      const dT = (e, n, o, r, c) => {
        var u, f, b, y;
        const E = n.validate, N = o.getSpecialElements();
        e.nodeType === ai && !n.allow_conditional_comments && /^\[if/i.test((u = e.nodeValue) !== null && u !== void 0 ? u : "") && (e.nodeValue = " " + e.nodeValue);
        const M = (f = c?.tagName) !== null && f !== void 0 ? f : e.nodeName.toLowerCase();
        if (r !== "html" && o.isValid(r)) {
          De(c) && (c.allowedTags[M] = !0);
          return;
        }
        if (e.nodeType !== Rc || M === "body")
          return;
        const I = le.fromDom(e), X = ea(I, N3), te = ia(I, "data-mce-bogus");
        if (!X && J(te)) {
          te === "all" ? bs(I) : qc(I);
          return;
        }
        const G = o.getElementRule(M);
        if (E && !G) {
          Zn(N, M) ? bs(I) : qc(I);
          return;
        } else
          De(c) && (c.allowedTags[M] = !0);
        if (E && G && !X) {
          if (ae((b = G.attributesForced) !== null && b !== void 0 ? b : [], (ne) => {
            ks(I, ne.name, ne.value === "{$uid}" ? `mce_${HM++}` : ne.value);
          }), ae((y = G.attributesDefault) !== null && y !== void 0 ? y : [], (ne) => {
            ea(I, ne.name) || ks(I, ne.name, ne.value === "{$uid}" ? `mce_${HM++}` : ne.value);
          }), G.attributesRequired && !pe(G.attributesRequired, (ne) => ea(I, ne))) {
            qc(I);
            return;
          }
          if (G.removeEmptyAttrs && Vr(I)) {
            qc(I);
            return;
          }
          G.outputName && G.outputName !== M && ld(I, G.outputName);
        }
      }, d8 = (e, n, o, r, c) => {
        const u = e.tagName.toLowerCase(), { attrName: f, attrValue: b } = c;
        c.keepAttr = M3(n, o, r, u, f, b), c.keepAttr ? (c.allowedAttributes[f] = !0, VM(f, o) && (c.attrValue = f), n.allow_svg_data_urls && Kn(b, "data:image/svg+xml") && (c.forceKeepAttr = !0)) : zM(e, f) && (c.forceKeepAttr = !0);
      }, M3 = (e, n, o, r, c, u) => o !== "html" && !ad(r) ? !0 : !(c in u8 && R3(e, u, r)) && (!e.validate || n.isValid(r, c) || Kn(c, "data-") || Kn(c, "aria-")), zM = (e, n) => e.hasAttribute(N3) && (n === "id" || n === "class" || n === "style"), VM = (e, n) => e in n.getBoolAttrs(), m8 = (e, n, o, r) => {
        const { attributes: c } = e;
        for (let u = c.length - 1; u >= 0; u--) {
          const f = c[u], b = f.name, y = f.value;
          !M3(n, o, r, e.tagName.toLowerCase(), b, y) && !zM(e, b) ? e.removeAttribute(b) : VM(b, o) && e.setAttribute(b, b);
        }
      }, f8 = (e, n, o) => {
        const r = $M();
        return r.addHook("uponSanitizeElement", (c, u) => {
          dT(c, e, n, o.track(c), u);
        }), r.addHook("uponSanitizeAttribute", (c, u) => {
          d8(c, e, n, o.current(), u);
        }), r;
      }, g8 = (e, n) => {
        const r = { ...{
          IN_PLACE: !0,
          ALLOW_UNKNOWN_PROTOCOLS: !0,
          ALLOWED_TAGS: [
            "#comment",
            "#cdata-section",
            "body"
          ],
          ALLOWED_ATTR: [],
          SAFE_FOR_XML: !1
        } };
        return r.PARSER_MEDIA_TYPE = n, e.allow_script_urls ? r.ALLOWED_URI_REGEXP = /.*/ : e.allow_html_data_urls && (r.ALLOWED_URI_REGEXP = /^(?!(\w+script|mhtml):)/i), r;
      }, h8 = (e) => {
        const n = [
          "type",
          "href",
          "role",
          "arcrole",
          "title",
          "show",
          "actuate",
          "label",
          "from",
          "to"
        ].map((r) => `xlink:${r}`), o = {
          IN_PLACE: !0,
          USE_PROFILES: {
            html: !0,
            svg: !0,
            svgFilters: !0
          },
          ALLOWED_ATTR: n
        };
        return $M().sanitize(e, o), e.innerHTML;
      }, p8 = (e, n) => {
        const o = hf();
        if (e.sanitize) {
          const r = f8(e, n, o);
          return {
            sanitizeHtmlElement: (u, f) => {
              r.sanitize(u, g8(e, f)), r.removed = [], o.reset();
            },
            sanitizeNamespaceElement: h8
          };
        } else
          return {
            sanitizeHtmlElement: (u, f) => {
              const b = document.createNodeIterator(u, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT);
              let y;
              for (; y = b.nextNode(); ) {
                const E = o.track(y);
                dT(y, e, n, E), xn(y) && m8(y, e, n, E);
              }
              o.reset();
            },
            sanitizeNamespaceElement: Oe
          };
      }, UM = _t.makeMap, WM = _t.extend, N2 = (e, n, o, r) => {
        const c = e.name, u = c in o && c !== "title" && c !== "textarea" && c !== "noscript", f = n.childNodes;
        for (let b = 0, y = f.length; b < y; b++) {
          const E = f[b], N = new Ki(E.nodeName.toLowerCase(), E.nodeType);
          if (xn(E)) {
            const M = E.attributes;
            for (let I = 0, X = M.length; I < X; I++) {
              const te = M[I];
              N.attr(te.name, te.value);
            }
            ad(N.name) && (r(E), N.value = E.innerHTML);
          } else Mt(E) ? (N.value = E.data, u && (N.raw = !0)) : (rd(E) || Xb(E) || Nd(E)) && (N.value = E.data);
          ad(N.name) || N2(N, E, o, r), e.append(N);
        }
      }, Xi = (e, n, o) => {
        const r = [];
        for (let c = e, u = c; c; u = c, c = c.walk()) {
          const f = c;
          ae(n, (b) => b(f)), gn(f.parent) && f !== e ? c = u : r.push(f);
        }
        for (let c = r.length - 1; c >= 0; c--) {
          const u = r[c];
          ae(o, (f) => f(u));
        }
      }, b8 = (e, n, o, r) => {
        const c = o.validate, u = n.getNonEmptyElements(), f = n.getWhitespaceElements(), b = WM(UM("script,style,head,html,body,title,meta,param"), n.getBlockElements()), y = Iw(n), E = /[ \t\r\n]+/g, N = /^[ \t\r\n]+/, M = /[ \t\r\n]+$/, I = (ke) => {
          let Ae = ke.parent;
          for (; De(Ae); ) {
            if (Ae.name in f)
              return !0;
            Ae = Ae.parent;
          }
          return !1;
        }, X = (ke) => {
          let Ae = ke;
          for (; De(Ae); ) {
            if (Ae.name in y)
              return wv(n, u, f, Ae);
            Ae = Ae.parent;
          }
          return !1;
        }, te = (ke) => ke.name in b || Cm(n, ke) || ad(ke.name) && ke.parent === e, G = (ke, Ae) => {
          const Me = Ae ? ke.prev : ke.next;
          return De(Me) || gn(ke.parent) ? !1 : te(ke.parent) && (ke.parent !== e || r.isRootContent === !0);
        };
        return [
          (ke) => {
            var Ae;
            if (ke.type === 3 && !I(ke)) {
              let Me = (Ae = ke.value) !== null && Ae !== void 0 ? Ae : "";
              Me = Me.replace(E, " "), (EN(ke.prev, te) || G(ke, !0)) && (Me = Me.replace(N, "")), Me.length === 0 ? ke.remove() : ke.value = Me;
            }
          },
          (ke) => {
            var Ae;
            if (ke.type === 1) {
              const Me = n.getElementRule(ke.name);
              if (c && Me) {
                const pt = wv(n, u, f, ke);
                Me.paddInEmptyBlock && pt && X(ke) ? Px(o, r, te, ke) : Me.removeEmpty && pt ? te(ke) ? ke.remove() : ke.unwrap() : Me.paddEmpty && (pt || xN(ke)) && Px(o, r, te, ke);
              }
            } else if (ke.type === 3 && !I(ke)) {
              let Me = (Ae = ke.value) !== null && Ae !== void 0 ? Ae : "";
              (ke.next && te(ke.next) || G(ke, !1)) && (Me = Me.replace(M, "")), Me.length === 0 ? ke.remove() : ke.value = Me;
            }
          }
        ];
      }, mT = (e, n) => {
        var o;
        const r = (o = n.forced_root_block) !== null && o !== void 0 ? o : e.forced_root_block;
        return r === !1 ? "" : r === !0 ? "p" : r;
      }, Qd = (e = {}, n = Tm()) => {
        const o = bM(), r = bM(), c = {
          validate: !0,
          root_name: "body",
          sanitize: !0,
          ...e
        }, u = new DOMParser(), f = p8(c, n), b = (Ae, Me, pt = "html") => {
          const It = pt === "xhtml" ? "application/xhtml+xml" : "text/html", un = Zn(n.getSpecialElements(), Me.toLowerCase()), nt = un ? `<${Me}>${Ae}</${Me}>` : Ae, qe = pt === "xhtml" ? `<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>${nt}</body></html>` : `<body>${nt}</body>`, xt = u.parseFromString(qe, It).body;
          return f.sanitizeHtmlElement(xt, It), un ? xt.firstChild : xt;
        }, y = o.addFilter, E = o.getFilters, N = o.removeFilter, M = r.addFilter, I = r.getFilters, X = r.removeFilter, te = (Ae, Me) => {
          Fx(n, Ae) && Me.push(Ae);
        }, G = (Ae, Me) => {
          const pt = J(Me.attr(N3)), It = Me.type === 1 && !Zn(Ae, Me.name) && !Cm(n, Me) && !ad(Me.name);
          return Me.type === 3 || It && !pt;
        }, ne = (Ae, Me) => {
          const pt = WM(UM("script,style,head,html,body,title,meta,param"), n.getBlockElements()), It = /^[ \t\r\n]+/, un = /[ \t\r\n]+$/;
          let nt = Ae.firstChild, qe = null;
          const xt = (bn) => {
            var Yn, Po;
            bn && (nt = bn.firstChild, nt && nt.type === 3 && (nt.value = (Yn = nt.value) === null || Yn === void 0 ? void 0 : Yn.replace(It, "")), nt = bn.lastChild, nt && nt.type === 3 && (nt.value = (Po = nt.value) === null || Po === void 0 ? void 0 : Po.replace(un, "")));
          };
          if (n.isValidChild(Ae.name, Me.toLowerCase())) {
            for (; nt; ) {
              const bn = nt.next;
              G(pt, nt) ? (qe || (qe = new Ki(Me, 1), qe.attr(c.forced_root_block_attrs), Ae.insert(qe, nt)), qe.append(nt)) : (xt(qe), qe = null), nt = bn;
            }
            xt(qe);
          }
        }, ke = {
          schema: n,
          addAttributeFilter: M,
          getAttributeFilters: I,
          removeAttributeFilter: X,
          addNodeFilter: y,
          getNodeFilters: E,
          removeNodeFilter: N,
          parse: (Ae, Me = {}) => {
            var pt;
            const It = c.validate, un = (pt = Me.context) !== null && pt !== void 0 ? pt : c.root_name, nt = b(Ae, un, Me.format);
            h1(n, nt);
            const qe = new Ki(un, 11);
            N2(qe, nt, n.getSpecialElements(), f.sanitizeNamespaceElement), nt.innerHTML = "";
            const [xt, bn] = b8(qe, n, c, Me), Yn = [], Po = It ? (wa) => te(wa, Yn) : Oe, Ko = {
              nodes: {},
              attributes: {}
            }, er = (wa) => UA(E(), I(), wa, Ko);
            if (Xi(qe, [
              xt,
              er
            ], [
              bn,
              Po
            ]), Yn.reverse(), It && Yn.length > 0)
              if (Me.context) {
                const {
                  pass: wa,
                  fail: si
                } = Vn(Yn, (kc) => kc.parent === qe);
                $x(si, n, qe, er), Me.invalid = wa.length > 0;
              } else
                $x(Yn, n, qe, er);
            const Er = mT(c, Me);
            return Er && (qe.name === "body" || Me.isRootContent) && ne(qe, Er), Me.invalid || v2(Ko, Me), qe;
          }
        };
        return n8(ke, c), Y6(ke, c, n), ke;
      }, ZM = (e) => Tp(e) ? yp({ validate: !1 }).serialize(e) : e, Wl = (e, n, o) => {
        const r = ZM(e), c = n(r);
        if (c.isDefaultPrevented())
          return c;
        if (Tp(e))
          if (c.content !== r) {
            const u = Qd({
              validate: !1,
              forced_root_block: !1,
              ...o
            }).parse(c.content, { context: e.name });
            return {
              ...c,
              content: u
            };
          } else
            return {
              ...c,
              content: e
            };
        else
          return c;
      }, Op = (e, n) => {
        if (n.no_events)
          return Ui.value(n);
        {
          const o = W_(e, n);
          return o.isDefaultPrevented() ? Ui.error(ts(e, {
            content: "",
            ...o
          }).content) : Ui.value(o);
        }
      }, P3 = (e, n, o) => o.no_events ? n : Wl(n, (c) => ts(e, {
        ...o,
        content: c
      }), {
        sanitize: Kh(e),
        sandbox_iframes: I0(e)
      }).content, B3 = (e, n) => {
        if (n.no_events)
          return Ui.value(n);
        {
          const o = Wl(n.content, (r) => oR(e, {
            ...n,
            content: r
          }), {
            sanitize: Kh(e),
            sandbox_iframes: I0(e)
          });
          return o.isDefaultPrevented() ? (ex(e, o), Ui.error(void 0)) : Ui.value(o);
        }
      }, fT = (e, n, o) => {
        o.no_events || ex(e, {
          ...o,
          content: n
        });
      }, $3 = (e, n, o) => ({
        element: e,
        width: n,
        rows: o
      }), F3 = (e, n) => ({
        element: e,
        cells: n
      }), M2 = (e, n) => ({
        x: e,
        y: n
      }), gT = (e, n) => wc(e, n).bind(xa).getOr(1), v8 = (e, n, o, r, c) => {
        const u = gT(c, "rowspan"), f = gT(c, "colspan"), b = e.rows;
        for (let y = o; y < o + u; y++) {
          b[y] || (b[y] = F3(w0(r), []));
          for (let E = n; E < n + f; E++) {
            const N = b[y].cells;
            N[E] = y === o && E === n ? c : dl(c);
          }
        }
      }, jM = (e, n, o) => {
        const r = e.rows;
        return !!(r[o] ? r[o].cells : [])[n];
      }, y8 = (e, n, o) => {
        for (; jM(e, n, o); )
          n++;
        return n;
      }, hT = (e) => Xe(e, (n, o) => o.cells.length > n ? o.cells.length : n, 0), pT = (e, n) => {
        const o = e.rows;
        for (let r = 0; r < o.length; r++) {
          const c = o[r].cells;
          for (let u = 0; u < c.length; u++)
            if (fs(c[u], n))
              return F.some(M2(u, r));
        }
        return F.none();
      }, qM = (e, n, o, r, c) => {
        const u = [], f = e.rows;
        for (let b = o; b <= c; b++) {
          const y = f[b].cells, E = n < r ? y.slice(n, r + 1) : y.slice(r, n + 1);
          u.push(F3(f[b].element, E));
        }
        return u;
      }, C8 = (e, n, o) => {
        const r = n.x, c = n.y, u = o.x, f = o.y, b = c < f ? qM(e, r, c, u, f) : qM(e, r, f, u, c);
        return $3(e.element, hT(b), b);
      }, Wf = (e, n) => {
        const o = dl(e.element), r = le.fromTag("tbody");
        return Ms(r, n), la(o, r), o;
      }, I3 = (e) => ye(e.rows, (n) => {
        const o = ye(n.cells, (c) => {
          const u = w0(c);
          return _r(u, "colspan"), _r(u, "rowspan"), u;
        }), r = dl(n.element);
        return Ms(r, o), r;
      }), w8 = (e) => {
        const n = $3(dl(e), 0, []);
        return ae(uc(e, "tr"), (o, r) => {
          ae(uc(o, "td,th"), (c, u) => {
            v8(n, y8(n, u, r), r, o, c);
          });
        }), $3(n.element, hT(n.rows), n.rows);
      }, bT = (e) => Wf(e, I3(e)), L3 = (e, n, o) => pT(e, n).bind((r) => pT(e, o).map((c) => C8(e, r, c))), GM = (e) => hn(e, (n) => Qo(n) === "ul" || Qo(n) === "ol"), KM = (e, n) => hn(e, (o) => Qo(o) === "li" && $C(o, n)).fold(it([]), (o) => GM(e).map((r) => {
        const c = le.fromTag(Qo(r)), u = xs(fm(r), (f, b) => Kn(b, "list-style"));
        return Ya(c, u), [
          le.fromTag("li"),
          c
        ];
      }).getOr([])), YM = (e, n) => {
        const o = Xe(n, (r, c) => (la(c, r), c), e);
        return n.length > 0 ? e2([o]) : o;
      }, S8 = (e) => al(e) ? lc(e).filter(Pc).fold(it([]), (n) => [
        e,
        n
      ]) : Pc(e) ? [e] : [], x8 = (e, n, o) => {
        const r = le.fromDom(n.commonAncestorContainer), c = Lf(r, e), u = Yt(c, (y) => o.isWrapper(Qo(y))), f = KM(c, n), b = u.concat(f.length ? f : S8(r));
        return ye(b, dl);
      }, XM = () => e2([]), T8 = (e, n, o) => YM(le.fromDom(n.cloneContents()), x8(e, n, o)), E8 = (e, n) => _l(n, "table", Ye(fs, e)), JM = (e, n) => E8(e, n[0]).bind((o) => {
        const r = n[0], c = n[n.length - 1], u = w8(o);
        return L3(u, r, c).map((f) => e2([bT(f)]));
      }).getOrThunk(XM), k8 = (e, n, o) => n.length > 0 && n[0].collapsed ? XM() : T8(e, n[0], o), _8 = (e, n, o) => {
        const r = P_(n, e);
        return r.length > 0 ? JM(e, r) : k8(e, n, o);
      }, vT = (e, n) => n >= 0 && n < e.length && cp(e.charAt(n)), H3 = (e) => q(e.innerText), z3 = (e) => e.map((n) => n.nodeName).getOr("div").toLowerCase(), V3 = (e) => F.from(e.selection.getRng()).map((n) => {
        var o;
        const r = F.from(e.dom.getParent(n.commonAncestorContainer, e.dom.isBlock)), c = e.getBody(), u = z3(r), f = le.fromDom(n.cloneContents());
        Bo(f), gA(f);
        const b = e.dom.add(c, u, {
          "data-mce-bogus": "all",
          style: "overflow: hidden; opacity: 0;"
        }, f.dom), y = H3(b), E = q((o = b.textContent) !== null && o !== void 0 ? o : "");
        if (e.dom.remove(b), vT(E, 0) || vT(E, E.length - 1)) {
          const N = r.getOr(c), M = H3(N), I = M.indexOf(y);
          if (I === -1)
            return y;
          {
            const X = vT(M, I - 1), te = vT(M, I + y.length);
            return (X ? " " : "") + y + (te ? " " : "");
          }
        } else
          return y;
      }).getOr(""), QM = (e, n) => {
        const o = e.selection.getRng(), r = e.dom.create("body"), c = e.selection.getSel(), u = fA(e, G0(c)), f = n.contextual ? _8(le.fromDom(e.getBody()), u, e.schema).dom : o.cloneContents();
        return f && r.appendChild(f), e.selection.serializer.serialize(r, n);
      }, U3 = (e, n) => {
        if (n.format === "text")
          return V3(e);
        {
          const o = QM(e, n);
          return n.format === "tree" ? o : e.selection.isCollapsed() ? "" : o;
        }
      }, eP = (e, n) => ({
        ...e,
        format: n,
        get: !0,
        selection: !0,
        getInner: !0
      }), tP = (e, n, o = {}) => {
        const r = eP(o, n);
        return Op(e, r).fold(Gn, (c) => {
          const u = U3(e, c);
          return P3(e, u, c);
        });
      }, P2 = 0, W3 = 1, Z3 = 2, nP = (e, n) => {
        const o = e.length + n.length + 2, r = new Array(o), c = new Array(o), u = (N, M, I) => ({
          start: N,
          end: M,
          diag: I
        }), f = (N, M, I, X, te) => {
          const G = y(N, M, I, X);
          if (G === null || G.start === M && G.diag === M - X || G.end === N && G.diag === N - I) {
            let ne = N, Se = I;
            for (; ne < M || Se < X; )
              ne < M && Se < X && e[ne] === n[Se] ? (te.push([
                P2,
                e[ne]
              ]), ++ne, ++Se) : M - N > X - I ? (te.push([
                Z3,
                e[ne]
              ]), ++ne) : (te.push([
                W3,
                n[Se]
              ]), ++Se);
          } else {
            f(N, G.start, I, G.start - G.diag, te);
            for (let ne = G.start; ne < G.end; ++ne)
              te.push([
                P2,
                e[ne]
              ]);
            f(G.end, M, G.end - G.diag, X, te);
          }
        }, b = (N, M, I, X) => {
          let te = N;
          for (; te - M < X && te < I && e[te] === n[te - M]; )
            ++te;
          return u(N, te, M);
        }, y = (N, M, I, X) => {
          const te = M - N, G = X - I;
          if (te === 0 || G === 0)
            return null;
          const ne = te - G, Se = G + te, ke = (Se % 2 === 0 ? Se : Se + 1) / 2;
          r[1 + ke] = N, c[1 + ke] = M + 1;
          let Ae, Me, pt, It, un;
          for (Ae = 0; Ae <= ke; ++Ae) {
            for (Me = -Ae; Me <= Ae; Me += 2) {
              for (pt = Me + ke, Me === -Ae || Me !== Ae && r[pt - 1] < r[pt + 1] ? r[pt] = r[pt + 1] : r[pt] = r[pt - 1] + 1, It = r[pt], un = It - N + I - Me; It < M && un < X && e[It] === n[un]; )
                r[pt] = ++It, ++un;
              if (ne % 2 !== 0 && ne - Ae <= Me && Me <= ne + Ae && c[pt - ne] <= r[pt])
                return b(c[pt - ne], Me + N - I, M, X);
            }
            for (Me = ne - Ae; Me <= ne + Ae; Me += 2) {
              for (pt = Me + ke - ne, Me === ne - Ae || Me !== ne + Ae && c[pt + 1] <= c[pt - 1] ? c[pt] = c[pt + 1] - 1 : c[pt] = c[pt - 1], It = c[pt] - 1, un = It - N + I - Me; It >= N && un >= I && e[It] === n[un]; )
                c[pt] = It--, un--;
              if (ne % 2 === 0 && -Ae <= Me && Me <= Ae && c[pt] <= r[pt + ne])
                return b(c[pt], Me + N - I, M, X);
            }
          }
          return null;
        }, E = [];
        return f(0, e.length, 0, n.length, E), E;
      }, oP = (e) => xn(e) ? e.outerHTML : Mt(e) ? wg.encodeRaw(e.data, !1) : rd(e) ? "<!--" + e.data + "-->" : "", j3 = (e) => {
        let n;
        const o = document.createElement("div"), r = document.createDocumentFragment();
        for (e && (o.innerHTML = e); n = o.firstChild; )
          r.appendChild(n);
        return r;
      }, A8 = (e, n, o) => {
        const r = j3(n);
        if (e.hasChildNodes() && o < e.childNodes.length) {
          const c = e.childNodes[o];
          e.insertBefore(r, c);
        } else
          e.appendChild(r);
      }, yT = (e, n) => {
        if (e.hasChildNodes() && n < e.childNodes.length) {
          const o = e.childNodes[n];
          e.removeChild(o);
        }
      }, O8 = (e, n) => {
        let o = 0;
        ae(e, (r) => {
          r[0] === P2 ? o++ : r[0] === W3 ? (A8(n, r[1], o), o++) : r[0] === Z3 && yT(n, o);
        });
      }, D8 = (e, n) => Yt(ye(rs(e.childNodes), A(q, oP)), (o) => o.length > 0), R8 = (e, n) => {
        const o = ye(rs(n.childNodes), oP);
        return O8(nP(o, e), n), n;
      }, sP = Je(() => document.implementation.createHTMLDocument("undo")), rP = (e) => e.querySelector("iframe") !== null, N8 = (e) => ({
        type: "fragmented",
        fragments: e,
        content: "",
        bookmark: null,
        beforeBookmark: null
      }), M8 = (e) => ({
        type: "complete",
        fragments: null,
        content: e,
        bookmark: null,
        beforeBookmark: null
      }), CT = (e) => {
        const n = e.serializer.getTempAttrs(), o = OR(e.getBody(), n);
        return rP(o) ? N8(D8(o)) : M8(q(o.innerHTML));
      }, q3 = (e, n, o) => {
        const r = o ? n.beforeBookmark : n.bookmark;
        n.type === "fragmented" ? R8(n.fragments, e.getBody()) : e.setContent(n.content, {
          format: "raw",
          no_selection: De(r) && IS(r) ? !r.isFakeCaret : !0
        }), r && (e.selection.moveToBookmark(r), e.selection.scrollIntoView());
      }, G3 = (e) => e.type === "fragmented" ? e.fragments.join("") : e.content, K3 = (e) => {
        const n = le.fromTag("body", sP());
        return sd(n, G3(e)), ae(uc(n, "*[data-mce-bogus]"), qc), Wo(n);
      }, Dj = (e, n) => G3(e) === G3(n), P8 = (e, n) => K3(e) === K3(n), Y3 = (e, n) => !e || !n ? !1 : Dj(e, n) ? !0 : P8(e, n), X3 = (e) => e.get() === 0, wT = (e, n, o) => {
        X3(o) && (e.typing = n);
      }, aP = (e, n) => {
        e.typing && (wT(e, !1, n), e.add());
      }, B8 = (e) => {
        e.typing && (e.typing = !1, e.add());
      }, $8 = (e, n, o) => {
        X3(n) && o.set(Vh(e.selection));
      }, cP = (e, n, o, r, c, u, f) => {
        const b = CT(e), y = _t.extend(u || {}, b);
        if (!X3(r) || e.removed)
          return null;
        const E = n.data[o.get()];
        if (e.dispatch("BeforeAddUndo", {
          level: y,
          lastLevel: E,
          originalEvent: f
        }).isDefaultPrevented() || E && Y3(E, y))
          return null;
        n.data[o.get()] && c.get().each((I) => {
          n.data[o.get()].beforeBookmark = I;
        });
        const N = $1(e);
        if (N && n.data.length > N) {
          for (let I = 0; I < n.data.length - 1; I++)
            n.data[I] = n.data[I + 1];
          n.data.length--, o.set(n.data.length);
        }
        y.bookmark = Vh(e.selection), o.get() < n.data.length - 1 && (n.data.length = o.get() + 1), n.data.push(y), o.set(n.data.length - 1);
        const M = {
          level: y,
          lastLevel: E,
          originalEvent: f
        };
        return o.get() > 0 ? (e.setDirty(!0), e.dispatch("AddUndo", M), e.dispatch("change", M)) : e.dispatch("AddUndo", M), y;
      }, F8 = (e, n, o) => {
        n.data = [], o.set(0), n.typing = !1, e.dispatch("ClearUndos");
      }, I8 = (e, n, o, r, c) => {
        if (n.transact(r)) {
          const u = n.data[o.get()].bookmark, f = n.data[o.get() - 1];
          q3(e, f, !0), n.transact(c) && (n.data[o.get() - 1].beforeBookmark = u);
        }
      }, L8 = (e, n, o) => {
        let r;
        return n.get() < o.length - 1 && (n.set(n.get() + 1), r = o[n.get()], q3(e, r, !1), e.setDirty(!0), e.dispatch("Redo", { level: r })), r;
      }, H8 = (e, n, o, r) => {
        let c;
        return n.typing && (n.add(), n.typing = !1, wT(n, !1, o)), r.get() > 0 && (r.set(r.get() - 1), c = n.data[r.get()], q3(e, c, !0), e.setDirty(!0), e.dispatch("Undo", { level: c })), c;
      }, z8 = (e) => {
        e.clear(), e.add();
      }, Rj = (e, n, o) => o.get() > 0 || n.typing && n.data[0] && !Y3(CT(e), n.data[0]), Nj = (e, n) => n.get() < e.data.length - 1 && !e.typing, V8 = (e, n, o) => (aP(e, n), e.beforeChange(), e.ignore(o), e.add()), U8 = (e, n) => {
        try {
          e.set(e.get() + 1), n();
        } finally {
          e.set(e.get() - 1);
        }
      }, Mj = (e, n) => {
        const o = e.dom, r = De(n) ? n : e.getBody();
        ae(o.select("table,a", r), (c) => {
          switch (c.nodeName) {
            case "TABLE":
              const u = a_(e), f = o.getAttrib(c, "border");
              (!f || f === "0") && e.hasVisual ? o.addClass(c, u) : o.removeClass(c, u);
              break;
            case "A":
              if (!o.getAttrib(c, "href")) {
                const b = o.getAttrib(c, "name") || c.id, y = yS(e);
                b && e.hasVisual ? o.addClass(c, y) : o.removeClass(c, y);
              }
              break;
          }
        }), e.dispatch("VisualAid", {
          element: n,
          hasVisual: e.hasVisual
        });
      }, iP = (e) => ({
        init: { bindEvents: Oe },
        undoManager: {
          beforeChange: (n, o) => $8(e, n, o),
          add: (n, o, r, c, u, f) => cP(e, n, o, r, c, u, f),
          undo: (n, o, r) => H8(e, n, o, r),
          redo: (n, o) => L8(e, n, o),
          clear: (n, o) => F8(e, n, o),
          reset: (n) => z8(n),
          hasUndo: (n, o) => Rj(e, n, o),
          hasRedo: (n, o) => Nj(n, o),
          transact: (n, o, r) => V8(n, o, r),
          ignore: (n, o) => U8(n, o),
          extra: (n, o, r, c) => I8(e, n, o, r, c)
        },
        formatter: {
          match: (n, o, r, c) => Sv(e, n, o, r, c),
          matchAll: (n, o) => WN(e, n, o),
          matchNode: (n, o, r, c) => zf(e, n, o, r, c),
          canApply: (n) => k6(e, n),
          closest: (n) => ZN(e, n),
          apply: (n, o, r) => dM(e, n, o, r),
          remove: (n, o, r, c) => p3(e, n, o, r, c),
          toggle: (n, o, r) => hM(e, n, o, r),
          formatChanged: (n, o, r, c, u) => Z6(e, n, o, r, c, u)
        },
        editor: {
          getContent: (n) => Ej(e, n),
          setContent: (n, o) => T6(e, n, o),
          insertContent: (n, o) => S6(e, n, o),
          addVisual: (n) => Mj(e, n)
        },
        selection: { getContent: (n, o) => tP(e, n, o) },
        autocompleter: {
          addDecoration: (n) => SL(e, n),
          removeDecoration: () => TL(e, le.fromDom(e.getBody()))
        },
        raw: { getModel: () => F.none() }
      }), Ca = (e) => {
        const n = (E) => Qe(E) ? E : {}, { init: o, undoManager: r, formatter: c, editor: u, selection: f, autocompleter: b, raw: y } = e;
        return {
          init: { bindEvents: o.bindEvents },
          undoManager: {
            beforeChange: r.beforeChange,
            add: r.add,
            undo: r.undo,
            redo: r.redo,
            clear: r.clear,
            reset: r.reset,
            hasUndo: r.hasUndo,
            hasRedo: r.hasRedo,
            transact: (E, N, M) => r.transact(M),
            ignore: (E, N) => r.ignore(N),
            extra: (E, N, M, I) => r.extra(M, I)
          },
          formatter: {
            match: (E, N, M, I) => c.match(E, n(N), I),
            matchAll: c.matchAll,
            matchNode: c.matchNode,
            canApply: (E) => c.canApply(E),
            closest: (E) => c.closest(E),
            apply: (E, N, M) => c.apply(E, n(N)),
            remove: (E, N, M, I) => c.remove(E, n(N)),
            toggle: (E, N, M) => c.toggle(E, n(N)),
            formatChanged: (E, N, M, I, X) => c.formatChanged(N, M, I, X)
          },
          editor: {
            getContent: (E) => u.getContent(E),
            setContent: (E, N) => ({
              content: u.setContent(E, N),
              html: ""
            }),
            insertContent: (E, N) => (u.insertContent(E), ""),
            addVisual: u.addVisual
          },
          selection: { getContent: (E, N) => f.getContent(N) },
          autocompleter: {
            addDecoration: b.addDecoration,
            removeDecoration: b.removeDecoration
          },
          raw: { getModel: () => F.some(y.getRawModel()) }
        };
      }, J3 = () => {
        const e = it(null), n = it("");
        return {
          init: { bindEvents: Oe },
          undoManager: {
            beforeChange: Oe,
            add: e,
            undo: e,
            redo: e,
            clear: Oe,
            reset: Oe,
            hasUndo: $e,
            hasRedo: $e,
            transact: e,
            ignore: Oe,
            extra: Oe
          },
          formatter: {
            match: $e,
            matchAll: it([]),
            matchNode: it(void 0),
            canApply: $e,
            closest: n,
            apply: Oe,
            remove: Oe,
            toggle: Oe,
            formatChanged: it({ unbind: Oe })
          },
          editor: {
            getContent: n,
            setContent: it({
              content: "",
              html: ""
            }),
            insertContent: it(""),
            addVisual: Oe
          },
          selection: { getContent: n },
          autocompleter: {
            addDecoration: Oe,
            removeDecoration: Oe
          },
          raw: { getModel: it(F.none()) }
        };
      }, Yg = (e) => Zn(e.plugins, "rtc"), W8 = (e) => Ts(e.plugins, "rtc").bind((n) => F.from(n.setup)), Z8 = (e) => {
        const n = e;
        return W8(e).fold(() => (n.rtcInstance = iP(e), F.none()), (o) => (n.rtcInstance = J3(), F.some(() => o().then((r) => (n.rtcInstance = Ca(r), r.rtc.isRemote)))));
      }, Dp = (e) => e.rtcInstance ? e.rtcInstance : iP(e), gc = (e) => {
        const n = e.rtcInstance;
        if (n)
          return n;
        throw new Error("Failed to get RTC instance not yet initialized.");
      }, Pj = (e, n, o) => {
        gc(e).undoManager.beforeChange(n, o);
      }, vi = (e, n, o, r, c, u, f) => gc(e).undoManager.add(n, o, r, c, u, f), lP = (e, n, o, r) => gc(e).undoManager.undo(n, o, r), uP = (e, n, o) => gc(e).undoManager.redo(n, o), dP = (e, n, o) => {
        gc(e).undoManager.clear(n, o);
      }, j8 = (e, n) => {
        gc(e).undoManager.reset(n);
      }, q8 = (e, n, o) => gc(e).undoManager.hasUndo(n, o), ST = (e, n, o) => gc(e).undoManager.hasRedo(n, o), G8 = (e, n, o, r) => gc(e).undoManager.transact(n, o, r), Q3 = (e, n, o) => {
        gc(e).undoManager.ignore(n, o);
      }, K8 = (e, n, o, r, c) => {
        gc(e).undoManager.extra(n, o, r, c);
      }, mP = (e, n, o, r, c) => gc(e).formatter.match(n, o, r, c), fP = (e, n, o) => gc(e).formatter.matchAll(n, o), eO = (e, n, o, r, c) => gc(e).formatter.matchNode(n, o, r, c), gP = (e, n) => gc(e).formatter.canApply(n), tO = (e, n) => gc(e).formatter.closest(n), Y8 = (e, n, o, r) => {
        gc(e).formatter.apply(n, o, r);
      }, X8 = (e, n, o, r, c) => {
        gc(e).formatter.remove(n, o, r, c);
      }, J8 = (e, n, o, r) => {
        gc(e).formatter.toggle(n, o, r);
      }, xd = (e, n, o, r, c, u) => gc(e).formatter.formatChanged(n, o, r, c, u), Q8 = (e, n) => Dp(e).editor.getContent(n), e7 = (e, n, o) => Dp(e).editor.setContent(n, o), t7 = (e, n, o) => Dp(e).editor.insertContent(n, o), n7 = (e, n, o) => gc(e).selection.getContent(n, o), o7 = (e, n) => gc(e).editor.addVisual(n), nO = (e) => gc(e).init.bindEvents(), s7 = (e, n) => gc(e).autocompleter.addDecoration(n), r7 = (e) => gc(e).autocompleter.removeDecoration(), a7 = (e, n = {}) => {
        const o = n.format ? n.format : "html";
        return n7(e, o, n);
      }, B2 = (e) => e.dom.length === 0 ? (bs(e), F.none()) : F.some(e), c7 = (e, n) => e.filter((o) => Fg.isBookmarkNode(o.dom)).bind(n ? El : Li), i7 = (e, n, o, r, c) => {
        const u = e.dom, f = n.dom, b = r ? u.length : f.length;
        r ? (Ec(u, f, c, !1, !r), o.setStart(f, b)) : (Ec(f, u, c, !1, !r), o.setEnd(f, b));
      }, hP = (e, n, o) => {
        lc(e).each((r) => {
          const c = e.dom;
          n && gv(r, We(c, 0), o) ? bb(c, 0, o) : !n && hv(r, We(c, c.length), o) && JR(c, c.length, o);
        });
      }, xT = (e, n, o, r, c) => {
        e.bind((u) => ((r ? JR : bb)(u.dom, r ? u.dom.length : 0, c), n.filter(vo).map((b) => i7(u, b, o, r, c)))).orThunk(() => c7(n, r).or(n).filter(vo).map((f) => hP(f, r, c)));
      }, l7 = (e, n, o) => {
        const r = F.from(n.firstChild).map(le.fromDom), c = F.from(n.lastChild).map(le.fromDom);
        e.deleteContents(), e.insertNode(n);
        const u = r.bind(Li).filter(vo).bind(B2), f = c.bind(El).filter(vo).bind(B2);
        xT(u, r, e, !0, o), xT(f, c, e, !1, o), e.collapse(!1);
      }, u7 = (e, n) => ({
        format: "html",
        ...e,
        set: !0,
        selection: !0,
        content: n
      }), Bj = (e, n) => {
        if (n.format !== "raw") {
          const o = e.selection.getRng(), r = e.dom.getParent(o.commonAncestorContainer, e.dom.isBlock), c = r ? { context: r.nodeName.toLowerCase() } : {}, u = e.parser.parse(n.content, {
            forced_root_block: !1,
            ...c,
            ...n
          });
          return yp({ validate: !1 }, e.schema).serialize(u);
        } else
          return n.content;
      }, d7 = (e, n, o = {}) => {
        const r = u7(o, n);
        B3(e, r).each((c) => {
          const u = Bj(e, c), f = e.selection.getRng();
          l7(f, f.createContextualFragment(u), e.schema), e.selection.setRng(f), fb(e, f), fT(e, u, c);
        });
      }, pP = (e, n, o) => {
        if (Zn(e, n)) {
          const r = Yt(e[n], (c) => c !== o);
          r.length === 0 ? delete e[n] : e[n] = r;
        }
      };
      var bP = (e, n) => {
        let o, r;
        const c = (b, y) => hn(y, (E) => e.is(E, b)), u = (b) => e.getParents(b, void 0, e.getRoot()), f = () => {
          o = {}, r = {}, n.on("NodeChange", (b) => {
            const y = b.element, E = u(y), N = {};
            Dt(o, (M, I) => {
              c(I, E).each((X) => {
                r[I] || (ae(M, (te) => {
                  te(!0, {
                    node: X,
                    selector: I,
                    parents: E
                  });
                }), r[I] = M), N[I] = M;
              });
            }), Dt(r, (M, I) => {
              N[I] || (delete r[I], ae(M, (X) => {
                X(!1, {
                  node: y,
                  selector: I,
                  parents: E
                });
              }));
            });
          });
        };
        return {
          selectorChangedWithUnbind: (b, y) => (o || f(), o[b] || (o[b] = []), o[b].push(y), c(b, u(n.selection.getStart())).each(() => {
            r[b] = o[b];
          }), {
            unbind: () => {
              pP(o, b, y), pP(r, b, y);
            }
          })
        };
      };
      const oO = (e) => !!(e && e.ownerDocument) && ic(le.fromDom(e.ownerDocument), le.fromDom(e)), m7 = (e) => e ? oO(e.startContainer) && oO(e.endContainer) : !1, Rp = (e, n, o, r) => {
        let c, u;
        const { selectorChangedWithUnbind: f } = bP(e, r), b = (Gt, vn) => {
          const As = e.createRng();
          De(Gt) && De(vn) ? (As.setStart(Gt, vn), As.setEnd(Gt, vn), Me(As), Se(!1)) : (FC(e, As, r.getBody(), !0), Me(As));
        }, y = (Gt) => a7(r, Gt), E = (Gt, vn) => d7(r, Gt, vn), N = (Gt) => dA(r.getBody(), Ae(), Gt), M = (Gt) => yR(r.getBody(), Ae(), Gt), I = (Gt, vn) => si.getBookmark(Gt, vn), X = (Gt) => si.moveToBookmark(Gt), te = (Gt, vn) => (gL(e, Gt, vn).each(Me), Gt), G = () => {
          const Gt = Ae(), vn = ke();
          return !Gt || Gt.item ? !1 : Gt.compareEndPoints ? Gt.compareEndPoints("StartToEnd", Gt) === 0 : !vn || Gt.collapsed;
        }, ne = () => {
          const Gt = Ae(), vn = r.getBody().querySelectorAll('[data-mce-selected="1"]');
          return vn.length > 0 ? No(vn, (As) => e.isEditable(As.parentElement)) : bR(e, Gt);
        }, Se = (Gt) => {
          const vn = Ae();
          vn.collapse(!!Gt), Me(vn);
        }, ke = () => n.getSelection ? n.getSelection() : n.document.selection, Ae = () => {
          let Gt;
          const vn = (vs, zn, Un) => {
            try {
              return zn.compareBoundaryPoints(vs, Un);
            } catch {
              return -1;
            }
          }, As = n.document;
          if (De(r.bookmark) && !vp(r)) {
            const vs = cA(r);
            if (vs.isSome())
              return vs.map((zn) => fA(r, [zn])[0]).getOr(As.createRange());
          }
          try {
            const vs = ke();
            vs && !tu(vs.anchorNode) && (vs.rangeCount > 0 ? Gt = vs.getRangeAt(0) : Gt = As.createRange(), Gt = fA(r, [Gt])[0]);
          } catch {
          }
          if (Gt || (Gt = As.createRange()), dg(Gt.startContainer) && Gt.collapsed) {
            const vs = e.getRoot();
            Gt.setStart(vs, 0), Gt.setEnd(vs, 0);
          }
          return c && u && (vn(Gt.START_TO_START, Gt, c) === 0 && vn(Gt.END_TO_END, Gt, c) === 0 ? Gt = u : (c = null, u = null)), Gt;
        }, Me = (Gt, vn) => {
          if (!m7(Gt))
            return;
          const As = ke();
          if (Gt = r.dispatch("SetSelectionRange", {
            range: Gt,
            forward: vn
          }).range, As) {
            u = Gt;
            try {
              As.removeAllRanges(), As.addRange(Gt);
            } catch {
            }
            vn === !1 && As.extend && (As.collapse(Gt.endContainer, Gt.endOffset), As.extend(Gt.startContainer, Gt.startOffset)), c = As.rangeCount > 0 ? As.getRangeAt(0) : null;
          }
          if (!Gt.collapsed && Gt.startContainer === Gt.endContainer && As?.setBaseAndExtent && Gt.endOffset - Gt.startOffset < 2 && Gt.startContainer.hasChildNodes()) {
            const zn = Gt.startContainer.childNodes[Gt.startOffset];
            zn && zn.nodeName === "IMG" && (As.setBaseAndExtent(Gt.startContainer, Gt.startOffset, Gt.endContainer, Gt.endOffset), (As.anchorNode !== Gt.startContainer || As.focusNode !== Gt.endContainer) && As.setBaseAndExtent(zn, 0, zn, 1));
          }
          r.dispatch("AfterSetSelectionRange", {
            range: Gt,
            forward: vn
          });
        }, pt = (Gt) => (E(e.getOuterHTML(Gt)), Gt), It = () => CR(r.getBody(), Ae()), un = (Gt, vn) => fL(e, Ae(), Gt, vn), nt = () => {
          const Gt = ke(), vn = Gt?.anchorNode, As = Gt?.focusNode;
          if (!Gt || !vn || !As || tu(vn) || tu(As))
            return !0;
          const vs = e.createRng(), zn = e.createRng();
          try {
            vs.setStart(vn, Gt.anchorOffset), vs.collapse(!0), zn.setStart(As, Gt.focusOffset), zn.collapse(!0);
          } catch {
            return !0;
          }
          return vs.compareBoundaryPoints(vs.START_TO_START, zn) <= 0;
        }, wa = {
          dom: e,
          win: n,
          serializer: o,
          editor: r,
          expand: (Gt = { type: "word" }) => Me(W(e).expand(Ae(), Gt)),
          collapse: Se,
          setCursorLocation: b,
          getContent: y,
          setContent: E,
          getBookmark: I,
          moveToBookmark: X,
          select: te,
          isCollapsed: G,
          isEditable: ne,
          isForward: nt,
          setNode: pt,
          getNode: It,
          getSel: ke,
          setRng: Me,
          getRng: Ae,
          getStart: N,
          getEnd: M,
          getSelectedBlocks: un,
          normalize: () => {
            const Gt = Ae(), vn = ke();
            if (!$g(vn) && Y0(r)) {
              const As = T(e, Gt);
              return As.each((vs) => {
                Me(vs, nt());
              }), As.getOr(Gt);
            }
            return Gt;
          },
          selectorChanged: (Gt, vn) => (f(Gt, vn), wa),
          selectorChangedWithUnbind: f,
          getScrollContainer: () => {
            let Gt, vn = e.getRoot();
            for (; vn && vn.nodeName !== "BODY"; ) {
              if (vn.scrollHeight > vn.clientHeight) {
                Gt = vn;
                break;
              }
              vn = vn.parentNode;
            }
            return Gt;
          },
          scrollIntoView: (Gt, vn) => {
            De(Gt) ? ni(r, Gt, vn) : fb(r, Ae(), vn);
          },
          placeCaretAt: (Gt, vn) => Me(Hl(Gt, vn, r.getDoc())),
          getBoundingClientRect: () => {
            const Gt = Ae();
            return Gt.collapsed ? We.fromRangeStart(Gt).getClientRects()[0] : Gt.getBoundingClientRect();
          },
          destroy: () => {
            n = c = u = null, kc.destroy();
          }
        }, si = Fg(wa), kc = rR(wa, r);
        return wa.bookmarkManager = si, wa.controlSelection = kc, wa;
      }, Av = (e, n, o) => {
        e.addAttributeFilter("data-mce-tabindex", (r, c) => {
          let u = r.length;
          for (; u--; ) {
            const f = r[u];
            f.attr("tabindex", f.attr("data-mce-tabindex")), f.attr(c, null);
          }
        }), e.addAttributeFilter("src,href,style", (r, c) => {
          const u = "data-mce-" + c, f = n.url_converter, b = n.url_converter_scope;
          let y = r.length;
          for (; y--; ) {
            const E = r[y];
            let N = E.attr(u);
            N !== void 0 ? (E.attr(c, N.length > 0 ? N : null), E.attr(u, null)) : (N = E.attr(c), c === "style" ? N = o.serializeStyle(o.parseStyle(N), E.name) : f && (N = f.call(b, N, c, E.name)), E.attr(c, N.length > 0 ? N : null));
          }
        }), e.addAttributeFilter("class", (r) => {
          let c = r.length;
          for (; c--; ) {
            const u = r[c];
            let f = u.attr("class");
            f && (f = f.replace(/(?:^|\s)mce-item-\w+(?!\S)/g, ""), u.attr("class", f.length > 0 ? f : null));
          }
        }), e.addAttributeFilter("data-mce-type", (r, c, u) => {
          let f = r.length;
          for (; f--; ) {
            const b = r[f];
            b.attr("data-mce-type") === "bookmark" && !u.cleanup && (F.from(b.firstChild).exists((E) => {
              var N;
              return !H((N = E.value) !== null && N !== void 0 ? N : "");
            }) ? b.unwrap() : b.remove());
          }
        }), e.addNodeFilter("script,style", (r, c) => {
          var u;
          const f = (y) => y.replace(/(<!--\[CDATA\[|\]\]-->)/g, `
`).replace(/^[\r\n]*|[\r\n]*$/g, "").replace(/^\s*((<!--)?(\s*\/\/)?\s*<!\[CDATA\[|(<!--\s*)?\/\*\s*<!\[CDATA\[\s*\*\/|(\/\/)?\s*<!--|\/\*\s*<!--\s*\*\/)\s*[\r\n]*/gi, "").replace(/\s*(\/\*\s*\]\]>\s*\*\/(-->)?|\s*\/\/\s*\]\]>(-->)?|\/\/\s*(-->)?|\]\]>|\/\*\s*-->\s*\*\/|\s*-->\s*)\s*$/g, "");
          let b = r.length;
          for (; b--; ) {
            const y = r[b], E = y.firstChild, N = (u = E?.value) !== null && u !== void 0 ? u : "";
            if (c === "script") {
              const M = y.attr("type");
              M && y.attr("type", M === "mce-no/type" ? null : M.replace(/^mce\-/, "")), n.element_format === "xhtml" && E && N.length > 0 && (E.value = `// <![CDATA[
` + f(N) + `
// ]]>`);
            } else
              n.element_format === "xhtml" && E && N.length > 0 && (E.value = `<!--
` + f(N) + `
-->`);
          }
        }), e.addNodeFilter("#comment", (r) => {
          let c = r.length;
          for (; c--; ) {
            const u = r[c], f = u.value;
            n.preserve_cdata && f?.indexOf("[CDATA[") === 0 ? (u.name = "#cdata", u.type = 4, u.value = o.decode(f.replace(/^\[CDATA\[|\]\]$/g, ""))) : f?.indexOf("mce:protected ") === 0 && (u.name = "#text", u.type = 3, u.raw = !0, u.value = unescape(f).substr(14));
          }
        }), e.addNodeFilter("xml:namespace,input", (r, c) => {
          let u = r.length;
          for (; u--; ) {
            const f = r[u];
            f.type === 7 ? f.remove() : f.type === 1 && c === "input" && !f.attr("type") && f.attr("type", "text");
          }
        }), e.addAttributeFilter("data-mce-type", (r) => {
          ae(r, (c) => {
            c.attr("data-mce-type") === "format-caret" && (c.isEmpty(e.schema.getNonEmptyElements()) ? c.remove() : c.unwrap());
          });
        }), e.addAttributeFilter("data-mce-src,data-mce-href,data-mce-style,data-mce-selected,data-mce-expando,data-mce-block,data-mce-type,data-mce-resize,data-mce-placeholder", (r, c) => {
          let u = r.length;
          for (; u--; )
            r[u].attr(c, null);
        }), n.remove_trailing_brs && vM(n, e, e.schema);
      }, $2 = (e) => {
        const n = (r) => r?.name === "br", o = e.lastChild;
        if (n(o)) {
          const r = o.prev;
          n(r) && (o.remove(), r.remove());
        }
      }, vP = (e, n, o) => {
        let r;
        const c = e.dom;
        let u = n.cloneNode(!0);
        const f = document.implementation;
        if (f.createHTMLDocument) {
          const b = f.createHTMLDocument("");
          _t.each(u.nodeName === "BODY" ? u.childNodes : [u], (y) => {
            b.body.appendChild(b.importNode(y, !0));
          }), u.nodeName !== "BODY" ? u = b.body.firstChild : u = b.body, r = c.doc, c.doc = b;
        }
        return jC(e, {
          ...o,
          node: u
        }), r && (c.doc = r), u;
      }, yP = (e, n) => De(e) && e.hasEventListeners("PreProcess") && !n.no_events, f7 = (e, n, o) => yP(e, o) ? vP(e, n, o) : n, CP = (e, n, o) => {
        _t.inArray(n, o) === -1 && (e.addAttributeFilter(o, (r, c) => {
          let u = r.length;
          for (; u--; )
            r[u].attr(c, null);
        }), n.push(o));
      }, g7 = (e, n, o) => !n.no_events && e ? z_(e, {
        ...n,
        content: o
      }).content : o, h7 = (e, n, o) => {
        const r = q(o.getInner ? n.innerHTML : e.getOuterHTML(n));
        return o.selection || Pa(le.fromDom(n)) ? r : _t.trim(r);
      }, p7 = (e, n, o) => {
        const r = o.selection ? {
          forced_root_block: !1,
          ...o
        } : o, c = e.parse(n, r);
        return $2(c), c;
      }, b7 = (e, n, o) => yp(e, n).serialize(o), wP = (e, n, o, r, c) => {
        const u = b7(n, o, r);
        return g7(e, c, u);
      }, v7 = (e, n) => {
        const o = ["data-mce-selected"], r = {
          entity_encoding: "named",
          remove_trailing_brs: !0,
          pad_empty_with_br: !1,
          ...e
        }, c = n && n.dom ? n.dom : xr.DOM, u = n && n.schema ? n.schema : Tm(r), f = Qd(r, u);
        Av(f, r, c);
        const b = (y, E = {}) => {
          const N = {
            format: "html",
            ...E
          }, M = f7(n, y, N), I = h7(c, M, N), X = p7(f, I, N);
          return N.format === "tree" ? X : wP(n, r, u, X, N);
        };
        return {
          schema: u,
          addNodeFilter: f.addNodeFilter,
          addAttributeFilter: f.addAttributeFilter,
          serialize: b,
          addRules: u.addValidElements,
          setRules: u.setValidElements,
          addTempAttr: Ye(CP, f, o),
          getTempAttrs: it(o),
          getNodeFilters: f.getNodeFilters,
          getAttributeFilters: f.getAttributeFilters,
          removeNodeFilter: f.removeNodeFilter,
          removeAttributeFilter: f.removeAttributeFilter
        };
      }, SP = (e, n) => {
        const o = v7(e, n);
        return {
          schema: o.schema,
          addNodeFilter: o.addNodeFilter,
          addAttributeFilter: o.addAttributeFilter,
          serialize: o.serialize,
          addRules: o.addRules,
          setRules: o.setRules,
          addTempAttr: o.addTempAttr,
          getTempAttrs: o.getTempAttrs,
          getNodeFilters: o.getNodeFilters,
          getAttributeFilters: o.getAttributeFilters,
          removeNodeFilter: o.removeNodeFilter,
          removeAttributeFilter: o.removeAttributeFilter
        };
      }, F2 = "html", xP = (e, n) => ({
        ...e,
        format: n,
        get: !0,
        getInner: !0
      }), TP = (e, n = {}) => {
        const o = n.format ? n.format : F2, r = xP(n, o);
        return Op(e, r).fold(Gn, (c) => {
          const u = Q8(e, c);
          return P3(e, u, c);
        });
      }, y7 = "html", C7 = (e, n) => ({
        format: y7,
        ...e,
        set: !0,
        content: n
      }), sO = (e, n, o = {}) => {
        const r = C7(o, n);
        return B3(e, r).map((c) => {
          const u = e7(e, c.content, c);
          return fT(e, u.html, c), u.content;
        }).getOr(n);
      }, EP = "autoresize_on_init,content_editable_state,padd_empty_with_br,block_elements,boolean_attributes,editor_deselector,editor_selector,elements,file_browser_callback_types,filepicker_validator_handler,force_hex_style_colors,force_p_newlines,gecko_spellcheck,images_dataimg_filter,media_scripts,mode,move_caret_before_on_enter_elements,non_empty_elements,self_closing_elements,short_ended_elements,special,spellchecker_select_languages,spellchecker_whitelist,tab_focus,tabfocus_elements,table_responsive_width,text_block_elements,text_inline_elements,toolbar_drawer,types,validate,whitespace_elements,paste_enable_default_filters,paste_filter_drop,paste_word_valid_elements,paste_retain_style_properties,paste_convert_word_fake_lists".split(","), w7 = "template_cdate_classes,template_mdate_classes,template_selected_content_classes,template_preview_replace_values,template_replace_values,templates,template_cdate_format,template_mdate_format".split(","), S7 = "bbcode,colorpicker,contextmenu,fullpage,legacyoutput,spellchecker,textcolor".split(","), kP = [
        {
          name: "template",
          replacedWith: "Advanced Template"
        },
        { name: "rtc" }
      ], _P = (e, n) => {
        const o = Yt(n, (r) => Zn(e, r));
        return et(o);
      }, $j = (e) => {
        const n = _P(e, EP), o = e.forced_root_block;
        return (o === !1 || o === "") && n.push("forced_root_block (false only)"), et(n);
      }, Zm = (e) => _P(e, w7), TT = (e, n) => {
        const o = _t.makeMap(e.plugins, " "), c = Yt(n, (u) => Zn(o, u));
        return et(c);
      }, x7 = (e) => TT(e, S7), T7 = (e) => TT(e, kP.map((n) => n.name)), E7 = (e, n) => {
        const o = $j(e), r = x7(n), c = r.length > 0, u = o.length > 0, f = n.theme === "mobile";
        if (c || u || f) {
          const y = f ? `

Themes:
- mobile` : "", E = c ? `

Plugins:
- ${r.join(`
- `)}` : "", N = u ? `

Options:
- ${o.join(`
- `)}` : "";
        }
      }, k7 = (e) => hn(kP, (n) => n.name === e).fold(() => e, (n) => n.replacedWith ? `${e}, replaced by ${n.replacedWith}` : e), qs = (e, n) => {
        const o = Zm(e), r = T7(n), c = r.length > 0, u = o.length > 0;
        if (c || u) {
          const b = c ? `

Plugins:
- ${r.map(k7).join(`
- `)}` : "", y = u ? `

Options:
- ${o.join(`
- `)}` : "";
        }
      }, Fj = (e, n) => {
        E7(e, n), qs(e, n);
      }, ET = xr.DOM, _7 = (e) => {
        ET.setStyle(e.id, "display", e.orgDisplay);
      }, Lr = (e) => F.from(e).each((n) => n.destroy()), A7 = (e) => {
        const n = e;
        n.contentAreaContainer = n.formElement = n.container = n.editorContainer = null, n.bodyElement = n.contentDocument = n.contentWindow = null, n.iframeElement = n.targetElm = null;
        const o = e.selection;
        if (o) {
          const r = o.dom;
          n.selection = o.win = o.dom = r.doc = null;
        }
      }, I2 = (e) => {
        const n = e.formElement;
        n && (n._mceOldSubmit && (n.submit = n._mceOldSubmit, delete n._mceOldSubmit), ET.unbind(n, "submit reset", e.formEventDelegate));
      }, O7 = (e) => {
        if (!e.removed) {
          const { _selectionOverrides: n, editorUpload: o } = e, r = e.getBody(), c = e.getElement();
          r && e.save({ is_removing: !0 }), e.removed = !0, e.unbindAllNativeEvents(), e.hasHiddenInput && De(c?.nextSibling) && ET.remove(c.nextSibling), mp(e), e.editorManager.remove(e), !e.inline && r && _7(e), fp(e), ET.remove(e.getContainer()), Lr(n), Lr(o), e.destroy();
        }
      }, D7 = (e, n) => {
        const { selection: o, dom: r } = e;
        if (!e.destroyed) {
          if (!n && !e.removed) {
            e.remove();
            return;
          }
          n || (e.editorManager.off("beforeunload", e._beforeUnload), e.theme && e.theme.destroy && e.theme.destroy(), Lr(o), Lr(r)), I2(e), A7(e), e.destroyed = !0;
        }
      }, L2 = (() => {
        const e = {};
        return {
          add: (c, u) => {
            e[c] = u;
          },
          get: (c) => e[c] ? e[c] : { icons: {} },
          has: (c) => Zn(e, c)
        };
      })(), Td = mi.ModelManager, Zl = (e, n) => n.dom[e], Ov = (e, n) => parseInt(ha(n, e), 10), Np = Ye(Zl, "clientWidth"), Zf = Ye(Zl, "clientHeight"), H2 = Ye(Ov, "margin-top"), rO = Ye(Ov, "margin-left"), aO = (e) => e.dom.getBoundingClientRect(), AP = (e, n, o) => {
        const r = Np(e), c = Zf(e);
        return n >= 0 && o >= 0 && n <= r && o <= c;
      }, OP = (e, n, o, r) => {
        const c = aO(n), u = e ? c.left + n.dom.clientLeft + rO(n) : 0, f = e ? c.top + n.dom.clientTop + H2(n) : 0, b = o - u, y = r - f;
        return {
          x: b,
          y
        };
      }, R7 = (e, n, o) => {
        const r = le.fromDom(e.getBody()), c = e.inline ? r : xu(r), u = OP(e.inline, c, n, o);
        return AP(c, u.x, u.y);
      }, N7 = (e) => F.from(e).map(le.fromDom), DP = (e) => {
        const n = e.inline ? e.getBody() : e.getContentAreaContainer();
        return N7(n).map(td).getOr(!1);
      };
      var RP = () => {
        const e = () => {
          throw new Error("Theme did not provide a NotificationManager implementation.");
        };
        return {
          open: e,
          close: e,
          getArgs: e
        };
      };
      const cO = (e) => {
        const n = [], o = () => {
          const I = e.theme;
          return I && I.getNotificationManagerImpl ? I.getNotificationManagerImpl() : RP();
        }, r = () => F.from(n[0]), c = (I, X) => I.type === X.type && I.text === X.text && !I.progressBar && !I.timeout && !X.progressBar && !X.timeout, u = () => {
          ae(n, (I) => {
            I.reposition();
          });
        }, f = (I) => {
          n.push(I);
        }, b = (I) => {
          Xn(n, (X) => X === I).each((X) => {
            n.splice(X, 1);
          });
        }, y = (I, X = !0) => e.removed || !DP(e) ? {} : (X && e.dispatch("BeforeOpenNotification", { notification: I }), hn(n, (te) => c(o().getArgs(te), I)).getOrThunk(() => {
          e.editorManager.setActive(e);
          const te = o().open(I, () => {
            b(te), u(), pR(e) && r().fold(() => e.focus(), (G) => lx(le.fromDom(G.getEl())));
          });
          return f(te), u(), e.dispatch("OpenNotification", { notification: { ...te } }), te;
        })), E = () => {
          r().each((I) => {
            o().close(I), b(I), u();
          });
        }, N = it(n);
        return ((I) => {
          I.on("SkinLoaded", () => {
            const X = t_(I);
            X && y({
              text: X,
              type: "warning",
              timeout: 0
            }, !1), u();
          }), I.on("show ResizeEditor ResizeWindow NodeChange", () => {
            requestAnimationFrame(u);
          }), I.on("remove", () => {
            ae(n.slice(), (X) => {
              o().close(X);
            });
          });
        })(e), {
          open: y,
          close: E,
          getNotifications: N
        };
      }, _b = mi.PluginManager, Xg = mi.ThemeManager;
      var Lj = () => {
        const e = () => {
          throw new Error("Theme did not provide a WindowManager implementation.");
        };
        return {
          open: e,
          openUrl: e,
          alert: e,
          confirm: e,
          close: e
        };
      };
      const NP = (e) => {
        let n = [];
        const o = () => {
          const G = e.theme;
          return G && G.getWindowManagerImpl ? G.getWindowManagerImpl() : Lj();
        }, r = (G, ne) => (...Se) => ne ? ne.apply(G, Se) : void 0, c = (G) => {
          e.dispatch("OpenWindow", { dialog: G });
        }, u = (G) => {
          e.dispatch("CloseWindow", { dialog: G });
        }, f = (G) => {
          n.push(G), c(G);
        }, b = (G) => {
          u(G), n = Yt(n, (ne) => ne !== G), n.length === 0 && e.focus();
        }, y = () => F.from(n[n.length - 1]), E = (G) => {
          e.editorManager.setActive(e), mv(e), e.ui.show();
          const ne = G();
          return f(ne), ne;
        }, N = (G, ne) => E(() => o().open(G, ne, b)), M = (G) => E(() => o().openUrl(G, b)), I = (G, ne, Se) => {
          const ke = o();
          ke.alert(G, r(Se || ke, ne));
        }, X = (G, ne, Se) => {
          const ke = o();
          ke.confirm(G, r(Se || ke, ne));
        }, te = () => {
          y().each((G) => {
            o().close(G), b(G);
          });
        };
        return e.on("remove", () => {
          ae(n, (G) => {
            o().close(G);
          });
        }), {
          open: N,
          openUrl: M,
          alert: I,
          confirm: X,
          close: te
        };
      }, M7 = (e, n) => {
        e.notificationManager.open({
          type: "error",
          text: n
        });
      }, kT = (e, n) => {
        e._skinLoaded ? M7(e, n) : e.on("SkinLoaded", () => {
          M7(e, n);
        });
      }, P7 = (e, n) => {
        kT(e, Fu.translate([
          "Failed to upload image: {0}",
          n
        ]));
      }, ju = (e, n, o) => {
        gl(e, n, { message: o });
      }, _T = (e, n, o) => o ? `Failed to load ${e}: ${o} from url ${n}` : `Failed to load ${e} url: ${n}`, Hj = (e, n, o) => {
        ju(e, "PluginLoadError", _T("plugin", n, o));
      }, B7 = (e, n, o) => {
        ju(e, "IconsLoadError", _T("icons", n, o));
      }, z2 = (e, n, o) => {
        ju(e, "LanguageLoadError", _T("language", n, o));
      }, $7 = (e, n, o) => {
        ju(e, "ThemeLoadError", _T("theme", n, o));
      }, MP = (e, n, o) => {
        ju(e, "ModelLoadError", _T("model", n, o));
      }, PP = (e, n, o) => {
        const r = Fu.translate([
          "Failed to initialize plugin: {0}",
          n
        ]);
        gl(e, "PluginLoadError", { message: r }), V2(r, o), kT(e, r);
      }, V2 = (e, ...n) => {
        const o = window.console;
        o && (o.error ? o.error(e, ...n) : o.log(e, ...n));
      }, F7 = (e) => /^[a-z0-9\-]+$/i.test(e), iO = (e) => "content/" + e + "/content.css", Mp = (e) => tinymce.Resource.has(iO(e)), I7 = (e) => BP(e, uC(e)), L7 = (e) => BP(e, mS(e)), BP = (e, n) => {
        const o = e.editorManager.baseURL + "/skins/content", c = `content${e.editorManager.suffix}.css`;
        return ye(n, (u) => Mp(u) ? u : F7(u) && !e.inline ? `${o}/${u}/${c}` : e.documentBaseURI.toAbsolute(u));
      }, H7 = (e) => {
        e.contentCSS = e.contentCSS.concat(I7(e), L7(e));
      }, z7 = (e) => e ? rs(e.getElementsByTagName("img")) : [], V7 = (e, n) => {
        const o = {};
        return { findAll: (c, u = ot) => {
          const f = Yt(z7(c), (y) => {
            const E = y.src;
            return y.hasAttribute("data-mce-bogus") || y.hasAttribute("data-mce-placeholder") || !E || E === sn.transparentSrc ? !1 : Kn(E, "blob:") ? !e.isUploaded(E) && u(y) : Kn(E, "data:") ? u(y) : !1;
          }), b = ye(f, (y) => {
            const E = y.src;
            if (Zn(o, E))
              return o[E].then((N) => J(N) ? N : {
                image: y,
                blobInfo: N.blobInfo
              });
            {
              const N = Aj(n, E).then((M) => (delete o[E], {
                image: y,
                blobInfo: M
              })).catch((M) => (delete o[E], M));
              return o[E] = N, N;
            }
          });
          return Promise.all(b);
        } };
      }, $P = () => {
        let o = {};
        const r = (I, X) => ({
          status: I,
          resultUri: X
        }), c = (I) => I in o;
        return {
          hasBlobUri: c,
          getResultUri: (I) => {
            const X = o[I];
            return X ? X.resultUri : null;
          },
          isPending: (I) => c(I) ? o[I].status === 1 : !1,
          isUploaded: (I) => c(I) ? o[I].status === 2 : !1,
          markPending: (I) => {
            o[I] = r(1, null);
          },
          markUploaded: (I, X) => {
            o[I] = r(2, X);
          },
          removeFailed: (I) => {
            delete o[I];
          },
          destroy: () => {
            o = {};
          }
        };
      };
      let U7 = 0;
      const W7 = () => {
        const e = () => Math.round(Math.random() * 4294967295).toString(36);
        return "s" + (/* @__PURE__ */ new Date()).getTime().toString(36) + e() + e() + e();
      }, AT = (e) => e + U7++ + W7(), Z7 = () => {
        let e = [];
        const n = (M) => ({
          "image/jpeg": "jpg",
          "image/jpg": "jpg",
          "image/gif": "gif",
          "image/png": "png",
          "image/apng": "apng",
          "image/avif": "avif",
          "image/svg+xml": "svg",
          "image/webp": "webp",
          "image/bmp": "bmp",
          "image/tiff": "tiff"
        })[M.toLowerCase()] || "dat", o = (M, I, X, te, G) => {
          if (J(M))
            return r({
              id: M,
              name: te,
              filename: G,
              blob: I,
              base64: X
            });
          if (Qe(M))
            return r(M);
          throw new Error("Unknown input type");
        }, r = (M) => {
          if (!M.blob || !M.base64)
            throw new Error("blob and base64 representations of the image are required for BlobInfo to be created");
          const I = M.id || AT("blobid"), X = M.name || I, te = M.blob;
          return {
            id: it(I),
            name: it(X),
            filename: it(M.filename || X + "." + n(te.type)),
            blob: it(te),
            base64: it(M.base64),
            blobUri: it(M.blobUri || URL.createObjectURL(te)),
            uri: it(M.uri)
          };
        }, c = (M) => {
          f(M.id()) || e.push(M);
        }, u = (M) => hn(e, M).getOrUndefined(), f = (M) => u((I) => I.id() === M);
        return {
          create: o,
          add: c,
          get: f,
          getByUri: (M) => u((I) => I.blobUri() === M),
          getByData: (M, I) => u((X) => X.base64() === M && X.blob().type === I),
          findFirst: u,
          removeByUri: (M) => {
            e = Yt(e, (I) => I.blobUri() === M ? (URL.revokeObjectURL(I.blobUri()), !1) : !0);
          },
          destroy: () => {
            ae(e, (M) => {
              URL.revokeObjectURL(M.blobUri());
            }), e = [];
          }
        };
      }, j7 = (e, n) => {
        const o = {}, r = (G, ne) => G ? G.replace(/\/$/, "") + "/" + ne.replace(/^\//, "") : ne, c = (G, ne) => new Promise((Se, ke) => {
          const Ae = new XMLHttpRequest();
          Ae.open("POST", n.url), Ae.withCredentials = n.credentials, Ae.upload.onprogress = (pt) => {
            ne(pt.loaded / pt.total * 100);
          }, Ae.onerror = () => {
            ke("Image upload failed due to a XHR Transport error. Code: " + Ae.status);
          }, Ae.onload = () => {
            if (Ae.status < 200 || Ae.status >= 300) {
              ke("HTTP Error: " + Ae.status);
              return;
            }
            const pt = JSON.parse(Ae.responseText);
            if (!pt || !J(pt.location)) {
              ke("Invalid JSON: " + Ae.responseText);
              return;
            }
            Se(r(n.basePath, pt.location));
          };
          const Me = new FormData();
          Me.append("file", G.blob(), G.filename()), Ae.send(Me);
        }), u = re(n.handler) ? n.handler : c, f = () => new Promise((G) => {
          G([]);
        }), b = (G, ne) => ({
          url: ne,
          blobInfo: G,
          status: !0
        }), y = (G, ne) => ({
          url: "",
          blobInfo: G,
          status: !1,
          error: ne
        }), E = (G, ne) => {
          _t.each(o[G], (Se) => {
            Se(ne);
          }), delete o[G];
        }, N = (G, ne, Se) => (e.markPending(G.blobUri()), new Promise((ke) => {
          let Ae, Me;
          try {
            const pt = () => {
              Ae && (Ae.close(), Me = Oe);
            }, It = (nt) => {
              pt(), e.markUploaded(G.blobUri(), nt), E(G.blobUri(), b(G, nt)), ke(b(G, nt));
            }, un = (nt) => {
              pt(), e.removeFailed(G.blobUri()), E(G.blobUri(), y(G, nt)), ke(y(G, nt));
            };
            Me = (nt) => {
              nt < 0 || nt > 100 || F.from(Ae).orThunk(() => F.from(Se).map(bt)).each((qe) => {
                Ae = qe, qe.progressBar.value(nt);
              });
            }, ne(G, Me).then(It, (nt) => {
              un(J(nt) ? { message: nt } : nt);
            });
          } catch (pt) {
            ke(y(G, pt));
          }
        })), M = (G) => G === c, I = (G) => {
          const ne = G.blobUri();
          return new Promise((Se) => {
            o[ne] = o[ne] || [], o[ne].push(Se);
          });
        }, X = (G, ne) => (G = _t.grep(G, (Se) => !e.isUploaded(Se.blobUri())), Promise.all(_t.map(G, (Se) => e.isPending(Se.blobUri()) ? I(Se) : N(Se, u, ne))));
        return { upload: (G, ne) => !n.url && M(u) ? f() : X(G, ne) };
      }, q7 = (e) => () => e.notificationManager.open({
        text: e.translate("Image uploading..."),
        type: "info",
        timeout: -1,
        progressBar: !0
      }), Dv = (e, n) => j7(n, {
        url: Yk(e),
        basePath: Xk(e),
        credentials: cC(e),
        handler: Jk(e)
      }), G7 = (e) => {
        const n = $P(), o = Dv(e, n);
        return { upload: (r, c = !0) => o.upload(r, c ? q7(e) : void 0) };
      }, lO = (e, n) => e.dom.isEmpty(n.dom) && De(e.schema.getTextBlockElements()[Qo(n)]), K7 = (e) => (n) => {
        lO(e, n) && la(n, le.fromHtml('<br data-mce-bogus="1" />'));
      }, Y7 = (e) => {
        const n = Z7();
        let o, r;
        const c = $P(), u = [], f = (Ae) => (Me) => e.selection ? Ae(Me) : [], b = (Ae) => Ae + (Ae.indexOf("?") === -1 ? "?" : "&") + (/* @__PURE__ */ new Date()).getTime(), y = (Ae, Me, pt) => {
          let It = 0;
          do
            It = Ae.indexOf(Me, It), It !== -1 && (Ae = Ae.substring(0, It) + pt + Ae.substr(It + Me.length), It += pt.length - Me.length + 1);
          while (It !== -1);
          return Ae;
        }, E = (Ae, Me, pt) => {
          const It = `src="${pt}"${pt === sn.transparentSrc ? ' data-mce-placeholder="1"' : ""}`;
          return Ae = y(Ae, `src="${Me}"`, It), Ae = y(Ae, 'data-mce-src="' + Me + '"', 'data-mce-src="' + pt + '"'), Ae;
        }, N = (Ae, Me) => {
          ae(e.undoManager.data, (pt) => {
            pt.type === "fragmented" ? pt.fragments = ye(pt.fragments, (It) => E(It, Ae, Me)) : pt.content = E(pt.content, Ae, Me);
          });
        }, M = (Ae, Me) => {
          const pt = e.convertURL(Me, "src");
          N(Ae.src, Me), Br(le.fromDom(Ae), {
            src: P1(e) ? b(Me) : Me,
            "data-mce-src": pt
          });
        }, I = () => (o || (o = Dv(e, c)), ne().then(f((Ae) => {
          const Me = ye(Ae, (pt) => pt.blobInfo);
          return o.upload(Me, q7(e)).then(f((pt) => {
            const It = [];
            let un = !1;
            const nt = ye(pt, (qe, xt) => {
              const { blobInfo: bn, image: Yn } = Ae[xt];
              let Po = !1;
              return qe.status && dS(e) ? (qe.url && !Mn(Yn.src, qe.url) && (un = !0), n.removeByUri(Yn.src), Yg(e) || M(Yn, qe.url)) : qe.error && (qe.error.remove && (N(Yn.src, sn.transparentSrc), It.push(Yn), Po = !0), P7(e, qe.error.message)), {
                element: Yn,
                status: qe.status,
                uploadUri: qe.url,
                blobInfo: bn,
                removed: Po
              };
            });
            return It.length > 0 && !Yg(e) ? e.undoManager.transact(() => {
              ae(_u(It), (qe) => {
                const xt = lc(qe);
                bs(qe), xt.each(K7(e)), n.removeByUri(qe.dom.src);
              });
            }) : un && e.undoManager.dispatchChange(), nt;
          }));
        }))), X = () => uS(e) ? I() : Promise.resolve([]), te = (Ae) => No(u, (Me) => Me(Ae)), G = (Ae) => {
          u.push(Ae);
        }, ne = () => (r || (r = V7(c, n)), r.findAll(e.getBody(), te).then(f((Ae) => {
          const Me = Yt(Ae, (pt) => J(pt) ? (kT(e, pt), !1) : pt.uriType !== "blob");
          return Yg(e) || ae(Me, (pt) => {
            N(pt.image.src, pt.blobInfo.blobUri()), pt.image.src = pt.blobInfo.blobUri(), pt.image.removeAttribute("data-mce-src");
          }), Me;
        }))), Se = () => {
          n.destroy(), c.destroy(), r = o = null;
        }, ke = (Ae) => Ae.replace(/src="(blob:[^"]+)"/g, (Me, pt) => {
          const It = c.getResultUri(pt);
          if (It)
            return 'src="' + It + '"';
          let un = n.getByUri(pt);
          return un || (un = Xe(e.editorManager.get(), (nt, qe) => nt || qe.editorUpload && qe.editorUpload.blobCache.getByUri(pt), void 0)), un ? 'src="data:' + un.blob().type + ";base64," + un.base64() + '"' : Me;
        });
        return e.on("SetContent", () => {
          uS(e) ? X() : ne();
        }), e.on("RawSaveContent", (Ae) => {
          Ae.content = ke(Ae.content);
        }), e.on("GetContent", (Ae) => {
          Ae.source_view || Ae.format === "raw" || Ae.format === "tree" || (Ae.content = ke(Ae.content));
        }), e.on("PostRender", () => {
          e.parser.addNodeFilter("img", (Ae) => {
            ae(Ae, (Me) => {
              const pt = Me.attr("src");
              if (!pt || n.getByUri(pt))
                return;
              const It = c.getResultUri(pt);
              It && Me.attr("src", It);
            });
          });
        }), {
          blobCache: n,
          addFilter: G,
          uploadImages: I,
          uploadImagesAuto: X,
          scanForImages: ne,
          destroy: Se
        };
      }, X7 = (e) => {
        const n = e.dom, o = e.schema.type, r = {
          valigntop: [{
            selector: "td,th",
            styles: { verticalAlign: "top" }
          }],
          valignmiddle: [{
            selector: "td,th",
            styles: { verticalAlign: "middle" }
          }],
          valignbottom: [{
            selector: "td,th",
            styles: { verticalAlign: "bottom" }
          }],
          alignleft: [
            {
              selector: "figure.image",
              collapsed: !1,
              classes: "align-left",
              ceFalseOverride: !0,
              preview: "font-family font-size"
            },
            {
              selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
              styles: { textAlign: "left" },
              inherit: !1,
              preview: !1
            },
            {
              selector: "img,audio,video",
              collapsed: !1,
              styles: { float: "left" },
              preview: "font-family font-size"
            },
            {
              selector: "table",
              collapsed: !1,
              styles: {
                marginLeft: "0px",
                marginRight: "auto"
              },
              onformat: (c) => {
                n.setStyle(c, "float", null);
              },
              preview: "font-family font-size"
            },
            {
              selector: ".mce-preview-object,[data-ephox-embed-iri]",
              ceFalseOverride: !0,
              styles: { float: "left" }
            }
          ],
          aligncenter: [
            {
              selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
              styles: { textAlign: "center" },
              inherit: !1,
              preview: "font-family font-size"
            },
            {
              selector: "figure.image",
              collapsed: !1,
              classes: "align-center",
              ceFalseOverride: !0,
              preview: "font-family font-size"
            },
            {
              selector: "img,audio,video",
              collapsed: !1,
              styles: {
                display: "block",
                marginLeft: "auto",
                marginRight: "auto"
              },
              preview: !1
            },
            {
              selector: "table",
              collapsed: !1,
              styles: {
                marginLeft: "auto",
                marginRight: "auto"
              },
              preview: "font-family font-size"
            },
            {
              selector: ".mce-preview-object",
              ceFalseOverride: !0,
              styles: {
                display: "table",
                marginLeft: "auto",
                marginRight: "auto"
              },
              preview: !1
            },
            {
              selector: "[data-ephox-embed-iri]",
              ceFalseOverride: !0,
              styles: {
                marginLeft: "auto",
                marginRight: "auto"
              },
              preview: !1
            }
          ],
          alignright: [
            {
              selector: "figure.image",
              collapsed: !1,
              classes: "align-right",
              ceFalseOverride: !0,
              preview: "font-family font-size"
            },
            {
              selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
              styles: { textAlign: "right" },
              inherit: !1,
              preview: "font-family font-size"
            },
            {
              selector: "img,audio,video",
              collapsed: !1,
              styles: { float: "right" },
              preview: "font-family font-size"
            },
            {
              selector: "table",
              collapsed: !1,
              styles: {
                marginRight: "0px",
                marginLeft: "auto"
              },
              onformat: (c) => {
                n.setStyle(c, "float", null);
              },
              preview: "font-family font-size"
            },
            {
              selector: ".mce-preview-object,[data-ephox-embed-iri]",
              ceFalseOverride: !0,
              styles: { float: "right" },
              preview: !1
            }
          ],
          alignjustify: [{
            selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
            styles: { textAlign: "justify" },
            inherit: !1,
            preview: "font-family font-size"
          }],
          bold: [
            {
              inline: "strong",
              remove: "all",
              preserve_attributes: [
                "class",
                "style"
              ]
            },
            {
              inline: "span",
              styles: { fontWeight: "bold" }
            },
            {
              inline: "b",
              remove: "all",
              preserve_attributes: [
                "class",
                "style"
              ]
            }
          ],
          italic: [
            {
              inline: "em",
              remove: "all",
              preserve_attributes: [
                "class",
                "style"
              ]
            },
            {
              inline: "span",
              styles: { fontStyle: "italic" }
            },
            {
              inline: "i",
              remove: "all",
              preserve_attributes: [
                "class",
                "style"
              ]
            }
          ],
          underline: [
            {
              inline: "span",
              styles: { textDecoration: "underline" },
              exact: !0
            },
            {
              inline: "u",
              remove: "all",
              preserve_attributes: [
                "class",
                "style"
              ]
            }
          ],
          strikethrough: /* @__PURE__ */ (() => {
            const c = {
              inline: "span",
              styles: { textDecoration: "line-through" },
              exact: !0
            }, u = {
              inline: "strike",
              remove: "all",
              preserve_attributes: [
                "class",
                "style"
              ]
            }, f = {
              inline: "s",
              remove: "all",
              preserve_attributes: [
                "class",
                "style"
              ]
            };
            return o !== "html4" ? [
              f,
              c,
              u
            ] : [
              c,
              f,
              u
            ];
          })(),
          forecolor: {
            inline: "span",
            styles: { color: "%value" },
            links: !0,
            remove_similar: !0,
            clear_child_styles: !0
          },
          hilitecolor: {
            inline: "span",
            styles: { backgroundColor: "%value" },
            links: !0,
            remove_similar: !0,
            clear_child_styles: !0
          },
          fontname: {
            inline: "span",
            toggle: !1,
            styles: { fontFamily: "%value" },
            clear_child_styles: !0
          },
          fontsize: {
            inline: "span",
            toggle: !1,
            styles: { fontSize: "%value" },
            clear_child_styles: !0
          },
          lineheight: {
            selector: "h1,h2,h3,h4,h5,h6,p,li,td,th,div",
            styles: { lineHeight: "%value" }
          },
          fontsize_class: {
            inline: "span",
            attributes: { class: "%value" }
          },
          blockquote: {
            block: "blockquote",
            wrapper: !0,
            remove: "all"
          },
          subscript: { inline: "sub" },
          superscript: { inline: "sup" },
          code: { inline: "code" },
          link: {
            inline: "a",
            selector: "a",
            remove: "all",
            split: !0,
            deep: !0,
            onmatch: (c, u, f) => xn(c) && c.hasAttribute("href"),
            onformat: (c, u, f) => {
              _t.each(f, (b, y) => {
                n.setAttrib(c, y, b);
              });
            }
          },
          lang: {
            inline: "span",
            clear_child_styles: !0,
            remove_similar: !0,
            attributes: {
              lang: "%value",
              "data-mce-lang": (c) => {
                var u;
                return (u = c?.customValue) !== null && u !== void 0 ? u : null;
              }
            }
          },
          removeformat: [
            {
              selector: "b,strong,em,i,font,u,strike,s,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins,small",
              remove: "all",
              split: !0,
              expand: !1,
              block_expand: !0,
              deep: !0
            },
            {
              selector: "span",
              attributes: [
                "style",
                "class"
              ],
              remove: "empty",
              split: !0,
              expand: !1,
              deep: !0
            },
            {
              selector: "*",
              attributes: [
                "style",
                "class"
              ],
              split: !1,
              expand: !1,
              deep: !0
            }
          ]
        };
        return _t.each("p h1 h2 h3 h4 h5 h6 div address pre dt dd samp".split(/\s/), (c) => {
          r[c] = {
            block: c,
            remove: "all"
          };
        }), r;
      }, FP = {
        remove_similar: !0,
        inherit: !1
      }, em = {
        selector: "td,th",
        ...FP
      }, Ab = {
        tablecellbackgroundcolor: {
          styles: { backgroundColor: "%value" },
          ...em
        },
        tablecellverticalalign: {
          styles: { "vertical-align": "%value" },
          ...em
        },
        tablecellbordercolor: {
          styles: { borderColor: "%value" },
          ...em
        },
        tablecellclass: {
          classes: ["%value"],
          ...em
        },
        tableclass: {
          selector: "table",
          classes: ["%value"],
          ...FP
        },
        tablecellborderstyle: {
          styles: { borderStyle: "%value" },
          ...em
        },
        tablecellborderwidth: {
          styles: { borderWidth: "%value" },
          ...em
        }
      }, OT = it(Ab), DT = (e) => {
        const n = {}, o = (f) => De(f) ? n[f] : n, r = (f) => Zn(n, f), c = (f, b) => {
          f && (J(f) ? (ht(b) || (b = [b]), ae(b, (y) => {
            Ht(y.deep) && (y.deep = !Hc(y)), Ht(y.split) && (y.split = !Hc(y) || Ba(y)), Ht(y.remove) && Hc(y) && !Ba(y) && (y.remove = "none"), Hc(y) && Ba(y) && (y.mixed = !0, y.block_expand = !0), J(y.classes) && (y.classes = y.classes.split(/\s+/));
          }), n[f] = b) : Dt(f, (y, E) => {
            c(E, y);
          }));
        }, u = (f) => (f && n[f] && delete n[f], n);
        return c(X7(e)), c(OT()), c(o_(e)), {
          get: o,
          has: r,
          register: c,
          unregister: u
        };
      }, jf = _t.each, Mi = xr.DOM, Rv = (e) => De(e) && Qe(e), U2 = (e, n) => {
        const o = n && n.schema || Tm({}), r = (y, E) => {
          E.classes.length > 0 && Mi.addClass(y, E.classes.join(" ")), Mi.setAttribs(y, E.attrs);
        }, c = (y) => {
          const E = J(y) ? {
            name: y,
            classes: [],
            attrs: {}
          } : y, N = Mi.create(E.name);
          return r(N, E), N;
        }, u = (y, E) => {
          const N = o.getElementRule(y.nodeName.toLowerCase()), M = N?.parentsRequired;
          return M && M.length ? E && ee(M, E) ? E : M[0] : !1;
        }, f = (y, E, N) => {
          let M;
          const I = E[0], X = Rv(I) ? I.name : void 0, te = u(y, X);
          if (te)
            X === te ? (M = I, E = E.slice(1)) : M = te;
          else if (I)
            M = I, E = E.slice(1);
          else if (!N)
            return y;
          const G = M ? c(M) : Mi.create("div");
          G.appendChild(y), N && _t.each(N, (Se) => {
            const ke = c(Se);
            G.insertBefore(ke, y);
          });
          const ne = Rv(M) ? M.siblings : void 0;
          return f(G, E, ne);
        }, b = Mi.create("div");
        if (e.length > 0) {
          const y = e[0], E = c(y), N = Rv(y) ? y.siblings : void 0;
          b.appendChild(f(E, e.slice(1), N));
        }
        return b;
      }, IP = (e) => {
        e = _t.trim(e);
        let n = "div";
        const o = {
          name: n,
          classes: [],
          attrs: {},
          selector: e
        };
        return e !== "*" && (n = e.replace(/(?:([#\.]|::?)([\w\-]+)|(\[)([^\]]+)\]?)/g, (r, c, u, f, b) => {
          switch (c) {
            case "#":
              o.attrs.id = u;
              break;
            case ".":
              o.classes.push(u);
              break;
            case ":":
              _t.inArray("checked disabled enabled read-only required".split(" "), u) !== -1 && (o.attrs[u] = u);
              break;
          }
          if (f === "[") {
            const y = b.match(/([\w\-]+)(?:\=\"([^\"]+))?/);
            y && (o.attrs[y[1]] = y[2]);
          }
          return "";
        })), o.name = n || "div", o;
      }, uO = (e) => J(e) ? (e = e.split(/\s*,\s*/)[0], e = e.replace(/\s*(~\+|~|\+|>)\s*/g, "$1"), _t.map(e.split(/(?:>|\s+(?![^\[\]]+\]))/), (n) => {
        const o = _t.map(n.split(/(?:~\+|~|\+)/), IP), r = o.pop();
        return o.length && (r.siblings = o), r;
      }).reverse()) : [], dO = (e, n) => {
        let o = "", r = hS(e);
        if (r === "")
          return "";
        const c = (I) => J(I) ? I.replace(/%(\w+)/g, "") : "", u = (I, X) => Mi.getStyle(X ?? e.getBody(), I, !0);
        if (J(n)) {
          const I = e.formatter.get(n);
          if (!I)
            return "";
          n = I[0];
        }
        if ("preview" in n) {
          const I = n.preview;
          if (I === !1)
            return "";
          r = I || r;
        }
        let f = n.block || n.inline || "span", b;
        const y = uO(n.selector);
        y.length > 0 ? (y[0].name || (y[0].name = f), f = n.selector, b = U2(y, e)) : b = U2([f], e);
        const E = Mi.select(f, b)[0] || b.firstChild;
        jf(n.styles, (I, X) => {
          const te = c(I);
          te && Mi.setStyle(E, X, te);
        }), jf(n.attributes, (I, X) => {
          const te = c(I);
          te && Mi.setAttrib(E, X, te);
        }), jf(n.classes, (I) => {
          const X = c(I);
          Mi.hasClass(E, X) || Mi.addClass(E, X);
        }), e.dispatch("PreviewFormats"), Mi.setStyles(b, {
          position: "absolute",
          left: -65535
        }), e.getBody().appendChild(b);
        const N = u("fontSize"), M = /px$/.test(N) ? parseInt(N, 10) : 0;
        return jf(r.split(" "), (I) => {
          let X = u(I, E);
          if (!(I === "background-color" && /transparent|rgba\s*\([^)]+,\s*0\)/.test(X) && (X = u(I), kh(X).toLowerCase() === "#ffffff")) && !(I === "color" && kh(X).toLowerCase() === "#000000")) {
            if (I === "font-size" && /em|%$/.test(X)) {
              if (M === 0)
                return;
              X = parseFloat(X) / (/%$/.test(X) ? 100 : 1) * M + "px";
            }
            I === "border" && X && (o += "padding:0 2px;"), o += I + ":" + X + ";";
          }
        }), e.dispatch("AfterPreviewFormats"), Mi.remove(b), o;
      }, LP = (e) => {
        e.addShortcut("meta+b", "", "Bold"), e.addShortcut("meta+i", "", "Italic"), e.addShortcut("meta+u", "", "Underline");
        for (let n = 1; n <= 6; n++)
          e.addShortcut("access+" + n, "", [
            "FormatBlock",
            !1,
            "h" + n
          ]);
        e.addShortcut("access+7", "", [
          "FormatBlock",
          !1,
          "p"
        ]), e.addShortcut("access+8", "", [
          "FormatBlock",
          !1,
          "div"
        ]), e.addShortcut("access+9", "", [
          "FormatBlock",
          !1,
          "address"
        ]);
      }, mO = (e) => {
        const n = DT(e), o = jr({});
        return LP(e), D6(e), Yg(e) || V6(o, e), {
          get: n.get,
          has: n.has,
          register: n.register,
          unregister: n.unregister,
          apply: (r, c, u) => {
            Y8(e, r, c, u);
          },
          remove: (r, c, u, f) => {
            X8(e, r, c, u, f);
          },
          toggle: (r, c, u) => {
            J8(e, r, c, u);
          },
          match: (r, c, u, f) => mP(e, r, c, u, f),
          closest: (r) => tO(e, r),
          matchAll: (r, c) => fP(e, r, c),
          matchNode: (r, c, u, f) => eO(e, r, c, u, f),
          canApply: (r) => gP(e, r),
          formatChanged: (r, c, u, f) => xd(e, o, r, c, u, f),
          getCssText: Ye(dO, e)
        };
      }, Ob = (e) => {
        switch (e.toLowerCase()) {
          case "undo":
          case "redo":
          case "mcefocus":
            return !0;
          default:
            return !1;
        }
      }, HP = (e, n, o) => {
        const r = jr(!1), c = (y) => {
          wT(n, !1, o), n.add({}, y);
        };
        e.on("init", () => {
          n.add();
        }), e.on("BeforeExecCommand", (y) => {
          const E = y.command;
          Ob(E) || (aP(n, o), n.beforeChange());
        }), e.on("ExecCommand", (y) => {
          const E = y.command;
          Ob(E) || c(y);
        }), e.on("ObjectResizeStart cut", () => {
          n.beforeChange();
        }), e.on("SaveContent ObjectResized blur", c), e.on("dragend", c), e.on("keyup", (y) => {
          const E = y.keyCode;
          if (y.isDefaultPrevented())
            return;
          const N = sn.os.isMacOS() && y.key === "Meta";
          (E >= 33 && E <= 36 || E >= 37 && E <= 40 || E === 45 || y.ctrlKey || N) && (c(), e.nodeChanged()), (E === 46 || E === 8) && e.nodeChanged(), r.get() && n.typing && !Y3(CT(e), n.data[0]) && (e.isDirty() || e.setDirty(!0), e.dispatch("TypingUndo"), r.set(!1), e.nodeChanged());
        }), e.on("keydown", (y) => {
          const E = y.keyCode;
          if (y.isDefaultPrevented())
            return;
          if (E >= 33 && E <= 36 || E >= 37 && E <= 40 || E === 45) {
            n.typing && c(y);
            return;
          }
          const N = y.ctrlKey && !y.altKey || y.metaKey;
          if ((E < 16 || E > 20) && E !== 224 && E !== 91 && !n.typing && !N) {
            n.beforeChange(), wT(n, !0, o), n.add({}, y), r.set(!0);
            return;
          }
          (sn.os.isMacOS() ? y.metaKey : y.ctrlKey && !y.altKey) && n.beforeChange();
        }), e.on("mousedown", (y) => {
          n.typing && c(y);
        });
        const u = (y) => y.inputType === "insertReplacementText", f = (y) => y.inputType === "insertText" && y.data === null, b = (y) => y.inputType === "insertFromPaste" || y.inputType === "insertFromDrop";
        e.on("input", (y) => {
          y.inputType && (u(y) || f(y) || b(y)) && c(y);
        }), e.on("AddUndo Undo Redo ClearUndos", (y) => {
          y.isDefaultPrevented() || e.nodeChanged();
        });
      }, zP = (e) => {
        e.addShortcut("meta+z", "", "Undo"), e.addShortcut("meta+y,meta+shift+z", "", "Redo");
      }, fO = (e) => {
        const n = Cf(), o = jr(0), r = jr(0), c = {
          data: [],
          typing: !1,
          beforeChange: () => {
            Pj(e, o, n);
          },
          add: (u, f) => vi(e, c, r, o, n, u, f),
          dispatchChange: () => {
            e.setDirty(!0);
            const u = CT(e);
            u.bookmark = Vh(e.selection), e.dispatch("change", {
              level: u,
              lastLevel: nn(c.data, r.get()).getOrUndefined()
            });
          },
          undo: () => lP(e, c, o, r),
          redo: () => uP(e, r, c.data),
          clear: () => {
            dP(e, c, r);
          },
          reset: () => {
            j8(e, c);
          },
          hasUndo: () => q8(e, c, r),
          hasRedo: () => ST(e, c, r),
          transact: (u) => G8(e, c, o, u),
          ignore: (u) => {
            Q3(e, o, u);
          },
          extra: (u, f) => {
            K8(e, c, r, u, f);
          }
        };
        return Yg(e) || HP(e, c, o), zP(e), c;
      }, RT = [
        9,
        27,
        Tn.HOME,
        Tn.END,
        19,
        20,
        44,
        144,
        145,
        33,
        34,
        45,
        16,
        17,
        18,
        91,
        92,
        93,
        Tn.DOWN,
        Tn.UP,
        Tn.LEFT,
        Tn.RIGHT
      ].concat(sn.browser.isFirefox() ? [224] : []), gO = "data-mce-placeholder", hO = (e) => e.type === "keydown" || e.type === "keyup", pO = (e) => {
        const n = e.keyCode;
        return n === Tn.BACKSPACE || n === Tn.DELETE;
      }, VP = (e) => {
        if (hO(e)) {
          const n = e.keyCode;
          return !pO(e) && (Tn.metaKeyPressed(e) || e.altKey || n >= 112 && n <= 123 || ee(RT, n));
        } else
          return !1;
      }, Jg = (e) => hO(e) && !(pO(e) || e.type === "keyup" && e.keyCode === 229), Pp = (e, n, o) => {
        if (sa(le.fromDom(n), !1)) {
          const r = n.firstElementChild;
          return r ? e.getStyle(n.firstElementChild, "padding-left") || e.getStyle(n.firstElementChild, "padding-right") ? !1 : o === r.nodeName.toLowerCase() : !0;
        } else
          return !1;
      }, tm = (e) => {
        var n;
        const o = e.dom, r = gi(e), c = (n = X4(e)) !== null && n !== void 0 ? n : "", u = (f, b) => {
          if (VP(f))
            return;
          const y = e.getBody(), E = Jg(f) ? !1 : Pp(o, y, r);
          (o.getAttrib(y, gO) !== "" !== E || b) && (o.setAttrib(y, gO, E ? c : null), o.setAttrib(y, "aria-placeholder", E ? c : null), U_(e, E), e.on(E ? "keydown" : "keyup", u), e.off(E ? "keyup" : "keydown", u));
        };
        lo(c) && e.on("init", (f) => {
          u(f, !0), e.on("change SetContent ExecCommand", u), e.on("paste", (b) => Uu.setEditorTimeout(e, () => u(b)));
        });
      }, J7 = (e, n) => ({
        block: e,
        position: n
      }), Q7 = (e, n) => ({
        from: e,
        to: n
      }), bO = (e, n) => {
        const o = le.fromDom(e), r = le.fromDom(n.container());
        return pv(o, r).map((c) => J7(c, n));
      }, eH = (e) => !fs(e.from.block, e.to.block), UP = (e, n) => ci(n, (c) => Ai(c) || Kc(c.dom), (c) => fs(c, e)).filter(yn).getOr(e), tH = (e, n) => {
        const o = le.fromDom(e);
        return fs(UP(o, n.from.block), UP(o, n.to.block));
      }, nH = (e) => es(e.from.block.dom) === !1 && es(e.to.block.dom) === !1, oH = (e) => {
        const n = (o) => Ne(o) || o0(o.dom);
        return n(e.from.block) && n(e.to.block);
      }, sH = (e, n, o) => Js(o.position.getNode()) && !sa(o.block) ? rp(!1, o.block.dom).bind((r) => r.isEqual(o.position) ? Tc(n, e, r).bind((c) => bO(e, c)) : F.some(o)).getOr(o) : o, rH = (e, n, o) => {
        const r = bO(e, We.fromRangeStart(o)), c = r.bind((u) => Tc(n, e, u.position).bind((f) => bO(e, f).map((b) => sH(e, n, b))));
        return Zr(r, c, Q7).filter((u) => eH(u) && tH(e, u) && nH(u) && oH(u));
      }, aH = (e, n, o) => o.collapsed ? rH(e, n, o) : F.none(), cH = (e, n) => {
        const o = Ea(e);
        return Xn(o, (r) => n.isBlock(Qo(r))).fold(it(o), (r) => o.slice(0, r));
      }, NT = (e, n) => {
        const o = cH(e, n);
        return ae(o, bs), o;
      }, MT = (e, n) => {
        const o = Lf(n, e);
        return hn(o.reverse(), (r) => sa(r)).each(bs);
      }, WP = (e) => Yt(ng(e), (n) => !sa(n)).length === 0, iH = (e, n, o, r, c) => {
        if (sa(o))
          return Nu(o), Ri(o.dom);
        WP(c) && sa(n) && ka(c, le.fromTag("br"));
        const u = ji(o.dom, We.before(c.dom));
        return ae(NT(n, r), (f) => {
          ka(c, f);
        }), MT(e, n), u;
      }, lH = (e, n) => e.isInline(Qo(n)), ZP = (e, n, o, r) => {
        if (sa(o)) {
          if (sa(n)) {
            const f = Ct(((b) => {
              const y = (E, N) => mm(E).fold(() => N, (M) => lH(r, M) ? y(M, N.concat(dl(M))) : N);
              return y(b, []);
            })(o), (b, y) => (ag(b, y), y), di());
            Ei(n), la(n, f);
          }
          return bs(o), Ri(n.dom);
        }
        const c = Hu(o.dom);
        return ae(NT(n, r), (u) => {
          la(o, u);
        }), MT(e, n), c;
      }, jP = (e, n) => {
        const o = Lf(n, e);
        return F.from(o[o.length - 1]);
      }, vO = (e, n) => ic(n, e) ? jP(n, e) : F.none(), yO = (e, n) => {
        rp(e, n.dom).bind((o) => F.from(o.getNode())).map(le.fromDom).filter(Pd).each(bs);
      }, CO = (e, n, o, r) => (yO(!0, n), yO(!1, o), vO(n, o).fold(Ye(ZP, e, n, o, r), Ye(iH, e, n, o, r))), PT = (e, n, o, r, c) => n ? CO(e, r, o, c) : CO(e, o, r, c), wO = (e, n) => {
        const o = le.fromDom(e.getBody());
        return aH(o.dom, n, e.selection.getRng()).map((c) => () => {
          PT(o, n, c.from.block, c.to.block, e.schema).each((u) => {
            e.selection.setRng(u.toRange());
          });
        });
      }, uH = (e, n, o) => {
        const r = n.getRng();
        return Zr(pv(e, le.fromDom(r.startContainer)), pv(e, le.fromDom(r.endContainer)), (c, u) => fs(c, u) ? F.none() : F.some(() => {
          r.deleteContents(), PT(e, !0, c, u, o).each((f) => {
            n.setRng(f.toRange());
          });
        })).getOr(F.none());
      }, jm = (e, n) => {
        const o = le.fromDom(n), r = Ye(fs, e);
        return Ar(o, Ai, r).isSome();
      }, nm = (e, n) => jm(e, n.startContainer) || jm(e, n.endContainer), BT = (e, n) => {
        const o = ji(e.dom, We.fromRangeStart(n)).isNone(), r = pi(e.dom, We.fromRangeEnd(n)).isNone();
        return !nm(e, n) && o && r;
      }, qP = (e) => F.some(() => {
        e.setContent(""), e.selection.setCursorLocation();
      }), $T = (e) => {
        const n = le.fromDom(e.getBody()), o = e.selection.getRng();
        return BT(n, o) ? qP(e) : uH(n, e.selection, e.schema);
      }, FT = (e, n) => e.selection.isCollapsed() ? F.none() : $T(e), qf = (e, n, o, r, c) => F.from(n._selectionOverrides.showCaret(e, o, r, c)), GP = (e) => {
        const n = e.ownerDocument.createRange();
        return n.selectNode(e), n;
      }, Nv = (e, n) => e.dispatch("BeforeObjectSelected", { target: n }).isDefaultPrevented() ? F.none() : F.some(GP(n)), KP = (e, n, o) => {
        const r = OC(1, e.getBody(), n), c = We.fromRangeStart(r), u = c.getNode();
        if (L0(u))
          return qf(1, e, u, !c.isAtEnd(), !1);
        const f = c.getNode(!0);
        if (L0(f))
          return qf(1, e, f, !1, !1);
        const b = Sp(e.dom.getRoot(), c.getNode());
        return L0(b) ? qf(1, e, b, !1, o) : F.none();
      }, IT = (e, n, o) => n.collapsed ? KP(e, n, o).getOr(n) : n, LT = (e) => Vg(e) || r2(e), SO = (e) => zm(e) || fv(e), dH = (e, n) => {
        Mt(n) && n.data.length === 0 && e.remove(n);
      }, YP = (e, n, o, r, c, u) => {
        qf(r, e, u.getNode(!c), c, !0).each((f) => {
          if (n.collapsed) {
            const b = n.cloneRange();
            c ? b.setEnd(f.startContainer, f.startOffset) : b.setStart(f.endContainer, f.endOffset), b.deleteContents();
          } else
            n.deleteContents();
          e.selection.setRng(f);
        }), dH(e.dom, o);
      }, mH = (e, n) => {
        const o = e.selection.getRng();
        if (!Mt(o.commonAncestorContainer))
          return F.none();
        const r = n ? ya.Forwards : ya.Backwards, c = fd(e.getBody()), u = Ye(BS, n ? c.next : c.prev), f = n ? LT : SO, b = Rf(r, e.getBody(), o), y = u(b), E = y && vd(n, y);
        if (!E || !DC(b, E))
          return F.none();
        if (f(E))
          return F.some(() => YP(e, o, b.getNode(), r, n, E));
        const N = u(E);
        return N && f(N) && DC(E, N) ? F.some(() => YP(e, o, b.getNode(), r, n, N)) : F.none();
      }, xO = (e, n) => mH(e, n), HT = (e, n) => {
        const o = e.getBody();
        return n ? Ri(o).filter(Vg) : Hu(o).filter(zm);
      }, TO = (e) => {
        const n = e.selection.getRng();
        return !n.collapsed && (HT(e, !0).exists((o) => o.isEqual(We.fromRangeStart(n))) || HT(e, !1).exists((o) => o.isEqual(We.fromRangeEnd(n))));
      }, fH = (e) => De(e) && (Ai(le.fromDom(e)) || al(le.fromDom(e))), jl = dd.generate([
        { remove: ["element"] },
        { moveToElement: ["element"] },
        { moveToPosition: ["position"] }
      ]), gH = (e, n) => {
        const o = n.getNode(!e), r = e ? "after" : "before";
        return xn(o) && o.getAttribute("data-mce-caret") === r;
      }, hH = (e, n, o, r, c) => {
        const u = (f) => c.isInline(f.nodeName.toLowerCase()) && !md(o, r, e);
        return PS(!n, o).fold(() => PS(n, r).fold($e, u), u);
      }, XP = (e, n, o, r) => {
        const c = r.getNode(!n);
        return pv(le.fromDom(e), le.fromDom(o.getNode())).map((u) => sa(u) ? jl.remove(u.dom) : jl.moveToElement(c)).orThunk(() => F.some(jl.moveToElement(c)));
      }, JP = (e, n, o, r) => Tc(n, e, o).bind((c) => fH(c.getNode()) || hH(e, n, o, c, r) ? F.none() : n && es(c.getNode()) || !n && es(c.getNode(!0)) ? XP(e, n, o, c) : n && zm(o) || !n && Vg(o) ? F.some(jl.moveToPosition(c)) : F.none()), pH = (e, n) => gn(n) ? F.none() : e && es(n.nextSibling) ? F.some(jl.moveToElement(n.nextSibling)) : !e && es(n.previousSibling) ? F.some(jl.moveToElement(n.previousSibling)) : F.none(), bH = (e, n, o) => o.fold((r) => F.some(jl.remove(r)), (r) => F.some(jl.moveToElement(r)), (r) => md(n, r, e) ? F.none() : F.some(jl.moveToPosition(r))), vH = (e, n, o, r) => gH(n, o) ? pH(n, o.getNode(!n)).orThunk(() => JP(e, n, o, r)) : JP(e, n, o, r).bind((c) => bH(e, o, c)), zT = (e, n, o, r) => {
        const c = OC(n ? 1 : -1, e, o), u = We.fromRangeStart(c), f = le.fromDom(e);
        return !n && zm(u) ? F.some(jl.remove(u.getNode(!0))) : n && Vg(u) ? F.some(jl.remove(u.getNode())) : !n && Vg(u) && c2(f, u, r) ? WL(f, u, r).map((b) => jl.remove(b.getNode())) : n && zm(u) && a2(f, u, r) ? ZL(f, u, r).map((b) => jl.remove(b.getNode())) : vH(e, n, u, r);
      }, EO = (e, n) => (o) => (e._selectionOverrides.hideFakeCaret(), Wg(e, n, le.fromDom(o)), !0), yH = (e, n) => (o) => {
        const r = n ? We.before(o) : We.after(o);
        return e.selection.setRng(r.toRange()), !0;
      }, CH = (e) => (n) => (e.selection.setRng(n.toRange()), !0), QP = (e, n) => F.from(Sp(e.getBody(), n)), wH = (e, n) => {
        const o = e.selection.getNode();
        return QP(e, o).filter(es).fold(() => zT(e.getBody(), n, e.selection.getRng(), e.schema).map((r) => () => r.fold(EO(e, n), yH(e, n), CH(e))), () => F.some(Oe));
      }, eB = (e) => {
        ae(uc(e, ".mce-offscreen-selection"), bs);
      }, SH = (e, n) => {
        const o = e.selection.getNode();
        return es(o) && !mg(o) ? QP(e, o.parentNode).filter(es).fold(() => F.some(() => {
          eB(le.fromDom(e.getBody())), Wg(e, n, le.fromDom(e.selection.getNode())), kA(e);
        }), () => F.some(Oe)) : TO(e) ? F.some(() => {
          Ox(e, e.selection.getRng(), le.fromDom(e.getBody()));
        }) : F.none();
      }, tB = (e) => {
        const n = e.dom, o = e.selection, r = Sp(e.getBody(), o.getNode());
        if (Kc(r) && n.isBlock(r) && n.isEmpty(r)) {
          const c = n.create("br", { "data-mce-bogus": "1" });
          n.setHTML(r, ""), r.appendChild(c), o.setRng(We.before(c).toRange());
        }
        return !0;
      }, W2 = (e, n) => e.selection.isCollapsed() ? wH(e, n) : SH(e, n), xH = (e, n) => {
        const o = We.fromRangeStart(e.selection.getRng());
        return Tc(n, e.getBody(), o).filter((r) => n ? IL(r) : LL(r)).bind((r) => U1(n ? 0 : -1, r)).map((r) => () => e.selection.select(r));
      }, kO = (e, n) => e.selection.isCollapsed() ? xH(e, n) : F.none(), Mv = Mt, nB = (e) => Mv(e) && e.data[0] === k, oB = (e) => Mv(e) && e.data[e.data.length - 1] === k, sB = (e) => {
        var n;
        return ((n = e.ownerDocument) !== null && n !== void 0 ? n : document).createTextNode(k);
      }, TH = (e) => {
        var n;
        if (Mv(e.previousSibling))
          return oB(e.previousSibling) || e.previousSibling.appendData(k), e.previousSibling;
        if (Mv(e))
          return nB(e) || e.insertData(0, k), e;
        {
          const o = sB(e);
          return (n = e.parentNode) === null || n === void 0 || n.insertBefore(o, e), o;
        }
      }, VT = (e) => {
        var n, o;
        if (Mv(e.nextSibling))
          return nB(e.nextSibling) || e.nextSibling.insertData(0, k), e.nextSibling;
        if (Mv(e))
          return oB(e) || e.appendData(k), e;
        {
          const r = sB(e);
          return e.nextSibling ? (n = e.parentNode) === null || n === void 0 || n.insertBefore(r, e.nextSibling) : (o = e.parentNode) === null || o === void 0 || o.appendChild(r), r;
        }
      }, Db = (e, n) => e ? TH(n) : VT(n), EH = Ye(Db, !0), kH = Ye(Db, !1), Z2 = (e, n) => Mt(e.container()) ? Db(n, e.container()) : Db(n, e.getNode()), rB = (e, n) => {
        const o = n.get();
        return o && e.container() === o && oo(o);
      }, _O = (e, n) => n.fold((o) => {
        nc(e.get());
        const r = EH(o);
        return e.set(r), F.some(We(r, r.length - 1));
      }, (o) => Ri(o).map((r) => {
        if (rB(r, e)) {
          const c = e.get();
          return We(c, 1);
        } else {
          nc(e.get());
          const c = Z2(r, !0);
          return e.set(c), We(c, 1);
        }
      }), (o) => Hu(o).map((r) => {
        if (rB(r, e)) {
          const c = e.get();
          return We(c, c.length - 1);
        } else {
          nc(e.get());
          const c = Z2(r, !1);
          return e.set(c), We(c, c.length - 1);
        }
      }), (o) => {
        nc(e.get());
        const r = kH(o);
        return e.set(r), F.some(We(r, 1));
      }), aB = (e, n) => {
        for (let o = 0; o < e.length; o++) {
          const r = e[o].apply(null, n);
          if (r.isSome())
            return r;
        }
        return F.none();
      }, pl = dd.generate([
        { before: ["element"] },
        { start: ["element"] },
        { end: ["element"] },
        { after: ["element"] }
      ]), cB = (e, n) => {
        const o = Dm(n, e);
        return o || e;
      }, _H = (e, n, o) => {
        const r = yr(o), c = cB(n, r.container());
        return Vc(e, c, r).fold(() => pi(c, r).bind(Ye(Vc, e, c)).map((u) => pl.before(u)), F.none);
      }, AH = (e, n) => Pg(e, n) === null, iB = (e, n, o) => Vc(e, n, o).filter(Ye(AH, n)), OH = (e, n, o) => {
        const r = oN(o);
        return iB(e, n, r).bind((c) => ji(c, r).isNone() ? F.some(pl.start(c)) : F.none());
      }, DH = (e, n, o) => {
        const r = yr(o);
        return iB(e, n, r).bind((c) => pi(c, r).isNone() ? F.some(pl.end(c)) : F.none());
      }, RH = (e, n, o) => {
        const r = oN(o), c = cB(n, r.container());
        return Vc(e, c, r).fold(() => ji(c, r).bind(Ye(Vc, e, c)).map((u) => pl.after(u)), F.none);
      }, NH = (e) => !nN(j2(e)), oi = (e, n, o) => aB([
        _H,
        OH,
        DH,
        RH
      ], [
        e,
        n,
        o
      ]).filter(NH), j2 = (e) => e.fold(Gn, Gn, Gn, Gn), AO = (e) => e.fold(it("before"), it("start"), it("end"), it("after")), q2 = (e) => e.fold(pl.before, pl.before, pl.after, pl.after), OO = (e) => e.fold(pl.start, pl.start, pl.end, pl.end), lB = (e, n) => AO(e) === AO(n) && j2(e) === j2(n), MH = (e, n, o, r, c, u) => Zr(Vc(n, o, r), Vc(n, o, c), (f, b) => f !== b && u2(o, f, b) ? pl.after(e ? f : b) : u).getOr(u), uB = (e, n) => e.fold(ot, (o) => !lB(o, n)), PH = (e, n, o, r, c) => {
        const u = vd(e, c);
        return Tc(e, o, u).map(Ye(vd, e)).fold(() => r.map(q2), (y) => oi(n, o, y).map(Ye(MH, e, n, o, u, y)).filter(Ye(uB, r))).filter(NH);
      }, BH = (e, n) => e ? n.fold(A(F.some, pl.start), F.none, A(F.some, pl.after), F.none) : n.fold(F.none, A(F.some, pl.before), F.none, A(F.some, pl.end)), $H = (e, n, o, r) => {
        const c = vd(e, r), u = oi(n, o, c);
        return oi(n, o, c).bind(Ye(BH, e)).orThunk(() => PH(e, n, o, u, r));
      }, Pv = (e) => re(e.selection.getSel().modify), DO = (e, n, o) => {
        const r = e ? 1 : -1;
        return n.setRng(We(o.container(), o.offset() + r).toRange()), n.getSel().modify("move", e ? "forward" : "backward", "word"), !0;
      }, dB = (e, n) => {
        const o = n.selection.getRng(), r = e ? We.fromRangeEnd(o) : We.fromRangeStart(o);
        return Pv(n) ? e && Ws(r) ? DO(!0, n.selection, r) : !e && Yc(r) ? DO(!1, n.selection, r) : !1 : !1;
      };
      var qm;
      (function(e) {
        e[e.Br = 0] = "Br", e[e.Block = 1] = "Block", e[e.Wrap = 2] = "Wrap", e[e.Eol = 3] = "Eol";
      })(qm || (qm = {}));
      const Bv = (e, n) => e === ya.Backwards ? Ao(n) : n, FH = (e, n, o) => e === ya.Forwards ? n.next(o) : n.prev(o), IH = (e, n, o, r) => Js(r.getNode(n === ya.Forwards)) ? qm.Br : md(o, r) === !1 ? qm.Block : qm.Wrap, mB = (e, n, o, r) => {
        const c = fd(o);
        let u = r;
        const f = [];
        for (; u; ) {
          const b = FH(n, c, u);
          if (!b)
            break;
          if (Js(b.getNode(!1)))
            return n === ya.Forwards ? {
              positions: Bv(n, f).concat([b]),
              breakType: qm.Br,
              breakAt: F.some(b)
            } : {
              positions: Bv(n, f),
              breakType: qm.Br,
              breakAt: F.some(b)
            };
          if (!b.isVisible()) {
            u = b;
            continue;
          }
          if (e(u, b)) {
            const y = IH(o, n, u, b);
            return {
              positions: Bv(n, f),
              breakType: y,
              breakAt: F.some(b)
            };
          }
          f.push(b), u = b;
        }
        return {
          positions: Bv(n, f),
          breakType: qm.Eol,
          breakAt: F.none()
        };
      }, LH = (e, n, o, r) => n(o, r).breakAt.map((c) => {
        const u = n(o, c).positions;
        return e === ya.Backwards ? u.concat(c) : [c].concat(u);
      }).getOr([]), fB = (e, n) => Xe(e, (o, r) => o.fold(() => F.some(r), (c) => Zr(qt(c.getClientRects()), qt(r.getClientRects()), (u, f) => {
        const b = Math.abs(n - u.left);
        return Math.abs(n - f.left) <= b ? r : c;
      }).or(o)), F.none()), RO = (e, n) => qt(n.getClientRects()).bind((o) => fB(e, o.left)), ql = Ye(mB, We.isAbove, -1), G2 = Ye(mB, We.isBelow, 1), gB = Ye(LH, -1, ql), Bp = Ye(LH, 1, G2), NO = (e, n) => ql(e, n).breakAt.isNone(), hB = (e, n) => G2(e, n).breakAt.isNone(), UT = (e) => Ri(e).map((n) => [n].concat(G2(e, n).positions)).getOr([]), HH = (e) => Hu(e).map((n) => ql(e, n).positions.concat(n)).getOr([]), zH = (e, n) => RO(gB(e, n), n), VH = (e, n) => RO(Bp(e, n), n), UH = es, pB = (e, n) => Math.abs(e.left - n), bB = (e, n) => Math.abs(e.right - n), Qg = (e) => dr(e, "node"), vB = (e, n) => de(e, (o, r) => {
        const c = Math.min(pB(o, n), bB(o, n)), u = Math.min(pB(r, n), bB(r, n));
        return u === c && Qg(r) && UH(r.node) || u < c ? r : o;
      }), WH = (e) => {
        const n = (o) => ye(o, (r) => {
          const c = _g(r);
          return c.node = e, c;
        });
        if (xn(e))
          return n(e.getClientRects());
        if (Mt(e)) {
          const o = e.ownerDocument.createRange();
          return o.setStart(e, 0), o.setEnd(e, e.data.length), n(o.getClientRects());
        } else
          return [];
      }, yB = (e) => ds(e, WH);
      var K2;
      (function(e) {
        e[e.Up = -1] = "Up", e[e.Down = 1] = "Down";
      })(K2 || (K2 = {}));
      const ZH = (e, n, o, r) => {
        let c = r;
        for (; c = Qh(c, e, Jb, n); )
          if (o(c))
            return;
      }, WT = (e, n, o, r, c, u) => {
        let f = 0;
        const b = [], y = (M) => {
          let I = yB([M]);
          e === -1 && (I = I.reverse());
          for (let X = 0; X < I.length; X++) {
            const te = I[X];
            if (!o(te, E)) {
              if (b.length > 0 && n(te, ze(b)) && f++, te.line = f, c(te))
                return !0;
              b.push(te);
            }
          }
          return !1;
        }, E = ze(u.getClientRects());
        if (!E)
          return b;
        const N = u.getNode();
        return N && (y(N), ZH(e, r, y, N)), b;
      }, MO = (e, n) => n.line > e, PO = (e, n) => n.line === e, CB = Ye(WT, K2.Up, Sf, Og), wB = Ye(WT, K2.Down, Og, Sf), BO = (e) => ze(e.getClientRects()), jH = (e, n, o, r) => {
        const c = fd(n);
        let u, f, b, y;
        const E = [];
        let N = 0;
        e === 1 ? (u = c.next, f = Og, b = Sf, y = We.after(r)) : (u = c.prev, f = Sf, b = Og, y = We.before(r));
        const M = BO(y);
        do {
          if (!y.isVisible())
            continue;
          const I = BO(y);
          if (b(I, M))
            continue;
          E.length > 0 && f(I, ze(E)) && N++;
          const X = _g(I);
          if (X.position = y, X.line = N, o(X))
            return E;
          E.push(X);
        } while (y = u(y));
        return E;
      }, $v = (e) => (n) => MO(e, n), Fv = (e) => (n) => PO(e, n), Gf = (e, n) => {
        e.selection.setRng(n), fb(e, e.selection.getRng());
      }, ZT = (e, n, o) => F.some(IT(e, n, o)), $O = (e, n, o, r, c, u) => {
        const f = n === ya.Forwards, b = fd(e.getBody()), y = Ye(BS, f ? b.next : b.prev), E = f ? r : c;
        if (!o.collapsed) {
          const te = Hy(o);
          if (u(te))
            return qf(n, e, te, n === ya.Backwards, !1);
          if (TO(e)) {
            const G = o.cloneRange();
            return G.collapse(n === ya.Backwards), F.from(G);
          }
        }
        const N = Rf(n, e.getBody(), o);
        if (E(N))
          return Nv(e, N.getNode(!f));
        let M = y(N);
        const I = cf(o);
        if (M)
          M = vd(f, M);
        else
          return I ? F.some(o) : F.none();
        if (E(M))
          return qf(n, e, M.getNode(!f), f, !1);
        const X = y(M);
        return X && E(X) && DC(M, X) ? qf(n, e, X.getNode(!f), f, !1) : I ? ZT(e, M.toRange(), !1) : F.none();
      }, FO = (e, n, o, r, c, u) => {
        const f = Rf(n, e.getBody(), o), b = ze(f.getClientRects()), y = n === K2.Down, E = e.getBody();
        if (!b)
          return F.none();
        if (TO(e)) {
          const ne = y ? We.fromRangeEnd(o) : We.fromRangeStart(o);
          return (y ? VH : zH)(E, ne).orThunk(() => F.from(ne)).map((ke) => ke.toRange());
        }
        const M = (y ? wB : CB)(E, $v(1), f), I = Yt(M, Fv(1)), X = b.left, te = vB(I, X);
        if (te && u(te.node)) {
          const ne = Math.abs(X - te.left), Se = Math.abs(X - te.right);
          return qf(n, e, te.node, ne < Se, !1);
        }
        let G;
        if (r(f) ? G = f.getNode() : c(f) ? G = f.getNode(!0) : G = Hy(o), G) {
          const ne = jH(n, E, $v(1), G);
          let Se = vB(Yt(ne, Fv(1)), X);
          if (Se || (Se = ze(Yt(ne, Fv(0))), Se))
            return ZT(e, Se.position.toRange(), !1);
        }
        return I.length === 0 ? Iv(e, y).filter(y ? c : r).map((ne) => IT(e, ne.toRange(), !1)) : F.none();
      }, Iv = (e, n) => {
        const o = e.selection.getRng(), r = n ? We.fromRangeEnd(o) : We.fromRangeStart(o), c = _C(r.container(), e.getBody());
        if (n) {
          const u = G2(c, r);
          return ko(u.positions);
        } else {
          const u = ql(c, r);
          return qt(u.positions);
        }
      }, jT = (e, n, o) => Iv(e, n).filter(o).exists((r) => (e.selection.setRng(r.toRange()), !0)), $p = (e, n) => {
        const o = e.dom.createRng();
        o.setStart(n.container(), n.offset()), o.setEnd(n.container(), n.offset()), e.selection.setRng(o);
      }, SB = (e, n) => {
        e ? n.setAttribute("data-mce-selected", "inline-boundary") : n.removeAttribute("data-mce-selected");
      }, IO = (e, n, o) => _O(n, o).map((r) => ($p(e, r), o)), qH = (e, n, o) => {
        const r = We.fromRangeStart(e);
        if (e.collapsed)
          return r;
        {
          const c = We.fromRangeEnd(e);
          return o ? ji(n, c).getOr(c) : pi(n, r).getOr(r);
        }
      }, GH = (e, n, o) => {
        const r = e.getBody(), c = qH(e.selection.getRng(), r, o), u = Ye(vb, e);
        return $H(o, u, r, c).bind((b) => IO(e, n, b));
      }, xB = (e, n, o) => {
        const r = ye(uc(le.fromDom(n.getRoot()), '*[data-mce-selected="inline-boundary"]'), (f) => f.dom), c = Yt(r, e), u = Yt(o, e);
        ae(Cs(c, u), Ye(SB, !1)), ae(Cs(u, c), Ye(SB, !0));
      }, KH = (e, n) => {
        const o = n.get();
        if (e.selection.isCollapsed() && !e.composing && o) {
          const r = We.fromRangeStart(e.selection.getRng());
          We.isTextPosition(r) && !bd(r) && ($p(e, OS(o, r)), n.set(null));
        }
      }, TB = (e, n, o, r) => {
        if (n.selection.isCollapsed()) {
          const c = Yt(r, e);
          ae(c, (u) => {
            const f = We.fromRangeStart(n.selection.getRng());
            oi(e, n.getBody(), f).bind((b) => IO(n, o, b));
          });
        }
      }, YH = (e, n, o) => Rg(e) ? GH(e, n, o).isSome() : !1, EB = (e, n, o) => Rg(n) ? dB(e, n) : !1, XH = (e) => {
        const n = jr(null), o = Ye(vb, e);
        return e.on("NodeChange", (r) => {
          Rg(e) && (xB(o, e.dom, r.parents), KH(e, n), TB(o, e, n, r.parents));
        }), n;
      }, JH = Ye(EB, !0), QH = Ye(EB, !1), qT = (e, n, o) => {
        if (Rg(e)) {
          const r = Iv(e, n).getOrThunk(() => {
            const c = e.selection.getRng();
            return n ? We.fromRangeEnd(c) : We.fromRangeStart(c);
          });
          return oi(Ye(vb, e), e.getBody(), r).exists((c) => {
            const u = q2(c);
            return _O(o, u).exists((f) => ($p(e, f), !0));
          });
        } else
          return !1;
      }, e9 = (e, n) => {
        const o = document.createRange();
        return o.setStart(e.container(), e.offset()), o.setEnd(n.container(), n.offset()), o;
      }, t9 = (e) => Zr(Ri(e), Hu(e), (n, o) => {
        const r = vd(!0, n), c = vd(!1, o);
        return pi(e, r).forall((u) => u.isEqual(c));
      }).getOr(!0), kB = (e, n) => (o) => _O(n, o).map((r) => () => $p(e, r)), LO = (e, n, o, r) => {
        const c = e.getBody(), u = Ye(vb, e);
        e.undoManager.ignore(() => {
          e.selection.setRng(e9(o, r)), Ax(e), oi(u, c, We.fromRangeStart(e.selection.getRng())).map(OO).bind(kB(e, n)).each(kn);
        }), e.nodeChanged();
      }, n9 = (e, n) => {
        const o = Dm(n, e);
        return o || e;
      }, Rb = (e, n, o, r) => {
        const c = n9(e.getBody(), r.container()), u = Ye(vb, e), f = oi(u, c, r);
        return f.bind((y) => o ? y.fold(it(F.some(OO(y))), F.none, it(F.some(q2(y))), F.none) : y.fold(F.none, it(F.some(q2(y))), F.none, it(F.some(OO(y))))).map(kB(e, n)).getOrThunk(() => {
          const y = Nm(o, c, r), E = y.bind((N) => oi(u, c, N));
          return Zr(f, E, () => Vc(u, c, r).bind((N) => t9(N) ? F.some(() => {
            Wg(e, o, le.fromDom(N));
          }) : F.none())).getOrThunk(() => E.bind(() => y.map((N) => () => {
            o ? LO(e, n, r, N) : LO(e, n, N, r);
          })));
        });
      }, GT = (e, n, o) => {
        if (e.selection.isCollapsed() && Rg(e)) {
          const r = We.fromRangeStart(e.selection.getRng());
          return Rb(e, n, o, r);
        }
        return F.none();
      }, HO = (e) => Mc(e) > 1, zO = (e, n) => {
        const o = le.fromDom(e.getBody()), r = le.fromDom(e.selection.getStart()), c = Lf(r, o);
        return Xn(c, n).fold(it(c), (u) => c.slice(0, u));
      }, VO = (e) => Mc(e) === 1, Fp = (e) => zO(e, (n) => e.schema.isBlock(Qo(n)) || HO(n)), _B = (e) => zO(e, (n) => e.schema.isBlock(Qo(n))), qu = (e, n) => {
        const o = Ye(XN, e);
        return ds(n, (r) => o(r) ? [r.dom] : []);
      }, Ip = (e) => {
        const n = _B(e);
        return qu(e, n);
      }, UO = (e, n, o, r) => {
        const c = qu(n, r);
        if (c.length === 0)
          Wg(n, e, o);
        else {
          const u = Gx(o.dom, c);
          n.selection.setRng(u.toRange());
        }
      }, o9 = (e, n) => {
        const o = Yt(Fp(e), VO);
        return ko(o).bind((r) => {
          const c = We.fromRangeStart(e.selection.getRng());
          return _A(n, c, r.dom) && !nb(r) ? F.some(() => UO(n, e, r, o)) : F.none();
        });
      }, AB = (e, n) => {
        const o = n.parentElement;
        return Js(n) && !U(o) && e.dom.isEmpty(o);
      }, s9 = (e) => nb(le.fromDom(e)), OB = (e, n) => {
        const o = e.selection.getStart(), r = AB(e, o) || s9(o) ? Gx(o, n) : YN(e.selection.getRng(), n);
        e.selection.setRng(r.toRange());
      }, r9 = (e, n) => {
        const o = Cs(n, Ip(e));
        o.length > 0 && OB(e, o);
      }, DB = (e) => Mt(e.startContainer), a9 = (e) => e.startOffset === 0 && DB(e), RB = (e, n) => {
        const o = n.startContainer.parentElement;
        return !U(o) && XN(e, le.fromDom(o));
      }, c9 = (e) => {
        const n = e.startContainer.parentNode, o = e.endContainer.parentNode;
        return !U(n) && !U(o) && n.isEqualNode(o);
      }, i9 = (e) => {
        const n = e.endContainer;
        return e.endOffset === (Mt(n) ? n.length : n.childNodes.length);
      }, Lv = (e) => c9(e) && i9(e), WO = (e) => !e.endContainer.isEqualNode(e.commonAncestorContainer), NB = (e) => Lv(e) || WO(e), MB = (e) => {
        const n = e.selection.getRng();
        return a9(n) && RB(e, n) && NB(n);
      }, ZO = (e) => {
        if (MB(e)) {
          const n = Ip(e);
          return F.some(() => {
            Ax(e), r9(e, n);
          });
        } else
          return F.none();
      }, jO = (e, n) => e.selection.isCollapsed() ? o9(e, n) : ZO(e), l9 = (e, n) => sN(e, (o) => Fl(o.dom), (o) => n.isBlock(Qo(o))), u9 = (e) => l9(le.fromDom(e.selection.getStart()), e.schema), d9 = (e) => {
        const n = e.selection.getRng();
        return n.collapsed && (DB(n) || e.dom.isEmpty(n.startContainer)) && !u9(e);
      }, Y2 = (e) => (d9(e) && OB(e, []), !0), qO = (e, n, o) => De(o) ? F.some(() => {
        e._selectionOverrides.hideFakeCaret(), Wg(e, n, le.fromDom(o));
      }) : F.none(), m9 = (e, n) => {
        const o = n ? r2 : fv, r = n ? ya.Forwards : ya.Backwards, c = Rf(r, e.getBody(), e.selection.getRng());
        return o(c) ? qO(e, n, c.getNode(!n)) : F.from(vd(n, c)).filter((u) => o(u) && DC(c, u)).bind((u) => qO(e, n, u.getNode(!n)));
      }, PB = (e, n) => {
        const o = e.selection.getNode();
        return oa(o) ? qO(e, n, o) : F.none();
      }, GO = (e, n) => e.selection.isCollapsed() ? m9(e, n) : PB(e, n), f9 = (e) => ci(e, (n) => Kc(n.dom) || es(n.dom)).exists((n) => Kc(n.dom)), Gl = (e) => xa(e ?? "").getOr(0), BB = (e, n) => {
        const o = e || ui(n) ? "margin" : "padding", r = ha(n, "direction") === "rtl" ? "-right" : "-left";
        return o + r;
      }, KO = (e, n, o, r, c, u) => {
        const f = BB(o, le.fromDom(u)), b = Gl(e.getStyle(u, f));
        if (n === "outdent") {
          const y = Math.max(0, b - r);
          e.setStyle(u, f, y ? y + c : "");
        } else {
          const y = b + r + c;
          e.setStyle(u, f, y);
        }
      }, $B = (e, n) => No(n, (o) => {
        const r = BB(R0(e), o), c = ta(o, r).map(Gl).getOr(0);
        return e.dom.getContentEditable(o.dom) !== "false" && c > 0;
      }), KT = (e) => {
        const n = IB(e);
        return !e.mode.isReadOnly() && (n.length > 1 || $B(e, n));
      }, FB = (e) => Pc(e) || al(e), g9 = (e) => lc(e).exists(FB), IB = (e) => Yt(_u(e.selection.getSelectedBlocks()), (n) => !FB(n) && !g9(n) && f9(n)), LB = (e, n) => {
        var o, r;
        const { dom: c } = e, u = lC(e), f = (r = (o = /[a-z%]+$/i.exec(u)) === null || o === void 0 ? void 0 : o[0]) !== null && r !== void 0 ? r : "px", b = Gl(u), y = R0(e);
        ae(IB(e), (E) => {
          KO(c, n, y, b, f, E.dom);
        });
      }, h9 = (e) => LB(e, "indent"), YO = (e) => LB(e, "outdent"), HB = (e) => {
        if (e.selection.isCollapsed() && KT(e)) {
          const n = e.dom, o = e.selection.getRng(), r = We.fromRangeStart(o), c = n.getParent(o.startContainer, n.isBlock);
          if (c !== null && yA(le.fromDom(c), r, e.schema))
            return F.some(() => YO(e));
        }
        return F.none();
      }, zB = (e, n, o) => Gs([
        HB,
        W2,
        xO,
        (r, c) => GT(r, n, c),
        wO,
        Mx,
        kO,
        GO,
        FT,
        jO
      ], (r) => r(e, o)).filter((r) => e.selection.isEditable()), X2 = (e, n) => {
        zB(e, n, !1).fold(() => {
          e.selection.isEditable() && (Ax(e), kA(e));
        }, kn);
      }, eh = (e, n) => {
        zB(e, n, !0).fold(() => {
          e.selection.isEditable() && TA(e);
        }, kn);
      }, Nb = (e, n) => {
        e.addCommand("delete", () => {
          X2(e, n);
        }), e.addCommand("forwardDelete", () => {
          eh(e, n);
        });
      }, J2 = 5, XO = 400, YT = (e) => e.touches === void 0 || e.touches.length !== 1 ? F.none() : F.some(e.touches[0]), VB = (e, n) => {
        const o = Math.abs(e.clientX - n.x), r = Math.abs(e.clientY - n.y);
        return o > J2 || r > J2;
      }, p9 = (e) => {
        const n = Cf(), o = jr(!1), r = b0((c) => {
          e.dispatch("longpress", {
            ...c,
            type: "longpress"
          }), o.set(!0);
        }, XO);
        e.on("touchstart", (c) => {
          YT(c).each((u) => {
            r.cancel();
            const f = {
              x: u.clientX,
              y: u.clientY,
              target: c.target
            };
            r.throttle(c), o.set(!1), n.set(f);
          });
        }, !0), e.on("touchmove", (c) => {
          r.cancel(), YT(c).each((u) => {
            n.on((f) => {
              VB(u, f) && (n.clear(), o.set(!1), e.dispatch("longpresscancel"));
            });
          });
        }, !0), e.on("touchend touchcancel", (c) => {
          r.cancel(), c.type !== "touchcancel" && n.get().filter((u) => u.target.isEqualNode(c.target)).each(() => {
            o.get() ? c.preventDefault() : e.dispatch("tap", {
              ...c,
              type: "tap"
            });
          });
        }, !0);
      }, XT = (e, n) => Zn(e, n.nodeName), UB = (e, n) => Mt(n) ? !0 : xn(n) ? !XT(e.getBlockElements(), n) && !Il(n) && !cs(e, n) && !wy(n) : !1, b9 = (e, n, o) => pe(bA(le.fromDom(o), le.fromDom(n)), (r) => XT(e, r.dom)), v9 = (e, n) => {
        if (Mt(n)) {
          if (n.data.length === 0)
            return !0;
          if (/^\s+$/.test(n.data))
            return !n.nextSibling || XT(e, n.nextSibling) || wy(n.nextSibling);
        }
        return !1;
      }, WB = (e) => e.dom.create(gi(e), M1(e)), y9 = (e) => {
        const n = e.dom, o = e.selection, r = e.schema, c = r.getBlockElements(), u = o.getStart(), f = e.getBody();
        let b, y, E = !1;
        const N = gi(e);
        if (!u || !xn(u))
          return;
        const M = f.nodeName.toLowerCase();
        if (!r.isValidChild(M, N.toLowerCase()) || b9(c, f, u))
          return;
        const I = o.getRng(), { startContainer: X, startOffset: te, endContainer: G, endOffset: ne } = I, Se = vp(e);
        let ke = f.firstChild;
        for (; ke; )
          if (xn(ke) && n0(r, ke), UB(r, ke)) {
            if (v9(c, ke)) {
              y = ke, ke = ke.nextSibling, n.remove(y);
              continue;
            }
            b || (b = WB(e), f.insertBefore(b, ke), E = !0), y = ke, ke = ke.nextSibling, b.appendChild(y);
          } else
            b = null, ke = ke.nextSibling;
        E && Se && (I.setStart(X, te), I.setEnd(G, ne), o.setRng(I), e.nodeChanged());
      }, ZB = (e, n, o) => {
        const r = le.fromDom(WB(e)), c = di();
        la(r, c), o(n, r);
        const u = document.createRange();
        return u.setStartBefore(c.dom), u.setEndBefore(c.dom), u;
      }, C9 = (e) => {
        e.on("NodeChange", Ye(y9, e));
      }, JO = (e) => (n) => (" " + n.attr("class") + " ").indexOf(e) !== -1, jB = (e, n, o) => function(r) {
        const c = arguments, u = c[c.length - 2], f = u > 0 ? n.charAt(u - 1) : "";
        if (f === '"')
          return r;
        if (f === ">") {
          const b = n.lastIndexOf("<", u);
          if (b !== -1 && n.substring(b, u).indexOf('contenteditable="false"') !== -1)
            return r;
        }
        return '<span class="' + o + '" data-mce-content="' + e.dom.encode(c[0]) + '">' + e.dom.encode(typeof c[1] == "string" ? c[1] : c[0]) + "</span>";
      }, zj = (e, n, o) => {
        let r = n.length, c = o.content;
        if (o.format !== "raw") {
          for (; r--; )
            c = c.replace(n[r], jB(e, c, vC(e)));
          o.content = c;
        }
      }, Vj = (e, n) => No(e, (o) => {
        const r = n.match(o);
        return r !== null && r[0].length === n.length;
      }), Uj = (e) => {
        const n = "contenteditable", o = " " + _t.trim(TS(e)) + " ", r = " " + _t.trim(vC(e)) + " ", c = JO(o), u = JO(r), f = h_(e);
        f.length > 0 && e.on("BeforeSetContent", (b) => {
          zj(e, f, b);
        }), e.parser.addAttributeFilter("class", (b) => {
          let y = b.length;
          for (; y--; ) {
            const E = b[y];
            c(E) ? E.attr(n, "true") : u(E) && E.attr(n, "false");
          }
        }), e.serializer.addAttributeFilter(n, (b) => {
          let y = b.length;
          for (; y--; ) {
            const E = b[y];
            if (!c(E) && !u(E))
              continue;
            const N = E.attr("data-mce-content");
            f.length > 0 && N ? Vj(f, N) ? (E.name = "#text", E.type = 3, E.raw = !0, E.value = N) : E.remove() : E.attr(n, null);
          }
        });
      }, w9 = (e) => ii(le.fromDom(e.getBody()), "*[data-mce-caret]").map((n) => n.dom).getOrNull(), S9 = (e, n) => {
        n.hasAttribute("data-mce-caret") && (Dl(n), e.selection.setRng(e.selection.getRng()), e.selection.scrollIntoView(n));
      }, Wj = (e, n) => {
        const o = w9(e);
        if (o) {
          if (n.type === "compositionstart") {
            n.preventDefault(), n.stopPropagation(), S9(e, o);
            return;
          }
          Fr(o) && (S9(e, o), e.undoManager.add());
        }
      }, x9 = (e) => {
        e.on("keyup compositionstart", Ye(Wj, e));
      }, qB = es, Zj = (e, n, o) => $O(n, e, o, Vg, zm, qB), T9 = (e, n, o) => FO(n, e, o, (u) => Vg(u) || BR(u), (u) => zm(u) || Vo(u), qB), gu = (e) => {
        const n = e.dom.create(gi(e));
        return n.innerHTML = '<br data-mce-bogus="1">', n;
      }, QO = (e, n, o) => {
        const r = fd(e.getBody()), c = Ye(BS, n === 1 ? r.next : r.prev);
        if (o.collapsed) {
          const u = e.dom.getParent(o.startContainer, "PRE");
          if (!u)
            return;
          if (!c(We.fromRangeStart(o))) {
            const b = le.fromDom(gu(e));
            n === 1 ? Ti(le.fromDom(u), b) : ka(le.fromDom(u), b), e.selection.select(b.dom, !0), e.selection.collapse();
          }
        }
      }, Q2 = (e, n) => {
        const o = n ? ya.Forwards : ya.Backwards, r = e.selection.getRng();
        return Zj(o, e, r).orThunk(() => (QO(e, o, r), F.none()));
      }, E9 = (e, n) => {
        const o = n ? 1 : -1, r = e.selection.getRng();
        return T9(o, e, r).orThunk(() => (QO(e, o, r), F.none()));
      }, GB = (e, n) => {
        const o = n ? e.getEnd(!0) : e.getStart(!0);
        return nN(o) ? !n : n;
      }, eD = (e, n) => Q2(e, GB(e.selection, n)).exists((o) => (Gf(e, o), !0)), JT = (e, n) => E9(e, n).exists((o) => (Gf(e, o), !0)), KB = (e, n) => jT(e, n, n ? zm : Vg), QT = (e, n) => HT(e, !n).map((o) => {
        const r = o.toRange(), c = e.selection.getRng();
        return n ? r.setStart(c.startContainer, c.startOffset) : r.setEnd(c.endContainer, c.endOffset), r;
      }).exists((o) => (Gf(e, o), !0)), YB = (e) => ee(["figcaption"], Qo(e)), k9 = (e, n, o) => {
        const r = Ye(fs, n);
        return ci(le.fromDom(e.container()), (c) => o.isBlock(Qo(c)), r).filter(YB);
      }, _9 = (e, n, o) => n ? hB(e.dom, o) : NO(e.dom, o), A9 = (e, n) => {
        const o = le.fromDom(e.getBody()), r = We.fromRangeStart(e.selection.getRng());
        return k9(r, o, e.schema).exists(() => {
          if (_9(o, n, r)) {
            const u = ZB(e, o, n ? la : gm);
            return e.selection.setRng(u), !0;
          } else
            return !1;
        });
      }, eE = (e, n) => e.selection.isCollapsed() ? A9(e, n) : !1, O9 = (e, n, o) => {
        const r = e.selection.getRng(), c = We.fromRangeStart(r);
        return e.getBody().firstChild === n && NO(o, c) ? (e.execCommand("InsertNewBlockBefore"), !0) : !1;
      }, D9 = (e, n) => {
        const o = e.selection.getRng(), r = We.fromRangeStart(o);
        return e.getBody().lastChild === n && hB(n, r) ? (e.execCommand("InsertNewBlockAfter"), !0) : !1;
      }, jj = (e, n) => n ? F.from(e.dom.getParent(e.selection.getNode(), "details")).map((o) => D9(e, o)).getOr(!1) : F.from(e.dom.getParent(e.selection.getNode(), "summary")).bind((o) => F.from(e.dom.getParent(o, "details")).map((r) => O9(e, r, o))).getOr(!1), XB = (e, n) => jj(e, n), tD = {
        shiftKey: !1,
        altKey: !1,
        ctrlKey: !1,
        metaKey: !1,
        keyCode: 0
      }, qj = (e) => ye(e, (n) => ({
        ...tD,
        ...n
      })), R9 = (e) => ye(e, (n) => ({
        ...tD,
        ...n
      })), JB = (e, n) => n.keyCode === e.keyCode && n.shiftKey === e.shiftKey && n.altKey === e.altKey && n.ctrlKey === e.ctrlKey && n.metaKey === e.metaKey, N9 = (e, n) => ds(qj(e), (o) => JB(o, n) ? [o] : []), nD = (e, n) => ds(R9(e), (o) => JB(o, n) ? [o] : []), yo = (e, ...n) => () => e.apply(null, n), Hv = (e, n) => hn(N9(e, n), (o) => o.action()), oD = (e, n) => Gs(nD(e, n), (o) => o.action()), QB = (e, n) => {
        const o = n ? ya.Forwards : ya.Backwards, r = e.selection.getRng();
        return $O(e, o, r, r2, fv, oa).exists((c) => (Gf(e, c), !0));
      }, e$ = (e, n) => {
        const o = n ? 1 : -1, r = e.selection.getRng();
        return FO(e, o, r, r2, fv, oa).exists((c) => (Gf(e, c), !0));
      }, tE = (e, n) => jT(e, n, n ? fv : r2), t$ = dd.generate([
        { none: ["current"] },
        { first: ["current"] },
        {
          middle: [
            "current",
            "target"
          ]
        },
        { last: ["current"] }
      ]), ew = {
        ...t$,
        none: (e) => t$.none(e)
      }, M9 = (e, n) => Ed(e, n, ot), Ed = (e, n, o) => ds(Ea(e), (r) => Si(r, n) ? o(r) ? [r] : [] : Ed(r, n, o)), n$ = (e, n, o = $e) => {
        if (o(n))
          return F.none();
        if (ee(e, Qo(n)))
          return F.some(n);
        const r = (c) => Si(c, "table") || o(c);
        return _l(n, e.join(","), r);
      }, o$ = (e, n) => n$([
        "td",
        "th"
      ], e, n), Kj = (e) => M9(e, "th,td"), P9 = (e, n) => Hi(e, "table", n), s$ = (e, n, o, r, c = ot) => {
        const u = r === 1;
        if (!u && o <= 0)
          return ew.first(e[0]);
        if (u && o >= e.length - 1)
          return ew.last(e[e.length - 1]);
        {
          const f = o + r, b = e[f];
          return c(b) ? ew.middle(n, b) : s$(e, n, f, r, c);
        }
      }, B9 = (e, n) => P9(e, n).bind((o) => {
        const r = Kj(o);
        return Xn(r, (u) => fs(e, u)).map((u) => ({
          index: u,
          all: r
        }));
      }), $9 = (e, n, o) => B9(e, o).fold(() => ew.none(e), (c) => s$(c.all, e, c.index, 1, n)), nE = (e, n, o) => B9(e, o).fold(() => ew.none(), (c) => s$(c.all, e, c.index, -1, n)), F9 = (e, n) => ({
        left: e.left - n,
        top: e.top - n,
        right: e.right + n * 2,
        bottom: e.bottom + n * 2,
        width: e.width + n,
        height: e.height + n
      }), sD = (e, n) => ds(n, (o) => {
        const r = F9(_g(o.getBoundingClientRect()), -1);
        return [
          {
            x: r.left,
            y: e(r),
            cell: o
          },
          {
            x: r.right,
            y: e(r),
            cell: o
          }
        ];
      }), r$ = (e, n, o) => Xe(e, (r, c) => r.fold(() => F.some(c), (u) => {
        const f = Math.sqrt(Math.abs(u.x - n) + Math.abs(u.y - o)), b = Math.sqrt(Math.abs(c.x - n) + Math.abs(c.y - o));
        return F.some(b < f ? c : u);
      }), F.none()), rD = (e, n, o, r, c) => {
        const u = uc(le.fromDom(o), "td,th,caption").map((b) => b.dom), f = Yt(sD(e, u), (b) => n(b, c));
        return r$(f, r, c).map((b) => b.cell);
      }, a$ = (e) => e.bottom, I9 = (e) => e.top, L9 = (e, n) => e.y < n, H9 = (e, n) => e.y > n, z9 = Ye(rD, a$, L9), oE = Ye(rD, I9, H9), V9 = (e, n) => qt(n.getClientRects()).bind((o) => z9(e, o.left, o.top)).bind((o) => RO(HH(o), n)), U9 = (e, n) => ko(n.getClientRects()).bind((o) => oE(e, o.left, o.top)).bind((o) => RO(UT(o), n)), W9 = (e, n, o) => o.breakAt.exists((r) => e(n, r).breakAt.isSome()), aD = (e) => e.breakType === qm.Wrap && e.positions.length === 0, Z9 = (e) => e.breakType === qm.Br && e.positions.length === 1, c$ = (e, n, o) => {
        const r = e(n, o);
        return aD(r) || !Js(o.getNode()) && Z9(r) ? !W9(e, n, r) : r.breakAt.isNone();
      }, i$ = Ye(c$, ql), j9 = Ye(c$, G2), q9 = (e, n, o) => {
        const r = We.fromRangeStart(n);
        return rp(!e, o).exists((c) => c.isEqual(r));
      }, G9 = (e, n, o, r) => {
        const c = e.selection.getRng(), u = n ? 1 : -1;
        return z1() && q9(n, c, o) ? (qf(u, e, o, !n, !1).each((f) => {
          Gf(e, f);
        }), !0) : !1;
      }, K9 = (e, n, o) => V9(n, o).orThunk(() => qt(o.getClientRects()).bind((r) => fB(gB(e, We.before(n)), r.left))).getOr(We.before(n)), Y9 = (e, n, o) => U9(n, o).orThunk(() => qt(o.getClientRects()).bind((r) => fB(Bp(e, We.after(n)), r.left))).getOr(We.after(n)), l$ = (e, n) => {
        const o = n.getNode(e);
        return Du(o) ? F.some(o) : F.none();
      }, cD = (e, n, o) => {
        n.undoManager.transact(() => {
          const r = e ? Ti : ka, c = ZB(n, le.fromDom(o), r);
          Gf(n, c);
        });
      }, u$ = (e, n, o) => {
        const r = l$(!!n, o), c = n === !1;
        r.fold(() => Gf(e, o.toRange()), (u) => rp(c, e.getBody()).filter((f) => f.isEqual(o)).fold(() => Gf(e, o.toRange()), (f) => cD(n, e, u)));
      }, d$ = (e, n, o, r) => {
        const c = e.selection.getRng(), u = We.fromRangeStart(c), f = e.getBody();
        if (!n && i$(r, u)) {
          const b = K9(f, o, u);
          return u$(e, n, b), !0;
        } else if (n && j9(r, u)) {
          const b = Y9(f, o, u);
          return u$(e, n, b), !0;
        } else
          return !1;
      }, m$ = (e, n, o) => F.from(e.dom.getParent(e.selection.getNode(), "td,th")).bind((r) => F.from(e.dom.getParent(r, "table")).map((c) => o(e, n, c, r))).getOr(!1), f$ = (e, n) => m$(e, n, G9), iD = (e, n) => m$(e, n, d$), X9 = (e) => {
        const n = Lm.exact(e, 0, e, 0);
        return sA(n);
      }, g$ = (e, n, o) => o.fold(F.none, F.none, (r, c) => yL(c).map((u) => X9(u)), (r) => (e.execCommand("mceTableInsertRowAfter"), h$(e, n, r))), h$ = (e, n, o) => g$(e, n, $9(o, Mo)), hc = (e, n, o) => g$(e, n, nE(o, Mo)), p$ = (e, n) => {
        const o = [
          "table",
          "li",
          "dl"
        ], r = le.fromDom(e.getBody()), c = (b) => {
          const y = Qo(b);
          return fs(b, r) || ee(o, y);
        }, u = e.selection.getRng(), f = le.fromDom(n ? u.endContainer : u.startContainer);
        return o$(f, c).map((b) => (P9(b, c).each((N) => {
          e.model.table.clearSelectedCells(N.dom);
        }), e.selection.collapse(!n), (n ? h$ : hc)(e, c, b).each((N) => {
          e.selection.setRng(N);
        }), !0)).getOr(!1);
      }, J9 = (e, n, o) => {
        const r = sn.os.isMacOS() || sn.os.isiOS();
        Hv([
          {
            keyCode: Tn.RIGHT,
            action: yo(eD, e, !0)
          },
          {
            keyCode: Tn.LEFT,
            action: yo(eD, e, !1)
          },
          {
            keyCode: Tn.UP,
            action: yo(JT, e, !1)
          },
          {
            keyCode: Tn.DOWN,
            action: yo(JT, e, !0)
          },
          ...r ? [
            {
              keyCode: Tn.UP,
              action: yo(QT, e, !1),
              metaKey: !0,
              shiftKey: !0
            },
            {
              keyCode: Tn.DOWN,
              action: yo(QT, e, !0),
              metaKey: !0,
              shiftKey: !0
            }
          ] : [],
          {
            keyCode: Tn.RIGHT,
            action: yo(f$, e, !0)
          },
          {
            keyCode: Tn.LEFT,
            action: yo(f$, e, !1)
          },
          {
            keyCode: Tn.UP,
            action: yo(iD, e, !1)
          },
          {
            keyCode: Tn.DOWN,
            action: yo(iD, e, !0)
          },
          {
            keyCode: Tn.UP,
            action: yo(iD, e, !1)
          },
          {
            keyCode: Tn.UP,
            action: yo(XB, e, !1)
          },
          {
            keyCode: Tn.DOWN,
            action: yo(XB, e, !0)
          },
          {
            keyCode: Tn.RIGHT,
            action: yo(QB, e, !0)
          },
          {
            keyCode: Tn.LEFT,
            action: yo(QB, e, !1)
          },
          {
            keyCode: Tn.UP,
            action: yo(e$, e, !1)
          },
          {
            keyCode: Tn.DOWN,
            action: yo(e$, e, !0)
          },
          {
            keyCode: Tn.RIGHT,
            action: yo(YH, e, n, !0)
          },
          {
            keyCode: Tn.LEFT,
            action: yo(YH, e, n, !1)
          },
          {
            keyCode: Tn.RIGHT,
            ctrlKey: !r,
            altKey: r,
            action: yo(JH, e, n)
          },
          {
            keyCode: Tn.LEFT,
            ctrlKey: !r,
            altKey: r,
            action: yo(QH, e, n)
          },
          {
            keyCode: Tn.UP,
            action: yo(eE, e, !1)
          },
          {
            keyCode: Tn.DOWN,
            action: yo(eE, e, !0)
          }
        ], o).each((c) => {
          o.preventDefault();
        });
      }, Q9 = (e, n) => {
        e.on("keydown", (o) => {
          o.isDefaultPrevented() || J9(e, n, o);
        });
      }, om = (e, n) => ({
        container: e,
        offset: n
      }), zv = xr.DOM, tw = (e) => (n) => e === n ? -1 : 0, Lp = (e) => (n) => e.isBlock(n) || ee([
        "BR",
        "IMG",
        "HR",
        "INPUT"
      ], n.nodeName) || e.getContentEditable(n) === "false", nw = (e, n, o) => {
        if (Mt(e) && n >= 0)
          return F.some(om(e, n));
        {
          const r = wf(zv);
          return F.from(r.backwards(e, n, tw(e), o)).map((c) => om(c.container, c.container.data.length));
        }
      }, b$ = (e, n, o) => {
        if (Mt(e) && n >= e.length)
          return F.some(om(e, n));
        {
          const r = wf(zv);
          return F.from(r.forwards(e, n, tw(e), o)).map((c) => om(c.container, 0));
        }
      }, ow = (e, n, o) => {
        if (!Mt(e))
          return F.none();
        const r = e.data;
        if (n >= 0 && n <= r.length)
          return F.some(om(e, n));
        {
          const c = wf(zv);
          return F.from(c.backwards(e, n, tw(e), o)).bind((u) => {
            const f = u.container.data;
            return ow(u.container, n + f.length, o);
          });
        }
      }, sE = (e, n, o) => {
        if (!Mt(e))
          return F.none();
        const r = e.data;
        if (n <= r.length)
          return F.some(om(e, n));
        {
          const c = wf(zv);
          return F.from(c.forwards(e, n, tw(e), o)).bind((u) => sE(u.container, n - r.length, o));
        }
      }, sw = (e, n, o, r, c) => {
        const u = wf(e, Lp(e));
        return F.from(u.backwards(n, o, r, c));
      }, v$ = (e) => e.collapsed && Mt(e.startContainer), rw = (e) => q(e.toString().replace(/\u00A0/g, " ")), aw = (e) => e !== "" && `  \f
\r	\v`.indexOf(e) !== -1, Mb = (e, n) => e.substring(n.length), cw = (e, n, o) => {
        let r;
        const c = o.charAt(0);
        for (r = n - 1; r >= 0; r--) {
          const u = e.charAt(r);
          if (aw(u))
            return F.none();
          if (c === u && Mn(e, o, r, n))
            break;
        }
        return F.some(r);
      }, sm = (e, n, o, r = 0) => {
        if (!v$(n))
          return F.none();
        const c = {
          text: "",
          offset: 0
        }, u = (b, y, E) => (c.text = E + c.text, c.offset += y, cw(c.text, c.offset, o).getOr(y)), f = e.getParent(n.startContainer, e.isBlock) || e.getRoot();
        return sw(e, n.startContainer, n.startOffset, u, f).bind((b) => {
          const y = n.cloneRange();
          if (y.setStart(b.container, b.offset), y.setEnd(n.endContainer, n.endOffset), y.collapsed)
            return F.none();
          const E = rw(y);
          return E.lastIndexOf(o) !== 0 || Mb(E, o).length < r ? F.none() : F.some({
            text: Mb(E, o),
            range: y,
            trigger: o
          });
        });
      }, Vv = (e, n, o, r = 0) => xL(le.fromDom(n.startContainer)).fold(() => sm(e, n, o, r), (c) => {
        const u = e.createRng();
        u.selectNode(c.dom);
        const f = rw(u);
        return F.some({
          range: u,
          text: Mb(f, o),
          trigger: o
        });
      }), y$ = (e) => e.nodeType === Qu, C$ = (e) => e.nodeType === Rc, w$ = (e) => {
        if (y$(e))
          return om(e, e.data.length);
        {
          const n = e.childNodes;
          return n.length > 0 ? w$(n[n.length - 1]) : om(e, n.length);
        }
      }, lD = (e, n) => {
        const o = e.childNodes;
        return o.length > 0 && n < o.length ? lD(o[n], 0) : o.length > 0 && C$(e) && o.length === n ? w$(o[o.length - 1]) : om(e, n);
      }, ez = (e, n) => {
        var o;
        const r = (o = e.getParent(n.container, e.isBlock)) !== null && o !== void 0 ? o : e.getRoot();
        return sw(e, n.container, n.offset, (c, u) => u === 0 ? -1 : u, r).filter((c) => {
          const u = c.container.data.charAt(c.offset - 1);
          return !aw(u);
        }).isSome();
      }, tz = (e) => (n) => {
        const o = lD(n.startContainer, n.startOffset);
        return !ez(e, o);
      }, iw = (e, n, o) => Gs(o.triggers, (r) => Vv(e, n, r)), nz = (e, n) => {
        const o = n(), r = e.selection.getRng();
        return iw(e.dom, r, o).bind((c) => S$(e, n, c));
      }, S$ = (e, n, o, r = {}) => {
        var c;
        const u = n(), b = (c = e.selection.getRng().startContainer.nodeValue) !== null && c !== void 0 ? c : "", y = Yt(u.lookupByTrigger(o.trigger), (N) => o.text.length >= N.minChars && N.matches.getOrThunk(() => tz(e.dom))(o.range, b, o.text));
        if (y.length === 0)
          return F.none();
        const E = Promise.all(ye(y, (N) => N.fetch(o.text, N.maxResults, r).then((I) => ({
          matchText: o.text,
          items: I,
          columns: N.columns,
          onAction: N.onAction,
          highlightOn: N.highlightOn
        }))));
        return F.some({
          lookupData: E,
          context: o
        });
      };
      var Gm;
      (function(e) {
        e[e.Error = 0] = "Error", e[e.Value = 1] = "Value";
      })(Gm || (Gm = {}));
      const uD = (e, n, o) => e.stype === Gm.Error ? n(e.serror) : o(e.svalue), oz = (e) => {
        const n = [], o = [];
        return ae(e, (r) => {
          uD(r, (c) => o.push(c), (c) => n.push(c));
        }), {
          values: n,
          errors: o
        };
      }, sz = (e, n) => e.stype === Gm.Error ? {
        stype: Gm.Error,
        serror: n(e.serror)
      } : e, rz = (e, n) => e.stype === Gm.Value ? {
        stype: Gm.Value,
        svalue: n(e.svalue)
      } : e, az = (e, n) => e.stype === Gm.Value ? n(e.svalue) : e, cz = (e, n) => e.stype === Gm.Error ? n(e.serror) : e, x$ = (e) => ({
        stype: Gm.Value,
        svalue: e
      }), T$ = (e) => ({
        stype: Gm.Error,
        serror: e
      }), yi = {
        fromResult: (e) => e.fold(T$, x$),
        toResult: (e) => uD(e, Ui.error, Ui.value),
        svalue: x$,
        partition: oz,
        serror: T$,
        bind: az,
        bindError: cz,
        map: rz,
        mapError: sz,
        fold: uD
      }, rE = (e) => Qe(e) && Ss(e).length > 100 ? " removed due to size" : JSON.stringify(e, null, 2), E$ = (e) => {
        const n = e.length > 10 ? e.slice(0, 10).concat([{
          path: [],
          getErrorInfo: it("... (only showing first ten failures)")
        }]) : e;
        return ye(n, (o) => "Failed path: (" + o.path.join(" > ") + `)
` + o.getErrorInfo());
      }, lw = (e, n) => yi.serror([{
        path: e,
        getErrorInfo: n
      }]), iz = (e, n, o) => lw(e, () => 'Could not find valid *required* value for "' + n + '" in ' + rE(o)), lz = (e, n) => lw(e, () => 'Choice schema did not contain choice key: "' + n + '"'), uz = (e, n, o) => lw(e, () => 'The chosen schema: "' + o + '" did not exist in branches: ' + rE(n)), dz = (e, n) => lw(e, it(n)), k$ = (e, n, o, r) => Ts(o, r).fold(() => uz(e, o, r), (u) => u.extract(e.concat(["branch: " + r]), n)), mz = (e, n) => ({
        extract: (c, u) => Ts(u, e).fold(() => lz(c, e), (b) => k$(c, u, n, b)),
        toString: () => "chooseOn(" + e + "). Possible values: " + Ss(n)
      }), _$ = (e, n) => n, fz = (e, n) => xo(e) && xo(n) ? uw(e, n) : n, dD = (e) => (...n) => {
        if (n.length === 0)
          throw new Error("Can't merge zero objects");
        const o = {};
        for (let r = 0; r < n.length; r++) {
          const c = n[r];
          for (const u in c)
            Zn(c, u) && (o[u] = e(o[u], c[u]));
        }
        return o;
      }, uw = dD(fz), gz = dD(_$), A$ = () => ({
        tag: "required",
        process: {}
      }), hz = (e) => ({
        tag: "defaultedThunk",
        process: e
      }), mD = (e) => hz(it(e)), pz = () => ({
        tag: "option",
        process: {}
      }), bz = (e, n) => e.length > 0 ? yi.svalue(uw(n, gz.apply(void 0, e))) : yi.svalue(n), fD = (e) => A(yi.serror, Xo)(e), O$ = {
        consolidateObj: (e, n) => {
          const o = yi.partition(e);
          return o.errors.length > 0 ? fD(o.errors) : bz(o.values, n);
        },
        consolidateArr: (e) => {
          const n = yi.partition(e);
          return n.errors.length > 0 ? fD(n.errors) : yi.svalue(n.values);
        }
      }, vz = (e, n, o, r) => ({
        tag: "field",
        key: e,
        newKey: n,
        presence: o,
        prop: r
      }), yz = (e, n) => ({
        tag: "custom",
        newKey: e,
        instantiator: n
      }), D$ = (e, n, o) => {
        switch (e.tag) {
          case "field":
            return n(e.key, e.newKey, e.presence, e.prop);
          case "custom":
            return o(e.newKey, e.instantiator);
        }
      }, aE = (e) => {
        const n = (r, c) => yi.bindError(e(c), (u) => dz(r, u)), o = it("val");
        return {
          extract: n,
          toString: o
        };
      }, R$ = aE(yi.svalue), Cz = (e, n, o, r) => Ts(n, o).fold(() => iz(e, o, n), r), N$ = (e, n, o, r) => {
        const c = Ts(e, n).getOrThunk(() => o(e));
        return r(c);
      }, wz = (e, n, o) => o(Ts(e, n)), Sz = (e, n, o, r) => {
        const c = Ts(e, n).map((u) => u === !0 ? o(e) : u);
        return r(c);
      }, xz = (e, n, o, r, c) => {
        const u = (b) => c.extract(n.concat([r]), b), f = (b) => b.fold(() => yi.svalue(F.none()), (y) => {
          const E = c.extract(n.concat([r]), y);
          return yi.map(E, F.some);
        });
        switch (e.tag) {
          case "required":
            return Cz(n, o, r, u);
          case "defaultedThunk":
            return N$(o, r, e.process, u);
          case "option":
            return wz(o, r, f);
          case "defaultedOptionThunk":
            return Sz(o, r, e.process, f);
          case "mergeWithThunk":
            return N$(o, r, it({}), (b) => {
              const y = uw(e.process(o), b);
              return u(y);
            });
        }
      }, Tz = (e, n, o) => {
        const r = {}, c = [];
        for (const u of o)
          D$(u, (f, b, y, E) => {
            const N = xz(y, e, n, f, E);
            yi.fold(N, (M) => {
              c.push(...M);
            }, (M) => {
              r[b] = M;
            });
          }, (f, b) => {
            r[f] = b(n);
          });
        return c.length > 0 ? yi.serror(c) : yi.svalue(r);
      }, gD = (e) => ({
        extract: (r, c) => Tz(r, c, e),
        toString: () => `obj{
` + ye(e, (c) => D$(c, (u, f, b, y) => u + " -> " + y.toString(), (u, f) => "state(" + u + ")")).join(`
`) + "}"
      }), M$ = (e) => ({
        extract: (r, c) => {
          const u = ye(c, (f, b) => e.extract(r.concat(["[" + b + "]"]), f));
          return O$.consolidateArr(u);
        },
        toString: () => "array(" + e.toString() + ")"
      }), eq = (e) => aE((n) => e(n).fold(yi.serror, yi.svalue)), Ez = (e, n, o) => {
        const r = n.extract([e], o);
        return yi.mapError(r, (c) => ({
          input: o,
          errors: c
        }));
      }, P$ = (e, n, o) => yi.toResult(Ez(e, n, o)), B$ = (e) => `Errors: 
` + E$(e.errors).join(`
`) + `

Input object: ` + rE(e.input), hD = (e, n) => mz(e, Lo(n, gD)), kz = it(R$), dw = (e, n) => aE((o) => {
        const r = typeof o;
        return e(o) ? yi.svalue(o) : yi.serror(`Expected type: ${n} but got: ${r}`);
      }), $$ = dw(ho, "number"), cE = dw(J, "string"), _z = dw(Tt, "boolean"), pD = dw(re, "function"), Uv = vz, F$ = yz, bD = (e) => eq((n) => ee(e, n) ? Ui.value(n) : Ui.error(`Unsupported value: "${n}", choose one of "${e.join(", ")}".`)), I$ = (e, n) => Uv(e, e, A$(), n), L$ = (e) => I$(e, cE), H$ = (e) => I$(e, pD), z$ = (e, n) => Uv(e, e, A$(), M$(n)), vD = (e, n) => Uv(e, e, pz(), n), iE = (e) => vD(e, cE), Az = (e) => vD(e, pD), Oz = (e, n) => Uv(e, e, mD(n), kz()), Wv = (e, n, o) => Uv(e, e, mD(n), o), pc = (e, n) => Wv(e, n, $$), Kf = (e, n) => Wv(e, n, cE), V$ = (e, n, o) => Wv(e, n, bD(o)), U$ = (e, n) => Wv(e, n, _z), yD = (e, n) => Wv(e, n, pD), Dz = (e, n, o) => Wv(e, n, M$(o)), Rz = L$("type"), Nz = H$("fetch"), lE = H$("onAction"), Zv = yD("onSetup", () => Oe), tq = iE("text"), Mz = iE("icon"), Pz = iE("tooltip"), Km = iE("label"), Bz = U$("active", !1), $z = U$("enabled", !0), CD = U$("primary", !1), Fz = (e) => Oz("columns", e), Pb = (e) => Kf("type", e), W$ = gD([
        Rz,
        L$("trigger"),
        pc("minChars", 1),
        Fz(1),
        pc("maxResults", 10),
        Az("matches"),
        Nz,
        lE,
        Dz("highlightOn", [], cE)
      ]), Iz = (e) => P$("Autocompleter", W$, {
        trigger: e.ch,
        ...e
      }), wD = [
        $z,
        Pz,
        Mz,
        tq,
        Zv
      ], Z$ = [Bz].concat(wD), j$ = [
        yD("predicate", $e),
        V$("scope", "node", [
          "node",
          "editor"
        ]),
        V$("position", "selection", [
          "node",
          "selection",
          "line"
        ])
      ], q$ = wD.concat([
        Pb("contextformbutton"),
        CD,
        lE,
        F$("original", Gn)
      ]), SD = Z$.concat([
        Pb("contextformbutton"),
        CD,
        lE,
        F$("original", Gn)
      ]), xD = wD.concat([Pb("contextformbutton")]), TD = Z$.concat([Pb("contextformtogglebutton")]), Lz = hD("type", {
        contextformbutton: q$,
        contextformtogglebutton: SD
      });
      gD([
        Pb("contextform"),
        yD("initValue", it("")),
        Km,
        z$("commands", Lz),
        vD("launch", hD("type", {
          contextformbutton: xD,
          contextformtogglebutton: TD
        }))
      ].concat(j$));
      const Hz = (e) => {
        const n = e.ui.registry.getAll().popups, o = Lo(n, (f) => Iz(f).fold((b) => {
          throw new Error(B$(b));
        }, Gn)), r = Za(fa(o, (f) => f.trigger)), c = Qr(o);
        return {
          dataset: o,
          triggers: r,
          lookupByTrigger: (f) => Yt(c, (b) => b.trigger === f)
        };
      }, zz = (e, n) => {
        const o = b0(n.load, 50);
        e.on("keypress compositionend", (r) => {
          r.which !== 27 && o.throttle();
        }), e.on("keydown", (r) => {
          const c = r.which;
          c === 8 ? o.throttle() : c === 27 && n.cancelIfNecessary();
        }), e.on("remove", o.cancel);
      }, Vz = (e) => {
        const n = Cf(), o = jr(!1), r = n.isSet, c = () => {
          r() && (r7(e), YC(e), o.set(!1), n.clear());
        }, u = (E) => {
          r() || (s7(e, E.range), n.set({
            trigger: E.trigger,
            matchLength: E.text.length
          }));
        }, f = Je(() => Hz(e)), b = (E) => n.get().map((N) => Vv(e.dom, e.selection.getRng(), N.trigger).bind((M) => S$(e, f, M, E))).getOrThunk(() => nz(e, f)), y = (E) => {
          b(E).fold(c, (N) => {
            u(N.context), N.lookupData.then((M) => {
              n.get().map((I) => {
                const X = N.context;
                I.trigger === X.trigger && (X.text.length - I.matchLength >= 10 ? c() : (n.set({
                  ...I,
                  matchLength: X.text.length
                }), o.get() ? tx(e, { lookupData: M }) : (o.set(!0), KC(e, { lookupData: M }))));
              });
            });
          });
        };
        e.addCommand("mceAutocompleterReload", (E, N) => {
          const M = Qe(N) ? N.fetchOptions : {};
          y(M);
        }), e.addCommand("mceAutocompleterClose", c), zz(e, {
          cancelIfNecessary: c,
          load: y
        });
      }, K$ = Is().browser.isSafari(), Y$ = (e) => Nu(le.fromDom(e)), ED = (e, n) => {
        var o;
        return e.startOffset === 0 && e.endOffset === ((o = n.textContent) === null || o === void 0 ? void 0 : o.length);
      }, uE = (e, n) => F.from(e.getParent(n.container(), "details")), dE = (e, n) => uE(e, n).isSome(), Uz = (e, n) => {
        const o = F.from(e.getParent(n.startContainer, "details")), r = F.from(e.getParent(n.endContainer, "details"));
        if (o.isSome() || r.isSome()) {
          const c = o.bind((u) => F.from(e.select("summary", u)[0]));
          return F.some({
            startSummary: c,
            startDetails: o,
            endDetails: r
          });
        } else
          return F.none();
      }, Wz = (e, n) => Ri(n).exists((o) => o.isEqual(e)), Zz = (e, n) => Hu(n).exists((o) => Js(o.getNode()) && ji(n, o).exists((r) => r.isEqual(e)) || o.isEqual(e)), jz = (e, n) => n.startSummary.exists((o) => Wz(e, o)), qz = (e, n) => n.startSummary.exists((o) => Zz(e, o)), X$ = (e, n) => n.startDetails.exists((o) => ji(o, e).forall((r) => n.startSummary.exists((c) => !c.contains(e.container()) && c.contains(r.container())))), kD = (e, n, o) => o.startDetails.exists((r) => pi(e, n).forall((c) => !r.contains(c.container()))), _D = (e, n) => {
        const o = n.getNode();
        Ht(o) || e.selection.setCursorLocation(o, n.offset());
      }, AD = (e, n, o) => {
        const r = e.dom.getParent(n.container(), "details");
        if (r && !r.open) {
          const c = e.dom.select("summary", r)[0];
          c && (o ? Ri(c) : Hu(c)).each((f) => _D(e, f));
        } else
          _D(e, n);
      }, Gz = (e, n) => {
        const o = (y) => y.contains(e.startContainer), r = (y) => y.contains(e.endContainer), c = n.startSummary.exists(o), u = n.startSummary.exists(r), f = n.startDetails.forall((y) => n.endDetails.forall((E) => y !== E));
        return (c || u) && !(c && u) || f;
      }, J$ = (e, n, o) => {
        const { dom: r, selection: c } = e, u = e.getBody();
        if (o === "character") {
          const f = We.fromRangeStart(c.getRng()), b = r.getParent(f.container(), r.isBlock), y = uE(r, f), E = b && r.isEmpty(b), N = U(b?.previousSibling), M = U(b?.nextSibling);
          return E && (n ? M : N) && Nm(!n, u, f).exists((te) => dE(r, te) && !qa(y, uE(r, te))) ? !0 : Nm(n, u, f).fold($e, (I) => {
            const X = uE(r, I);
            if (dE(r, I) && !qa(y, X)) {
              if (n || AD(e, I, !1), b && E) {
                if (n && N)
                  return !0;
                if (!n && M)
                  return !0;
                AD(e, I, n), e.dom.remove(b);
              }
              return !0;
            } else
              return !1;
          });
        } else
          return !1;
      }, Kz = (e, n, o, r) => {
        const u = e.selection.getRng(), f = We.fromRangeStart(u), b = e.getBody();
        return r === "selection" ? Gz(u, n) : o ? qz(f, n) || kD(b, f, n) : jz(f, n) || X$(f, n);
      }, mE = (e, n, o) => Uz(e.dom, e.selection.getRng()).fold(() => J$(e, n, o), (r) => Kz(e, r, n, o) || J$(e, n, o)), Q$ = (e, n, o) => {
        const r = e.selection, c = r.getNode(), u = r.getRng(), f = We.fromRangeStart(u);
        return _i(c) ? (o === "selection" && ED(u, c) || _A(n, f, c) ? Y$(c) : e.undoManager.transact(() => {
          const b = r.getSel();
          let { anchorNode: y, anchorOffset: E, focusNode: N, focusOffset: M } = b ?? {};
          const I = () => {
            De(y) && De(E) && De(N) && De(M) && b?.setBaseAndExtent(y, E, N, M);
          }, X = () => {
            y = b?.anchorNode, E = b?.anchorOffset, N = b?.focusNode, M = b?.focusOffset;
          }, te = (ne, Se) => {
            ae(ne.childNodes, (ke) => {
              Y1(ke) && Se.appendChild(ke);
            });
          }, G = e.dom.create("span", { "data-mce-bogus": "1" });
          te(c, G), c.appendChild(G), I(), (o === "word" || o === "line") && b?.modify("extend", n ? "right" : "left", o), !r.isCollapsed() && ED(r.getRng(), G) ? Y$(c) : (e.execCommand(n ? "ForwardDelete" : "Delete"), X(), te(G, c), I()), e.dom.remove(G);
        }), !0) : !1;
      }, Hp = (e, n, o) => mE(e, n, o) || K$ && Q$(e, n, o) ? F.some(Oe) : F.none(), e5 = (e) => (n, o, r = {}) => {
        const c = n.getBody(), u = {
          bubbles: !0,
          composed: !0,
          data: null,
          isComposing: !1,
          detail: 0,
          view: null,
          target: c,
          currentTarget: c,
          eventPhase: Event.AT_TARGET,
          originalTarget: c,
          explicitOriginalTarget: c,
          isTrusted: !1,
          srcElement: c,
          cancelable: !1,
          preventDefault: Oe,
          inputType: o
        }, f = _h(new InputEvent(e));
        return n.dispatch(e, {
          ...f,
          ...u,
          ...r
        });
      }, mw = e5("input"), OD = e5("beforeinput"), Yz = Is(), Xz = Yz.os, t5 = Xz.isMacOS() || Xz.isiOS(), Jz = Yz.browser.isFirefox(), Qz = (e, n, o) => {
        const r = o.keyCode === Tn.BACKSPACE ? "deleteContentBackward" : "deleteContentForward", c = e.selection.isCollapsed(), u = c ? "character" : "selection", f = (b) => c ? b ? "word" : "line" : "selection";
        oD([
          {
            keyCode: Tn.BACKSPACE,
            action: yo(HB, e)
          },
          {
            keyCode: Tn.BACKSPACE,
            action: yo(W2, e, !1)
          },
          {
            keyCode: Tn.DELETE,
            action: yo(W2, e, !0)
          },
          {
            keyCode: Tn.BACKSPACE,
            action: yo(xO, e, !1)
          },
          {
            keyCode: Tn.DELETE,
            action: yo(xO, e, !0)
          },
          {
            keyCode: Tn.BACKSPACE,
            action: yo(GT, e, n, !1)
          },
          {
            keyCode: Tn.DELETE,
            action: yo(GT, e, n, !0)
          },
          {
            keyCode: Tn.BACKSPACE,
            action: yo(Mx, e, !1)
          },
          {
            keyCode: Tn.DELETE,
            action: yo(Mx, e, !0)
          },
          {
            keyCode: Tn.BACKSPACE,
            action: yo(Hp, e, !1, u)
          },
          {
            keyCode: Tn.DELETE,
            action: yo(Hp, e, !0, u)
          },
          ...t5 ? [
            {
              keyCode: Tn.BACKSPACE,
              altKey: !0,
              action: yo(Hp, e, !1, f(!0))
            },
            {
              keyCode: Tn.DELETE,
              altKey: !0,
              action: yo(Hp, e, !0, f(!0))
            },
            {
              keyCode: Tn.BACKSPACE,
              metaKey: !0,
              action: yo(Hp, e, !1, f(!1))
            }
          ] : [
            {
              keyCode: Tn.BACKSPACE,
              ctrlKey: !0,
              action: yo(Hp, e, !1, f(!0))
            },
            {
              keyCode: Tn.DELETE,
              ctrlKey: !0,
              action: yo(Hp, e, !0, f(!0))
            }
          ],
          {
            keyCode: Tn.BACKSPACE,
            action: yo(kO, e, !1)
          },
          {
            keyCode: Tn.DELETE,
            action: yo(kO, e, !0)
          },
          {
            keyCode: Tn.BACKSPACE,
            action: yo(GO, e, !1)
          },
          {
            keyCode: Tn.DELETE,
            action: yo(GO, e, !0)
          },
          {
            keyCode: Tn.BACKSPACE,
            action: yo(FT, e, !1)
          },
          {
            keyCode: Tn.DELETE,
            action: yo(FT, e, !0)
          },
          {
            keyCode: Tn.BACKSPACE,
            action: yo(wO, e, !1)
          },
          {
            keyCode: Tn.DELETE,
            action: yo(wO, e, !0)
          },
          {
            keyCode: Tn.BACKSPACE,
            action: yo(jO, e, !1)
          },
          {
            keyCode: Tn.DELETE,
            action: yo(jO, e, !0)
          }
        ], o).filter((b) => e.selection.isEditable()).each((b) => {
          o.preventDefault(), OD(e, r).isDefaultPrevented() || (b(), mw(e, r));
        });
      }, nq = (e, n, o) => Hv([
        {
          keyCode: Tn.BACKSPACE,
          action: yo(tB, e)
        },
        {
          keyCode: Tn.DELETE,
          action: yo(tB, e)
        },
        ...t5 ? [
          {
            keyCode: Tn.BACKSPACE,
            altKey: !0,
            action: yo(Y2, e)
          },
          {
            keyCode: Tn.DELETE,
            altKey: !0,
            action: yo(Y2, e)
          },
          ...o ? [{
            keyCode: Jz ? 224 : 91,
            action: yo(Y2, e)
          }] : []
        ] : [
          {
            keyCode: Tn.BACKSPACE,
            ctrlKey: !0,
            action: yo(Y2, e)
          },
          {
            keyCode: Tn.DELETE,
            ctrlKey: !0,
            action: yo(Y2, e)
          }
        ]
      ], n), eV = (e, n) => {
        let o = !1;
        e.on("keydown", (r) => {
          o = r.keyCode === Tn.BACKSPACE, r.isDefaultPrevented() || Qz(e, n, r);
        }), e.on("keyup", (r) => {
          r.isDefaultPrevented() || nq(e, r, o), o = !1;
        });
      }, Da = (e) => {
        for (; e; ) {
          if (xn(e) || Mt(e) && e.data && /[\r\n\s]/.test(e.data))
            return e;
          e = e.nextSibling;
        }
        return null;
      }, zp = (e, n) => {
        const o = e.dom, r = e.schema.getMoveCaretBeforeOnEnterElements();
        if (!n)
          return;
        if (/^(LI|DT|DD)$/.test(n.nodeName)) {
          const u = Da(n.firstChild);
          u && /^(UL|OL|DL)$/.test(u.nodeName) && n.insertBefore(o.doc.createTextNode(_s), n.firstChild);
        }
        const c = o.createRng();
        if (n.normalize(), n.hasChildNodes()) {
          const u = new br(n, n);
          let f = n, b;
          for (; b = u.current(); ) {
            if (Mt(b)) {
              c.setStart(b, 0), c.setEnd(b, 0);
              break;
            }
            if (r[b.nodeName.toLowerCase()]) {
              c.setStartBefore(b), c.setEndBefore(b);
              break;
            }
            f = b, b = u.next();
          }
          b || (c.setStart(f, 0), c.setEnd(f, 0));
        } else
          Js(n) ? n.nextSibling && o.isBlock(n.nextSibling) ? (c.setStartBefore(n), c.setEndBefore(n)) : (c.setStartAfter(n), c.setEndAfter(n)) : (c.setStart(n, 0), c.setEnd(n, 0));
        e.selection.setRng(c), fb(e, c);
      }, Gu = (e, n) => {
        const o = e.getRoot();
        let r, c = n;
        for (; c !== o && c && e.getContentEditable(c) !== "false"; ) {
          if (e.getContentEditable(c) === "true") {
            r = c;
            break;
          }
          c = c.parentNode;
        }
        return c !== o ? r : o;
      }, fE = (e) => F.from(e.dom.getParent(e.selection.getStart(!0), e.dom.isBlock)), n5 = (e) => fE(e).fold(it(""), (n) => n.nodeName.toUpperCase()), tV = (e) => fE(e).filter((n) => al(le.fromDom(n))).isSome(), jv = (e) => {
        e.innerHTML = '<br data-mce-bogus="1">';
      }, DD = (e, n, o) => {
        const r = e.dom;
        F.from(o.style).map(r.parseStyle).each((y) => {
          const N = {
            ...fm(le.fromDom(n)),
            ...y
          };
          r.setStyles(n, N);
        });
        const c = F.from(o.class).map((y) => y.split(/\s+/)), u = F.from(n.className).map((y) => Yt(y.split(/\s+/), (E) => E !== ""));
        Zr(c, u, (y, E) => {
          const N = Yt(E, (I) => !ee(y, I)), M = [
            ...y,
            ...N
          ];
          r.setAttrib(n, "class", M.join(" "));
        });
        const f = [
          "style",
          "class"
        ], b = xs(o, (y, E) => !ee(f, E));
        r.setAttribs(n, b);
      }, qv = (e, n) => {
        if (gi(e).toLowerCase() === n.tagName.toLowerCase()) {
          const r = M1(e);
          DD(e, n, r);
        }
      }, RD = (e, n, o, r, c = !0, u, f) => {
        const b = e.dom, y = e.schema, E = gi(e), N = o ? o.nodeName.toUpperCase() : "";
        let M = n;
        const I = y.getTextInlineElements();
        let X;
        u || N === "TABLE" || N === "HR" ? X = b.create(u || E, f || {}) : X = o.cloneNode(!1);
        let te = X;
        if (!c)
          b.setAttrib(X, "style", null), b.setAttrib(X, "class", null);
        else
          do
            if (I[M.nodeName]) {
              if (Fl(M) || Il(M))
                continue;
              const G = M.cloneNode(!1);
              b.setAttrib(G, "id", ""), X.hasChildNodes() ? (G.appendChild(X.firstChild), X.appendChild(G)) : (te = G, X.appendChild(G));
            }
          while ((M = M.parentNode) && M !== r);
        return qv(e, X), jv(te), X;
      }, nV = (e, n) => e.dom.getParent(n, gt), oV = (e, n, o) => {
        let r = n;
        for (; r && r !== e && U(r.nextSibling); ) {
          const c = r.parentElement;
          if (!c || !o(c))
            return gt(c);
          r = c;
        }
        return !1;
      }, sV = (e, n, o) => !n && o.nodeName.toLowerCase() === gi(e) && e.dom.isEmpty(o) && oV(e.getBody(), o, (r) => Zn(e.schema.getTextBlockElements(), r.nodeName.toLowerCase())), rV = (e, n, o) => {
        var r, c, u;
        const f = n(gi(e)), b = nV(e, o);
        b && (e.dom.insertAfter(f, b), zp(e, f), ((u = (c = (r = o.parentElement) === null || r === void 0 ? void 0 : r.childNodes) === null || c === void 0 ? void 0 : c.length) !== null && u !== void 0 ? u : 0) > 1 && e.dom.remove(o));
      }, aV = (e, n) => e.firstChild && e.firstChild.nodeName === n, o5 = (e) => {
        var n;
        return ((n = e.parentNode) === null || n === void 0 ? void 0 : n.firstChild) === e;
      }, s5 = (e, n) => {
        const o = e?.parentNode;
        return De(o) && o.nodeName === n;
      }, r5 = (e) => De(e) && /^(OL|UL|LI)$/.test(e.nodeName), ND = (e) => De(e) && /^(LI|DT|DD)$/.test(e.nodeName), cV = (e) => r5(e) && r5(e.parentNode), gE = (e) => {
        const n = e.parentNode;
        return ND(n) ? n : e;
      }, fw = (e, n, o) => {
        let r = e[o ? "firstChild" : "lastChild"];
        for (; r && !xn(r); )
          r = r[o ? "nextSibling" : "previousSibling"];
        return r === n;
      }, MD = (e) => Xe(fa(fm(le.fromDom(e)), (n, o) => `${o}: ${n};`), (n, o) => n + o, ""), iV = (e, n, o, r, c) => {
        const u = e.dom, f = e.selection.getRng(), b = o.parentNode;
        if (o === e.getBody() || !b)
          return;
        cV(o) && (c = "LI");
        const y = ND(r) ? MD(r) : void 0;
        let E = ND(r) && y ? n(c, { style: MD(r) }) : n(c);
        if (fw(o, r, !0) && fw(o, r, !1))
          if (s5(o, "LI")) {
            const N = gE(o);
            u.insertAfter(E, N), o5(o) ? u.remove(N) : u.remove(o);
          } else
            u.replace(E, o);
        else if (fw(o, r, !0))
          s5(o, "LI") ? (u.insertAfter(E, gE(o)), E.appendChild(u.doc.createTextNode(" ")), E.appendChild(o)) : b.insertBefore(E, o), u.remove(r);
        else if (fw(o, r, !1))
          u.insertAfter(E, gE(o)), u.remove(r);
        else {
          o = gE(o);
          const N = f.cloneRange();
          N.setStartAfter(r), N.setEndAfter(o);
          const M = N.extractContents();
          if (c === "LI" && aV(M, "LI")) {
            const I = Yt(ye(E.children, le.fromDom), io(pr("br")));
            E = M.firstChild, u.insertAfter(M, o), ae(I, (X) => gm(le.fromDom(E), X)), y && E.setAttribute("style", y);
          } else
            u.insertAfter(M, o), u.insertAfter(E, o);
          u.remove(r);
        }
        zp(e, E);
      }, lV = (e) => {
        ae(eu(le.fromDom(e), vo), (n) => {
          const o = n.dom;
          o.nodeValue = q(o.data);
        });
      }, oq = (e, n) => {
        const o = e.dom.getParent(n, "ol,ul,dl");
        return o !== null && e.dom.getContentEditableParent(o) === "false";
      }, PD = (e, n) => n && n.nodeName === "A" && e.isEmpty(n), BD = (e, n) => e.nodeName === n || e.previousSibling && e.previousSibling.nodeName === n, $D = (e, n) => De(n) && e.isBlock(n) && !/^(TD|TH|CAPTION|FORM)$/.test(n.nodeName) && !/^(fixed|absolute)/i.test(n.style.position) && e.isEditable(n.parentNode) && e.getContentEditable(n) !== "false", uV = (e, n, o) => {
        var r;
        const c = [];
        if (!o)
          return;
        let u = o;
        for (; u = u.firstChild; ) {
          if (e.isBlock(u))
            return;
          xn(u) && !n[u.nodeName.toLowerCase()] && c.push(u);
        }
        let f = c.length;
        for (; f--; )
          u = c[f], (!u.hasChildNodes() || u.firstChild === u.lastChild && ((r = u.firstChild) === null || r === void 0 ? void 0 : r.nodeValue) === "" || PD(e, u)) && e.remove(u);
      }, hE = (e, n, o) => Mt(n) ? e ? o === 1 && n.data.charAt(o - 1) === k ? 0 : o : o === n.data.length - 1 && n.data.charAt(o) === k ? n.data.length : o : o, dV = (e) => {
        const n = e.cloneRange();
        return n.setStart(e.startContainer, hE(!0, e.startContainer, e.startOffset)), n.setEnd(e.endContainer, hE(!1, e.endContainer, e.endOffset)), n;
      }, a5 = (e) => {
        let n = e;
        do
          Mt(n) && (n.data = n.data.replace(/^[\r\n]+/, "")), n = n.firstChild;
        while (n);
      }, mV = (e, n, o, r, c) => {
        var u, f;
        const b = e.dom, y = (u = Gu(b, r)) !== null && u !== void 0 ? u : b.getRoot();
        let E = b.getParent(r, b.isBlock);
        if (!E || !$D(b, E)) {
          if (E = E || y, !E.hasChildNodes()) {
            const X = b.create(n);
            return qv(e, X), E.appendChild(X), o.setStart(X, 0), o.setEnd(X, 0), X;
          }
          let N = r;
          for (; N && N.parentNode !== E; )
            N = N.parentNode;
          let M;
          for (; N && !b.isBlock(N); )
            M = N, N = N.previousSibling;
          const I = (f = M?.parentElement) === null || f === void 0 ? void 0 : f.nodeName;
          if (M && I && e.schema.isValidChild(I, n.toLowerCase())) {
            const X = M.parentNode, te = b.create(n);
            for (qv(e, te), X.insertBefore(te, M), N = M; N && !b.isBlock(N); ) {
              const G = N.nextSibling;
              te.appendChild(N), N = G;
            }
            o.setStart(r, c), o.setEnd(r, c);
          }
        }
        return r;
      }, fV = (e, n) => {
        n.normalize();
        const o = n.lastChild;
        (!o || xn(o) && /^(left|right)$/gi.test(e.getStyle(o, "float", !0))) && e.add(n, "br");
      }, sq = (e, n) => {
        const o = lS(e);
        return gn(n) ? !1 : J(o) ? ee(_t.explode(o), n.nodeName.toLowerCase()) : o;
      }, c5 = {
        insert: (e, n) => {
          let o, r, c, u, f = !1;
          const b = e.dom, y = e.schema, E = y.getNonEmptyElements(), N = e.selection.getRng(), M = gi(e), I = le.fromDom(N.startContainer), X = ed(I, N.startOffset), te = X.exists((xt) => je(xt) && !Mo(xt)), G = N.collapsed && te, ne = (xt, bn) => RD(e, o, It, pt, Kk(e), xt, bn), Se = (xt) => {
            const bn = hE(xt, o, r);
            if (Mt(o) && (xt ? bn > 0 : bn < o.data.length))
              return !1;
            if (o.parentNode === It && f && !xt || xt && xn(o) && o === It.firstChild)
              return !0;
            if (BD(o, "TABLE") || BD(o, "HR"))
              return f && !xt || !f && xt;
            const Yn = new br(o, It);
            Mt(o) && (xt && bn === 0 ? Yn.prev() : !xt && bn === o.data.length && Yn.next());
            let Po;
            for (; Po = Yn.current(); ) {
              if (xn(Po)) {
                if (!Po.getAttribute("data-mce-bogus")) {
                  const Ko = Po.nodeName.toLowerCase();
                  if (E[Ko] && Ko !== "br")
                    return !1;
                }
              } else if (Mt(Po) && !ff(Po.data))
                return !1;
              xt ? Yn.prev() : Yn.next();
            }
            return !0;
          }, ke = () => {
            let xt;
            return /^(H[1-6]|PRE|FIGURE)$/.test(c) && un !== "HGROUP" ? xt = ne(M) : xt = ne(), sq(e, u) && $D(b, u) && b.isEmpty(It, void 0, { includeZwsp: !0 }) ? xt = b.split(u, It) : b.insertAfter(xt, It), zp(e, xt), xt;
          };
          T(b, N).each((xt) => {
            N.setStart(xt.startContainer, xt.startOffset), N.setEnd(xt.endContainer, xt.endOffset);
          }), o = N.startContainer, r = N.startOffset;
          const Ae = !!(n && n.shiftKey), Me = !!(n && n.ctrlKey);
          xn(o) && o.hasChildNodes() && !G && (f = r > o.childNodes.length - 1, o = o.childNodes[Math.min(r, o.childNodes.length - 1)] || o, f && Mt(o) ? r = o.data.length : r = 0);
          const pt = Gu(b, o);
          if (!pt || oq(e, o))
            return;
          Ae || (o = mV(e, M, N, o, r));
          let It = b.getParent(o, b.isBlock) || b.getRoot();
          u = De(It?.parentNode) ? b.getParent(It.parentNode, b.isBlock) : null, c = It ? It.nodeName.toUpperCase() : "";
          const un = u ? u.nodeName.toUpperCase() : "";
          if (un === "LI" && !Me) {
            const xt = u;
            It = xt, u = xt.parentNode, c = un;
          }
          if (xn(u) && sV(e, Ae, It))
            return rV(e, ne, It);
          if (/^(LI|DT|DD)$/.test(c) && xn(u) && b.isEmpty(It)) {
            iV(e, ne, u, It, M);
            return;
          }
          if (!G && (It === e.getBody() || !$D(b, It)))
            return;
          const nt = It.parentNode;
          let qe;
          if (G)
            qe = ne(M), X.fold(() => {
              la(I, le.fromDom(qe));
            }, (xt) => {
              ka(xt, le.fromDom(qe));
            }), e.selection.setCursorLocation(qe, 0);
          else if (pn(It))
            qe = Dl(It), b.isEmpty(It) && jv(It), qv(e, qe), zp(e, qe);
          else if (Se(!1))
            qe = ke();
          else if (Se(!0) && nt) {
            qe = nt.insertBefore(ne(), It);
            const xt = ih(le.fromDom(N.startContainer)) && N.collapsed;
            zp(e, BD(It, "HR") || xt ? qe : It);
          } else {
            const xt = dV(N).cloneRange();
            xt.setEndAfter(It);
            const bn = xt.extractContents();
            lV(bn), a5(bn), qe = bn.firstChild, b.insertAfter(bn, It), uV(b, E, qe), fV(b, It), b.isEmpty(It) && jv(It), qe.normalize(), b.isEmpty(qe) ? (b.remove(qe), ke()) : (qv(e, qe), zp(e, qe));
          }
          b.setAttrib(qe, "id", ""), e.dispatch("NewBlock", { newBlock: qe });
        },
        fakeEventName: "insertParagraph"
      }, gV = (e, n, o) => {
        const r = new br(n, o);
        let c;
        const u = e.getNonEmptyElements();
        for (; c = r.next(); )
          if (u[c.nodeName.toLowerCase()] || Mt(c) && c.length > 0)
            return !0;
        return !1;
      }, i5 = (e, n, o) => {
        const r = e.dom.createRng();
        o ? (r.setStartBefore(n), r.setEndBefore(n)) : (r.setStartAfter(n), r.setEndAfter(n)), e.selection.setRng(r), fb(e, r);
      }, hV = (e, n) => {
        const o = e.selection, r = e.dom, c = o.getRng();
        let u, f = !1;
        T(r, c).each((X) => {
          c.setStart(X.startContainer, X.startOffset), c.setEnd(X.endContainer, X.endOffset);
        });
        let b = c.startOffset, y = c.startContainer;
        if (xn(y) && y.hasChildNodes()) {
          const X = b > y.childNodes.length - 1;
          y = y.childNodes[Math.min(b, y.childNodes.length - 1)] || y, X && Mt(y) ? b = y.data.length : b = 0;
        }
        let E = r.getParent(y, r.isBlock);
        const N = E && E.parentNode ? r.getParent(E.parentNode, r.isBlock) : null, M = N ? N.nodeName.toUpperCase() : "", I = !!(n && n.ctrlKey);
        M === "LI" && !I && (E = N), Mt(y) && b >= y.data.length && (gV(e.schema, y, E || r.getRoot()) || (u = r.create("br"), c.insertNode(u), c.setStartAfter(u), c.setEndAfter(u), f = !0)), u = r.create("br"), Zy(r, c, u), i5(e, u, f), e.undoManager.add();
      }, pV = (e, n) => {
        const o = le.fromTag("br");
        ka(le.fromDom(n), o), e.undoManager.add();
      }, bV = (e, n) => {
        vV(e.getBody(), n) || Ti(le.fromDom(n), le.fromTag("br"));
        const o = le.fromTag("br");
        Ti(le.fromDom(n), o), i5(e, o.dom, !1), e.undoManager.add();
      }, pE = (e) => Js(e.getNode()), vV = (e, n) => pE(We.after(n)) ? !0 : pi(e, We.after(n)).map((o) => Js(o.getNode())).getOr(!1), l5 = (e) => e && e.nodeName === "A" && "href" in e, FD = (e) => e.fold($e, l5, l5, $e), ID = (e) => {
        const n = Ye(vb, e), o = We.fromRangeStart(e.selection.getRng());
        return oi(n, e.getBody(), o).filter(FD);
      }, yV = (e, n) => {
        n.fold(Oe, Ye(pV, e), Ye(bV, e), Oe);
      }, CV = {
        insert: (e, n) => {
          const o = ID(e);
          o.isSome() ? o.each(Ye(yV, e)) : hV(e, n);
        },
        fakeEventName: "insertLineBreak"
      }, u5 = (e, n) => fE(e).filter((o) => n.length > 0 && Si(le.fromDom(o), n)).isSome(), wV = (e) => u5(e, Gk(e)), aq = (e) => u5(e, rC(e)), Ku = dd.generate([
        { br: [] },
        { block: [] },
        { none: [] }
      ]), Ym = (e, n) => aq(e), d5 = (e) => (n, o) => tV(n) === e, LD = (e, n) => (o, r) => n5(o) === e.toUpperCase() === n, SV = (e) => {
        const n = Gu(e.dom, e.selection.getStart());
        return gn(n);
      }, gw = (e) => LD("pre", e), xV = () => LD("summary", !0), bE = (e) => (n, o) => jk(n) === e, TV = (e, n) => wV(e), vE = (e, n) => n, EV = (e) => {
        const n = gi(e), o = Gu(e.dom, e.selection.getStart());
        return De(o) && e.schema.isValidChild(o.nodeName, n);
      }, HD = (e) => {
        const n = e.selection.getRng(), o = le.fromDom(n.startContainer), c = ed(o, n.startOffset).map((u) => je(u) && !Mo(u));
        return n.collapsed && c.getOr(!0);
      }, Yu = (e, n) => (o, r) => Xe(e, (u, f) => u && f(o, r), !0) ? F.some(n) : F.none(), yE = (e, n) => aB([
        Yu([Ym], Ku.none()),
        Yu([
          gw(!0),
          SV
        ], Ku.none()),
        Yu([xV()], Ku.br()),
        Yu([
          gw(!0),
          bE(!1),
          vE
        ], Ku.br()),
        Yu([
          gw(!0),
          bE(!1)
        ], Ku.block()),
        Yu([
          gw(!0),
          bE(!0),
          vE
        ], Ku.block()),
        Yu([
          gw(!0),
          bE(!0)
        ], Ku.br()),
        Yu([
          d5(!0),
          vE
        ], Ku.br()),
        Yu([d5(!0)], Ku.block()),
        Yu([TV], Ku.br()),
        Yu([vE], Ku.br()),
        Yu([EV], Ku.block()),
        Yu([HD], Ku.block())
      ], [
        e,
        !!(n && n.shiftKey)
      ]).getOr(Ku.none()), CE = (e, n, o) => {
        n.selection.isCollapsed() || d2(n), !(De(o) && OD(n, e.fakeEventName).isDefaultPrevented()) && (e.insert(n, o), De(o) && mw(n, e.fakeEventName));
      }, m5 = (e, n) => {
        const o = () => CE(CV, e, n), r = () => CE(c5, e, n), c = yE(e, n);
        switch (qk(e)) {
          case "linebreak":
            c.fold(o, o, Oe);
            break;
          case "block":
            c.fold(r, r, Oe);
            break;
          case "invert":
            c.fold(r, o, Oe);
            break;
          default:
            c.fold(o, r, Oe);
            break;
        }
      }, f5 = Is(), kV = f5.os.isiOS() && f5.browser.isSafari(), g5 = (e, n) => {
        n.isDefaultPrevented() || (n.preventDefault(), B8(e.undoManager), e.undoManager.transact(() => {
          m5(e, n);
        }));
      }, h5 = (e) => {
        if (!e.collapsed)
          return !1;
        const n = e.startContainer;
        if (Mt(n)) {
          const o = /^[\uAC00-\uD7AF\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uD7B0-\uD7FF]$/, r = n.data.charAt(e.startOffset - 1);
          return o.test(r);
        } else
          return !1;
      }, _V = (e) => {
        let n = F.none();
        const o = (c) => {
          n = F.some(c.selection.getBookmark()), c.undoManager.add();
        }, r = (c, u) => {
          c.undoManager.undo(), n.fold(Oe, (f) => c.selection.moveToBookmark(f)), g5(c, u), n = F.none();
        };
        e.on("keydown", (c) => {
          c.keyCode === Tn.ENTER && (kV && h5(e.selection.getRng()) ? o(e) : g5(e, c));
        }), e.on("keyup", (c) => {
          c.keyCode === Tn.ENTER && n.each(() => r(e, c));
        });
      }, p5 = (e, n, o) => {
        const r = sn.os.isMacOS() || sn.os.isiOS();
        Hv([
          {
            keyCode: Tn.END,
            action: yo(KB, e, !0)
          },
          {
            keyCode: Tn.HOME,
            action: yo(KB, e, !1)
          },
          ...r ? [] : [
            {
              keyCode: Tn.HOME,
              action: yo(QT, e, !1),
              ctrlKey: !0,
              shiftKey: !0
            },
            {
              keyCode: Tn.END,
              action: yo(QT, e, !0),
              ctrlKey: !0,
              shiftKey: !0
            }
          ],
          {
            keyCode: Tn.END,
            action: yo(tE, e, !0)
          },
          {
            keyCode: Tn.HOME,
            action: yo(tE, e, !1)
          },
          {
            keyCode: Tn.END,
            action: yo(qT, e, !0, n)
          },
          {
            keyCode: Tn.HOME,
            action: yo(qT, e, !1, n)
          }
        ], o).each((c) => {
          o.preventDefault();
        });
      }, b5 = (e, n) => {
        e.on("keydown", (o) => {
          o.isDefaultPrevented() || p5(e, n, o);
        });
      }, AV = (e) => {
        e.on("input", (n) => {
          n.isComposing || e6(e);
        });
      }, OV = Is(), zD = (e, n, o) => {
        Hv([
          {
            keyCode: Tn.PAGE_UP,
            action: yo(qT, e, !1, n)
          },
          {
            keyCode: Tn.PAGE_DOWN,
            action: yo(qT, e, !0, n)
          }
        ], o);
      }, v5 = (e) => e.stopImmediatePropagation(), y5 = (e) => e.keyCode === Tn.PAGE_UP || e.keyCode === Tn.PAGE_DOWN, hw = (e, n, o) => {
        o && !e.get() ? n.on("NodeChange", v5, !0) : !o && e.get() && n.off("NodeChange", v5), e.set(o);
      }, DV = (e, n) => {
        if (OV.os.isMacOS())
          return;
        const o = jr(!1);
        e.on("keydown", (r) => {
          y5(r) && hw(o, e, !0);
        }), e.on("keyup", (r) => {
          r.isDefaultPrevented() || zD(e, n, r), y5(r) && o.get() && (hw(o, e, !1), e.nodeChanged());
        });
      }, VD = (e) => {
        e.on("beforeinput", (n) => {
          (!e.selection.isEditable() || pe(n.getTargetRanges(), (o) => !bR(e.dom, o))) && n.preventDefault();
        });
      }, wE = (e, n) => {
        const o = n.container(), r = n.offset();
        return Mt(o) ? (o.insertData(r, e), F.some(We(o, r + e.length))) : z0(n).map((c) => {
          const u = le.fromText(e);
          return n.isAtEnd() ? Ti(c, u) : ka(c, u), We(u.dom, e.length);
        });
      }, UD = Ye(wE, _s), C5 = Ye(wE, " "), cq = (e, n, o) => GR(e, n, o) ? UD(n) : C5(n), Vp = (e) => (n) => n.fold((o) => ji(e.dom, We.before(o)), (o) => Ri(o), (o) => Hu(o), (o) => pi(e.dom, We.after(o))), RV = (e, n, o) => (r) => GR(e, r, o) ? UD(n) : C5(n), w5 = (e) => (n) => {
        e.selection.setRng(n.toRange()), e.nodeChanged();
      }, NV = (e, n) => e.isEditable(e.getParent(n, "summary")), SE = (e) => {
        const n = We.fromRangeStart(e.selection.getRng()), o = le.fromDom(e.getBody());
        if (e.selection.isCollapsed()) {
          const r = Ye(vb, e), c = We.fromRangeStart(e.selection.getRng());
          return oi(r, e.getBody(), c).bind(Vp(o)).map((u) => () => RV(o, n, e.schema)(u).each(w5(e)));
        } else
          return F.none();
      }, S5 = (e) => {
        const n = () => {
          const o = le.fromDom(e.getBody());
          e.selection.isCollapsed() || e.getDoc().execCommand("Delete");
          const r = We.fromRangeStart(e.selection.getRng());
          cq(o, r, e.schema).each(w5(e));
        };
        return Jo(sn.browser.isFirefox() && e.selection.isEditable() && NV(e.dom, e.selection.getRng().startContainer), n);
      }, x5 = (e, n) => {
        oD([
          {
            keyCode: Tn.SPACEBAR,
            action: yo(SE, e)
          },
          {
            keyCode: Tn.SPACEBAR,
            action: yo(S5, e)
          }
        ], n).each((o) => {
          n.preventDefault(), OD(e, "insertText", { data: " " }).isDefaultPrevented() || (o(), mw(e, "insertText", { data: " " }));
        });
      }, MV = (e) => {
        e.on("keydown", (n) => {
          n.isDefaultPrevented() || x5(e, n);
        });
      }, T5 = (e) => w_(e) ? [
        {
          keyCode: Tn.TAB,
          action: yo(p$, e, !0)
        },
        {
          keyCode: Tn.TAB,
          shiftKey: !0,
          action: yo(p$, e, !1)
        }
      ] : [], PV = (e, n) => {
        Hv([...T5(e)], n).each((o) => {
          n.preventDefault();
        });
      }, BV = (e) => {
        e.on("keydown", (n) => {
          n.isDefaultPrevented() || PV(e, n);
        });
      }, $V = (e) => {
        if (e.addShortcut("Meta+P", "", "mcePrint"), Vz(e), Yg(e))
          return jr(null);
        {
          const n = XH(e);
          return VD(e), x9(e), Q9(e, n), eV(e, n), _V(e), MV(e), AV(e), BV(e), b5(e, n), DV(e, n), n;
        }
      };
      class E5 {
        constructor(n) {
          this.lastPath = [], this.editor = n;
          let o;
          const r = this;
          "onselectionchange" in n.getDoc() || n.on("NodeChange click mouseup keyup focus", (c) => {
            const u = n.selection.getRng(), f = {
              startContainer: u.startContainer,
              startOffset: u.startOffset,
              endContainer: u.endContainer,
              endOffset: u.endOffset
            };
            (c.type === "nodechange" || !Hm(f, o)) && n.dispatch("SelectionChange"), o = f;
          }), n.on("contextmenu", () => {
            n.dispatch("SelectionChange");
          }), n.on("SelectionChange", () => {
            const c = n.selection.getStart(!0);
            c && Y0(n) && !r.isSameElementPath(c) && n.dom.isChildOf(c, n.getBody()) && n.nodeChanged({ selectionChange: !0 });
          }), n.on("mouseup", (c) => {
            !c.isDefaultPrevented() && Y0(n) && (n.selection.getNode().nodeName === "IMG" ? Uu.setEditorTimeout(n, () => {
              n.nodeChanged();
            }) : n.nodeChanged());
          });
        }
        nodeChanged(n = {}) {
          const o = this.editor.selection;
          let r;
          if (this.editor.initialized && o && !M0(this.editor) && !this.editor.mode.isReadOnly()) {
            const c = this.editor.getBody();
            r = o.getStart(!0) || c, (r.ownerDocument !== this.editor.getDoc() || !this.editor.dom.isChildOf(r, c)) && (r = c);
            const u = [];
            this.editor.dom.getParent(r, (f) => f === c ? !0 : (u.push(f), !1)), this.editor.dispatch("NodeChange", {
              ...n,
              element: r,
              parents: u
            });
          }
        }
        isSameElementPath(n) {
          let o;
          const r = this.editor, c = Ao(r.dom.getParents(n, ot, r.getBody()));
          if (c.length === this.lastPath.length) {
            for (o = c.length; o >= 0 && c[o] === this.lastPath[o]; o--)
              ;
            if (o === -1)
              return this.lastPath = c, !0;
          }
          return this.lastPath = c, !1;
        }
      }
      const xE = Eg("image"), FV = (e) => {
        const n = e;
        return F.from(n[xE]);
      }, WD = (e, n) => {
        const o = e;
        o[xE] = n;
      }, TE = Eg("event"), EE = (e) => {
        const n = e;
        return F.from(n[TE]);
      }, pw = (e) => (n) => {
        const o = n;
        o[TE] = e;
      }, k5 = (e, n) => pw(n)(e), _5 = pw(0), IV = pw(2), kE = pw(1), HV = ((e) => (n) => {
        const o = n;
        return F.from(o[TE]).exists((r) => r === e);
      })(0), zV = () => Object.freeze({
        length: 0,
        item: (e) => null
      }), _E = Eg("mode"), VV = (e) => {
        const n = e;
        return F.from(n[_E]);
      }, AE = (e) => (n) => {
        const o = n;
        o[_E] = e;
      }, A5 = (e, n) => AE(n)(e), O5 = AE(0), ZD = AE(2), D5 = AE(1), R5 = (e) => (n) => {
        const o = n;
        return F.from(o[_E]).exists((r) => r === e);
      }, Bb = R5(0), N5 = R5(1), UV = (e, n) => ({
        ...n,
        get length() {
          return n.length;
        },
        add: (o, r) => {
          if (Bb(e))
            if (J(o)) {
              if (!Ht(r))
                return n.add(o, r);
            } else
              return n.add(o);
          return null;
        },
        remove: (o) => {
          Bb(e) && n.remove(o);
        },
        clear: () => {
          Bb(e) && n.clear();
        }
      }), WV = [
        "none",
        "copy",
        "link",
        "move"
      ], ZV = [
        "none",
        "copy",
        "copyLink",
        "copyMove",
        "link",
        "linkMove",
        "move",
        "all",
        "uninitialized"
      ], jD = () => {
        const e = new window.DataTransfer();
        let n = "move", o = "all";
        const r = {
          get dropEffect() {
            return n;
          },
          set dropEffect(c) {
            ee(WV, c) && (n = c);
          },
          get effectAllowed() {
            return o;
          },
          set effectAllowed(c) {
            HV(r) && ee(ZV, c) && (o = c);
          },
          get items() {
            return UV(r, e.items);
          },
          get files() {
            return N5(r) ? zV() : e.files;
          },
          get types() {
            return e.types;
          },
          setDragImage: (c, u, f) => {
            Bb(r) && (WD(r, {
              image: c,
              x: u,
              y: f
            }), e.setDragImage(c, u, f));
          },
          getData: (c) => N5(r) ? "" : e.getData(c),
          setData: (c, u) => {
            Bb(r) && e.setData(c, u);
          },
          clearData: (c) => {
            Bb(r) && e.clearData(c);
          }
        };
        return O5(r), r;
      }, Gv = (e) => {
        const n = jD(), o = VV(e);
        return ZD(e), _5(n), n.dropEffect = e.dropEffect, n.effectAllowed = e.effectAllowed, FV(e).each((r) => n.setDragImage(r.image, r.x, r.y)), ae(e.types, (r) => {
          r !== "Files" && n.setData(r, e.getData(r));
        }), ae(e.files, (r) => n.items.add(r)), EE(e).each((r) => {
          k5(n, r);
        }), o.each((r) => {
          A5(e, r), A5(n, r);
        }), n;
      }, jV = (e) => {
        const n = e.getData("text/html");
        return n === "" ? F.none() : F.some(n);
      }, M5 = (e, n) => e.setData("text/html", n), qD = "x-tinymce/html", OE = it(qD), GD = "<!-- " + qD + " -->", qV = (e) => GD + e, P5 = (e) => e.replace(GD, ""), B5 = (e) => e.indexOf(GD) !== -1, GV = (e) => !/<(?:\/?(?!(?:div|p|br|span)>)\w+|(?:(?!(?:span style="white-space:\s?pre;?">)|br\s?\/>))\w+\s[^>]+)>/i.test(e), iq = (e, n) => {
        let o = "<" + e;
        const r = fa(n, (c, u) => u + '="' + wg.encodeAllRaw(c) + '"');
        return r.length && (o += " " + r.join(" ")), o + ">";
      }, DE = (e, n, o) => {
        const r = e.split(/\n\n/), c = iq(n, o), u = "</" + n + ">", f = ye(r, (y) => y.split(/\n/).join("<br />")), b = (y) => c + y + u;
        return f.length === 1 ? f[0] : ye(f, b).join("");
      }, $5 = "%MCEPASTEBIN%", KV = (e, n) => {
        const { dom: o, selection: r } = e, c = e.getBody();
        n.set(r.getRng());
        const u = o.add(e.getBody(), "div", {
          id: "mcepastebin",
          class: "mce-pastebin",
          contentEditable: !0,
          "data-mce-bogus": "all",
          style: "position: fixed; top: 50%; width: 10px; height: 10px; overflow: hidden; opacity: 0"
        }, $5);
        sn.browser.isFirefox() && o.setStyle(u, "left", o.getStyle(c, "direction", !0) === "rtl" ? 65535 : -65535), o.bind(u, "beforedeactivate focusin focusout", (f) => {
          f.stopPropagation();
        }), u.focus(), r.select(u, !0);
      }, YV = (e, n) => {
        const o = e.dom;
        if (KD(e)) {
          let r;
          const c = n.get();
          for (; r = KD(e); )
            o.remove(r), o.unbind(r);
          c && e.selection.setRng(c);
        }
        n.set(null);
      }, KD = (e) => e.dom.get("mcepastebin"), XV = (e) => De(e) && e.id === "mcepastebin", JV = (e) => {
        const n = e.dom, o = (f, b) => {
          f.appendChild(b), n.remove(b, !0);
        }, [r, ...c] = Yt(e.getBody().childNodes, XV);
        ae(c, (f) => {
          o(r, f);
        });
        const u = n.select("div[id=mcepastebin]", r);
        for (let f = u.length - 1; f >= 0; f--) {
          const b = n.create("div");
          r.insertBefore(b, u[f]), o(b, u[f]);
        }
        return r ? r.innerHTML : "";
      }, F5 = (e) => e === $5, QV = (e) => {
        const n = jr(null);
        return {
          create: () => KV(e, n),
          remove: () => YV(e, n),
          getEl: () => KD(e),
          getHtml: () => JV(e),
          getLastRng: n.get
        };
      }, I5 = (e, n) => (_t.each(n, (o) => {
        Kt(o, RegExp) ? e = e.replace(o, "") : e = e.replace(o[0], o[1]);
      }), e), eU = (e) => {
        const n = Tm(), o = Qd({}, n);
        let r = "";
        const c = n.getVoidElements(), u = _t.makeMap("script noscript style textarea video audio iframe object", " "), f = n.getBlockElements(), b = (y) => {
          const E = y.name, N = y;
          if (E === "br") {
            r += `
`;
            return;
          }
          if (E !== "wbr") {
            if (c[E] && (r += " "), u[E]) {
              r += " ";
              return;
            }
            if (y.type === 3 && (r += y.value), !(y.name in n.getVoidElements())) {
              let M = y.firstChild;
              if (M)
                do
                  b(M);
                while (M = M.next);
            }
            f[E] && N.next && (r += `
`, E === "p" && (r += `
`));
          }
        };
        return e = I5(e, [/<!\[[^\]]+\]>/g]), b(o.parse(e)), r;
      }, L5 = (e) => (e = I5(e, [
        /^[\s\S]*<body[^>]*>\s*|\s*<\/body[^>]*>[\s\S]*$/ig,
        /<!--StartFragment-->|<!--EndFragment-->/g,
        [
          /( ?)<span class="Apple-converted-space">\u00a0<\/span>( ?)/g,
          (o, r, c) => !r && !c ? " " : _s
        ],
        /<br class="Apple-interchange-newline">/g,
        /<br>$/i
      ]), e), tU = (e) => {
        let n = 0;
        return () => e + n++;
      }, nU = (e) => {
        const n = e.toLowerCase(), o = {
          jpg: "jpeg",
          jpe: "jpeg",
          jfi: "jpeg",
          jif: "jpeg",
          jfif: "jpeg",
          pjpeg: "jpeg",
          pjp: "jpeg",
          svg: "svg+xml"
        };
        return _t.hasOwn(o, n) ? "image/" + o[n] : "image/" + n;
      }, Tr = (e, n) => {
        const o = Qd({
          sanitize: Kh(e),
          sandbox_iframes: I0(e)
        }, e.schema);
        o.addNodeFilter("meta", (c) => {
          _t.each(c, (u) => {
            u.remove();
          });
        });
        const r = o.parse(n, {
          forced_root_block: !1,
          isRootContent: !0
        });
        return yp({ validate: !0 }, e.schema).serialize(r);
      }, H5 = (e, n) => ({
        content: e,
        cancelled: n
      }), z5 = (e, n, o) => {
        const r = e.dom.create("div", { style: "display:none" }, n), c = j_(e, r, o);
        return H5(c.node.innerHTML, c.isDefaultPrevented());
      }, oU = (e, n, o) => {
        const r = Z_(e, n, o), c = Tr(e, r.content);
        return e.hasEventListeners("PastePostProcess") && !r.isDefaultPrevented() ? z5(e, c, o) : H5(c, r.isDefaultPrevented());
      }, YD = (e, n, o) => oU(e, n, o), RE = (e, n) => (e.insertContent(n, {
        merge: pC(e),
        paste: !0
      }), !0), XD = (e) => /^https?:\/\/[\w\-\/+=.,!;:&%@^~(){}?#]+$/i.test(e), sU = (e, n) => XD(n) && pe(ES(e), (o) => zo(n.toLowerCase(), `.${o.toLowerCase()}`)), V5 = (e, n, o) => (e.undoManager.extra(() => {
        o(e, n);
      }, () => {
        e.insertContent('<img src="' + n + '">');
      }), !0), JD = (e, n, o) => (e.undoManager.extra(() => {
        o(e, n);
      }, () => {
        e.execCommand("mceInsertLink", !1, n);
      }), !0), rU = (e, n, o) => !e.selection.isCollapsed() && XD(n) ? JD(e, n, o) : !1, aU = (e, n, o) => sU(e, n) ? V5(e, n, o) : !1, cU = (e, n) => {
        _t.each([
          rU,
          aU,
          RE
        ], (o) => !o(e, n, RE));
      }, U5 = (e, n, o) => {
        o || !xS(e) ? RE(e, n) : cU(e, n);
      }, iU = tU("mceclip"), lU = (e) => {
        const n = jD();
        return M5(n, e), ZD(n), n;
      }, $b = (e, n, o, r, c) => {
        const u = YD(e, n, o);
        if (!u.cancelled) {
          const f = u.content, b = () => U5(e, f, r);
          c ? OD(e, "insertFromPaste", { dataTransfer: lU(f) }).isDefaultPrevented() || (b(), mw(e, "insertFromPaste")) : b();
        }
      }, NE = (e, n, o, r) => {
        const c = o || B5(n);
        $b(e, P5(n), c, !1, r);
      }, Up = (e, n, o) => {
        const r = e.dom.encode(n).replace(/\r\n/g, `
`), c = pg(r, f_(e)), u = DE(c, gi(e), M1(e));
        $b(e, u, !1, !0, o);
      }, Kv = (e) => {
        const n = {};
        if (e && e.types)
          for (let o = 0; o < e.types.length; o++) {
            const r = e.types[o];
            try {
              n[r] = e.getData(r);
            } catch {
              n[r] = "";
            }
          }
        return n;
      }, Wp = (e, n) => n in e && e[n].length > 0, W5 = (e) => Wp(e, "text/html") || Wp(e, "text/plain"), Yv = (e, n) => {
        const o = n.match(/([\s\S]+?)(?:\.[a-z0-9.]+)$/i);
        return De(o) ? e.dom.encode(o[1]) : void 0;
      }, uU = (e, n, o, r) => {
        const c = iU(), u = P1(e) && De(o.name), f = u ? Yv(e, o.name) : c, b = u ? o.name : void 0, y = n.create(c, o, r, f, b);
        return n.add(y), y;
      }, QD = (e, n) => {
        E2(n.uri).each(({ data: o, type: r, base64Encoded: c }) => {
          const u = c ? o : btoa(o), f = n.file, b = e.editorUpload.blobCache, y = b.getByData(u, r), E = y ?? uU(e, b, f, u);
          NE(e, `<img src="${E.blobUri()}">`, !1, !0);
        });
      }, dU = (e) => e.type === "paste", Z5 = (e) => Promise.all(ye(e, (n) => y3(n).then((o) => ({
        file: n,
        uri: o
      })))), j5 = (e) => {
        const n = ES(e);
        return (o) => Kn(o.type, "image/") && pe(n, (r) => nU(r) === o.type);
      }, e4 = (e, n) => {
        const o = n.items ? ds(rs(n.items), (c) => c.kind === "file" ? [c.getAsFile()] : []) : [], r = n.files ? rs(n.files) : [];
        return Yt(o.length > 0 ? o : r, j5(e));
      }, t4 = (e, n, o) => {
        const r = dU(n) ? n.clipboardData : n.dataTransfer;
        if (B0(e) && r) {
          const c = e4(e, r);
          if (c.length > 0)
            return n.preventDefault(), Z5(c).then((u) => {
              o && e.selection.setRng(o), ae(u, (f) => {
                QD(e, f);
              });
            }), !0;
        }
        return !1;
      }, mU = (e) => {
        var n, o;
        return sn.os.isAndroid() && ((o = (n = e.clipboardData) === null || n === void 0 ? void 0 : n.items) === null || o === void 0 ? void 0 : o.length) === 0;
      }, fU = (e) => Tn.metaKeyPressed(e) && e.keyCode === 86 || e.shiftKey && e.keyCode === 45, ME = (e, n, o, r, c) => {
        let u = L5(o);
        const f = Wp(n, OE()) || B5(o), b = !f && GV(u), y = XD(u);
        (F5(u) || !u.length || b && !y) && (r = !0), (r || y) && (Wp(n, "text/plain") && b ? u = n["text/plain"] : u = eU(u)), !F5(u) && (r ? Up(e, u, c) : NE(e, u, f, c));
      }, gU = (e, n, o) => {
        let r;
        const c = () => n.getLastRng() || e.selection.getRng();
        e.on("keydown", (u) => {
          fU(u) && !u.isDefaultPrevented() && (r = u.shiftKey && u.keyCode === 86);
        }), e.on("paste", (u) => {
          if (u.isDefaultPrevented() || mU(u))
            return;
          const f = o.get() === "text" || r;
          r = !1;
          const b = Kv(u.clipboardData);
          !W5(b) && t4(e, u, c()) || (Wp(b, "text/html") ? (u.preventDefault(), ME(e, b, b["text/html"], f, !0)) : Wp(b, "text/plain") && Wp(b, "text/uri-list") ? (u.preventDefault(), ME(e, b, b["text/plain"], f, !0)) : (n.create(), Uu.setEditorTimeout(e, () => {
            const y = n.getHtml();
            n.remove(), ME(e, b, y, f, !1);
          }, 0)));
        });
      }, q5 = (e) => {
        const n = (c) => Kn(c, "webkit-fake-url"), o = (c) => Kn(c, "data:"), r = (c) => {
          var u;
          return ((u = c.data) === null || u === void 0 ? void 0 : u.paste) === !0;
        };
        e.parser.addNodeFilter("img", (c, u, f) => {
          if (!B0(e) && r(f))
            for (const b of c) {
              const y = b.attr("src");
              J(y) && !b.attr("data-mce-object") && y !== sn.transparentSrc && (n(y) || !$0(e) && o(y)) && b.remove();
            }
        });
      }, n4 = (e, n, o) => {
        gU(e, n, o), q5(e);
      }, G5 = (e, n) => {
        n.get() === "text" ? (n.set("html"), nx(e, !1)) : (n.set("text"), nx(e, !0)), e.focus();
      }, hU = (e, n) => {
        e.addCommand("mceTogglePlainTextPaste", () => {
          G5(e, n);
        }), e.addCommand("mceInsertClipboardContent", (o, r) => {
          r.html && NE(e, r.html, r.internal, !1), r.text && Up(e, r.text, !1);
        });
      }, pU = (e, n, o) => {
        if (e)
          try {
            return e.clearData(), e.setData("text/html", n), e.setData("text/plain", o), e.setData(OE(), n), !0;
          } catch {
            return !1;
          }
        else
          return !1;
      }, K5 = (e, n, o, r) => {
        pU(e.clipboardData, n.html, n.text) ? (e.preventDefault(), r()) : o(n.html, r);
      }, o4 = (e) => (n, o) => {
        const { dom: r, selection: c } = e, u = r.create("div", {
          contenteditable: "false",
          "data-mce-bogus": "all"
        }), f = r.create("div", { contenteditable: "true" }, n);
        r.setStyles(u, {
          position: "fixed",
          top: "0",
          left: "-3000px",
          width: "1000px",
          overflow: "hidden"
        }), u.appendChild(f), r.add(e.getBody(), u);
        const b = c.getRng();
        f.focus();
        const y = r.createRng();
        y.selectNodeContents(f), c.setRng(y), Uu.setEditorTimeout(e, () => {
          c.setRng(b), r.remove(u), o();
        }, 0);
      }, PE = (e) => ({
        html: qV(e.selection.getContent({ contextual: !0 })),
        text: e.selection.getContent({ format: "text" })
      }), bU = (e) => !!e.dom.getParent(e.selection.getStart(), "td[data-mce-selected],th[data-mce-selected]", e.getBody()), s4 = (e) => !e.selection.isCollapsed() || bU(e), Y5 = (e) => (n) => {
        !n.isDefaultPrevented() && s4(e) && e.selection.isEditable() && K5(n, PE(e), o4(e), () => {
          if (sn.browser.isChromium() || sn.browser.isFirefox()) {
            const o = e.selection.getRng();
            Uu.setEditorTimeout(e, () => {
              e.selection.setRng(o), e.execCommand("Delete");
            }, 0);
          } else
            e.execCommand("Delete");
        });
      }, vU = (e) => (n) => {
        !n.isDefaultPrevented() && s4(e) && K5(n, PE(e), o4(e), Oe);
      }, X5 = (e) => {
        e.on("cut", Y5(e)), e.on("copy", vU(e));
      }, J5 = (e, n) => {
        var o, r;
        return W.getCaretRangeFromPoint((o = n.clientX) !== null && o !== void 0 ? o : 0, (r = n.clientY) !== null && r !== void 0 ? r : 0, e.getDoc());
      }, yU = (e) => {
        const n = e["text/plain"];
        return n ? n.indexOf("file://") === 0 : !1;
      }, Q5 = (e, n) => {
        e.focus(), n && e.selection.setRng(n);
      }, CU = (e) => pe(e.files, (n) => /^image\//.test(n.type)), wU = (e, n, o, r) => {
        const c = e.getParent(o, (f) => cs(n, f));
        if (!U(e.getParent(o, "summary")))
          return !0;
        if (c && Zn(r, "text/html")) {
          const f = new DOMParser().parseFromString(r["text/html"], "text/html").body;
          return !U(f.querySelector(c.nodeName.toLowerCase()));
        } else
          return !1;
      }, BE = (e) => {
        e.on("input", (n) => {
          const o = (r) => U(r.querySelector("summary"));
          if (n.inputType === "deleteByDrag") {
            const r = Yt(e.dom.select("details"), o);
            ae(r, (c) => {
              Js(c.firstChild) && c.firstChild.remove();
              const u = e.dom.create("summary");
              u.appendChild(di().dom), c.prepend(u);
            });
          }
        });
      }, SU = (e, n) => {
        d_(e) && e.on("dragend dragover draggesture dragdrop drop drag", (o) => {
          o.preventDefault(), o.stopPropagation();
        }), B0(e) || e.on("drop", (o) => {
          const r = o.dataTransfer;
          r && CU(r) && o.preventDefault();
        }), e.on("drop", (o) => {
          if (o.isDefaultPrevented())
            return;
          const r = J5(e, o);
          if (gn(r))
            return;
          const c = Kv(o.dataTransfer), u = Wp(c, OE());
          if ((!W5(c) || yU(c)) && t4(e, o, r))
            return;
          const f = c[OE()], b = f || c["text/html"] || c["text/plain"], y = wU(e.dom, e.schema, r.startContainer, c), E = n.get();
          E && !y || b && (o.preventDefault(), Uu.setEditorTimeout(e, () => {
            e.undoManager.transact(() => {
              (f || E && y) && e.execCommand("Delete"), Q5(e, r);
              const N = L5(b);
              c["text/html"] ? NE(e, N, u, !0) : Up(e, N, !0);
            });
          }));
        }), e.on("dragstart", (o) => {
          n.set(!0);
        }), e.on("dragover dragend", (o) => {
          B0(e) && !n.get() && (o.preventDefault(), Q5(e, J5(e, o))), o.type === "dragend" && n.set(!1);
        }), BE(e);
      }, eF = (e) => {
        const n = (c) => (u) => {
          c(e, u);
        }, o = m_(e);
        re(o) && e.on("PastePreProcess", n(o));
        const r = SS(e);
        re(r) && e.on("PastePostProcess", n(r));
      }, xU = (e, n) => {
        e.on("PastePreProcess", (o) => {
          o.content = n(e, o.content, o.internal);
        });
      }, TU = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/gi, r4 = (e) => _t.trim(e).replace(TU, kh).toLowerCase(), tF = (e, n, o) => {
        const r = gC(e);
        if (o || r === "all" || !hC(e))
          return n;
        const c = r ? r.split(/[, ]/) : [];
        if (c && r !== "none") {
          const u = e.dom, f = e.selection.getNode();
          n = n.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, (b, y, E, N) => {
            const M = u.parseStyle(u.decode(E)), I = {};
            for (let te = 0; te < c.length; te++) {
              const G = M[c[te]];
              let ne = G, Se = u.getStyle(f, c[te], !0);
              /color/.test(c[te]) && (ne = r4(ne), Se = r4(Se)), Se !== ne && (I[c[te]] = G);
            }
            const X = u.serializeStyle(I, "span");
            return X ? y + ' style="' + X + '"' + N : y + N;
          });
        } else
          n = n.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, "$1$3");
        return n = n.replace(/(<[^>]+) data-mce-style="([^"]+)"([^>]*>)/gi, (u, f, b, y) => f + ' style="' + b + '"' + y), n;
      }, EU = (e) => {
        (sn.browser.isChromium() || sn.browser.isSafari()) && xU(e, tF);
      }, kU = (e) => {
        const n = jr(!1), o = jr(bC(e) ? "text" : "html"), r = QV(e);
        EU(e), hU(e, o), eF(e), e.on("PreInit", () => {
          X5(e), SU(e, n), n4(e, r, o);
        });
      }, _U = (e) => {
        e.on("click", (n) => {
          e.dom.getParent(n.target, "details") && n.preventDefault();
        });
      }, AU = (e) => {
        e.parser.addNodeFilter("details", (n) => {
          const o = xc(e);
          ae(n, (r) => {
            o === "expanded" ? r.attr("open", "open") : o === "collapsed" && r.attr("open", null);
          });
        }), e.serializer.addNodeFilter("details", (n) => {
          const o = J4(e);
          ae(n, (r) => {
            o === "expanded" ? r.attr("open", "open") : o === "collapsed" && r.attr("open", null);
          });
        });
      }, OU = (e) => {
        _U(e), AU(e);
      }, nF = Js, oF = Mt, DU = (e) => es(e.dom), RU = (e) => Kc(e.dom), sF = (e) => (n) => fs(le.fromDom(e), n), NU = (e, n, o) => ci(le.fromDom(e), (r) => RU(r) || o.isBlock(Qo(r)), sF(n)).getOr(le.fromDom(n)).dom, rF = (e, n) => ci(le.fromDom(e), DU, sF(n)), aF = (e, n, o) => {
        const r = new br(e, n), c = o ? r.next.bind(r) : r.prev.bind(r);
        let u = e;
        for (let f = o ? e : c(); f && !nF(f); f = c())
          Zs(f) && (u = f);
        return u;
      }, MU = (e, n, o) => {
        const c = We.fromRangeStart(e).getNode(), u = NU(c, n, o), f = aF(c, u, !1), b = aF(c, u, !0), y = document.createRange();
        return rF(f, u).fold(() => {
          oF(f) ? y.setStart(f, 0) : y.setStartBefore(f);
        }, (E) => y.setStartBefore(E.dom)), rF(b, u).fold(() => {
          oF(b) ? y.setEnd(b, b.data.length) : y.setEndAfter(b);
        }, (E) => y.setEndAfter(E.dom)), y;
      }, cF = (e) => {
        const n = MU(e.selection.getRng(), e.getBody(), e.schema);
        e.selection.setRng(Ix(n));
      }, iF = (e) => {
        e.on("mousedown", (n) => {
          n.detail >= 3 && (n.preventDefault(), cF(e));
        });
      };
      var Xv;
      (function(e) {
        e.Before = "before", e.After = "after";
      })(Xv || (Xv = {}));
      const PU = (e, n) => Math.abs(e.left - n), BU = (e, n) => Math.abs(e.right - n), $U = (e, n) => e >= n.top && e <= n.bottom, FU = (e, n) => e.top < n.bottom && e.bottom > n.top, IU = (e, n) => {
        const o = Fk(e, n) / Math.min(e.height, n.height);
        return FU(e, n) && o > 0.5;
      }, LU = (e, n) => {
        const o = Yt(e, (r) => $U(n, r));
        return $k(o).fold(() => [
          [],
          e
        ], (r) => {
          const {
            pass: c,
            fail: u
          } = Vn(e, (f) => IU(f, r));
          return [
            c,
            u
          ];
        });
      }, $E = (e, n) => ({
        node: e.node,
        position: PU(e, n) < BU(e, n) ? Xv.Before : Xv.After
      }), lF = (e, n, o) => n > e.left && n < e.right ? 0 : Math.min(Math.abs(e.left - n), Math.abs(e.right - n)), a4 = (e, n, o, r) => {
        const c = (M) => Zs(M.node) ? F.some(M) : xn(M.node) ? a4(rs(M.node.childNodes), n, o, !1) : F.none(), u = (M, I, X) => c(I).filter((te) => Math.abs(X(M, n, o) - X(te, n, o)) < 2 && Mt(te.node)), f = (M, I) => {
          const X = et(M, (te, G) => I(te, n, o) - I(G, n, o));
          return Gs(X, c).map((te) => r && !Mt(te.node) && X.length > 1 ? u(te, X[1], I).getOr(te) : te);
        }, [b, y] = LU(yB(e), o), {
          pass: E,
          fail: N
        } = Vn(y, (M) => M.top < o);
        return f(b, lF).orThunk(() => f(N, Ly)).orThunk(() => f(E, Ly));
      }, uF = (e, n, o, r) => {
        const c = (u, f) => {
          const b = (E) => xn(E) && E.classList.contains("mce-drag-container"), y = Yt(u.dom.childNodes, io(b));
          return f.fold(() => a4(y, o, r, !0), (E) => {
            const N = Yt(y, (M) => M !== E.dom);
            return a4(N, o, r, !0);
          }).orThunk(() => (fs(u, e) ? F.none() : Tl(u)).bind((N) => c(N, F.some(u))));
        };
        return c(n, F.none());
      }, dF = (e, n, o) => {
        const r = le.fromDom(e), c = xi(r), f = le.fromPoint(c, n, o).filter((b) => ic(r, b)).getOr(r);
        return uF(r, f, n, o);
      }, FE = (e, n, o) => dF(e, n, o).filter((r) => Jh(r.node)).map((r) => $E(r, n)), mF = (e) => {
        var n, o;
        const r = e.getBoundingClientRect(), c = e.ownerDocument, u = c.documentElement, f = c.defaultView;
        return {
          top: r.top + ((n = f?.scrollY) !== null && n !== void 0 ? n : 0) - u.clientTop,
          left: r.left + ((o = f?.scrollX) !== null && o !== void 0 ? o : 0) - u.clientLeft
        };
      }, fF = (e) => e.inline ? mF(e.getBody()) : {
        left: 0,
        top: 0
      }, HU = (e) => {
        const n = e.getBody();
        return e.inline ? {
          left: n.scrollLeft,
          top: n.scrollTop
        } : {
          left: 0,
          top: 0
        };
      }, gF = (e) => {
        const n = e.getBody(), o = e.getDoc().documentElement, r = {
          left: n.scrollLeft,
          top: n.scrollTop
        }, c = {
          left: n.scrollLeft || o.scrollLeft,
          top: n.scrollTop || o.scrollTop
        };
        return e.inline ? r : c;
      }, zU = (e, n) => {
        if (n.target.ownerDocument !== e.getDoc()) {
          const o = mF(e.getContentAreaContainer()), r = gF(e);
          return {
            left: n.pageX - o.left + r.left,
            top: n.pageY - o.top + r.top
          };
        }
        return {
          left: n.pageX,
          top: n.pageY
        };
      }, hF = (e, n, o) => ({
        pageX: o.left - e.left + n.left,
        pageY: o.top - e.top + n.top
      }), VU = (e, n) => hF(fF(e), HU(e), zU(e, n)), pF = (e) => ({
        target: e,
        srcElement: e
      }), UU = (e, n, o, r) => ({
        ...n,
        dataTransfer: r,
        type: e,
        ...pF(o)
      }), bw = (e, n, o) => {
        const r = jo("Function not supported on simulated event.");
        return {
          bubbles: !0,
          cancelBubble: !1,
          cancelable: !0,
          composed: !1,
          currentTarget: null,
          defaultPrevented: !1,
          eventPhase: 0,
          isTrusted: !0,
          returnValue: !1,
          timeStamp: 0,
          type: e,
          composedPath: r,
          initEvent: r,
          preventDefault: Oe,
          stopImmediatePropagation: Oe,
          stopPropagation: Oe,
          AT_TARGET: window.Event.AT_TARGET,
          BUBBLING_PHASE: window.Event.BUBBLING_PHASE,
          CAPTURING_PHASE: window.Event.CAPTURING_PHASE,
          NONE: window.Event.NONE,
          altKey: !1,
          button: 0,
          buttons: 0,
          clientX: 0,
          clientY: 0,
          ctrlKey: !1,
          metaKey: !1,
          movementX: 0,
          movementY: 0,
          offsetX: 0,
          offsetY: 0,
          pageX: 0,
          pageY: 0,
          relatedTarget: null,
          screenX: 0,
          screenY: 0,
          shiftKey: !1,
          x: 0,
          y: 0,
          detail: 0,
          view: null,
          which: 0,
          initUIEvent: r,
          initMouseEvent: r,
          getModifierState: r,
          dataTransfer: o,
          ...pF(n)
        };
      }, WU = (e, n) => {
        const o = Gv(e);
        return n === "dragstart" ? (_5(o), O5(o)) : n === "drop" ? (IV(o), ZD(o)) : (kE(o), D5(o)), o;
      }, ZU = (e, n, o, r) => {
        const c = WU(o, e);
        return Ht(r) ? bw(e, n, c) : UU(e, r, n, c);
      }, vw = 32, jU = 100, IE = 8, LE = 16, bF = es, qU = Ik(bF, Kc), HE = (e, n, o) => bF(o) && o !== n && e.isEditable(o.parentElement), vF = (e, n, o) => gn(n) || n === o || e.dom.isChildOf(n, o) ? !1 : e.dom.isEditable(n), yF = (e, n, o, r) => {
        const c = e.dom, u = n.cloneNode(!0);
        c.setStyles(u, {
          width: o,
          height: r
        }), c.setAttrib(u, "data-mce-selected", null);
        const f = c.create("div", {
          class: "mce-drag-container",
          "data-mce-bogus": "all",
          unselectable: "on",
          contenteditable: "false"
        });
        return c.setStyles(f, {
          position: "absolute",
          opacity: 0.5,
          overflow: "hidden",
          border: 0,
          padding: 0,
          margin: 0,
          width: o,
          height: r
        }), c.setStyles(u, {
          margin: 0,
          boxSizing: "border-box"
        }), f.appendChild(u), f;
      }, GU = (e, n) => {
        e.parentNode !== n && n.appendChild(e);
      }, zE = (e, n) => (o) => () => {
        const r = e === "left" ? o.scrollX : o.scrollY;
        o.scroll({
          [e]: r + n,
          behavior: "smooth"
        });
      }, CF = zE("left", -vw), KU = zE("left", vw), wF = zE("top", -vw), VE = zE("top", vw), c4 = (e, n, o, r, c, u, f, b, y, E, N, M) => {
        let I = 0, X = 0;
        e.style.left = n.pageX + "px", e.style.top = n.pageY + "px", n.pageX + o > c && (I = n.pageX + o - c), n.pageY + r > u && (X = n.pageY + r - u), e.style.width = o - I + "px", e.style.height = r - X + "px";
        const te = y.clientHeight, G = y.clientWidth, ne = f + y.getBoundingClientRect().top, Se = b + y.getBoundingClientRect().left;
        N.on((ke) => {
          ke.intervalId.clear(), ke.dragging && M && (f + IE >= te ? ke.intervalId.set(VE(E)) : f - IE <= 0 ? ke.intervalId.set(wF(E)) : b + IE >= G ? ke.intervalId.set(KU(E)) : b - IE <= 0 ? ke.intervalId.set(CF(E)) : ne + LE >= window.innerHeight ? ke.intervalId.set(VE(window)) : ne - LE <= 0 ? ke.intervalId.set(wF(window)) : Se + LE >= window.innerWidth ? ke.intervalId.set(KU(window)) : Se - LE <= 0 && ke.intervalId.set(CF(window)));
        });
      }, yw = (e) => {
        e && e.parentNode && e.parentNode.removeChild(e);
      }, YU = (e, n) => {
        const o = e.getParent(n.parentNode, e.isBlock);
        yw(n), o && o !== e.getRoot() && e.isEmpty(o) && Nu(le.fromDom(o));
      }, XU = (e) => e.button === 0, SF = (e, n) => ({
        pageX: n.pageX - e.relX,
        pageY: n.pageY + 5
      }), JU = (e, n) => (o) => {
        if (XU(o)) {
          const r = hn(n.dom.getParents(o.target), qU).getOr(null);
          if (De(r) && HE(n.dom, n.getBody(), r)) {
            const c = n.dom.getPos(r), u = n.getBody(), f = n.getDoc().documentElement;
            e.set({
              element: r,
              dataTransfer: jD(),
              dragging: !1,
              screenX: o.screenX,
              screenY: o.screenY,
              maxX: (n.inline ? u.scrollWidth : f.offsetWidth) - 2,
              maxY: (n.inline ? u.scrollHeight : f.offsetHeight) - 2,
              relX: o.pageX - c.x,
              relY: o.pageY - c.y,
              width: r.offsetWidth,
              height: r.offsetHeight,
              ghost: yF(n, r, r.offsetWidth, r.offsetHeight),
              intervalId: Pk(jU)
            });
          }
        }
      }, i4 = (e, n, o) => {
        e._selectionOverrides.hideFakeCaret(), FE(e.getBody(), n, o).fold(() => e.selection.placeCaretAt(n, o), (r) => {
          const c = e._selectionOverrides.showCaret(1, r.node, r.position === Xv.Before, !1);
          c ? e.selection.setRng(c) : e.selection.placeCaretAt(n, o);
        });
      }, Jv = (e, n, o, r, c) => {
        n === "dragstart" && M5(r, e.dom.getOuterHTML(o));
        const u = ZU(n, o, r, c);
        return e.dispatch(n, u);
      }, QU = (e, n) => {
        const o = T1((c, u) => i4(n, c, u), 0);
        n.on("remove", o.cancel);
        const r = e;
        return (c) => e.on((u) => {
          const f = Math.max(Math.abs(c.screenX - u.screenX), Math.abs(c.screenY - u.screenY));
          if (!u.dragging && f > 10) {
            const b = Jv(n, "dragstart", u.element, u.dataTransfer, c);
            if (De(b.dataTransfer) && (u.dataTransfer = b.dataTransfer), b.isDefaultPrevented())
              return;
            u.dragging = !0, n.focus();
          }
          if (u.dragging) {
            const b = c.currentTarget === n.getDoc().documentElement, y = SF(u, VU(n, c));
            GU(u.ghost, n.getBody()), c4(u.ghost, y, u.width, u.height, u.maxX, u.maxY, c.clientY, c.clientX, n.getContentAreaContainer(), n.getWin(), r, b), o.throttle(c.clientX, c.clientY);
          }
        });
      }, eW = (e) => {
        const n = e.getSel();
        if (De(n)) {
          const r = n.getRangeAt(0).startContainer;
          return Mt(r) ? r.parentNode : r;
        } else
          return null;
      }, xF = (e, n) => (o) => {
        e.on((r) => {
          var c;
          if (r.intervalId.clear(), r.dragging) {
            if (vF(n, eW(n.selection), r.element)) {
              const u = (c = n.getDoc().elementFromPoint(o.clientX, o.clientY)) !== null && c !== void 0 ? c : n.getBody();
              Jv(n, "drop", u, r.dataTransfer, o).isDefaultPrevented() || n.undoManager.transact(() => {
                YU(n.dom, r.element), jV(r.dataTransfer).each((b) => n.insertContent(b)), n._selectionOverrides.hideFakeCaret();
              });
            }
            Jv(n, "dragend", n.getBody(), r.dataTransfer, o);
          }
        }), EF(e);
      }, TF = (e, n, o) => {
        e.on((r) => {
          r.intervalId.clear(), r.dragging && o.fold(() => Jv(n, "dragend", r.element, r.dataTransfer), (c) => Jv(n, "dragend", r.element, r.dataTransfer, c));
        }), EF(e);
      }, lq = (e, n) => (o) => TF(e, n, F.some(o)), EF = (e) => {
        e.on((n) => {
          n.intervalId.clear(), yw(n.ghost);
        }), e.clear();
      }, tW = (e) => {
        const n = Cf(), o = xr.DOM, r = document, c = JU(n, e), u = QU(n, e), f = xF(n, e), b = lq(n, e);
        e.on("mousedown", c), e.on("mousemove", u), e.on("mouseup", f), o.bind(r, "mousemove", u), o.bind(r, "mouseup", b), e.on("remove", () => {
          o.unbind(r, "mousemove", u), o.unbind(r, "mouseup", b);
        }), e.on("keydown", (y) => {
          y.keyCode === Tn.ESC && TF(n, e, F.none());
        });
      }, nW = (e) => {
        const n = (c) => {
          if (!c.isDefaultPrevented()) {
            const u = c.dataTransfer;
            u && (ee(u.types, "Files") || u.files.length > 0) && (c.preventDefault(), c.type === "drop" && kT(e, "Dropped file type is not supported"));
          }
        }, o = (c) => {
          px(e, c.target) && n(c);
        }, r = () => {
          const c = xr.DOM, u = e.dom, f = document, b = e.inline ? e.getBody() : e.getDoc(), y = [
            "drop",
            "dragover"
          ];
          ae(y, (E) => {
            c.bind(f, E, o), u.bind(b, E, n);
          }), e.on("remove", () => {
            ae(y, (E) => {
              c.unbind(f, E, o), u.unbind(b, E, n);
            });
          });
        };
        e.on("init", () => {
          Uu.setEditorTimeout(e, r, 0);
        });
      }, kF = (e) => {
        tW(e), P0(e) && nW(e);
      }, oW = (e) => {
        const n = T1(() => {
          if (!e.removed && e.getBody().contains(document.activeElement)) {
            const o = e.selection.getRng();
            if (o.collapsed) {
              const r = IT(e, o, !1);
              e.selection.setRng(r);
            }
          }
        }, 0);
        e.on("focus", () => {
          n.throttle();
        }), e.on("blur", () => {
          n.cancel();
        });
      }, _F = (e) => {
        e.on("init", () => {
          e.on("focusin", (n) => {
            const o = n.target;
            if (oa(o)) {
              const r = Sp(e.getBody(), o), c = es(r) ? r : o;
              e.selection.getNode() !== c && Nv(e, c).each((u) => e.selection.setRng(u));
            }
          });
        });
      }, Cw = es, AF = (e, n) => Sp(e.getBody(), n), sW = (e) => {
        const n = e.selection, o = e.dom, r = e.getBody(), c = TC(e, r, o.isBlock, () => vp(e)), u = "sel-" + o.uniqueId(), f = "data-mce-selected";
        let b;
        const y = (un) => De(un) && o.hasClass(un, "mce-offscreen-selection"), E = (un) => un !== r && (Cw(un) || oa(un)) && o.isChildOf(un, r) && o.isEditable(un.parentNode), N = (un) => {
          un && n.setRng(un);
        }, M = (un, nt, qe, xt = !0) => e.dispatch("ShowCaret", {
          target: nt,
          direction: un,
          before: qe
        }).isDefaultPrevented() ? null : (xt && n.scrollIntoView(nt, un === -1), c.show(qe, nt)), I = (un) => {
          un.hasAttribute("data-mce-caret") && (Dl(un), n.scrollIntoView(un));
        }, X = () => {
          e.on("click", (nt) => {
            o.isEditable(nt.target) || (nt.preventDefault(), e.focus());
          }), e.on("blur NewBlock", Me), e.on("ResizeWindow FullscreenStateChanged", c.reposition), e.on("tap", (nt) => {
            const qe = nt.target, xt = AF(e, qe);
            Cw(xt) ? (nt.preventDefault(), Nv(e, xt).each(Ae)) : E(qe) && Nv(e, qe).each(Ae);
          }, !0), e.on("mousedown", (nt) => {
            const qe = nt.target;
            if (qe !== r && qe.nodeName !== "HTML" && !o.isChildOf(qe, r) || !R7(e, nt.clientX, nt.clientY))
              return;
            Me(), It();
            const xt = AF(e, qe);
            Cw(xt) ? (nt.preventDefault(), Nv(e, xt).each(Ae)) : FE(r, nt.clientX, nt.clientY).each((bn) => {
              nt.preventDefault();
              const Yn = M(1, bn.node, bn.position === Xv.Before, !1);
              N(Yn), Au(xt) ? xt.focus() : e.getBody().focus();
            });
          }), e.on("keypress", (nt) => {
            Tn.modifierPressed(nt) || Cw(n.getNode()) && nt.preventDefault();
          }), e.on("GetSelectionRange", (nt) => {
            let qe = nt.range;
            if (b) {
              if (!b.parentNode) {
                b = null;
                return;
              }
              qe = qe.cloneRange(), qe.selectNode(b), nt.range = qe;
            }
          }), e.on("SetSelectionRange", (nt) => {
            nt.range = ne(nt.range);
            const qe = Ae(nt.range, nt.forward);
            qe && (nt.range = qe);
          });
          const un = (nt) => xn(nt) && nt.id === "mcepastebin";
          e.on("AfterSetSelectionRange", (nt) => {
            const qe = nt.range, xt = qe.startContainer.parentElement;
            !G(qe) && !un(xt) && It(), y(xt) || Me();
          }), kF(e), oW(e), _F(e);
        }, te = (un) => Jn(un) || Vi(un) || Ol(un), G = (un) => te(un.startContainer) || te(un.endContainer), ne = (un) => {
          const nt = e.schema.getVoidElements(), qe = o.createRng(), xt = un.startContainer, bn = un.startOffset, Yn = un.endContainer, Po = un.endOffset;
          return Zn(nt, xt.nodeName.toLowerCase()) ? bn === 0 ? qe.setStartBefore(xt) : qe.setStartAfter(xt) : qe.setStart(xt, bn), Zn(nt, Yn.nodeName.toLowerCase()) ? Po === 0 ? qe.setEndBefore(Yn) : qe.setEndAfter(Yn) : qe.setEnd(Yn, Po), qe;
        }, Se = (un, nt) => {
          const qe = le.fromDom(e.getBody()), xt = e.getDoc(), bn = ii(qe, "#" + u).getOrThunk(() => {
            const Ko = le.fromHtml('<div data-mce-bogus="all" class="mce-offscreen-selection"></div>', xt);
            return ks(Ko, "id", u), la(qe, Ko), Ko;
          }), Yn = o.createRng();
          Ei(bn), Ms(bn, [
            le.fromText(_s, xt),
            le.fromDom(nt),
            le.fromText(_s, xt)
          ]), Yn.setStart(bn.dom.firstChild, 1), Yn.setEnd(bn.dom.lastChild, 0), Ya(bn, { top: o.getPos(un, e.getBody()).y + "px" }), lx(bn);
          const Po = n.getSel();
          return Po && (Po.removeAllRanges(), Po.addRange(Yn)), Yn;
        }, ke = (un) => {
          const nt = un.cloneNode(!0), qe = e.dispatch("ObjectSelected", {
            target: un,
            targetClone: nt
          });
          if (qe.isDefaultPrevented())
            return null;
          const xt = Se(un, qe.targetClone), bn = le.fromDom(un);
          return ae(uc(le.fromDom(e.getBody()), `*[${f}]`), (Yn) => {
            fs(bn, Yn) || _r(Yn, f);
          }), o.getAttrib(un, f) || un.setAttribute(f, "1"), b = un, It(), xt;
        }, Ae = (un, nt) => {
          if (!un)
            return null;
          if (un.collapsed) {
            if (!G(un)) {
              const Yn = nt ? 1 : -1, Po = Rf(Yn, r, un), Ko = Po.getNode(!nt);
              if (De(Ko)) {
                if (Jh(Ko))
                  return M(Yn, Ko, nt ? !Po.isAtEnd() : !1, !1);
                if (oo(Ko) && es(Ko.nextSibling)) {
                  const Er = o.createRng();
                  return Er.setStart(Ko, 0), Er.setEnd(Ko, 0), Er;
                }
              }
              const er = Po.getNode(nt);
              if (De(er)) {
                if (Jh(er))
                  return M(Yn, er, nt ? !1 : !Po.isAtEnd(), !1);
                if (oo(er) && es(er.previousSibling)) {
                  const Er = o.createRng();
                  return Er.setStart(er, 1), Er.setEnd(er, 1), Er;
                }
              }
            }
            return null;
          }
          let qe = un.startContainer, xt = un.startOffset;
          const bn = un.endOffset;
          if (Mt(qe) && xt === 0 && Cw(qe.parentNode) && (qe = qe.parentNode, xt = o.nodeIndex(qe), qe = qe.parentNode), !xn(qe))
            return null;
          if (bn === xt + 1 && qe === un.endContainer) {
            const Yn = qe.childNodes[xt];
            if (E(Yn))
              return ke(Yn);
          }
          return null;
        }, Me = () => {
          b && b.removeAttribute(f), ii(le.fromDom(e.getBody()), "#" + u).each(bs), b = null;
        }, pt = () => {
          c.destroy(), b = null;
        }, It = () => {
          c.hide();
        };
        return Yg(e) || X(), {
          showCaret: M,
          showBlockCaretContainer: I,
          hideFakeCaret: It,
          destroy: pt
        };
      }, rW = (e, n) => {
        let o = n;
        for (let r = e.previousSibling; Mt(r); r = r.previousSibling)
          o += r.data.length;
        return o;
      }, OF = (e, n, o, r, c) => {
        if (Mt(o) && (r < 0 || r > o.data.length))
          return [];
        const u = c && Mt(o) ? [rW(o, r)] : [r];
        let f = o;
        for (; f !== n && f.parentNode; )
          u.push(e.nodeIndex(f, c)), f = f.parentNode;
        return f === n ? u.reverse() : [];
      }, UE = (e, n, o, r, c, u, f = !1) => {
        const b = OF(e, n, o, r, f), y = OF(e, n, c, u, f);
        return {
          start: b,
          end: y
        };
      }, aW = (e, n) => {
        const o = n.slice(), r = o.pop();
        return ho(r) ? Xe(o, (u, f) => u.bind((b) => F.from(b.childNodes[f])), F.some(e)).bind((u) => Mt(u) && (r < 0 || r > u.data.length) ? F.none() : F.some({
          node: u,
          offset: r
        })) : F.none();
      }, DF = (e, n) => aW(e, n.start).bind(({
        node: o,
        offset: r
      }) => aW(e, n.end).map(({
        node: c,
        offset: u
      }) => {
        const f = document.createRange();
        return f.setStart(o, r), f.setEnd(c, u), f;
      })), RF = (e, n, o, r = !1) => UE(e, n, o.startContainer, o.startOffset, o.endContainer, o.endOffset, r), Qv = (e, n, o) => {
        if (n && e.isEmpty(n) && !o(n)) {
          const r = n.parentNode;
          e.remove(n, Mt(n.firstChild) && ff(n.firstChild.data)), Qv(e, r, o);
        }
      }, ey = (e, n, o, r = !0) => {
        const c = n.startContainer.parentNode, u = n.endContainer.parentNode;
        n.deleteContents(), r && !o(n.startContainer) && (Mt(n.startContainer) && n.startContainer.data.length === 0 && e.remove(n.startContainer), Mt(n.endContainer) && n.endContainer.data.length === 0 && e.remove(n.endContainer), Qv(e, c, o), c !== u && Qv(e, u, o));
      }, l4 = (e, n) => F.from(e.dom.getParent(n.startContainer, e.dom.isBlock)), NF = (e, n, o) => {
        const r = e.dynamicPatternsLookup({
          text: o,
          block: n
        });
        return {
          ...e,
          blockPatterns: D0(r).concat(e.blockPatterns),
          inlinePatterns: eC(r).concat(e.inlinePatterns)
        };
      }, MF = (e, n, o, r) => {
        const c = e.createRng();
        return c.setStart(n, 0), c.setEnd(o, r), c.toString();
      }, PF = (e) => /^\s[^\s]/.test(e), ww = (e, n, o) => {
        b$(n, 0, n).each((c) => {
          const u = c.container;
          sE(u, o.start.length, n).each((y) => {
            const E = e.createRng();
            E.setStart(u, 0), E.setEnd(y.container, y.offset), ey(e, E, (N) => N === n);
          });
          const f = le.fromDom(u), b = su(f);
          PF(b) && zi(f, b.slice(1));
        });
      }, BF = (e, n) => {
        const o = e.dom, r = n.pattern, c = DF(o.getRoot(), n.range).getOrDie("Unable to resolve path range"), u = (f, b) => {
          const y = b.get(f);
          return ht(y) && qt(y).exists((E) => Zn(E, "block"));
        };
        return l4(e, c).each((f) => {
          r.type === "block-format" ? u(r.format, e.formatter) && e.undoManager.transact(() => {
            ww(e.dom, f, r), e.formatter.apply(r.format);
          }) : r.type === "block-command" && e.undoManager.transact(() => {
            ww(e.dom, f, r), e.execCommand(r.cmd, !1, r.value);
          });
        }), !0;
      }, $F = (e) => et(e, (n, o) => o.start.length - n.start.length), cW = (e, n) => {
        const o = $F(e), r = n.replace(_s, " ");
        return hn(o, (c) => n.indexOf(c.start) === 0 || r.indexOf(c.start) === 0);
      }, iW = (e, n, o, r) => {
        var c;
        const u = e.dom, f = gi(e);
        if (!u.is(n, f))
          return [];
        const b = (c = n.textContent) !== null && c !== void 0 ? c : "";
        return cW(o.blockPatterns, b).map((y) => _t.trim(b).length === y.start.length ? [] : [{
          pattern: y,
          range: UE(u, u.getRoot(), n, 0, n, 0, r)
        }]).getOr([]);
      }, FF = (e, n) => {
        if (n.length === 0)
          return;
        const o = e.selection.getBookmark();
        ae(n, (r) => BF(e, r)), e.selection.moveToBookmark(o);
      }, IF = (e, n) => e.create("span", {
        "data-mce-type": "bookmark",
        id: n
      }), WE = (e, n) => {
        const o = e.createRng();
        return o.setStartAfter(n.start), o.setEndBefore(n.end), o;
      }, LF = (e, n, o) => {
        const r = DF(e.getRoot(), o).getOrDie("Unable to resolve path range"), c = r.startContainer, u = r.endContainer, f = r.endOffset === 0 ? u : u.splitText(r.endOffset), b = r.startOffset === 0 ? c : c.splitText(r.startOffset), y = b.parentNode, E = f.parentNode;
        return {
          prefix: n,
          end: E.insertBefore(IF(e, n + "-end"), f),
          start: y.insertBefore(IF(e, n + "-start"), b)
        };
      }, ZE = (e, n, o) => {
        Qv(e, e.get(n.prefix + "-end"), o), Qv(e, e.get(n.prefix + "-start"), o);
      }, u4 = (e) => e.start.length === 0, lW = (e) => (n, o) => {
        const c = n.data.substring(0, o), u = c.lastIndexOf(e.charAt(e.length - 1)), f = c.lastIndexOf(e);
        return f !== -1 ? f + e.length : u !== -1 ? u + 1 : -1;
      }, HF = (e, n, o, r) => {
        const c = n.start;
        return sw(e, r.container, r.offset, lW(c), o).bind((f) => {
          var b, y;
          const E = (y = (b = o.textContent) === null || b === void 0 ? void 0 : b.indexOf(c)) !== null && y !== void 0 ? y : -1;
          if (E !== -1 && f.offset >= E + c.length) {
            const M = e.createRng();
            return M.setStart(f.container, f.offset - c.length), M.setEnd(f.container, f.offset), F.some(M);
          } else {
            const M = f.offset - c.length;
            return ow(f.container, M, o).map((I) => {
              const X = e.createRng();
              return X.setStart(I.container, I.offset), X.setEnd(f.container, f.offset), X;
            }).filter((I) => I.toString() === c).orThunk(() => HF(e, n, o, om(f.container, 0)));
          }
        });
      }, uW = (e, n, o, r, c, u = !1) => {
        if (n.start.length === 0 && !u) {
          const f = e.createRng();
          return f.setStart(o, r), f.setEnd(o, r), F.some(f);
        }
        return nw(o, r, c).bind((f) => HF(e, n, c, f).bind((y) => {
          var E;
          if (u) {
            if (y.endContainer === f.container && y.endOffset === f.offset)
              return F.none();
            if (f.offset === 0 && ((E = y.endContainer.textContent) === null || E === void 0 ? void 0 : E.length) === y.endOffset)
              return F.none();
          }
          return F.some(y);
        }));
      }, dW = (e, n, o, r) => {
        const c = e.dom, u = c.getRoot(), f = o.pattern, b = o.position.container, y = o.position.offset;
        return ow(b, y - o.pattern.end.length, n).bind((E) => {
          const N = UE(c, u, E.container, E.offset, b, y, r);
          if (u4(f))
            return F.some({
              matches: [{
                pattern: f,
                startRng: N,
                endRng: N
              }],
              position: E
            });
          {
            const M = jE(e, o.remainingPatterns, E.container, E.offset, n, r), I = M.getOr({
              matches: [],
              position: E
            }), X = I.position;
            return uW(c, f, X.container, X.offset, n, M.isNone()).map((G) => {
              const ne = RF(c, u, G, r);
              return {
                matches: I.matches.concat([{
                  pattern: f,
                  startRng: ne,
                  endRng: N
                }]),
                position: om(G.startContainer, G.startOffset)
              };
            });
          }
        });
      }, jE = (e, n, o, r, c, u) => {
        const f = e.dom;
        return nw(o, r, f.getRoot()).bind((b) => {
          const y = MF(f, c, o, r);
          for (let E = 0; E < n.length; E++) {
            const N = n[E];
            if (!zo(y, N.end))
              continue;
            const M = n.slice();
            M.splice(E, 1);
            const I = dW(e, c, {
              pattern: N,
              remainingPatterns: M,
              position: b
            }, u);
            if (I.isNone() && r > 0)
              return jE(e, n, o, r - 1, c, u);
            if (I.isSome())
              return I;
          }
          return F.none();
        });
      }, d4 = (e, n, o) => {
        e.selection.setRng(o), n.type === "inline-format" ? ae(n.format, (r) => {
          e.formatter.apply(r);
        }) : e.execCommand(n.cmd, !1, n.value);
      }, zF = (e, n, o, r) => {
        const c = WE(e.dom, o);
        ey(e.dom, c, r), d4(e, n, c);
      }, m4 = (e, n, o, r, c) => {
        const u = e.dom, f = WE(u, r), b = WE(u, o);
        ey(u, b, c), ey(u, f, c);
        const y = {
          prefix: o.prefix,
          start: o.end,
          end: r.start
        }, E = WE(u, y);
        d4(e, n, E);
      }, f4 = (e, n) => {
        const o = Eg("mce_textpattern"), r = Ct(n, (c, u) => {
          const f = LF(e, o + `_end${c.length}`, u.endRng);
          return c.concat([{
            ...u,
            endMarker: f
          }]);
        }, []);
        return Ct(r, (c, u) => {
          const f = r.length - c.length - 1, b = u4(u.pattern) ? u.endMarker : LF(e, o + `_start${f}`, u.startRng);
          return c.concat([{
            ...u,
            startMarker: b
          }]);
        }, []);
      }, mW = (e) => et(e, (n, o) => o.end.length - n.end.length), g4 = (e, n) => {
        const o = No(e, (r) => pe(n, (c) => r.pattern.start === c.pattern.start && r.pattern.end === c.pattern.end));
        return e.length === n.length ? o ? e : n : e.length > n.length ? e : n;
      }, VF = (e, n, o, r, c, u) => {
        const f = jE(e, c.inlinePatterns, o, r, n, u).fold(() => [], (y) => y.matches), b = jE(e, mW(c.inlinePatterns), o, r, n, u).fold(() => [], (y) => y.matches);
        return g4(f, b);
      }, UF = (e, n) => {
        if (n.length === 0)
          return;
        const o = e.dom, r = e.selection.getBookmark(), c = f4(o, n);
        ae(c, (u) => {
          const f = o.getParent(u.startMarker.start, o.isBlock), b = (y) => y === f;
          u4(u.pattern) ? zF(e, u.pattern, u.endMarker, b) : m4(e, u.pattern, u.startMarker, u.endMarker, b), ZE(o, u.endMarker, b), ZE(o, u.startMarker, b);
        }), e.selection.moveToBookmark(r);
      }, WF = (e, n) => {
        const o = e.selection.getRng();
        return l4(e, o).map((r) => {
          var c;
          const u = Math.max(0, o.startOffset), f = NF(n, r, (c = r.textContent) !== null && c !== void 0 ? c : ""), b = VF(e, r, o.startContainer, u, f, !0), y = iW(e, r, f, !0);
          return y.length > 0 || b.length > 0 ? (e.undoManager.add(), e.undoManager.extra(() => {
            e.execCommand("mceInsertNewLine");
          }, () => {
            we(e), UF(e, b), FF(e, y);
            const E = e.selection.getRng(), N = nw(E.startContainer, E.startOffset, e.dom.getRoot());
            e.execCommand("mceInsertNewLine"), N.each((M) => {
              const I = M.container;
              I.data.charAt(M.offset - 1) === fg && (I.deleteData(M.offset - 1, 1), Qv(e.dom, I.parentNode, (X) => X === e.dom.getRoot()));
            });
          }), !0) : !1;
        }).getOr(!1);
      }, fW = (e, n) => {
        const o = e.selection.getRng();
        l4(e, o).map((r) => {
          const c = Math.max(0, o.startOffset - 1), u = MF(e.dom, r, o.startContainer, c), f = NF(n, r, u), b = VF(e, r, o.startContainer, c, f, !1);
          b.length > 0 && e.undoManager.transact(() => {
            UF(e, b);
          });
        });
      }, ZF = (e, n, o) => {
        for (let r = 0; r < e.length; r++)
          if (o(e[r], n))
            return !0;
        return !1;
      }, gW = (e, n) => ZF(e, n, (o, r) => o === r.keyCode && !Tn.modifierPressed(r)), hW = (e, n) => ZF(e, n, (o, r) => o.charCodeAt(0) === r.charCode), pW = (e) => {
        const n = [
          ",",
          ".",
          ";",
          ":",
          "!",
          "?"
        ], o = [32], r = () => Wi(F0(e), g_(e)), c = () => CC(e);
        e.on("keydown", (f) => {
          if (f.keyCode === 13 && !Tn.modifierPressed(f) && e.selection.isCollapsed()) {
            const b = r();
            (b.inlinePatterns.length > 0 || b.blockPatterns.length > 0 || c()) && WF(e, b) && f.preventDefault();
          }
        }, !0);
        const u = () => {
          if (e.selection.isCollapsed()) {
            const f = r();
            (f.inlinePatterns.length > 0 || c()) && fW(e, f);
          }
        };
        e.on("keyup", (f) => {
          gW(o, f) && u();
        }), e.on("keypress", (f) => {
          hW(n, f) && Uu.setEditorTimeout(e, u);
        });
      }, bW = (e) => {
        pW(e);
      }, vW = (e) => {
        const n = _t.each, o = Tn.BACKSPACE, r = Tn.DELETE, c = e.dom, u = e.selection, f = e.parser, b = sn.browser, y = b.isFirefox(), E = b.isChromium() || b.isSafari(), N = sn.deviceType.isiPhone() || sn.deviceType.isiPad(), M = sn.os.isMacOS() || sn.os.isiOS(), I = (zn, Un) => {
          try {
            e.getDoc().execCommand(zn, !1, String(Un));
          } catch {
          }
        }, X = (zn) => zn.isDefaultPrevented(), te = () => {
          const zn = (zt) => {
            const Eo = c.create("body"), hs = zt.cloneContents();
            return Eo.appendChild(hs), u.serializer.serialize(Eo, { format: "html" });
          }, Un = (zt) => {
            const Eo = zn(zt), hs = c.createRng();
            hs.selectNode(e.getBody());
            const nr = zn(hs);
            return Eo === nr;
          };
          e.on("keydown", (zt) => {
            const Eo = zt.keyCode;
            if (!X(zt) && (Eo === r || Eo === o) && e.selection.isEditable()) {
              const hs = e.selection.isCollapsed(), nr = e.getBody();
              if (hs && !sa(le.fromDom(nr)) || !hs && !Un(e.selection.getRng()))
                return;
              zt.preventDefault(), e.setContent(""), nr.firstChild && c.isBlock(nr.firstChild) ? e.selection.setCursorLocation(nr.firstChild, 0) : e.selection.setCursorLocation(nr, 0), e.nodeChanged();
            }
          });
        }, G = () => {
          e.shortcuts.add("meta+a", null, "SelectAll");
        }, ne = () => {
          e.inline || c.bind(e.getDoc(), "mousedown mouseup", (zn) => {
            let Un;
            if (zn.target === e.getDoc().documentElement)
              if (Un = u.getRng(), e.getBody().focus(), zn.type === "mousedown") {
                if (Jn(Un.startContainer))
                  return;
                u.placeCaretAt(zn.clientX, zn.clientY);
              } else
                u.setRng(Un);
          });
        }, Se = () => {
          e.on("keydown", (zn) => {
            if (!X(zn) && zn.keyCode === o) {
              if (!e.getBody().getElementsByTagName("hr").length)
                return;
              if (u.isCollapsed() && u.getRng().startOffset === 0) {
                const Un = u.getNode(), zt = Un.previousSibling;
                if (Un.nodeName === "HR") {
                  c.remove(Un), zn.preventDefault();
                  return;
                }
                zt && zt.nodeName && zt.nodeName.toLowerCase() === "hr" && (c.remove(zt), zn.preventDefault());
              }
            }
          });
        }, ke = () => {
          Range.prototype.getClientRects || e.on("mousedown", (zn) => {
            if (!X(zn) && zn.target.nodeName === "HTML") {
              const Un = e.getBody();
              Un.blur(), Uu.setEditorTimeout(e, () => {
                Un.focus();
              });
            }
          });
        }, Ae = () => {
          const zn = yS(e);
          e.on("click", (Un) => {
            const zt = Un.target;
            /^(IMG|HR)$/.test(zt.nodeName) && c.isEditable(zt) && (Un.preventDefault(), e.selection.select(zt), e.nodeChanged()), zt.nodeName === "A" && c.hasClass(zt, zn) && zt.childNodes.length === 0 && c.isEditable(zt.parentNode) && (Un.preventDefault(), u.select(zt));
          });
        }, Me = () => {
          const zn = () => {
            const zt = c.getAttribs(u.getStart().cloneNode(!1));
            return () => {
              const Eo = u.getStart();
              Eo !== e.getBody() && (c.setAttrib(Eo, "style", null), n(zt, (hs) => {
                Eo.setAttributeNode(hs.cloneNode(!0));
              }));
            };
          }, Un = () => !u.isCollapsed() && c.getParent(u.getStart(), c.isBlock) !== c.getParent(u.getEnd(), c.isBlock);
          e.on("keypress", (zt) => {
            let Eo;
            return !X(zt) && (zt.keyCode === 8 || zt.keyCode === 46) && Un() ? (Eo = zn(), e.getDoc().execCommand("delete", !1), Eo(), zt.preventDefault(), !1) : !0;
          }), c.bind(e.getDoc(), "cut", (zt) => {
            if (!X(zt) && Un()) {
              const Eo = zn();
              Uu.setEditorTimeout(e, () => {
                Eo();
              });
            }
          });
        }, pt = () => {
          e.on("keydown", (zn) => {
            if (!X(zn) && zn.keyCode === o && u.isCollapsed() && u.getRng().startOffset === 0) {
              const Un = u.getNode().previousSibling;
              if (Un && Un.nodeName && Un.nodeName.toLowerCase() === "table")
                return zn.preventDefault(), !1;
            }
            return !0;
          });
        }, It = () => {
          e.on("keydown", (zn) => {
            if (X(zn) || zn.keyCode !== Tn.BACKSPACE)
              return;
            let Un = u.getRng();
            const zt = Un.startContainer, Eo = Un.startOffset, hs = c.getRoot();
            let nr = zt;
            if (!(!Un.collapsed || Eo !== 0)) {
              for (; nr.parentNode && nr.parentNode.firstChild === nr && nr.parentNode !== hs; )
                nr = nr.parentNode;
              nr.nodeName === "BLOCKQUOTE" && (e.formatter.toggle("blockquote", void 0, nr), Un = c.createRng(), Un.setStart(zt, 0), Un.setEnd(zt, 0), u.setRng(Un));
            }
          });
        }, un = () => {
          const zn = () => {
            I("StyleWithCSS", !1), I("enableInlineTableEditing", !1), Wh(e) || I("enableObjectResizing", !1);
          };
          F1(e) || e.on("BeforeExecCommand mousedown", zn);
        }, nt = () => {
          const zn = () => {
            n(c.select("a:not([data-mce-block])"), (Un) => {
              var zt;
              let Eo = Un.parentNode;
              const hs = c.getRoot();
              if (Eo?.lastChild === Un) {
                for (; Eo && !c.isBlock(Eo); ) {
                  if (((zt = Eo.parentNode) === null || zt === void 0 ? void 0 : zt.lastChild) !== Eo || Eo === hs)
                    return;
                  Eo = Eo.parentNode;
                }
                c.add(Eo, "br", { "data-mce-bogus": 1 });
              }
            });
          };
          e.on("SetContent ExecCommand", (Un) => {
            (Un.type === "setcontent" || Un.command === "mceInsertLink") && zn();
          });
        }, qe = () => {
          e.on("init", () => {
            I("DefaultParagraphSeparator", gi(e));
          });
        }, xt = (zn) => {
          const Un = zn.getBody(), zt = zn.selection.getRng();
          return zt.startContainer === zt.endContainer && zt.startContainer === Un && zt.startOffset === 0 && zt.endOffset === Un.childNodes.length;
        }, bn = () => {
          e.on("keyup focusin mouseup", (zn) => {
            !Tn.modifierPressed(zn) && !xt(e) && u.normalize();
          }, !0);
        }, Yn = () => {
          e.contentStyles.push("img:-moz-broken {-moz-force-broken-image-icon:1;min-width:24px;min-height:24px}");
        }, Po = () => {
          e.inline || e.on("keydown", () => {
            document.activeElement === document.body && e.getWin().focus();
          });
        }, Ko = () => {
          e.inline || (e.contentStyles.push("body {min-height: 150px}"), e.on("click", (zn) => {
            let Un;
            zn.target.nodeName === "HTML" && (Un = e.selection.getRng(), e.getBody().focus(), e.selection.setRng(Un), e.selection.normalize(), e.nodeChanged());
          }));
        }, er = () => {
          M && e.on("keydown", (zn) => {
            Tn.metaKeyPressed(zn) && !zn.shiftKey && (zn.keyCode === 37 || zn.keyCode === 39) && (zn.preventDefault(), e.selection.getSel().modify("move", zn.keyCode === 37 ? "backward" : "forward", "lineboundary"));
          });
        }, Er = () => {
          e.on("click", (zn) => {
            let Un = zn.target;
            do
              if (Un.tagName === "A") {
                zn.preventDefault();
                return;
              }
            while (Un = Un.parentNode);
          }), e.contentStyles.push(".mce-content-body {-webkit-touch-callout: none}");
        }, wa = () => {
          e.on("init", () => {
            e.dom.bind(e.getBody(), "submit", (zn) => {
              zn.preventDefault();
            });
          });
        }, si = () => {
          f.addNodeFilter("br", (zn) => {
            let Un = zn.length;
            for (; Un--; )
              zn[Un].attr("class") === "Apple-interchange-newline" && zn[Un].remove();
          });
        }, kc = Oe, Gt = () => {
          if (!y || e.removed)
            return !1;
          const zn = e.selection.getSel();
          return !zn || !zn.rangeCount || zn.rangeCount === 0;
        }, vn = () => {
          E && (ne(), Ae(), wa(), G(), N && (Po(), Ko(), Er())), y && (ke(), un(), Yn(), er());
        }, As = () => {
          e.on("drop", (zn) => {
            var Un;
            const zt = (Un = zn.dataTransfer) === null || Un === void 0 ? void 0 : Un.getData("text/html");
            J(zt) && /^<img[^>]*>$/.test(zt) && e.dispatch("dragend", new window.DragEvent("dragend", zn));
          });
        }, vs = () => {
          It(), te(), sn.windowsPhone || bn(), E && (ne(), Ae(), qe(), wa(), pt(), si(), N ? (Po(), Ko(), Er()) : G()), y && (Se(), ke(), Me(), un(), nt(), Yn(), er(), pt(), As());
        };
        return Yg(e) ? vn() : vs(), {
          refreshContentEditable: kc,
          isHidden: Gt
        };
      }, qE = xr.DOM, yW = (e, n) => {
        const o = le.fromDom(e.getBody()), r = lh(kl(o)), c = le.fromTag("style");
        ks(c, "type", "text/css"), la(c, le.fromText(n)), la(r, c), e.on("remove", () => {
          bs(c);
        });
      }, h4 = (e) => e.inline ? e.getElement().nodeName.toLowerCase() : void 0, p4 = (e) => xs(e, (n) => Ht(n) === !1), jF = (e) => {
        const n = e.options.get, o = e.editorUpload.blobCache;
        return p4({
          allow_conditional_comments: n("allow_conditional_comments"),
          allow_html_data_urls: n("allow_html_data_urls"),
          allow_svg_data_urls: n("allow_svg_data_urls"),
          allow_html_in_named_anchor: n("allow_html_in_named_anchor"),
          allow_script_urls: n("allow_script_urls"),
          allow_unsafe_link_target: n("allow_unsafe_link_target"),
          convert_unsafe_embeds: n("convert_unsafe_embeds"),
          convert_fonts_to_spans: n("convert_fonts_to_spans"),
          fix_list_elements: n("fix_list_elements"),
          font_size_legacy_values: n("font_size_legacy_values"),
          forced_root_block: n("forced_root_block"),
          forced_root_block_attrs: n("forced_root_block_attrs"),
          preserve_cdata: n("preserve_cdata"),
          inline_styles: n("inline_styles"),
          root_name: h4(e),
          sandbox_iframes: n("sandbox_iframes"),
          sanitize: n("xss_sanitization"),
          validate: !0,
          blob_cache: o,
          document: e.getDoc()
        });
      }, qF = (e) => {
        const n = e.options.get;
        return p4({
          custom_elements: n("custom_elements"),
          extended_valid_elements: n("extended_valid_elements"),
          invalid_elements: n("invalid_elements"),
          invalid_styles: n("invalid_styles"),
          schema: n("schema"),
          valid_children: n("valid_children"),
          valid_classes: n("valid_classes"),
          valid_elements: n("valid_elements"),
          valid_styles: n("valid_styles"),
          verify_html: n("verify_html"),
          padd_empty_block_inline_children: n("format_empty_lines")
        });
      }, CW = (e) => {
        const n = e.options.get;
        return {
          ...jF(e),
          ...qF(e),
          ...p4({
            remove_trailing_brs: n("remove_trailing_brs"),
            pad_empty_with_br: n("pad_empty_with_br"),
            url_converter: n("url_converter"),
            url_converter_scope: n("url_converter_scope"),
            element_format: n("element_format"),
            entities: n("entities"),
            entity_encoding: n("entity_encoding"),
            indent: n("indent"),
            indent_after: n("indent_after"),
            indent_before: n("indent_before")
          })
        };
      }, wW = (e) => {
        const n = Qd(jF(e), e.schema);
        return n.addAttributeFilter("src,href,style,tabindex", (o, r) => {
          const c = e.dom, u = "data-mce-" + r;
          let f = o.length;
          for (; f--; ) {
            const b = o[f];
            let y = b.attr(r);
            if (y && !b.attr(u)) {
              if (y.indexOf("data:") === 0 || y.indexOf("blob:") === 0)
                continue;
              r === "style" ? (y = c.serializeStyle(c.parseStyle(y), b.name), y.length || (y = null), b.attr(u, y), b.attr(r, y)) : r === "tabindex" ? (b.attr(u, y), b.attr(r, null)) : b.attr(u, e.convertURL(y, r, b.name));
            }
          }
        }), n.addNodeFilter("script", (o) => {
          let r = o.length;
          for (; r--; ) {
            const c = o[r], u = c.attr("type") || "no/type";
            u.indexOf("mce-") !== 0 && c.attr("type", "mce-" + u);
          }
        }), yC(e) && n.addNodeFilter("#cdata", (o) => {
          var r;
          let c = o.length;
          for (; c--; ) {
            const u = o[c];
            u.type = 8, u.name = "#comment", u.value = "[CDATA[" + e.dom.encode((r = u.value) !== null && r !== void 0 ? r : "") + "]]";
          }
        }), n.addNodeFilter("p,h1,h2,h3,h4,h5,h6,div", (o) => {
          let r = o.length;
          const c = e.schema.getNonEmptyElements();
          for (; r--; ) {
            const u = o[r];
            u.isEmpty(c) && u.getAll("br").length === 0 && u.append(new Ki("br", 1));
          }
        }), n;
      }, SW = (e) => {
        const n = CS(e);
        n && Uu.setEditorTimeout(e, () => {
          let o;
          n === !0 ? o = e : o = e.editorManager.get(n), o && !o.destroyed && (o.focus(), o.selection.scrollIntoView());
        }, 100);
      }, GE = (e) => {
        const n = e.dom.getRoot();
        !e.inline && (!Y0(e) || e.selection.getStart(!0) === n) && Ri(n).each((o) => {
          const r = o.getNode(), c = Du(r) ? Ri(r).getOr(o) : o;
          e.selection.setRng(c.toRange());
        });
      }, xW = (e) => {
        e.bindPendingEventDelegates(), e.initialized = !0, cb(e), e.focus(!0), GE(e), e.nodeChanged({ initial: !0 });
        const n = i_(e);
        re(n) && n.call(e, e), SW(e);
      }, b4 = (e) => e.inline ? e.ui.styleSheetLoader : e.dom.styleSheetLoader, TW = (e, n, o) => {
        const {
          pass: r,
          fail: c
        } = Vn(n, (b) => tinymce.Resource.has(iO(b))), f = [
          ...r.map((b) => {
            const y = tinymce.Resource.get(iO(b));
            return J(y) ? Promise.resolve(b4(e).loadRawCss(b, y)) : Promise.resolve();
          }),
          b4(e).loadAll(c)
        ];
        return e.inline ? f : f.concat([e.ui.styleSheetLoader.loadAll(o)]);
      }, GF = (e) => {
        const n = b4(e), o = mS(e), r = e.contentCSS, c = () => {
          n.unloadAll(r), e.inline || e.ui.styleSheetLoader.unloadAll(o);
        }, u = () => {
          e.removed ? c() : e.on("remove", c);
        };
        if (e.contentStyles.length > 0) {
          let y = "";
          _t.each(e.contentStyles, (E) => {
            y += E + `\r
`;
          }), e.dom.addStyle(y);
        }
        const f = Promise.all(TW(e, r, o)).then(u).catch(u), b = N0(e);
        return b && yW(e, b), f;
      }, EW = (e) => {
        const n = e.getDoc(), o = e.getBody();
        $f(e), u_(e) || (n.body.spellcheck = !1, qE.setAttrib(o, "spellcheck", "false")), e.quirks = vW(e), V_(e);
        const r = Qk(e);
        r !== void 0 && (o.dir = r);
        const c = wS(e);
        c && e.on("BeforeSetContent", (u) => {
          _t.each(c, (f) => {
            u.content = u.content.replace(f, (b) => "<!--mce:protected " + escape(b) + "-->");
          });
        }), e.on("SetContent", () => {
          e.addVisual(e.getBody());
        }), e.on("compositionstart compositionend", (u) => {
          e.composing = u.type === "compositionstart";
        });
      }, kW = (e) => {
        Yg(e) || e.load({
          initial: !0,
          format: "html"
        }), e.startContent = e.getContent({ format: "raw" });
      }, v4 = (e) => {
        e.removed !== !0 && (kW(e), xW(e));
      }, _W = (e) => {
        let n = !1;
        const o = setTimeout(() => {
          n || e.setProgressState(!0);
        }, 500);
        return () => {
          clearTimeout(o), n = !0, e.setProgressState(!1);
        };
      }, KF = (e) => {
        const n = e.getElement();
        let o = e.getDoc();
        e.inline && (qE.addClass(n, "mce-content-body"), e.contentDocument = o = document, e.contentWindow = window, e.bodyElement = n, e.contentAreaContainer = n);
        const r = e.getBody();
        r.disabled = !0, e.readonly = F1(e), e._editableRoot = iu(e), !e.readonly && e.hasEditableRoot() && (e.inline && qE.getStyle(r, "position", !0) === "static" && (r.style.position = "relative"), r.contentEditable = "true"), r.disabled = !1, e.editorUpload = Y7(e), e.schema = Tm(qF(e)), e.dom = xr(o, {
          keep_values: !0,
          url_converter: e.convertURL,
          url_converter_scope: e,
          update_styles: !0,
          root_element: e.inline ? e.getBody() : null,
          collect: e.inline,
          schema: e.schema,
          contentCssCors: Om(e),
          referrerPolicy: Go(e),
          onSetAttrib: (f) => {
            e.dispatch("SetAttrib", f);
          },
          force_hex_color: Yh(e)
        }), e.parser = wW(e), e.serializer = SP(CW(e), e), e.selection = Rp(e.dom, e.getWin(), e.serializer, e), e.annotator = WC(e), e.formatter = mO(e), e.undoManager = fO(e), e._nodeChangeDispatcher = new E5(e), e._selectionOverrides = sW(e), p9(e), OU(e), Uj(e), Yg(e) || (iF(e), bW(e));
        const c = $V(e);
        Nb(e, c), C9(e), tm(e), kU(e);
        const u = Z8(e);
        EW(e), u.fold(() => {
          const f = _W(e);
          GF(e).then(() => {
            v4(e), f();
          });
        }, (f) => {
          e.setProgressState(!0), GF(e).then(() => {
            f().then((b) => {
              e.setProgressState(!1), v4(e), nO(e);
            }, (b) => {
              e.notificationManager.open({
                type: "error",
                text: String(b)
              }), v4(e), nO(e);
            });
          });
        });
      }, YF = ot, AW = (e, n, o) => Rd(e, n, YF, o), KE = xr.DOM, OW = (e, n, o, r) => {
        const c = le.fromTag("iframe");
        return r.each((u) => ks(c, "tabindex", u)), Br(c, o), Br(c, {
          id: e + "_ifr",
          frameBorder: "0",
          allowTransparency: "true",
          title: n
        }), Cu(c, "tox-edit-area__iframe"), c;
      }, DW = (e) => {
        let n = iS(e) + "<html><head>";
        nC(e) !== e.documentBaseUrl && (n += '<base href="' + e.documentBaseURI.getURI() + '" />'), n += '<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />';
        const o = oC(e), r = Zk(e), c = e.translate(c_(e));
        return sC(e) && (n += '<meta http-equiv="Content-Security-Policy" content="' + sC(e) + '" />'), n += `</head><body id="${o}" class="mce-content-body ${r}" data-id="${e.id}" aria-label="${c}"><br></body></html>`, n;
      }, XF = (e, n) => {
        const o = e.translate("Rich Text Area"), r = wc(le.fromDom(e.getElement()), "tabindex").bind(xa), c = OW(e.id, o, tC(e), r).dom;
        c.onload = () => {
          c.onload = null, e.dispatch("load");
        }, e.contentAreaContainer = n.iframeContainer, e.iframeElement = c, e.iframeHTML = DW(e), KE.add(n.iframeContainer, c);
      }, Sw = (e) => {
        const n = e.iframeElement, o = () => {
          e.contentDocument = n.contentDocument, KF(e);
        };
        if (b_(e) || sn.browser.isFirefox()) {
          const r = e.getDoc();
          r.open(), r.write(e.iframeHTML), r.close(), o();
        } else {
          const r = AW(le.fromDom(n), "load", () => {
            r.unbind(), o();
          });
          n.srcdoc = e.iframeHTML;
        }
      }, RW = (e, n) => {
        XF(e, n), n.editorContainer && (n.editorContainer.style.display = e.orgDisplay, e.hidden = KE.isHidden(n.editorContainer)), e.getElement().style.display = "none", KE.setAttrib(e.id, "aria-hidden", "true"), e.getElement().style.visibility = e.orgVisibility, Sw(e);
      }, y4 = xr.DOM, NW = (e, n, o) => {
        const r = _b.get(o), c = _b.urls[o] || e.documentBaseUrl.replace(/\/$/, "");
        if (o = _t.trim(o), r && _t.inArray(n, o) === -1) {
          if (e.plugins[o])
            return;
          try {
            const u = r(e, c) || {};
            e.plugins[o] = u, re(u.init) && (u.init(e, c), n.push(o));
          } catch (u) {
            PP(e, o, u);
          }
        }
      }, MW = (e) => e.replace(/^\-/, ""), PW = (e) => {
        const n = [];
        ae(I1(e), (o) => {
          NW(e, n, MW(o));
        });
      }, BW = (e) => {
        const n = _t.trim(aC(e)), o = e.ui.registry.getAll().icons, r = {
          ...L2.get("default").icons,
          ...L2.get(n).icons
        };
        Dt(r, (c, u) => {
          Zn(o, u) || e.ui.registry.addIcon(u, c);
        });
      }, JF = (e) => {
        const n = Zh(e);
        if (J(n)) {
          const o = Xg.get(n);
          e.theme = o(e, Xg.urls[n]) || {}, re(e.theme.init) && e.theme.init(e, Xg.urls[n] || e.documentBaseUrl.replace(/\/$/, ""));
        } else
          e.theme = {};
      }, $W = (e) => {
        const n = dC(e), o = Td.get(n);
        e.model = o(e, Td.urls[n]);
      }, QF = (e) => {
        const n = e.theme.renderUI;
        return n ? n() : tI(e);
      }, FW = (e) => {
        const n = e.getElement(), r = Zh(e)(e, n);
        return r.editorContainer.nodeType && (r.editorContainer.id = r.editorContainer.id || e.id + "_parent"), r.iframeContainer && r.iframeContainer.nodeType && (r.iframeContainer.id = r.iframeContainer.id || e.id + "_iframecontainer"), r.height = r.iframeHeight ? r.iframeHeight : n.offsetHeight, r;
      }, eI = (e, n) => ({
        editorContainer: e,
        iframeContainer: n,
        api: {}
      }), IW = (e) => {
        const n = y4.create("div");
        return y4.insertAfter(n, e), eI(n, n);
      }, tI = (e) => {
        const n = e.getElement();
        return e.inline ? eI(null) : IW(n);
      }, LW = (e) => {
        const n = e.getElement();
        return e.orgDisplay = n.style.display, J(Zh(e)) ? QF(e) : re(Zh(e)) ? FW(e) : tI(e);
      }, HW = (e, n) => {
        const o = {
          show: F.from(n.show).getOr(Oe),
          hide: F.from(n.hide).getOr(Oe),
          isEnabled: F.from(n.isEnabled).getOr(ot),
          setEnabled: (r) => {
            e.mode.isReadOnly() || F.from(n.setEnabled).each((c) => c(r));
          }
        };
        e.ui = {
          ...e.ui,
          ...o
        };
      }, zW = async (e) => {
        e.dispatch("ScriptsLoaded"), BW(e), JF(e), $W(e), PW(e);
        const n = await LW(e);
        HW(e, F.from(n.api).getOr({})), e.editorContainer = n.editorContainer, H7(e), e.inline ? KF(e) : RW(e, {
          editorContainer: n.editorContainer,
          iframeContainer: n.iframeContainer
        });
      }, Fb = xr.DOM, nI = (e) => e.charAt(0) === "-", oI = (e, n) => {
        const o = iC(n), r = hi(n);
        if (!Fu.hasCode(o) && o !== "en") {
          const c = lo(r) ? r : `${n.editorManager.baseURL}/langs/${o}.js`;
          e.add(c).catch(() => {
            z2(n, c, o);
          });
        }
      }, C4 = (e, n) => {
        const o = Zh(e);
        if (J(o) && !nI(o) && !Zn(Xg.urls, o)) {
          const r = n_(e), c = r ? e.documentBaseURI.toAbsolute(r) : `themes/${o}/theme${n}.js`;
          Xg.load(o, c).catch(() => {
            $7(e, c, o);
          });
        }
      }, sI = (e, n) => {
        const o = dC(e);
        if (o !== "plugin" && !Zn(Td.urls, o)) {
          const r = gS(e), c = J(r) ? e.documentBaseURI.toAbsolute(r) : `models/${o}/model${n}.js`;
          Td.load(o, c).catch(() => {
            MP(e, c, o);
          });
        }
      }, rI = (e) => F.from(Dg(e)).filter(lo).map((n) => ({
        url: n,
        name: F.none()
      })), aI = (e, n, o) => F.from(n).filter((r) => lo(r) && !L2.has(r)).map((r) => ({
        url: `${e.editorManager.baseURL}/icons/${r}/icons${o}.js`,
        name: F.some(r)
      })), VW = (e, n, o) => {
        const r = aI(n, "default", o), c = rI(n).orThunk(() => aI(n, aC(n), ""));
        ae(Xs([
          r,
          c
        ]), (u) => {
          e.add(u.url).catch(() => {
            B7(n, u.url, u.name.getOrUndefined());
          });
        });
      }, UW = (e, n) => {
        const o = (r, c) => {
          _b.load(r, c).catch(() => {
            Hj(e, c, r);
          });
        };
        Dt(kf(e), (r, c) => {
          o(c, r), e.options.set("plugins", I1(e).concat(c));
        }), ae(I1(e), (r) => {
          r = _t.trim(r), r && !_b.urls[r] && !nI(r) && o(r, `plugins/${r}/plugin${n}.js`);
        });
      }, cI = (e) => {
        const n = Zh(e);
        return !J(n) || De(Xg.get(n));
      }, iI = (e) => {
        const n = dC(e);
        return De(Td.get(n));
      }, WW = (e, n) => {
        const o = Ha.ScriptLoader, r = () => {
          !e.removed && cI(e) && iI(e) && zW(e);
        };
        C4(e, n), sI(e, n), oI(o, e), VW(o, e, n), UW(e, n), o.loadQueue().then(r, r);
      }, ZW = (e, n) => Ey.forElement(e, {
        contentCssCors: qh(n),
        referrerPolicy: Go(n)
      }), w4 = (e) => {
        const n = e.id;
        Fu.setCode(iC(e));
        const o = () => {
          Fb.unbind(window, "ready", o), e.render();
        };
        if (!ul.Event.domLoaded) {
          Fb.bind(window, "ready", o);
          return;
        }
        if (!e.getElement())
          return;
        const r = le.fromDom(e.getElement()), c = Nc(r);
        e.on("remove", () => {
          kt(r.dom.attributes, (f) => _r(r, f.name)), Br(r, c);
        }), e.ui.styleSheetLoader = ZW(r, e), mC(e) ? e.inline = !0 : (e.orgVisibility = e.getElement().style.visibility, e.getElement().style.visibility = "hidden");
        const u = e.getElement().form || Fb.getParent(n, "form");
        u && (e.formElement = u, s_(e) && !hh(e.getElement()) && (Fb.insertAfter(Fb.create("input", {
          type: "hidden",
          name: n
        }), n), e.hasHiddenInput = !0), e.formEventDelegate = (f) => {
          e.dispatch(f.type, f);
        }, Fb.bind(u, "submit reset", e.formEventDelegate), e.on("reset", () => {
          e.resetContent();
        }), vS(e) && !u.submit.nodeType && !u.submit.length && !u._mceOldSubmit && (u._mceOldSubmit = u.submit, u.submit = () => (e.editorManager.triggerSave(), e.setDirty(!1), u._mceOldSubmit(u)))), e.windowManager = NP(e), e.notificationManager = cO(e), C_(e) && e.on("GetContent", (f) => {
          f.save && (f.content = Fb.encode(f.content));
        }), Wd(e) && e.on("submit", () => {
          e.initialized && e.save();
        }), B1(e) && (e._beforeUnload = () => {
          e.initialized && !e.destroyed && !e.isHidden() && e.save({
            format: "raw",
            no_events: !0,
            set_dirty: !1
          });
        }, e.editorManager.on("BeforeUnload", e._beforeUnload)), e.editorManager.add(e), WW(e, e.suffix);
      }, YE = (e, n) => {
        e._editableRoot !== n && (e._editableRoot = n, e.readonly || (e.getBody().contentEditable = String(e.hasEditableRoot()), e.nodeChanged()), q_(e, n));
      }, XE = (e) => e._editableRoot, th = (e, n) => ({
        sections: it(e),
        options: it(n)
      }), xw = Is().deviceType, Ib = xw.isPhone(), lI = xw.isTablet(), Tw = (e) => {
        if (gn(e))
          return [];
        {
          const n = ht(e) ? e : e.split(/[ ,]/), o = ye(n, Ra);
          return Yt(o, lo);
        }
      }, jW = (e, n) => {
        const o = Jr(n, (r, c) => ee(e, c));
        return th(o.t, o.f);
      }, uI = (e, n, o = {}) => {
        const r = e.sections(), c = Ts(r, n).getOr({});
        return _t.extend({}, o, c);
      }, S4 = (e, n) => Zn(e.sections(), n), x4 = (e, n) => S4(e, n) ? e.sections()[n] : {}, JE = (e, n) => ({
        ...{
          table_grid: !1,
          object_resizing: !1,
          resize: !1,
          toolbar_mode: Ts(e, "toolbar_mode").getOr("scrolling"),
          toolbar_sticky: !1
        },
        ...n ? { menubar: !1 } : {}
      }), Zp = (e, n) => {
        var o;
        const r = (o = n.external_plugins) !== null && o !== void 0 ? o : {};
        return e && e.external_plugins ? _t.extend({}, e.external_plugins, r) : r;
      }, Lb = (e, n) => [
        ...Tw(e),
        ...Tw(n)
      ], dI = (e, n, o, r) => e && S4(n, "mobile") ? r : o, qW = (e, n, o, r) => {
        const c = Tw(o.forced_plugins), u = Tw(r.plugins), f = x4(n, "mobile"), b = f.plugins ? Tw(f.plugins) : u, y = dI(e, n, u, b), E = Lb(c, y);
        return _t.extend(r, {
          forced_plugins: c,
          plugins: E
        });
      }, GW = (e, n) => e && S4(n, "mobile"), KW = (e, n, o, r, c) => {
        var u;
        const f = e ? { mobile: JE((u = c.mobile) !== null && u !== void 0 ? u : {}, n) } : {}, b = jW(["mobile"], uw(f, c)), y = _t.extend(o, r, b.options(), GW(e, b) ? uI(b, "mobile") : {}, { external_plugins: Zp(r, b.options()) });
        return qW(e, b, r, y);
      }, YW = (e, n) => KW(Ib || lI, Ib, n, e, n), XW = (e, n) => o7(e, n), JW = (e) => {
        const n = (r, c) => {
          e.formatter.toggle(r, c), e.nodeChanged();
        }, o = (r) => () => {
          ae("left,center,right,justify".split(","), (c) => {
            r !== c && e.formatter.remove("align" + c);
          }), r !== "none" && n("align" + r);
        };
        e.editorCommands.addCommands({
          JustifyLeft: o("left"),
          JustifyCenter: o("center"),
          JustifyRight: o("right"),
          JustifyFull: o("justify"),
          JustifyNone: o("none")
        });
      }, mI = (e) => {
        const n = (o) => () => {
          const r = e.selection, c = r.isCollapsed() ? [e.dom.getParent(r.getNode(), e.dom.isBlock)] : r.getSelectedBlocks();
          return pe(c, (u) => De(e.formatter.matchNode(u, o)));
        };
        e.editorCommands.addCommands({
          JustifyLeft: n("alignleft"),
          JustifyCenter: n("aligncenter"),
          JustifyRight: n("alignright"),
          JustifyFull: n("alignjustify")
        }, "state");
      }, QW = (e) => {
        JW(e), mI(e);
      }, eZ = (e) => {
        e.editorCommands.addCommands({
          "Cut,Copy,Paste": (n) => {
            const o = e.getDoc();
            let r;
            try {
              o.execCommand(n);
            } catch {
              r = !0;
            }
            if (n === "paste" && !o.queryCommandEnabled(n) && (r = !0), r || !o.queryCommandSupported(n)) {
              let c = e.translate("Your browser doesn't support direct access to the clipboard. Please use the Ctrl+X/C/V keyboard shortcuts instead.");
              (sn.os.isMacOS() || sn.os.isiOS()) && (c = c.replace(/Ctrl\+/g, "⌘+")), e.notificationManager.open({
                text: c,
                type: "error"
              });
            }
          }
        });
      }, tZ = (e, n, o, r) => {
        const c = le.fromDom(e.getRoot());
        return gv(c, We.fromRangeStart(n), r) ? o = o.replace(/^ /, "&nbsp;") : o = o.replace(/^&nbsp;/, " "), hv(c, We.fromRangeEnd(n), r) ? o = o.replace(/(&nbsp;| )(<br( \/)>)?$/, "&nbsp;") : o = o.replace(/&nbsp;(<br( \/)?>)?$/, " "), o;
      }, uq = (e) => {
        if (typeof e != "string") {
          const n = _t.extend({
            paste: e.paste,
            data: { paste: e.paste }
          }, e);
          return {
            content: e.content,
            details: n
          };
        }
        return {
          content: e,
          details: {}
        };
      }, nZ = (e, n) => {
        const o = e.selection, r = e.dom;
        return /^ | $/.test(n) ? tZ(r, o.getRng(), n, e.schema) : n;
      }, ty = (e, n) => {
        if (e.selection.isEditable()) {
          const { content: o, details: r } = uq(n);
          B3(e, {
            ...r,
            content: nZ(e, o),
            format: "html",
            set: !1,
            selection: !0
          }).each((c) => {
            const u = t7(e, c.content, r);
            fT(e, u, c), e.addVisual();
          });
        }
      }, oZ = (e) => {
        e.editorCommands.addCommands({
          mceCleanup: () => {
            const n = e.selection.getBookmark();
            e.setContent(e.getContent()), e.selection.moveToBookmark(n);
          },
          insertImage: (n, o, r) => {
            ty(e, e.dom.createHTML("img", { src: r }));
          },
          insertHorizontalRule: () => {
            e.execCommand("mceInsertContent", !1, "<hr>");
          },
          insertText: (n, o, r) => {
            ty(e, e.dom.encode(r));
          },
          insertHTML: (n, o, r) => {
            ty(e, r);
          },
          mceInsertContent: (n, o, r) => {
            ty(e, r);
          },
          mceSetContent: (n, o, r) => {
            e.setContent(r);
          },
          mceReplaceContent: (n, o, r) => {
            e.execCommand("mceInsertContent", !1, r.replace(/\{\$selection\}/g, e.selection.getContent({ format: "text" })));
          },
          mceNewDocument: () => {
            e.setContent(Gh(e));
          }
        });
      }, sZ = {
        "font-size": "size",
        "font-family": "face"
      }, fI = pr("font"), rZ = (e, n, o) => {
        const r = (u) => ta(u, e).orThunk(() => fI(u) ? Ts(sZ, e).bind((f) => wc(u, f)) : F.none()), c = (u) => fs(le.fromDom(n), u);
        return s3(le.fromDom(o), (u) => r(u), c);
      }, gI = (e) => e.replace(/[\'\"\\]/g, "").replace(/,\s+/g, ","), aZ = (e, n) => F.from(xr.DOM.getStyle(n, e, !0)), QE = (e) => (n, o) => F.from(o).map(le.fromDom).filter(yn).bind((r) => rZ(e, n, r.dom).or(aZ(e, r.dom))).getOr(""), cZ = QE("font-size"), iZ = A(gI, QE("font-family")), lZ = (e) => Ri(e.getBody()).bind((n) => {
        const o = n.container();
        return F.from(Mt(o) ? o.parentNode : o);
      }), uZ = (e) => F.from(e.selection.getRng()).bind((n) => {
        const o = e.getBody();
        return n.startContainer === o && n.startOffset === 0 ? F.none() : F.from(e.selection.getStart(!0));
      }), hI = (e, n) => uZ(e).orThunk(Ye(lZ, e)).map(le.fromDom).filter(yn).bind(n), Ew = (e, n) => hI(e, mn(F.some, n)), T4 = (e, n) => {
        if (/^[0-9.]+$/.test(n)) {
          const o = parseInt(n, 10);
          if (o >= 1 && o <= 7) {
            const r = v_(e), c = y_(e);
            return c.length > 0 ? c[o - 1] || n : r[o - 1] || n;
          } else
            return n;
        } else
          return n;
      }, E4 = (e) => {
        const n = e.split(/\s*,\s*/);
        return ye(n, (o) => o.indexOf(" ") !== -1 && !(Kn(o, '"') || Kn(o, "'")) ? `'${o}'` : o).join(",");
      }, dZ = (e, n) => {
        const o = T4(e, n);
        e.formatter.toggle("fontname", { value: E4(o) }), e.nodeChanged();
      }, dq = (e) => Ew(e, (n) => iZ(e.getBody(), n.dom)).getOr(""), mq = (e, n) => {
        e.formatter.toggle("fontsize", { value: T4(e, n) }), e.nodeChanged();
      }, mZ = (e) => Ew(e, (n) => cZ(e.getBody(), n.dom)).getOr(""), pI = (e) => Ew(e, (n) => {
        const o = le.fromDom(e.getBody()), r = s3(n, (u) => ta(u, "line-height"), Ye(fs, o)), c = () => {
          const u = parseFloat(ha(n, "line-height")), f = parseFloat(ha(n, "font-size"));
          return String(u / f);
        };
        return r.getOrThunk(c);
      }).getOr(""), fZ = (e, n) => {
        e.formatter.toggle("lineheight", { value: String(n) }), e.nodeChanged();
      }, gZ = (e) => {
        const n = (o, r) => {
          e.formatter.toggle(o, r), e.nodeChanged();
        };
        e.editorCommands.addCommands({
          "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": (o) => {
            n(o);
          },
          "ForeColor,HiliteColor": (o, r, c) => {
            n(o, { value: c });
          },
          BackColor: (o, r, c) => {
            n("hilitecolor", { value: c });
          },
          FontName: (o, r, c) => {
            dZ(e, c);
          },
          FontSize: (o, r, c) => {
            mq(e, c);
          },
          LineHeight: (o, r, c) => {
            fZ(e, c);
          },
          Lang: (o, r, c) => {
            var u;
            n(o, {
              value: c.code,
              customValue: (u = c.customCode) !== null && u !== void 0 ? u : null
            });
          },
          RemoveFormat: (o) => {
            e.formatter.remove(o);
          },
          mceBlockQuote: () => {
            n("blockquote");
          },
          FormatBlock: (o, r, c) => {
            n(J(c) ? c : "p");
          },
          mceToggleFormat: (o, r, c) => {
            n(c);
          }
        });
      }, hZ = (e) => {
        const n = (o) => e.formatter.match(o);
        e.editorCommands.addCommands({
          "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": (o) => n(o),
          mceBlockQuote: () => n("blockquote")
        }, "state"), e.editorCommands.addQueryValueHandler("FontName", () => dq(e)), e.editorCommands.addQueryValueHandler("FontSize", () => mZ(e)), e.editorCommands.addQueryValueHandler("LineHeight", () => pI(e));
      }, fq = (e) => {
        gZ(e), hZ(e);
      }, gq = (e) => {
        e.editorCommands.addCommands({
          mceAddUndoLevel: () => {
            e.undoManager.add();
          },
          mceEndUndoLevel: () => {
            e.undoManager.add();
          },
          Undo: () => {
            e.undoManager.undo();
          },
          Redo: () => {
            e.undoManager.redo();
          }
        });
      }, bI = (e) => {
        e.editorCommands.addCommands({
          Indent: () => {
            h9(e);
          },
          Outdent: () => {
            YO(e);
          }
        }), e.editorCommands.addCommands({ Outdent: () => KT(e) }, "state");
      }, vI = (e) => {
        const n = (o, r, c) => {
          const u = J(c) ? { href: c } : c, f = e.dom.getParent(e.selection.getNode(), "a");
          Qe(u) && J(u.href) && (u.href = u.href.replace(/ /g, "%20"), (!f || !u.href) && e.formatter.remove("link"), u.href && e.formatter.apply("link", u, f));
        };
        e.editorCommands.addCommands({
          unlink: () => {
            if (e.selection.isEditable()) {
              if (e.selection.isCollapsed()) {
                const o = e.dom.getParent(e.selection.getStart(), "a");
                o && e.dom.remove(o, !0);
                return;
              }
              e.formatter.remove("link");
            }
          },
          mceInsertLink: n,
          createLink: n
        });
      }, pZ = (e) => {
        e.editorCommands.addCommands({
          "InsertUnorderedList,InsertOrderedList": (n) => {
            e.getDoc().execCommand(n);
            const o = e.dom.getParent(e.selection.getNode(), "ol,ul");
            if (o) {
              const r = o.parentNode;
              if (r && /^(H[1-6]|P|ADDRESS|PRE)$/.test(r.nodeName)) {
                const c = e.selection.getBookmark();
                e.dom.split(r, o), e.selection.moveToBookmark(c);
              }
            }
          }
        });
      }, bZ = (e) => {
        e.editorCommands.addCommands({
          "InsertUnorderedList,InsertOrderedList": (n) => {
            const o = e.dom.getParent(e.selection.getNode(), "ul,ol");
            return o && (n === "insertunorderedlist" && o.tagName === "UL" || n === "insertorderedlist" && o.tagName === "OL");
          }
        }, "state");
      }, vZ = (e) => {
        pZ(e), bZ(e);
      }, hq = (e, n, o, r) => {
        const c = e.dom, u = (b) => c.isBlock(b) && b.parentElement === o, f = u(n) ? n : c.getParent(r, u, o);
        return F.from(f).map(le.fromDom);
      }, yZ = (e, n) => {
        const o = e.dom, r = e.selection.getRng(), c = n ? e.selection.getStart() : e.selection.getEnd(), u = n ? r.startContainer : r.endContainer, f = Gu(o, u);
        if (!f || !f.isContentEditable)
          return;
        const b = n ? ka : Ti, y = gi(e);
        hq(e, c, f, u).each((E) => {
          const N = RD(e, u, E.dom, f, !1, y);
          b(E, le.fromDom(N)), e.selection.setCursorLocation(N, 0), e.dispatch("NewBlock", { newBlock: N }), mw(e, "insertParagraph");
        });
      }, pq = (e) => yZ(e, !0), CZ = (e) => yZ(e, !1), bq = (e) => {
        e.editorCommands.addCommands({
          InsertNewBlockBefore: () => {
            pq(e);
          },
          InsertNewBlockAfter: () => {
            CZ(e);
          }
        });
      }, wZ = (e) => {
        e.editorCommands.addCommands({
          insertParagraph: () => {
            CE(c5, e);
          },
          mceInsertNewLine: (n, o, r) => {
            m5(e, r);
          },
          InsertLineBreak: (n, o, r) => {
            CE(CV, e);
          }
        });
      }, Hb = (e) => {
        e.editorCommands.addCommands({
          mceSelectNodeDepth: (n, o, r) => {
            let c = 0;
            e.dom.getParent(e.selection.getNode(), (u) => xn(u) && c++ === r ? (e.selection.select(u), !1) : !0, e.getBody());
          },
          mceSelectNode: (n, o, r) => {
            e.selection.select(r);
          },
          selectAll: () => {
            const n = e.dom.getParent(e.selection.getStart(), Kc);
            if (n) {
              const o = e.dom.createRng();
              o.selectNodeContents(n), e.selection.setRng(o);
            }
          }
        });
      }, k4 = (e) => {
        e.editorCommands.addCommands({
          mceRemoveNode: (n, o, r) => {
            const c = r ?? e.selection.getNode();
            if (c !== e.getBody()) {
              const u = e.selection.getBookmark();
              e.dom.remove(c, !0), e.selection.moveToBookmark(u);
            }
          },
          mcePrint: () => {
            e.getWin().print();
          },
          mceFocus: (n, o, r) => {
            mL(e, r === !0);
          },
          mceToggleVisualAid: () => {
            e.hasVisual = !e.hasVisual, e.addVisual();
          }
        });
      }, ek = (e) => {
        QW(e), eZ(e), gq(e), Hb(e), oZ(e), vI(e), bI(e), bq(e), wZ(e), vZ(e), fq(e), k4(e);
      }, yI = ["toggleview"], _4 = (e) => ee(yI, e.toLowerCase());
      class A4 {
        constructor(n) {
          this.commands = {
            state: {},
            exec: {},
            value: {}
          }, this.editor = n;
        }
        execCommand(n, o = !1, r, c) {
          const u = this.editor, f = n.toLowerCase(), b = c?.skip_focus;
          if (u.removed || (f !== "mcefocus" && (!/^(mceAddUndoLevel|mceEndUndoLevel)$/i.test(f) && !b ? u.focus() : JI(u)), u.dispatch("BeforeExecCommand", {
            command: n,
            ui: o,
            value: r
          }).isDefaultPrevented()))
            return !1;
          const E = this.commands.exec[f];
          return re(E) ? (E(f, o, r), u.dispatch("ExecCommand", {
            command: n,
            ui: o,
            value: r
          }), !0) : !1;
        }
        queryCommandState(n) {
          if (!_4(n) && this.editor.quirks.isHidden() || this.editor.removed)
            return !1;
          const o = n.toLowerCase(), r = this.commands.state[o];
          return re(r) ? r(o) : !1;
        }
        queryCommandValue(n) {
          if (!_4(n) && this.editor.quirks.isHidden() || this.editor.removed)
            return "";
          const o = n.toLowerCase(), r = this.commands.value[o];
          return re(r) ? r(o) : "";
        }
        addCommands(n, o = "exec") {
          const r = this.commands;
          Dt(n, (c, u) => {
            ae(u.toLowerCase().split(","), (f) => {
              r[o][f] = c;
            });
          });
        }
        addCommand(n, o, r) {
          const c = n.toLowerCase();
          this.commands.exec[c] = (u, f, b) => o.call(r ?? this.editor, f, b);
        }
        queryCommandSupported(n) {
          const o = n.toLowerCase();
          return !!this.commands.exec[o];
        }
        addQueryStateHandler(n, o, r) {
          this.commands.state[n.toLowerCase()] = () => o.call(r ?? this.editor);
        }
        addQueryValueHandler(n, o, r) {
          this.commands.value[n.toLowerCase()] = () => o.call(r ?? this.editor);
        }
      }
      const zb = "data-mce-contenteditable", SZ = (e, n, o) => {
        wu(e, n) && !o ? Sl(e, n) : o && Cu(e, n);
      }, O4 = (e, n, o) => {
        try {
          e.getDoc().execCommand(n, !1, String(o));
        } catch {
        }
      }, tk = (e, n) => {
        e.dom.contentEditable = n ? "true" : "false";
      }, jp = (e) => {
        ae(uc(e, '*[contenteditable="true"]'), (n) => {
          ks(n, zb, "true"), tk(n, !1);
        });
      }, xZ = (e) => {
        ae(uc(e, `*[${zb}="true"]`), (n) => {
          _r(n, zb), tk(n, !0);
        });
      }, CI = (e) => {
        F.from(e.selection.getNode()).each((n) => {
          n.removeAttribute("data-mce-selected");
        });
      }, TZ = (e) => {
        e.selection.setRng(e.selection.getRng());
      }, nk = (e, n) => {
        const o = le.fromDom(e.getBody());
        SZ(o, "mce-content-readonly", n), n ? (e.selection.controlSelection.hideResizeRect(), e._selectionOverrides.hideFakeCaret(), CI(e), e.readonly = !0, tk(o, !1), jp(o)) : (e.readonly = !1, e.hasEditableRoot() && tk(o, !0), xZ(o), O4(e, "StyleWithCSS", !1), O4(e, "enableInlineTableEditing", !1), O4(e, "enableObjectResizing", !1), pR(e) && e.focus(), TZ(e), e.nodeChanged());
      }, Vb = (e) => e.readonly, wI = (e) => {
        e.parser.addAttributeFilter("contenteditable", (n) => {
          Vb(e) && ae(n, (o) => {
            o.attr(zb, o.attr("contenteditable")), o.attr("contenteditable", "false");
          });
        }), e.serializer.addAttributeFilter(zb, (n) => {
          Vb(e) && ae(n, (o) => {
            o.attr("contenteditable", o.attr(zb));
          });
        }), e.serializer.addTempAttr(zb);
      }, EZ = (e) => {
        e.serializer ? wI(e) : e.on("PreInit", () => {
          wI(e);
        });
      }, SI = (e) => e.type === "click", kZ = ["copy"], _Z = (e) => ee(kZ, e.type), AZ = (e, n) => Hi(n, "a", (r) => fs(r, le.fromDom(e.getBody()))).bind((r) => wc(r, "href")), D4 = (e, n) => {
        if (SI(n) && !Tn.metaKeyPressed(n)) {
          const o = le.fromDom(n.target);
          AZ(e, o).each((r) => {
            if (n.preventDefault(), /^#/.test(r)) {
              const c = e.dom.select(`${r},[name="${Dn(r, "#")}"]`);
              c.length && e.selection.scrollIntoView(c[0], !0);
            } else
              window.open(r, "_blank", "rel=noopener noreferrer,menubar=yes,toolbar=yes,location=yes,status=yes,resizable=yes,scrollbars=yes");
          });
        } else _Z(n) && e.dispatch(n.type, n);
      }, OZ = (e) => {
        e.on("ShowCaret", (n) => {
          Vb(e) && n.preventDefault();
        }), e.on("ObjectSelected", (n) => {
          Vb(e) && n.preventDefault();
        });
      }, DZ = _t.makeMap("focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange mouseout mouseenter mouseleave wheel keydown keypress keyup input beforeinput contextmenu dragstart dragend dragover draggesture dragdrop drop drag submit compositionstart compositionend compositionupdate touchstart touchmove touchend touchcancel", " ");
      class Va {
        static isNative(n) {
          return !!DZ[n.toLowerCase()];
        }
        constructor(n) {
          this.bindings = {}, this.settings = n || {}, this.scope = this.settings.scope || this, this.toggleEvent = this.settings.toggleEvent || $e;
        }
        fire(n, o) {
          return this.dispatch(n, o);
        }
        dispatch(n, o) {
          const r = n.toLowerCase(), c = Ah(r, o ?? {}, this.scope);
          this.settings.beforeFire && this.settings.beforeFire(c);
          const u = this.bindings[r];
          if (u)
            for (let f = 0, b = u.length; f < b; f++) {
              const y = u[f];
              if (!y.removed) {
                if (y.once && this.off(r, y.func), c.isImmediatePropagationStopped())
                  return c;
                if (y.func.call(this.scope, c) === !1)
                  return c.preventDefault(), c;
              }
            }
          return c;
        }
        on(n, o, r, c) {
          if (o === !1 && (o = $e), o) {
            const u = {
              func: o,
              removed: !1
            };
            c && _t.extend(u, c);
            const f = n.toLowerCase().split(" ");
            let b = f.length;
            for (; b--; ) {
              const y = f[b];
              let E = this.bindings[y];
              E || (E = [], this.toggleEvent(y, !0)), r ? E = [
                u,
                ...E
              ] : E = [
                ...E,
                u
              ], this.bindings[y] = E;
            }
          }
          return this;
        }
        off(n, o) {
          if (n) {
            const r = n.toLowerCase().split(" ");
            let c = r.length;
            for (; c--; ) {
              const u = r[c];
              let f = this.bindings[u];
              if (!u)
                return Dt(this.bindings, (b, y) => {
                  this.toggleEvent(y, !1), delete this.bindings[y];
                }), this;
              if (f) {
                if (!o)
                  f.length = 0;
                else {
                  const b = Vn(f, (y) => y.func === o);
                  f = b.fail, this.bindings[u] = f, ae(b.pass, (y) => {
                    y.removed = !0;
                  });
                }
                f.length || (this.toggleEvent(n, !1), delete this.bindings[u]);
              }
            }
          } else
            Dt(this.bindings, (r, c) => {
              this.toggleEvent(c, !1);
            }), this.bindings = {};
          return this;
        }
        once(n, o, r) {
          return this.on(n, o, r, { once: !0 });
        }
        has(n) {
          n = n.toLowerCase();
          const o = this.bindings[n];
          return !(!o || o.length === 0);
        }
      }
      const kw = (e) => (e._eventDispatcher || (e._eventDispatcher = new Va({
        scope: e,
        toggleEvent: (n, o) => {
          Va.isNative(n) && e.toggleNativeEvent && e.toggleNativeEvent(n, o);
        }
      })), e._eventDispatcher), R4 = {
        fire(e, n, o) {
          return this.dispatch(e, n, o);
        },
        dispatch(e, n, o) {
          const r = this;
          if (r.removed && e !== "remove" && e !== "detach")
            return Ah(e.toLowerCase(), n ?? {}, r);
          const c = kw(r).dispatch(e, n);
          if (o !== !1 && r.parent) {
            let u = r.parent();
            for (; u && !c.isPropagationStopped(); )
              u.dispatch(e, c, !1), u = u.parent ? u.parent() : void 0;
          }
          return c;
        },
        on(e, n, o) {
          return kw(this).on(e, n, o);
        },
        off(e, n) {
          return kw(this).off(e, n);
        },
        once(e, n) {
          return kw(this).once(e, n);
        },
        hasEventListeners(e) {
          return kw(this).has(e);
        }
      }, ny = xr.DOM;
      let qp;
      const oy = (e, n) => {
        if (n === "selectionchange")
          return e.getDoc();
        if (!e.inline && /^(?:mouse|touch|click|contextmenu|drop|dragover|dragend)/.test(n))
          return e.getDoc().documentElement;
        const o = Ef(e);
        return o ? (e.eventRoot || (e.eventRoot = ny.select(o)[0]), e.eventRoot) : e.getBody();
      }, RZ = (e) => !e.hidden && !Vb(e), xI = (e, n, o) => {
        RZ(e) ? e.dispatch(n, o) : Vb(e) && D4(e, o);
      }, TI = (e, n) => {
        if (e.delegates || (e.delegates = {}), e.delegates[n] || e.removed)
          return;
        const o = oy(e, n);
        if (Ef(e)) {
          if (qp || (qp = {}, e.editorManager.on("removeEditor", () => {
            e.editorManager.activeEditor || qp && (Dt(qp, (c, u) => {
              e.dom.unbind(oy(e, u));
            }), qp = null);
          })), qp[n])
            return;
          const r = (c) => {
            const u = c.target, f = e.editorManager.get();
            let b = f.length;
            for (; b--; ) {
              const y = f[b].getBody();
              (y === u || ny.isChildOf(u, y)) && xI(f[b], n, c);
            }
          };
          qp[n] = r, ny.bind(o, n, r);
        } else {
          const r = (c) => {
            xI(e, n, c);
          };
          ny.bind(o, n, r), e.delegates[n] = r;
        }
      }, EI = {
        ...R4,
        bindPendingEventDelegates() {
          const e = this;
          _t.each(e._pendingNativeEvents, (n) => {
            TI(e, n);
          });
        },
        toggleNativeEvent(e, n) {
          const o = this;
          e === "focus" || e === "blur" || o.removed || (n ? o.initialized ? TI(o, e) : o._pendingNativeEvents ? o._pendingNativeEvents.push(e) : o._pendingNativeEvents = [e] : o.initialized && o.delegates && (o.dom.unbind(oy(o, e), e, o.delegates[e]), delete o.delegates[e]));
        },
        unbindAllNativeEvents() {
          const e = this, n = e.getBody(), o = e.dom;
          e.delegates && (Dt(e.delegates, (r, c) => {
            e.dom.unbind(oy(e, c), c, r);
          }), delete e.delegates), !e.inline && n && o && (n.onload = null, o.unbind(e.getWin()), o.unbind(e.getDoc())), o && (o.unbind(n), o.unbind(e.getContainer()));
        }
      }, NZ = (e) => J(e) ? {
        value: e.split(/[ ,]/),
        valid: !0
      } : Te(e, J) ? {
        value: e,
        valid: !0
      } : {
        valid: !1,
        message: "The value must be a string[] or a comma/space separated string."
      }, MZ = (e) => {
        const n = (() => {
          switch (e) {
            case "array":
              return ht;
            case "boolean":
              return Tt;
            case "function":
              return re;
            case "number":
              return ho;
            case "object":
              return Qe;
            case "string":
              return J;
            case "string[]":
              return NZ;
            case "object[]":
              return (o) => Te(o, Qe);
            case "regexp":
              return (o) => Kt(o, RegExp);
            default:
              return ot;
          }
        })();
        return (o) => kd(o, n, `The value must be a ${e}.`);
      }, PZ = (e) => J(e.processor), vq = (e, n) => {
        const o = Fo(n.message) ? "" : `. ${n.message}`;
        return e + o;
      }, Ub = (e) => e.valid, kd = (e, n, o = "") => {
        const r = n(e);
        return Tt(r) ? r ? {
          value: e,
          valid: !0
        } : {
          valid: !1,
          message: o
        } : r;
      }, BZ = (e, n, o) => {
        if (!Ht(n)) {
          const r = kd(n, o);
          if (Ub(r))
            return r.value;
        }
      }, $Z = (e, n) => {
        const o = {}, r = {}, c = (M, I, X) => {
          const te = kd(I, X);
          return Ub(te) ? (r[M] = te.value, !0) : !1;
        }, u = (M, I) => {
          const X = PZ(I) ? MZ(I.processor) : I.processor, te = BZ(M, I.default, X);
          o[M] = {
            ...I,
            default: te,
            processor: X
          }, Ts(r, M).orThunk(() => Ts(n, M)).each((ne) => c(M, ne, X));
        }, f = (M) => Zn(o, M);
        return {
          register: u,
          isRegistered: f,
          get: (M) => Ts(r, M).orThunk(() => Ts(o, M).map((I) => I.default)).getOrUndefined(),
          set: (M, I) => {
            if (f(M)) {
              const X = o[M];
              return X.immutable ? !1 : c(M, I, X.processor);
            } else
              return !1;
          },
          unset: (M) => {
            const I = f(M);
            return I && delete r[M], I;
          },
          isSet: (M) => Zn(r, M)
        };
      }, FZ = [
        "design",
        "readonly"
      ], kI = (e, n, o, r) => {
        const c = o[n.get()], u = o[r];
        try {
          u.activate();
        } catch {
          return;
        }
        c.deactivate(), c.editorReadOnly !== u.editorReadOnly && nk(e, u.editorReadOnly), n.set(r), qC(e, r);
      }, IZ = (e, n, o, r) => {
        if (r !== o.get()) {
          if (!Zn(n, r))
            throw new Error(`Editor mode '${r}' is invalid`);
          e.initialized ? kI(e, o, n, r) : e.on("init", () => kI(e, o, n, r));
        }
      }, LZ = (e, n, o) => {
        if (ee(FZ, n))
          throw new Error(`Cannot override default mode ${n}`);
        return {
          ...e,
          [n]: {
            ...o,
            deactivate: () => {
              try {
                o.deactivate();
              } catch {
              }
            }
          }
        };
      }, HZ = (e) => {
        const n = jr("design"), o = jr({
          design: {
            activate: Oe,
            deactivate: Oe,
            editorReadOnly: !1
          },
          readonly: {
            activate: Oe,
            deactivate: Oe,
            editorReadOnly: !0
          }
        });
        return EZ(e), OZ(e), {
          isReadOnly: () => Vb(e),
          set: (r) => IZ(e, o.get(), n, r),
          get: () => n.get(),
          register: (r, c) => {
            o.set(LZ(o.get(), r, c));
          }
        };
      }, N4 = _t.each, M4 = _t.explode, yq = {
        f1: 112,
        f2: 113,
        f3: 114,
        f4: 115,
        f5: 116,
        f6: 117,
        f7: 118,
        f8: 119,
        f9: 120,
        f10: 121,
        f11: 122,
        f12: 123
      }, _I = _t.makeMap("alt,ctrl,shift,meta,access"), zZ = (e) => e in _I, VZ = (e) => {
        const n = {}, o = sn.os.isMacOS() || sn.os.isiOS();
        N4(M4(e.toLowerCase(), "+"), (u) => {
          zZ(u) ? n[u] = !0 : /^[0-9]{2,}$/.test(u) ? n.keyCode = parseInt(u, 10) : (n.charCode = u.charCodeAt(0), n.keyCode = yq[u] || u.toUpperCase().charCodeAt(0));
        });
        const r = [n.keyCode];
        let c;
        for (c in _I)
          n[c] ? r.push(c) : n[c] = !1;
        return n.id = r.join(","), n.access && (n.alt = !0, o ? n.ctrl = !0 : n.shift = !0), n.meta && (o ? n.meta = !0 : (n.ctrl = !0, n.meta = !1)), n;
      };
      class AI {
        constructor(n) {
          this.shortcuts = {}, this.pendingPatterns = [], this.editor = n;
          const o = this;
          n.on("keyup keypress keydown", (r) => {
            (o.hasModifier(r) || o.isFunctionKey(r)) && !r.isDefaultPrevented() && (N4(o.shortcuts, (c) => {
              o.matchShortcut(r, c) && (o.pendingPatterns = c.subpatterns.slice(0), r.type === "keydown" && o.executeShortcutAction(c));
            }), o.matchShortcut(r, o.pendingPatterns[0]) && (o.pendingPatterns.length === 1 && r.type === "keydown" && o.executeShortcutAction(o.pendingPatterns[0]), o.pendingPatterns.shift()));
          });
        }
        add(n, o, r, c) {
          const u = this, f = u.normalizeCommandFunc(r);
          return N4(M4(_t.trim(n)), (b) => {
            const y = u.createShortcut(b, o, f, c);
            u.shortcuts[y.id] = y;
          }), !0;
        }
        remove(n) {
          const o = this.createShortcut(n);
          return this.shortcuts[o.id] ? (delete this.shortcuts[o.id], !0) : !1;
        }
        normalizeCommandFunc(n) {
          const o = this, r = n;
          return typeof r == "string" ? () => {
            o.editor.execCommand(r, !1, null);
          } : _t.isArray(r) ? () => {
            o.editor.execCommand(r[0], r[1], r[2]);
          } : r;
        }
        createShortcut(n, o, r, c) {
          const u = _t.map(M4(n, ">"), VZ);
          return u[u.length - 1] = _t.extend(u[u.length - 1], {
            func: r,
            scope: c || this.editor
          }), _t.extend(u[0], {
            desc: this.editor.translate(o),
            subpatterns: u.slice(1)
          });
        }
        hasModifier(n) {
          return n.altKey || n.ctrlKey || n.metaKey;
        }
        isFunctionKey(n) {
          return n.type === "keydown" && n.keyCode >= 112 && n.keyCode <= 123;
        }
        matchShortcut(n, o) {
          return !o || o.ctrl !== n.ctrlKey || o.meta !== n.metaKey || o.alt !== n.altKey || o.shift !== n.shiftKey ? !1 : n.keyCode === o.keyCode || n.charCode && n.charCode === o.charCode ? (n.preventDefault(), !0) : !1;
        }
        executeShortcutAction(n) {
          return n.func ? n.func.call(n.scope) : null;
        }
      }
      const UZ = () => {
        const e = {}, n = {}, o = {}, r = {}, c = {}, u = {}, f = {}, b = {}, y = (N, M) => (I, X) => {
          N[I.toLowerCase()] = {
            ...X,
            type: M
          };
        }, E = (N, M) => r[N.toLowerCase()] = M;
        return {
          addButton: y(e, "button"),
          addGroupToolbarButton: y(e, "grouptoolbarbutton"),
          addToggleButton: y(e, "togglebutton"),
          addMenuButton: y(e, "menubutton"),
          addSplitButton: y(e, "splitbutton"),
          addMenuItem: y(n, "menuitem"),
          addNestedMenuItem: y(n, "nestedmenuitem"),
          addToggleMenuItem: y(n, "togglemenuitem"),
          addAutocompleter: y(o, "autocompleter"),
          addContextMenu: y(c, "contextmenu"),
          addContextToolbar: y(u, "contexttoolbar"),
          addContextForm: y(u, "contextform"),
          addSidebar: y(f, "sidebar"),
          addView: y(b, "views"),
          addIcon: E,
          getAll: () => ({
            buttons: e,
            menuItems: n,
            icons: r,
            popups: o,
            contextMenus: c,
            contextToolbars: u,
            sidebars: f,
            views: b
          })
        };
      }, WZ = () => {
        const e = UZ();
        return {
          addAutocompleter: e.addAutocompleter,
          addButton: e.addButton,
          addContextForm: e.addContextForm,
          addContextMenu: e.addContextMenu,
          addContextToolbar: e.addContextToolbar,
          addIcon: e.addIcon,
          addMenuButton: e.addMenuButton,
          addMenuItem: e.addMenuItem,
          addNestedMenuItem: e.addNestedMenuItem,
          addSidebar: e.addSidebar,
          addSplitButton: e.addSplitButton,
          addToggleButton: e.addToggleButton,
          addGroupToolbarButton: e.addGroupToolbarButton,
          addToggleMenuItem: e.addToggleMenuItem,
          addView: e.addView,
          getAll: e.getAll
        };
      }, sy = xr.DOM, OI = _t.extend, ZZ = _t.each;
      class ok {
        constructor(n, o, r) {
          this.plugins = {}, this.contentCSS = [], this.contentStyles = [], this.loadedCSS = {}, this.isNotDirty = !1, this.composing = !1, this.destroyed = !1, this.hasHiddenInput = !1, this.iframeElement = null, this.initialized = !1, this.readonly = !1, this.removed = !1, this.startContent = "", this._pendingNativeEvents = [], this._skinLoaded = !1, this._editableRoot = !0, this.editorManager = r, this.documentBaseUrl = r.documentBaseURL, OI(this, EI);
          const c = this;
          this.id = n, this.hidden = !1;
          const u = YW(r.defaultOptions, o);
          this.options = $Z(c, u), cS(c);
          const f = this.options.get;
          f("deprecation_warnings") && Fj(o, u);
          const b = f("suffix");
          b && (r.suffix = b), this.suffix = r.suffix;
          const y = f("base_url");
          y && r._setBaseUrl(y), this.baseUri = r.baseURI;
          const E = Go(c);
          E && (Ha.ScriptLoader._setReferrerPolicy(E), xr.DOM.styleSheetLoader._setReferrerPolicy(E));
          const N = qh(c);
          De(N) && xr.DOM.styleSheetLoader._setContentCssCors(N), mi.languageLoad = f("language_load"), mi.baseURL = r.baseURL, this.setDirty(!1), this.documentBaseURI = new Sd(nC(c), { base_uri: this.baseUri }), this.baseURI = this.baseUri, this.inline = mC(c), this.hasVisual = r_(c), this.shortcuts = new AI(this), this.editorCommands = new A4(this), ek(this);
          const M = f("cache_suffix");
          M && (sn.cacheSuffix = M.replace(/^[\?\&]+/, "")), this.ui = {
            registry: WZ(),
            styleSheetLoader: void 0,
            show: Oe,
            hide: Oe,
            setEnabled: Oe,
            isEnabled: ot
          }, this.mode = HZ(c), r.dispatch("SetupEditor", { editor: this });
          const I = fC(c);
          re(I) && I.call(c, c);
        }
        render() {
          w4(this);
        }
        focus(n) {
          this.execCommand("mceFocus", !1, n);
        }
        hasFocus() {
          return vp(this);
        }
        translate(n) {
          return Fu.translate(n);
        }
        getParam(n, o, r) {
          const c = this.options;
          return c.isRegistered(n) || (De(r) ? c.register(n, {
            processor: r,
            default: o
          }) : c.register(n, {
            processor: ot,
            default: o
          })), !c.isSet(n) && !Ht(o) ? o : c.get(n);
        }
        hasPlugin(n, o) {
          return ee(I1(this), n) ? o ? _b.get(n) !== void 0 : !0 : !1;
        }
        nodeChanged(n) {
          this._nodeChangeDispatcher.nodeChanged(n);
        }
        addCommand(n, o, r) {
          this.editorCommands.addCommand(n, o, r);
        }
        addQueryStateHandler(n, o, r) {
          this.editorCommands.addQueryStateHandler(n, o, r);
        }
        addQueryValueHandler(n, o, r) {
          this.editorCommands.addQueryValueHandler(n, o, r);
        }
        addShortcut(n, o, r, c) {
          this.shortcuts.add(n, o, r, c);
        }
        execCommand(n, o, r, c) {
          return this.editorCommands.execCommand(n, o, r, c);
        }
        queryCommandState(n) {
          return this.editorCommands.queryCommandState(n);
        }
        queryCommandValue(n) {
          return this.editorCommands.queryCommandValue(n);
        }
        queryCommandSupported(n) {
          return this.editorCommands.queryCommandSupported(n);
        }
        show() {
          const n = this;
          n.hidden && (n.hidden = !1, n.inline ? n.getBody().contentEditable = "true" : (sy.show(n.getContainer()), sy.hide(n.id)), n.load(), n.dispatch("show"));
        }
        hide() {
          const n = this;
          n.hidden || (n.save(), n.inline ? (n.getBody().contentEditable = "false", n === n.editorManager.focusedEditor && (n.editorManager.focusedEditor = null)) : (sy.hide(n.getContainer()), sy.setStyle(n.id, "display", n.orgDisplay)), n.hidden = !0, n.dispatch("hide"));
        }
        isHidden() {
          return this.hidden;
        }
        setProgressState(n, o) {
          this.dispatch("ProgressState", {
            state: n,
            time: o
          });
        }
        load(n = {}) {
          const o = this, r = o.getElement();
          if (o.removed)
            return "";
          if (r) {
            const c = {
              ...n,
              load: !0
            }, u = hh(r) ? r.value : r.innerHTML, f = o.setContent(u, c);
            return c.no_events || o.dispatch("LoadContent", {
              ...c,
              element: r
            }), f;
          } else
            return "";
        }
        save(n = {}) {
          const o = this;
          let r = o.getElement();
          if (!r || !o.initialized || o.removed)
            return "";
          const c = {
            ...n,
            save: !0,
            element: r
          };
          let u = o.getContent(c);
          const f = {
            ...c,
            content: u
          };
          if (f.no_events || o.dispatch("SaveContent", f), f.format === "raw" && o.dispatch("RawSaveContent", f), u = f.content, hh(r))
            r.value = u;
          else {
            (n.is_removing || !o.inline) && (r.innerHTML = u);
            const b = sy.getParent(o.id, "form");
            b && ZZ(b.elements, (y) => y.name === o.id ? (y.value = u, !1) : !0);
          }
          return f.element = c.element = r = null, f.set_dirty !== !1 && o.setDirty(!1), u;
        }
        setContent(n, o) {
          return sO(this, n, o);
        }
        getContent(n) {
          return TP(this, n);
        }
        insertContent(n, o) {
          o && (n = OI({ content: n }, o)), this.execCommand("mceInsertContent", !1, n);
        }
        resetContent(n) {
          n === void 0 ? sO(this, this.startContent, { format: "raw" }) : sO(this, n), this.undoManager.reset(), this.setDirty(!1), this.nodeChanged();
        }
        isDirty() {
          return !this.isNotDirty;
        }
        setDirty(n) {
          const o = !this.isNotDirty;
          this.isNotDirty = !n, n && n !== o && this.dispatch("dirty");
        }
        getContainer() {
          const n = this;
          return n.container || (n.container = n.editorContainer || sy.get(n.id + "_parent")), n.container;
        }
        getContentAreaContainer() {
          return this.contentAreaContainer;
        }
        getElement() {
          return this.targetElm || (this.targetElm = sy.get(this.id)), this.targetElm;
        }
        getWin() {
          const n = this;
          if (!n.contentWindow) {
            const o = n.iframeElement;
            o && (n.contentWindow = o.contentWindow);
          }
          return n.contentWindow;
        }
        getDoc() {
          const n = this;
          if (!n.contentDocument) {
            const o = n.getWin();
            o && (n.contentDocument = o.document);
          }
          return n.contentDocument;
        }
        getBody() {
          var n, o;
          const r = this.getDoc();
          return (o = (n = this.bodyElement) !== null && n !== void 0 ? n : r?.body) !== null && o !== void 0 ? o : null;
        }
        convertURL(n, o, r) {
          const c = this, u = c.options.get, f = l_(c);
          if (re(f))
            return f.call(c, n, r, !0, o);
          if (!u("convert_urls") || r === "link" || Qe(r) && r.nodeName === "LINK" || n.indexOf("file:") === 0 || n.length === 0)
            return n;
          const b = new Sd(n);
          return b.protocol !== "http" && b.protocol !== "https" && b.protocol !== "" ? n : u("relative_urls") ? c.documentBaseURI.toRelative(n) : (n = c.documentBaseURI.toAbsolute(n, u("remove_script_host")), n);
        }
        addVisual(n) {
          XW(this, n);
        }
        setEditableRoot(n) {
          YE(this, n);
        }
        hasEditableRoot() {
          return XE(this);
        }
        remove() {
          O7(this);
        }
        destroy(n) {
          D7(this, n);
        }
        uploadImages() {
          return this.editorUpload.uploadImages();
        }
        _scanForImages() {
          return this.editorUpload.scanForImages();
        }
      }
      const ry = xr.DOM, sk = _t.each;
      let DI = !1, rk, Kl = [];
      const ak = (e) => {
        const n = e.type;
        sk(Gp.get(), (o) => {
          switch (n) {
            case "scroll":
              o.dispatch("ScrollWindow", e);
              break;
            case "resize":
              o.dispatch("ResizeWindow", e);
              break;
          }
        });
      }, RI = (e) => {
        if (e !== DI) {
          const n = xr.DOM;
          e ? (n.bind(window, "resize", ak), n.bind(window, "scroll", ak)) : (n.unbind(window, "resize", ak), n.unbind(window, "scroll", ak)), DI = e;
        }
      }, NI = (e) => {
        const n = Kl;
        return Kl = Yt(Kl, (o) => e !== o), Gp.activeEditor === e && (Gp.activeEditor = Kl.length > 0 ? Kl[0] : null), Gp.focusedEditor === e && (Gp.focusedEditor = null), n.length !== Kl.length;
      }, jZ = (e) => {
        e && e.initialized && !(e.getContainer() || e.getBody()).parentNode && (NI(e), e.unbindAllNativeEvents(), e.destroy(!0), e.removed = !0);
      }, qZ = document.compatMode !== "CSS1Compat", Gp = {
        ...R4,
        baseURI: null,
        baseURL: null,
        defaultOptions: {},
        documentBaseURL: null,
        suffix: null,
        majorVersion: "6",
        minorVersion: "8.6",
        releaseDate: "TBD",
        i18n: Fu,
        activeEditor: null,
        focusedEditor: null,
        setup() {
          const e = this;
          let n = "", o = "", r = Sd.getDocumentBaseUrl(document.location);
          /^[^:]+:\/\/\/?[^\/]+\//.test(r) && (r = r.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, ""), /[\/\\]$/.test(r) || (r += "/"));
          const c = window.tinymce || window.tinyMCEPreInit;
          if (c)
            n = c.base || c.baseURL, o = c.suffix;
          else {
            const u = document.getElementsByTagName("script");
            for (let f = 0; f < u.length; f++) {
              const b = u[f].src || "";
              if (b === "")
                continue;
              const y = b.substring(b.lastIndexOf("/"));
              if (/tinymce(\.full|\.jquery|)(\.min|\.dev|)\.js/.test(b)) {
                y.indexOf(".min") !== -1 && (o = ".min"), n = b.substring(0, b.lastIndexOf("/"));
                break;
              }
            }
            if (!n && document.currentScript) {
              const f = document.currentScript.src;
              f.indexOf(".min") !== -1 && (o = ".min"), n = f.substring(0, f.lastIndexOf("/"));
            }
          }
          e.baseURL = new Sd(r).toAbsolute(n), e.documentBaseURL = r, e.baseURI = new Sd(e.baseURL), e.suffix = o, rL(e);
        },
        overrideDefaults(e) {
          const n = e.base_url;
          n && this._setBaseUrl(n);
          const o = e.suffix;
          o && (this.suffix = o), this.defaultOptions = e;
          const r = e.plugin_base_urls;
          r !== void 0 && Dt(r, (c, u) => {
            mi.PluginManager.urls[u] = c;
          });
        },
        init(e) {
          const n = this;
          let o;
          const r = _t.makeMap("area base basefont br col frame hr img input isindex link meta param embed source wbr track colgroup option table tbody tfoot thead tr th td script noscript style textarea video audio iframe object menu", " "), c = (N, M) => N.inline && M.tagName.toLowerCase() in r, u = (N) => {
            let M = N.id;
            return M || (M = Ts(N, "name").filter((I) => !ry.get(I)).getOrThunk(ry.uniqueId), N.setAttribute("id", M)), M;
          }, f = (N) => {
            const M = e[N];
            if (M)
              return M.apply(n, []);
          }, b = (N) => sn.browser.isIE() || sn.browser.isEdge() ? (V2("TinyMCE does not support the browser you are using. For a list of supported browsers please see: https://www.tiny.cloud/docs/tinymce/6/support/#supportedwebbrowsers"), []) : qZ ? (V2("Failed to initialize the editor as the document is not in standards mode. TinyMCE requires standards mode."), []) : J(N.selector) ? ry.select(N.selector) : De(N.target) ? [N.target] : [];
          let y = (N) => {
            o = N;
          };
          const E = () => {
            let N = 0;
            const M = [];
            let I;
            const X = (te, G, ne) => {
              const Se = new ok(te, G, n);
              M.push(Se), Se.on("init", () => {
                ++N === I.length && y(M);
              }), Se.targetElm = Se.targetElm || ne, Se.render();
            };
            ry.unbind(window, "ready", E), f("onpageload"), I = Yr(b(e)), _t.each(I, (te) => {
              jZ(n.get(te.id));
            }), I = _t.grep(I, (te) => !n.get(te.id)), I.length === 0 ? y([]) : sk(I, (te) => {
              c(e, te) ? V2("Could not initialize inline editor on invalid inline target element", te) : X(u(te), e, te);
            });
          };
          return ry.bind(window, "ready", E), new Promise((N) => {
            o ? N(o) : y = (M) => {
              N(M);
            };
          });
        },
        get(e) {
          return arguments.length === 0 ? Kl.slice(0) : J(e) ? hn(Kl, (n) => n.id === e).getOr(null) : ho(e) && Kl[e] ? Kl[e] : null;
        },
        add(e) {
          const n = this, o = n.get(e.id);
          return o === e || (o === null && Kl.push(e), RI(!0), n.activeEditor = e, n.dispatch("AddEditor", { editor: e }), rk || (rk = (r) => {
            const c = n.dispatch("BeforeUnload");
            if (c.returnValue)
              return r.preventDefault(), r.returnValue = c.returnValue, c.returnValue;
          }, window.addEventListener("beforeunload", rk))), e;
        },
        createEditor(e, n) {
          return this.add(new ok(e, n, this));
        },
        remove(e) {
          const n = this;
          let o;
          if (!e) {
            for (let r = Kl.length - 1; r >= 0; r--)
              n.remove(Kl[r]);
            return;
          }
          if (J(e)) {
            sk(ry.select(e), (r) => {
              o = n.get(r.id), o && n.remove(o);
            });
            return;
          }
          return o = e, U(n.get(o.id)) ? null : (NI(o) && n.dispatch("RemoveEditor", { editor: o }), Kl.length === 0 && window.removeEventListener("beforeunload", rk), o.remove(), RI(Kl.length > 0), o);
        },
        execCommand(e, n, o) {
          var r;
          const c = this, u = Qe(o) ? (r = o.id) !== null && r !== void 0 ? r : o.index : o;
          switch (e) {
            case "mceAddEditor": {
              if (!c.get(u)) {
                const f = o.options;
                new ok(u, f, c).render();
              }
              return !0;
            }
            case "mceRemoveEditor": {
              const f = c.get(u);
              return f && f.remove(), !0;
            }
            case "mceToggleEditor": {
              const f = c.get(u);
              return f ? (f.isHidden() ? f.show() : f.hide(), !0) : (c.execCommand("mceAddEditor", !1, o), !0);
            }
          }
          return c.activeEditor ? c.activeEditor.execCommand(e, n, o) : !1;
        },
        triggerSave: () => {
          sk(Kl, (e) => {
            e.save();
          });
        },
        addI18n: (e, n) => {
          Fu.add(e, n);
        },
        translate: (e) => Fu.translate(e),
        setActive(e) {
          const n = this.activeEditor;
          this.activeEditor !== e && (n && n.dispatch("deactivate", { relatedTarget: e }), e.dispatch("activate", { relatedTarget: n })), this.activeEditor = e;
        },
        _setBaseUrl(e) {
          this.baseURL = new Sd(this.documentBaseURL).toAbsolute(e.replace(/\/+$/, "")), this.baseURI = new Sd(this.baseURL);
        }
      };
      Gp.setup();
      const GZ = (() => {
        const e = Cf(), n = (u) => ({
          items: u,
          types: Ss(u),
          getType: (f) => Ts(u, f).getOrUndefined()
        }), o = (u) => {
          e.set(u);
        }, r = () => e.get().getOrUndefined(), c = e.clear;
        return {
          FakeClipboardItem: n,
          write: o,
          read: r,
          clear: c
        };
      })(), P4 = Math.min, ay = Math.max, ck = Math.round, MI = (e, n, o) => {
        let r = n.x, c = n.y;
        const u = e.w, f = e.h, b = n.w, y = n.h, E = (o || "").split("");
        return E[0] === "b" && (c += y), E[1] === "r" && (r += b), E[0] === "c" && (c += ck(y / 2)), E[1] === "c" && (r += ck(b / 2)), E[3] === "b" && (c -= f), E[4] === "r" && (r -= u), E[3] === "c" && (c -= ck(f / 2)), E[4] === "c" && (r -= ck(u / 2)), cy(r, c, u, f);
      }, KZ = (e, n, o, r) => {
        for (let c = 0; c < r.length; c++) {
          const u = MI(e, n, r[c]);
          if (u.x >= o.x && u.x + u.w <= o.w + o.x && u.y >= o.y && u.y + u.h <= o.h + o.y)
            return r[c];
        }
        return null;
      }, YZ = (e, n, o) => cy(e.x - n, e.y - o, e.w + n * 2, e.h + o * 2), XZ = (e, n) => {
        const o = ay(e.x, n.x), r = ay(e.y, n.y), c = P4(e.x + e.w, n.x + n.w), u = P4(e.y + e.h, n.y + n.h);
        return c - o < 0 || u - r < 0 ? null : cy(o, r, c - o, u - r);
      }, JZ = (e, n, o) => {
        let r = e.x, c = e.y, u = e.x + e.w, f = e.y + e.h;
        const b = n.x + n.w, y = n.y + n.h, E = ay(0, n.x - r), N = ay(0, n.y - c), M = ay(0, u - b), I = ay(0, f - y);
        return r += E, c += N, o && (u += E, f += N, r -= M, c -= I), u -= M, f -= I, cy(r, c, u - r, f - c);
      }, cy = (e, n, o, r) => ({
        x: e,
        y: n,
        w: o,
        h: r
      }), ej = {
        inflate: YZ,
        relativePosition: MI,
        findBestRelativePosition: KZ,
        intersect: XZ,
        clamp: JZ,
        create: cy,
        fromClientRect: (e) => cy(e.left, e.top, e.width, e.height)
      }, tj = (e, n, o = 1e3) => {
        let r = !1, c = null;
        const u = (E) => (...N) => {
          r || (r = !0, c !== null && (clearTimeout(c), c = null), E.apply(null, N));
        }, f = u(e), b = u(n);
        return {
          start: (...E) => {
            !r && c === null && (c = setTimeout(() => b.apply(null, E), o));
          },
          resolve: f,
          reject: b
        };
      }, nj = (() => {
        const e = {}, n = {}, o = {};
        return {
          load: (y, E) => {
            const N = `Script at URL "${E}" failed to load`, M = `Script at URL "${E}" did not call \`tinymce.Resource.add('${y}', data)\` within 1 second`;
            if (e[y] !== void 0)
              return e[y];
            {
              const I = new Promise((X, te) => {
                const G = tj(X, te);
                n[y] = G.resolve, Ha.ScriptLoader.loadScript(E).then(() => G.start(M), () => G.reject(N));
              });
              return e[y] = I, I;
            }
          },
          add: (y, E) => {
            n[y] !== void 0 && (n[y](E), delete n[y]), e[y] = Promise.resolve(E), o[y] = E;
          },
          has: (y) => y in o,
          get: (y) => o[y],
          unload: (y) => {
            delete e[y];
          }
        };
      })(), oj = () => (() => {
        let e = {}, n = [];
        const o = {
          getItem: (r) => {
            const c = e[r];
            return c || null;
          },
          setItem: (r, c) => {
            n.push(r), e[r] = String(c);
          },
          key: (r) => n[r],
          removeItem: (r) => {
            n = n.filter((c) => c === r), delete e[r];
          },
          clear: () => {
            n = [], e = {};
          },
          length: 0
        };
        return Object.defineProperty(o, "length", {
          get: () => n.length,
          configurable: !1,
          enumerable: !1
        }), o;
      })();
      let _w;
      try {
        const e = "__storage_test__";
        _w = window.localStorage, _w.setItem(e, e), _w.removeItem(e);
      } catch {
        _w = oj();
      }
      var sj = _w;
      const rj = {
        geom: { Rect: ej },
        util: {
          Delay: Uu,
          Tools: _t,
          VK: Tn,
          URI: Sd,
          EventDispatcher: Va,
          Observable: R4,
          I18n: Fu,
          LocalStorage: sj,
          ImageUploader: G7
        },
        dom: {
          EventUtils: ul,
          TreeWalker: br,
          TextSeeker: wf,
          DOMUtils: xr,
          ScriptLoader: Ha,
          RangeUtils: W,
          Serializer: SP,
          StyleSheetLoader: xy,
          ControlSelection: rR,
          BookmarkManager: Fg,
          Selection: Rp,
          Event: ul.Event
        },
        html: {
          Styles: l0,
          Entities: wg,
          Node: Ki,
          Schema: Tm,
          DomParser: Qd,
          Writer: DR,
          Serializer: yp
        },
        Env: sn,
        AddOnManager: mi,
        Annotator: WC,
        Formatter: mO,
        UndoManager: fO,
        EditorCommands: A4,
        WindowManager: NP,
        NotificationManager: cO,
        EditorObservable: EI,
        Shortcuts: AI,
        Editor: ok,
        FocusManager: uR,
        EditorManager: Gp,
        DOM: xr.DOM,
        ScriptLoader: Ha.ScriptLoader,
        PluginManager: _b,
        ThemeManager: Xg,
        ModelManager: Td,
        IconManager: L2,
        Resource: nj,
        FakeClipboard: GZ,
        trim: _t.trim,
        isArray: _t.isArray,
        is: _t.is,
        toArray: _t.toArray,
        makeMap: _t.makeMap,
        each: _t.each,
        map: _t.map,
        grep: _t.grep,
        inArray: _t.inArray,
        extend: _t.extend,
        walk: _t.walk,
        resolve: _t.resolve,
        explode: _t.explode,
        _addCacheSuffix: _t._addCacheSuffix
      }, B4 = _t.extend(Gp, rj), Sq = (e) => {
        try {
          vt.exports = e;
        } catch {
        }
      };
      ((e) => {
        window.tinymce = e, window.tinyMCE = e;
      })(B4), Sq(B4);
    })();
  })(Cj)), Cj.exports;
}
var DY = OY();
const RY = /* @__PURE__ */ fY(DY);
var oG = {}, sG = {}, rG;
function NY() {
  return rG || (rG = 1, (function() {
    var vt = tinymce.util.Tools.resolve("tinymce.ModelManager");
    const Ot = (l, m, h) => {
      var v;
      return h(l, m.prototype) ? !0 : ((v = l.constructor) === null || v === void 0 ? void 0 : v.name) === m.name;
    }, Pt = (l) => {
      const m = typeof l;
      return l === null ? "null" : m === "object" && Array.isArray(l) ? "array" : m === "object" && Ot(l, String, (h, v) => v.isPrototypeOf(h)) ? "string" : m;
    }, yt = (l) => (m) => Pt(m) === l, Nt = (l) => (m) => typeof m === l, Wt = (l) => (m) => l === m, Fe = yt("string"), Ee = yt("object"), Bt = yt("array"), fn = Wt(null), dn = Nt("boolean"), Sn = Wt(void 0), Ft = (l) => l == null, Zt = (l) => !Ft(l), Qt = Nt("function"), En = Nt("number"), st = () => {
    }, Pn = (l, m) => (...h) => l(m.apply(null, h)), Kt = (l, m) => (h) => l(m(h)), J = (l) => () => l, Qe = (l) => l, xo = (l, m) => l === m;
    function ht(l, ...m) {
      return (...h) => {
        const v = m.concat(h);
        return l.apply(null, v);
      };
    }
    const U = (l) => (m) => !l(m), Tt = (l) => () => {
      throw new Error(l);
    }, Ht = (l) => l(), gn = J(!1), De = J(!0);
    class re {
      constructor(m, h) {
        this.tag = m, this.value = h;
      }
      static some(m) {
        return new re(!0, m);
      }
      static none() {
        return re.singletonNone;
      }
      fold(m, h) {
        return this.tag ? h(this.value) : m();
      }
      isSome() {
        return this.tag;
      }
      isNone() {
        return !this.tag;
      }
      map(m) {
        return this.tag ? re.some(m(this.value)) : re.none();
      }
      bind(m) {
        return this.tag ? m(this.value) : re.none();
      }
      exists(m) {
        return this.tag && m(this.value);
      }
      forall(m) {
        return !this.tag || m(this.value);
      }
      filter(m) {
        return !this.tag || m(this.value) ? this : re.none();
      }
      getOr(m) {
        return this.tag ? this.value : m;
      }
      or(m) {
        return this.tag ? this : m;
      }
      getOrThunk(m) {
        return this.tag ? this.value : m();
      }
      orThunk(m) {
        return this.tag ? this : m();
      }
      getOrDie(m) {
        if (this.tag)
          return this.value;
        throw new Error(m ?? "Called getOrDie on None");
      }
      static from(m) {
        return Zt(m) ? re.some(m) : re.none();
      }
      getOrNull() {
        return this.tag ? this.value : null;
      }
      getOrUndefined() {
        return this.value;
      }
      each(m) {
        this.tag && m(this.value);
      }
      toArray() {
        return this.tag ? [this.value] : [];
      }
      toString() {
        return this.tag ? `some(${this.value})` : "none()";
      }
    }
    re.singletonNone = new re(!1);
    const ho = Array.prototype.slice, Te = Array.prototype.indexOf, Oe = Array.prototype.push, A = (l, m) => Te.call(l, m), mn = (l, m) => A(l, m) > -1, it = (l, m) => {
      for (let h = 0, v = l.length; h < v; h++) {
        const T = l[h];
        if (m(T, h))
          return !0;
      }
      return !1;
    }, Gn = (l, m) => {
      const h = [];
      for (let v = 0; v < l; v++)
        h.push(m(v));
      return h;
    }, rn = (l, m) => {
      const h = l.length, v = new Array(h);
      for (let T = 0; T < h; T++) {
        const O = l[T];
        v[T] = m(O, T);
      }
      return v;
    }, Ye = (l, m) => {
      for (let h = 0, v = l.length; h < v; h++) {
        const T = l[h];
        m(T, h);
      }
    }, io = (l, m) => {
      for (let h = l.length - 1; h >= 0; h--) {
        const v = l[h];
        m(v, h);
      }
    }, jo = (l, m) => {
      const h = [], v = [];
      for (let T = 0, O = l.length; T < O; T++) {
        const $ = l[T];
        (m($, T) ? h : v).push($);
      }
      return {
        pass: h,
        fail: v
      };
    }, bt = (l, m) => {
      const h = [];
      for (let v = 0, T = l.length; v < T; v++) {
        const O = l[v];
        m(O, v) && h.push(O);
      }
      return h;
    }, kn = (l, m, h) => (io(l, (v, T) => {
      h = m(h, v, T);
    }), h), $e = (l, m, h) => (Ye(l, (v, T) => {
      h = m(h, v, T);
    }), h), ot = (l, m, h) => {
      for (let v = 0, T = l.length; v < T; v++) {
        const O = l[v];
        if (m(O, v))
          return re.some(O);
        if (h(O, v))
          break;
      }
      return re.none();
    }, F = (l, m) => ot(l, m, gn), ss = (l, m) => {
      for (let h = 0, v = l.length; h < v; h++) {
        const T = l[h];
        if (m(T, h))
          return re.some(h);
      }
      return re.none();
    }, fo = (l) => {
      const m = [];
      for (let h = 0, v = l.length; h < v; ++h) {
        if (!Bt(l[h]))
          throw new Error("Arr.flatten item " + h + " was not an array, input: " + l);
        Oe.apply(m, l[h]);
      }
      return m;
    }, at = (l, m) => fo(rn(l, m)), lt = (l, m) => {
      for (let h = 0, v = l.length; h < v; ++h) {
        const T = l[h];
        if (m(T, h) !== !0)
          return !1;
      }
      return !0;
    }, Rn = (l) => {
      const m = ho.call(l, 0);
      return m.reverse(), m;
    }, ee = (l, m) => {
      const h = {};
      for (let v = 0, T = l.length; v < T; v++) {
        const O = l[v];
        h[String(O)] = m(O, v);
      }
      return h;
    }, pe = (l, m) => {
      const h = ho.call(l, 0);
      return h.sort(m), h;
    }, ye = (l, m) => m >= 0 && m < l.length ? re.some(l[m]) : re.none(), ae = (l) => ye(l, 0), kt = (l) => ye(l, l.length - 1), Vn = (l, m) => {
      for (let h = 0; h < l.length; h++) {
        const v = m(l[h], h);
        if (v.isSome())
          return v;
      }
      return re.none();
    }, Yt = Object.keys, Ct = Object.hasOwnProperty, Xe = (l, m) => {
      const h = Yt(l);
      for (let v = 0, T = h.length; v < T; v++) {
        const O = h[v], $ = l[O];
        m($, O);
      }
    }, In = (l, m) => hn(l, (h, v) => ({
      k: v,
      v: m(h, v)
    })), hn = (l, m) => {
      const h = {};
      return Xe(l, (v, T) => {
        const O = m(v, T);
        h[O.k] = O.v;
      }), h;
    }, Xn = (l) => (m, h) => {
      l[h] = m;
    }, Xo = (l, m, h, v) => {
      Xe(l, (T, O) => {
        (m(T, O) ? h : v)(T, O);
      });
    }, ds = (l, m) => {
      const h = {};
      return Xo(l, m, Xn(h), st), h;
    }, No = (l, m) => {
      const h = [];
      return Xe(l, (v, T) => {
        h.push(m(v, T));
      }), h;
    }, Ao = (l) => No(l, Qe), Cs = (l, m) => Ie(l, m) ? re.from(l[m]) : re.none(), Ie = (l, m) => Ct.call(l, m), et = (l, m) => Ie(l, m) && l[m] !== void 0 && l[m] !== null, nn = (l) => {
      for (const m in l)
        if (Ct.call(l, m))
          return !1;
      return !0;
    }, qt = typeof window < "u" ? window : Function("return this;")(), ko = (l, m) => {
      let h = m ?? qt;
      for (let v = 0; v < l.length && h !== void 0 && h !== null; ++v)
        h = h[l[v]];
      return h;
    }, rs = (l, m) => {
      const h = l.split(".");
      return ko(h, m);
    }, Gs = (l, m) => rs(l, m), Yr = (l, m) => {
      const h = Gs(l, m);
      if (h == null)
        throw new Error(l + " not available on this browser");
      return h;
    }, Ss = Object.getPrototypeOf, or = (l) => Yr("HTMLElement", l), Dt = (l) => {
      const m = rs("ownerDocument.defaultView", l);
      return Ee(l) && (or(m).prototype.isPrototypeOf(l) || /^HTML\w*Element$/.test(Ss(l).constructor.name));
    }, Lo = 8, Or = 9, aa = 11, Xr = 1, Jr = 3, xs = (l) => l.dom.nodeName.toLowerCase(), fa = (l) => l.dom.nodeType, Qr = (l) => (m) => fa(m) === l, Ts = (l) => fa(l) === Lo || xs(l) === "#comment", Zn = (l) => dr(l) && Dt(l.dom), dr = Qr(Xr), ga = Qr(Jr), Za = Qr(Or), _c = Qr(aa), sr = (l) => (m) => dr(m) && xs(m) === l, Ks = (l, m, h) => {
      if (Fe(h) || dn(h) || En(h))
        l.setAttribute(m, h + "");
      else
        throw new Error("Attribute value was not simple");
    }, Vs = (l, m, h) => {
      Ks(l.dom, m, h);
    }, Sa = (l, m) => {
      const h = l.dom;
      Xe(m, (v, T) => {
        Ks(h, T, v);
      });
    }, rc = (l, m) => {
      Xe(m, (h, v) => {
        h.fold(() => {
          ie(l, v);
        }, (T) => {
          Ks(l.dom, v, T);
        });
      });
    }, wr = (l, m) => {
      const h = l.dom.getAttribute(m);
      return h === null ? void 0 : h;
    }, de = (l, m) => re.from(wr(l, m)), ie = (l, m) => {
      l.dom.removeAttribute(m);
    }, ze = (l) => $e(l.dom.attributes, (m, h) => (m[h.name] = h.value, m), {}), Je = (l, m) => {
      const v = (m || document).createElement("div");
      if (v.innerHTML = l, !v.hasChildNodes() || v.childNodes.length > 1) {
        const T = "HTML does not have a single root node";
        throw new Error(T);
      }
      return _o(v.childNodes[0]);
    }, Nn = (l, m) => {
      const v = (m || document).createElement(l);
      return _o(v);
    }, Wn = (l, m) => {
      const v = (m || document).createTextNode(l);
      return _o(v);
    }, _o = (l) => {
      if (l == null)
        throw new Error("Node cannot be null or undefined");
      return { dom: l };
    }, ve = {
      fromHtml: Je,
      fromTag: Nn,
      fromText: Wn,
      fromDom: _o,
      fromPoint: (l, m, h) => re.from(l.dom.elementFromPoint(m, h)).map(_o)
    }, go = (l, m) => {
      const h = l.dom;
      if (h.nodeType !== Xr)
        return !1;
      {
        const v = h;
        if (v.matches !== void 0)
          return v.matches(m);
        if (v.msMatchesSelector !== void 0)
          return v.msMatchesSelector(m);
        if (v.webkitMatchesSelector !== void 0)
          return v.webkitMatchesSelector(m);
        if (v.mozMatchesSelector !== void 0)
          return v.mozMatchesSelector(m);
        throw new Error("Browser lacks native selectors");
      }
    }, ue = (l) => l.nodeType !== Xr && l.nodeType !== Or && l.nodeType !== aa || l.childElementCount === 0, he = (l, m) => {
      const h = m === void 0 ? document : m.dom;
      return ue(h) ? [] : rn(h.querySelectorAll(l), ve.fromDom);
    }, dt = (l, m) => {
      const h = m === void 0 ? document : m.dom;
      return ue(h) ? re.none() : re.from(h.querySelector(l)).map(ve.fromDom);
    }, wt = (l, m) => l.dom === m.dom, on = (l, m) => {
      const h = l.dom, v = m.dom;
      return h === v ? !1 : h.contains(v);
    }, Ln = go, On = (l) => ve.fromDom(l.dom.ownerDocument), Dn = (l) => Za(l) ? l : On(l), Mn = (l) => ve.fromDom(Dn(l).dom.documentElement), Kn = (l) => ve.fromDom(Dn(l).dom.defaultView), zo = (l) => re.from(l.dom.parentNode).map(ve.fromDom), Ds = (l) => re.from(l.dom.parentElement).map(ve.fromDom), Ra = (l, m) => {
      const h = Qt(m) ? m : gn;
      let v = l.dom;
      const T = [];
      for (; v.parentNode !== null && v.parentNode !== void 0; ) {
        const O = v.parentNode, $ = ve.fromDom(O);
        if (T.push($), h($) === !0)
          break;
        v = O;
      }
      return T;
    }, ac = (l) => re.from(l.dom.previousSibling).map(ve.fromDom), vc = (l) => re.from(l.dom.nextSibling).map(ve.fromDom), lo = (l) => rn(l.dom.childNodes, ve.fromDom), Fo = (l, m) => {
      const h = l.dom.childNodes;
      return re.from(h[m]).map(ve.fromDom);
    }, ms = (l) => Fo(l, 0), xa = (l, m) => {
      zo(l).each((v) => {
        v.dom.insertBefore(m.dom, l.dom);
      });
    }, zr = (l, m) => {
      vc(l).fold(() => {
        zo(l).each((T) => {
          Hs(T, m);
        });
      }, (v) => {
        xa(v, m);
      });
    }, mr = (l, m) => {
      ms(l).fold(() => {
        Hs(l, m);
      }, (v) => {
        l.dom.insertBefore(m.dom, v.dom);
      });
    }, Hs = (l, m) => {
      l.dom.appendChild(m.dom);
    }, Fa = (l, m, h) => {
      Fo(l, h).fold(() => {
        Hs(l, m);
      }, (v) => {
        xa(v, m);
      });
    }, nl = (l, m) => {
      xa(l, m), Hs(m, l);
    }, Rs = (l, m) => {
      Ye(m, (h, v) => {
        const T = v === 0 ? l : m[v - 1];
        zr(T, h);
      });
    }, ca = (l, m) => {
      Ye(m, (h) => {
        Hs(l, h);
      });
    }, Ia = (l) => {
      l.dom.textContent = "", Ye(lo(l), (m) => {
        Pr(m);
      });
    }, Pr = (l) => {
      const m = l.dom;
      m.parentNode !== null && m.parentNode.removeChild(m);
    }, yc = (l) => {
      const m = lo(l);
      m.length > 0 && Rs(l, m), Pr(l);
    }, Uc = (l, m) => ve.fromDom(l.dom.cloneNode(m)), Ta = (l) => Uc(l, !1), Ac = (l) => Uc(l, !0), Oc = (l, m) => {
      const h = ve.fromTag(m), v = ze(l);
      return Sa(h, v), h;
    }, vu = (l, m) => {
      const h = Oc(l, m), v = lo(Ac(l));
      return ca(h, v), h;
    }, Dc = (l, m) => {
      const h = Oc(l, m);
      zr(l, h);
      const v = lo(l);
      return ca(h, v), Pr(l), h;
    }, yl = [
      "tfoot",
      "thead",
      "tbody",
      "colgroup"
    ], ja = (l) => mn(yl, l), wi = (l, m) => ({
      rows: l,
      columns: m
    }), Bi = (l, m) => ({
      row: l,
      column: m
    }), Cl = (l, m, h) => ({
      element: l,
      rowspan: m,
      colspan: h
    }), Ju = (l, m, h, v) => ({
      element: l,
      rowspan: m,
      colspan: h,
      isNew: v
    }), Z = (l, m, h, v, T, O) => ({
      element: l,
      rowspan: m,
      colspan: h,
      row: v,
      column: T,
      isLocked: O
    }), fe = (l, m, h) => ({
      element: l,
      cells: m,
      section: h
    }), _e = (l, m, h, v) => ({
      element: l,
      cells: m,
      section: h,
      isNew: v
    }), Ve = (l, m, h) => ({
      element: l,
      isNew: m,
      isLocked: h
    }), Rt = (l, m, h, v) => ({
      element: l,
      cells: m,
      section: h,
      isNew: v
    }), eo = (l, m, h, v) => ({
      startRow: l,
      startCol: m,
      finishRow: h,
      finishCol: v
    }), Ns = (l, m, h) => ({
      element: l,
      colspan: m,
      column: h
    }), Is = (l, m) => ({
      element: l,
      columns: m
    }), Os = (l) => _c(l) && Zt(l.dom.host), Ys = Qt(Element.prototype.attachShadow) && Qt(Node.prototype.getRootNode), qo = J(Ys), fr = Ys ? (l) => ve.fromDom(l.dom.getRootNode()) : Dn, Na = (l) => {
      const m = fr(l);
      return Os(m) ? re.some(m) : re.none();
    }, ol = (l) => ve.fromDom(l.dom.host), sn = (l) => {
      if (qo() && Zt(l.target)) {
        const m = ve.fromDom(l.target);
        if (dr(m) && Ql(m) && l.composed && l.composedPath) {
          const h = l.composedPath();
          if (h)
            return ae(h);
        }
      }
      return re.from(l.target);
    }, Ql = (l) => Zt(l.dom.shadowRoot), rr = (l) => {
      const m = ga(l) ? l.dom.parentNode : l.dom;
      if (m == null || m.ownerDocument === null)
        return !1;
      const h = m.ownerDocument;
      return Na(ve.fromDom(m)).fold(() => h.body.contains(m), Kt(rr, ol));
    }, B = () => K(ve.fromDom(document)), K = (l) => {
      const m = l.dom.body;
      if (m == null)
        throw new Error("Body is not available yet");
      return ve.fromDom(m);
    }, se = (l, m, h) => bt(Ra(l, h), m), Ue = (l, m) => bt(lo(l), m), en = (l, m) => {
      let h = [];
      return Ye(lo(l), (v) => {
        m(v) && (h = h.concat([v])), h = h.concat(en(v, m));
      }), h;
    }, Io = (l, m, h) => se(l, (v) => go(v, m), h), _n = (l, m) => Ue(l, (h) => go(h, m)), gr = (l, m) => he(m, l);
    var _t = (l, m, h, v, T) => l(h, v) ? re.some(h) : Qt(T) && T(h) ? re.none() : m(h, v, T);
    const Us = (l, m, h) => {
      let v = l.dom;
      const T = Qt(h) ? h : gn;
      for (; v.parentNode; ) {
        v = v.parentNode;
        const O = ve.fromDom(v);
        if (m(O))
          return re.some(O);
        if (T(O))
          break;
      }
      return re.none();
    }, qa = (l, m, h) => _t((T, O) => O(T), Us, l, m, h), Xs = (l, m) => {
      const h = (T) => m(ve.fromDom(T));
      return F(l.dom.childNodes, h).map(ve.fromDom);
    }, Zr = (l, m) => {
      const h = (v) => {
        for (let T = 0; T < v.childNodes.length; T++) {
          const O = ve.fromDom(v.childNodes[T]);
          if (m(O))
            return re.some(O);
          const $ = h(v.childNodes[T]);
          if ($.isSome())
            return $;
        }
        return re.none();
      };
      return h(l.dom);
    }, ri = (l, m, h) => Us(l, (v) => go(v, m), h), Jo = (l, m) => Xs(l, (h) => go(h, m)), Ga = (l, m) => dt(m, l), ar = (l, m, h) => _t((T, O) => go(T, O), ri, l, m, h), $i = (l, m, h = xo) => l.exists((v) => h(v, m)), hr = (l) => {
      const m = [], h = (v) => {
        m.push(v);
      };
      for (let v = 0; v < l.length; v++)
        l[v].each(h);
      return m;
    }, yu = (l, m) => l != null ? m(l) : re.none(), um = (l, m) => l ? re.some(m) : re.none(), Xm = (l, m, h) => m === "" || l.length >= m.length && l.substr(h, h + m.length) === m, Es = (l, m, h = 0, v) => {
      const T = l.indexOf(m, h);
      return T !== -1 ? Sn(v) ? !0 : T + m.length <= v : !1;
    }, ai = (l, m) => Xm(l, m, 0), Fi = (l, m) => Xm(l, m, l.length - m.length), Rc = ((l) => (m) => m.replace(l, ""))(/^\s+|\s+$/g), Qu = (l) => l.length > 0, Qo = (l) => {
      const m = parseFloat(l);
      return isNaN(m) ? re.none() : re.some(m);
    }, j = (l) => l.style !== void 0 && Qt(l.style.getPropertyValue), oe = (l, m, h) => {
      if (!Fe(h))
        throw new Error("CSS value must be a string: " + h);
      j(l) && l.style.setProperty(m, h);
    }, Le = (l, m) => {
      j(l) && l.style.removeProperty(m);
    }, je = (l, m, h) => {
      const v = l.dom;
      oe(v, m, h);
    }, yn = (l, m) => {
      const h = l.dom;
      Xe(m, (v, T) => {
        oe(h, T, v);
      });
    }, vo = (l, m) => {
      const h = l.dom, T = window.getComputedStyle(h).getPropertyValue(m);
      return T === "" && !rr(l) ? Dr(h, m) : T;
    }, Dr = (l, m) => j(l) ? l.style.getPropertyValue(m) : "", Ka = (l, m) => {
      const h = l.dom, v = Dr(h, m);
      return re.from(v).filter((T) => T.length > 0);
    }, pr = (l, m) => {
      const h = l.dom;
      Le(h, m), $i(de(l, "style").map(Rc), "") && ie(l, "style");
    }, cc = (l, m) => {
      const h = l.dom, v = m.dom;
      j(h) && j(v) && (v.style.cssText = h.style.cssText);
    }, ks = (l, m, h = 0) => de(l, m).map((v) => parseInt(v, 10)).getOr(h), Br = (l, m) => ks(l, m, 1), ia = (l) => sr("col")(l) ? ks(l, "span", 1) > 1 : Br(l, "colspan") > 1, wc = (l) => Br(l, "rowspan") > 1, ea = (l, m) => parseInt(vo(l, m), 10), _r = J(10), Vr = J(10), Nc = (l, m) => Ii(l, m, De), Ii = (l, m, h) => at(lo(l), (v) => go(v, m) ? h(v) ? [v] : [] : Ii(v, m, h)), Jm = (l, m, h = gn) => {
      if (h(m))
        return re.none();
      if (mn(l, xs(m)))
        return re.some(m);
      const v = (T) => go(T, "table") || h(T);
      return ri(m, l.join(","), v);
    }, Qm = (l, m) => Jm([
      "td",
      "th"
    ], l, m), Wc = (l) => Nc(l, "th,td"), ef = (l) => go(l, "colgroup") ? _n(l, "col") : at(tf(l), (m) => _n(m, "col")), Zc = (l, m) => ar(l, "table", m), wl = (l) => Nc(l, "tr"), tf = (l) => Zc(l).fold(J([]), (m) => _n(m, "colgroup")), Cu = (l, m) => rn(l, (h) => {
      if (xs(h) === "colgroup") {
        const v = rn(ef(h), (T) => {
          const O = ks(T, "span", 1);
          return Cl(T, 1, O);
        });
        return fe(h, v, "colgroup");
      } else {
        const v = rn(Wc(h), (T) => {
          const O = ks(T, "rowspan", 1), $ = ks(T, "colspan", 1);
          return Cl(T, O, $);
        });
        return fe(h, v, m(h));
      }
    }), dm = (l) => zo(l).map((m) => {
      const h = xs(m);
      return ja(h) ? h : "tbody";
    }).getOr("tbody"), Sl = (l) => {
      const m = wl(l), v = [
        ...tf(l),
        ...m
      ];
      return Cu(v, dm);
    }, oh = (l, m) => Cu(l, () => m), wu = (l) => {
      let m = !1, h;
      return (...v) => (m || (m = !0, h = l.apply(null, v)), h);
    }, sh = (l, m, h, v) => {
      const T = l.isiOS() && /ipad/i.test(h) === !0, O = l.isiOS() && !T, $ = l.isiOS() || l.isAndroid(), W = $ || v("(pointer:coarse)"), Q = T || !O && $ && v("(min-device-width:768px)"), ge = O || $ && !Q, Re = m.isSafari() && l.isiOS() && /safari/i.test(h) === !1, Et = !ge && !Q && !Re;
      return {
        isiPad: J(T),
        isiPhone: J(O),
        isTablet: J(Q),
        isPhone: J(ge),
        isTouch: J(W),
        isAndroid: l.isAndroid,
        isiOS: l.isiOS,
        isWebView: J(Re),
        isDesktop: J(Et)
      };
    }, rh = (l, m) => {
      for (let h = 0; h < l.length; h++) {
        const v = l[h];
        if (v.test(m))
          return v;
      }
    }, ah = (l, m) => {
      const h = rh(l, m);
      if (!h)
        return {
          major: 0,
          minor: 0
        };
      const v = (T) => Number(m.replace(h, "$" + T));
      return le(v(1), v(2));
    }, Ad = (l, m) => {
      const h = String(m).toLowerCase();
      return l.length === 0 ? o1() : ah(l, h);
    }, o1 = () => le(0, 0), le = (l, m) => ({
      major: l,
      minor: m
    }), Su = {
      nu: le,
      detect: Ad,
      unknown: o1
    }, Si = (l, m) => Vn(m.brands, (h) => {
      const v = h.brand.toLowerCase();
      return F(l, (T) => {
        var O;
        return v === ((O = T.brand) === null || O === void 0 ? void 0 : O.toLowerCase());
      }).map((T) => ({
        current: T.name,
        version: Su.nu(parseInt(h.version, 10), 0)
      }));
    }), Od = (l, m) => {
      const h = String(m).toLowerCase();
      return F(l, (v) => v.search(h));
    }, tg = (l, m) => Od(l, m).map((h) => {
      const v = Su.detect(h.versionRegexes, m);
      return {
        current: h.name,
        version: v
      };
    }), s1 = (l, m) => Od(l, m).map((h) => {
      const v = Su.detect(h.versionRegexes, m);
      return {
        current: h.name,
        version: v
      };
    }), fs = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/, ic = (l) => (m) => Es(m, l), xl = [
      {
        name: "Edge",
        versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
        search: (l) => Es(l, "edge/") && Es(l, "chrome") && Es(l, "safari") && Es(l, "applewebkit")
      },
      {
        name: "Chromium",
        brand: "Chromium",
        versionRegexes: [
          /.*?chrome\/([0-9]+)\.([0-9]+).*/,
          fs
        ],
        search: (l) => Es(l, "chrome") && !Es(l, "chromeframe")
      },
      {
        name: "IE",
        versionRegexes: [
          /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
          /.*?rv:([0-9]+)\.([0-9]+).*/
        ],
        search: (l) => Es(l, "msie") || Es(l, "trident")
      },
      {
        name: "Opera",
        versionRegexes: [
          fs,
          /.*?opera\/([0-9]+)\.([0-9]+).*/
        ],
        search: ic("opera")
      },
      {
        name: "Firefox",
        versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
        search: ic("firefox")
      },
      {
        name: "Safari",
        versionRegexes: [
          fs,
          /.*?cpu os ([0-9]+)_([0-9]+).*/
        ],
        search: (l) => (Es(l, "safari") || Es(l, "mobile/")) && Es(l, "applewebkit")
      }
    ], xi = [
      {
        name: "Windows",
        search: ic("win"),
        versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: "iOS",
        search: (l) => Es(l, "iphone") || Es(l, "ipad"),
        versionRegexes: [
          /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
          /.*cpu os ([0-9]+)_([0-9]+).*/,
          /.*cpu iphone os ([0-9]+)_([0-9]+).*/
        ]
      },
      {
        name: "Android",
        search: ic("android"),
        versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: "macOS",
        search: ic("mac os x"),
        versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
      },
      {
        name: "Linux",
        search: ic("linux"),
        versionRegexes: []
      },
      {
        name: "Solaris",
        search: ic("sunos"),
        versionRegexes: []
      },
      {
        name: "FreeBSD",
        search: ic("freebsd"),
        versionRegexes: []
      },
      {
        name: "ChromeOS",
        search: ic("cros"),
        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
      }
    ], xu = {
      browsers: J(xl),
      oses: J(xi)
    }, sl = "Edge", lc = "Chromium", Tl = "IE", ch = "Opera", r1 = "Firefox", Li = "Safari", El = () => ng({
      current: void 0,
      version: Su.unknown()
    }), ng = (l) => {
      const m = l.current, h = l.version, v = (T) => () => m === T;
      return {
        current: m,
        version: h,
        isEdge: v(sl),
        isChromium: v(lc),
        isIE: v(Tl),
        isOpera: v(ch),
        isFirefox: v(r1),
        isSafari: v(Li)
      };
    }, Sc = {
      unknown: El,
      nu: ng
    }, Ea = "Windows", ed = "iOS", mm = "Android", rl = "Linux", Mc = "macOS", ih = "Solaris", a1 = "FreeBSD", nf = "ChromeOS", of = () => Dd({
      current: void 0,
      version: Su.unknown()
    }), Dd = (l) => {
      const m = l.current, h = l.version, v = (T) => () => m === T;
      return {
        current: m,
        version: h,
        isWindows: v(Ea),
        isiOS: v(ed),
        isAndroid: v(mm),
        isMacOS: v(Mc),
        isLinux: v(rl),
        isSolaris: v(ih),
        isFreeBSD: v(a1),
        isChromeOS: v(nf)
      };
    }, kl = {
      unknown: of,
      nu: Dd
    }, Yb = { detect: (l, m, h) => {
      const v = xu.browsers(), T = xu.oses(), O = m.bind((Q) => Si(v, Q)).orThunk(() => tg(v, l)).fold(Sc.unknown, Sc.nu), $ = s1(T, l).fold(kl.unknown, kl.nu), W = sh($, O, l, h);
      return {
        browser: O,
        os: $,
        deviceType: W
      };
    } }, og = (l) => window.matchMedia(l).matches;
    let c1 = wu(() => Yb.detect(navigator.userAgent, re.from(navigator.userAgentData), og));
    const Tu = () => c1(), sg = (l, m) => {
      const h = (W, Q) => {
        if (!En(Q) && !Q.match(/^[0-9]+$/))
          throw new Error(l + ".set accepts only positive integer values. Value was " + Q);
        const ge = W.dom;
        j(ge) && (ge.style[l] = Q + "px");
      }, v = (W) => {
        const Q = m(W);
        if (Q <= 0 || Q === null) {
          const ge = vo(W, l);
          return parseFloat(ge) || 0;
        }
        return Q;
      }, T = v, O = (W, Q) => $e(Q, (ge, Re) => {
        const Et = vo(W, Re), an = Et === void 0 ? 0 : parseInt(Et, 10);
        return isNaN(an) ? ge : ge + an;
      }, 0);
      return {
        set: h,
        get: v,
        getOuter: T,
        aggregate: O,
        max: (W, Q, ge) => {
          const Re = O(W, ge);
          return Q > Re ? Q - Re : 0;
        }
      };
    }, td = (l, m) => Qo(l).getOr(m), Rr = (l, m, h) => td(vo(l, m), h), Ar = (l, m, h, v) => {
      const T = Rr(l, `padding-${h}`, 0), O = Rr(l, `padding-${v}`, 0), $ = Rr(l, `border-${h}-width`, 0), W = Rr(l, `border-${v}-width`, 0);
      return m - T - O - $ - W;
    }, ci = (l, m) => {
      const h = l.dom, v = h.getBoundingClientRect().width || h.offsetWidth;
      return Ar(l, v, "left", "right");
    }, sf = (l) => Rr(l, "height", l.dom.offsetHeight), uh = (l) => Rr(l, "width", l.dom.offsetWidth), La = (l) => ci(l), _l = sg("width", (l) => l.dom.offsetWidth), ii = (l) => _l.get(l), Hi = (l) => _l.getOuter(l), dh = La, Mo = uh, jc = (l, m, h) => {
      const v = l.cells, T = v.slice(0, m), O = v.slice(m), $ = T.concat(h).concat(O);
      return rg(l, $);
    }, Eu = (l, m, h) => jc(l, m, [h]), nd = (l, m, h) => {
      const v = l.cells;
      v[m] = h;
    }, rg = (l, m) => Rt(l.element, m, l.section, l.isNew), rf = (l, m) => {
      const h = l.cells, v = rn(h, m);
      return Rt(l.element, v, l.section, l.isNew);
    }, Ya = (l, m) => l.cells[m], ha = (l, m) => Ya(l, m).element, li = (l) => l.cells.length, ta = (l) => {
      const m = jo(l, (h) => h.section === "colgroup");
      return {
        rows: m.fail,
        cols: m.pass
      };
    }, fm = (l, m, h) => {
      const v = rn(l.cells, h);
      return Rt(m(l.element), v, l.section, !0);
    }, od = "data-snooker-locked-cols", na = (l) => de(l, od).bind((m) => re.from(m.match(/\d+/g))).map((m) => ee(m, De)), ka = (l) => {
      const m = $e(ta(l).rows, (v, T) => (Ye(T.cells, (O, $) => {
        O.isLocked && (v[$] = !0);
      }), v), {}), h = No(m, (v, T) => parseInt(T, 10));
      return pe(h);
    }, Ti = (l, m) => l + "," + m, gm = (l, m, h) => re.from(l.access[Ti(m, h)]), la = (l, m, h) => {
      const v = ag(l, (T) => h(m, T.element));
      return v.length > 0 ? re.some(v[0]) : re.none();
    }, ag = (l, m) => {
      const h = at(l.all, (v) => v.cells);
      return bt(h, m);
    }, af = (l) => {
      const m = {};
      let h = 0;
      return Ye(l.cells, (v) => {
        const T = v.colspan;
        Gn(T, (O) => {
          const $ = h + O;
          m[$] = Ns(v.element, T, $);
        }), h += T;
      }), m;
    }, Ms = (l) => {
      const m = {}, h = [], T = ae(l).map((tn) => tn.element).bind(Zc).bind(na).getOr({});
      let O = 0, $ = 0, W = 0;
      const {
        pass: Q,
        fail: ge
      } = jo(l, (tn) => tn.section === "colgroup");
      Ye(ge, (tn) => {
        const ft = [];
        Ye(tn.cells, (cn) => {
          let ut = 0;
          for (; m[Ti(W, ut)] !== void 0; )
            ut++;
          const $n = et(T, ut.toString()), wo = Z(cn.element, cn.rowspan, cn.colspan, W, ut, $n);
          for (let Ho = 0; Ho < cn.colspan; Ho++)
            for (let Mr = 0; Mr < cn.rowspan; Mr++) {
              const oc = W + Mr, ma = ut + Ho, Gi = Ti(oc, ma);
              m[Gi] = wo, $ = Math.max($, ma + 1);
            }
          ft.push(wo);
        }), O++, h.push(fe(tn.element, ft, tn.section)), W++;
      });
      const { columns: Re, colgroups: Et } = kt(Q).map((tn) => {
        const ft = af(tn);
        return {
          colgroups: [Is(tn.element, Ao(ft))],
          columns: ft
        };
      }).getOrThunk(() => ({
        colgroups: [],
        columns: {}
      }));
      return {
        grid: wi(O, $),
        access: m,
        all: h,
        columns: Re,
        colgroups: Et
      };
    }, Wo = {
      fromTable: (l) => {
        const m = Sl(l);
        return Ms(m);
      },
      generate: Ms,
      getAt: gm,
      findItem: la,
      filterItems: ag,
      justCells: (l) => at(l.all, (m) => m.cells),
      justColumns: (l) => Ao(l.columns),
      hasColumns: (l) => Yt(l.columns).length > 0,
      getColumnAt: (l, m) => re.from(l.columns[m])
    }, sd = (l, m = De) => {
      const h = l.grid, v = Gn(h.columns, Qe), T = Gn(h.rows, Qe);
      return rn(v, (O) => mh(() => at(T, (ge) => Wo.getAt(l, ge, O).filter((Re) => Re.column === O).toArray()), (ge) => ge.colspan === 1 && m(ge.element), () => Wo.getAt(l, 0, O)));
    }, mh = (l, m, h) => {
      const v = l();
      return F(v, m).orThunk(() => re.from(v[0]).orThunk(h)).map(($) => $.element);
    }, cg = (l) => {
      const m = l.grid, h = Gn(m.rows, Qe), v = Gn(m.columns, Qe);
      return rn(h, (T) => mh(() => at(v, (Q) => Wo.getAt(l, T, Q).filter((ge) => ge.row === T).fold(J([]), (ge) => [ge])), (Q) => Q.rowspan === 1, () => Wo.getAt(l, T, 0)));
    }, fh = (l, m) => {
      if (m < 0 || m >= l.length - 1)
        return re.none();
      const h = l[m].fold(() => {
        const T = Rn(l.slice(0, m));
        return Vn(T, (O, $) => O.map((W) => ({
          value: W,
          delta: $ + 1
        })));
      }, (T) => re.some({
        value: T,
        delta: 0
      })), v = l[m + 1].fold(() => {
        const T = l.slice(m + 1);
        return Vn(T, (O, $) => O.map((W) => ({
          value: W,
          delta: $ + 1
        })));
      }, (T) => re.some({
        value: T,
        delta: 1
      }));
      return h.bind((T) => v.map((O) => {
        const $ = O.delta + T.delta;
        return Math.abs(O.value - T.value) / $;
      }));
    }, ig = (l, m) => (h) => i1(h) === "rtl" ? m : l, i1 = (l) => vo(l, "direction") === "rtl" ? "rtl" : "ltr", Rd = sg("height", (l) => {
      const m = l.dom;
      return rr(l) ? m.getBoundingClientRect().height : m.offsetHeight;
    }), lg = (l) => Rd.get(l), x = (l) => Rd.getOuter(l), R = sf, z = (l, m) => ({
      left: l,
      top: m,
      translate: (v, T) => z(l + v, m + T)
    }), ce = z, be = (l) => {
      const m = l.getBoundingClientRect();
      return ce(m.left, m.top);
    }, At = (l, m) => l !== void 0 ? l : m !== void 0 ? m : 0, Bn = (l) => {
      const m = l.dom.ownerDocument, h = m.body, v = m.defaultView, T = m.documentElement;
      if (h === l.dom)
        return ce(h.offsetLeft, h.offsetTop);
      const O = At(v?.pageYOffset, T.scrollTop), $ = At(v?.pageXOffset, T.scrollLeft), W = At(T.clientTop, h.clientTop), Q = At(T.clientLeft, h.clientLeft);
      return To(l).translate($ - Q, O - W);
    }, To = (l) => {
      const m = l.dom, v = m.ownerDocument.body;
      return v === m ? ce(v.offsetLeft, v.offsetTop) : rr(l) ? be(m) : ce(0, 0);
    }, Co = (l, m) => ({
      row: l,
      y: m
    }), ao = (l, m) => ({
      col: l,
      x: m
    }), Nr = (l) => Bn(l).left + Hi(l), Ma = (l) => Bn(l).left, ki = (l, m) => ao(l, Ma(m)), eu = (l, m) => ao(l, Nr(m)), uc = (l) => Bn(l).top, by = (l, m) => Co(l, uc(m)), br = (l, m) => Co(l, uc(m) + x(m)), jn = (l, m, h) => {
      if (h.length === 0)
        return [];
      const v = rn(h.slice(1), (O, $) => O.map((W) => l($, W))), T = h[h.length - 1].map((O) => m(h.length - 1, O));
      return v.concat([T]);
    }, tu = (l) => -l, xn = {
      delta: Qe,
      positions: (l) => jn(by, br, l),
      edge: uc
    }, Ou = ig({
      delta: Qe,
      edge: Ma,
      positions: (l) => jn(ki, eu, l)
    }, {
      delta: tu,
      edge: Nr,
      positions: (l) => jn(eu, ki, l)
    }), ua = {
      delta: (l, m) => Ou(m).delta(l, m),
      positions: (l, m) => Ou(m).positions(l, m),
      edge: (l) => Ou(l).edge(l)
    }, hm = {
      unsupportedLength: [
        "em",
        "ex",
        "cap",
        "ch",
        "ic",
        "rem",
        "lh",
        "rlh",
        "vw",
        "vh",
        "vi",
        "vb",
        "vmin",
        "vmax",
        "cm",
        "mm",
        "Q",
        "in",
        "pc",
        "pt",
        "px"
      ],
      fixed: [
        "px",
        "pt"
      ],
      relative: ["%"],
      empty: [""]
    }, ug = (() => {
      const l = "[0-9]+", h = "[eE]" + ("[+-]?" + l), v = "\\.", T = (W) => `(?:${W})?`, $ = `[+-]?(?:${[
        "Infinity",
        l + v + T(l) + T(h),
        v + l + T(h),
        l + T(h)
      ].join("|")})`;
      return new RegExp(`^(${$})(.*)$`);
    })(), Xa = (l, m) => it(m, (h) => it(hm[h], (v) => l === v)), nu = (l, m) => re.from(ug.exec(l)).bind((v) => {
      const T = Number(v[1]), O = v[2];
      return Xa(O, m) ? re.some({
        value: T,
        unit: O
      }) : re.none();
    }), gh = /(\d+(\.\d+)?)%/, Du = /(\d+(\.\d+)?)px|em/, l1 = sr("col"), hh = (l, m, h) => {
      const v = Ds(l).getOrThunk(() => K(On(l)));
      return m(l) / h(v) * 100;
    }, Mt = (l, m) => {
      je(l, "width", m + "px");
    }, Xb = (l, m) => {
      je(l, "width", m + "%");
    }, Nd = (l, m) => {
      je(l, "height", m + "px");
    }, rd = (l) => R(l) + "px", dg = (l, m, h, v) => {
      const T = Zc(l).map((O) => {
        const $ = h(O);
        return Math.floor(m / 100 * $);
      }).getOr(m);
      return v(l, T), T;
    }, $r = (l, m, h, v) => {
      const T = parseFloat(l);
      return Fi(l, "%") && xs(m) !== "table" ? dg(m, T, h, v) : T;
    }, Js = (l) => {
      const m = rd(l);
      return m ? $r(m, l, lg, Nd) : lg(l);
    }, Gc = (l, m, h) => {
      const v = h(l), T = Br(l, m);
      return v / T;
    }, Kc = (l, m) => Ka(l, m).orThunk(() => de(l, m).map((h) => h + "px")), es = (l) => Kc(l, "width"), mg = (l) => Kc(l, "height"), dc = (l) => hh(l, ii, dh), oa = (l) => l1(l) ? ii(l) : Mo(l), ph = (l) => Gc(l, "rowspan", Js), gt = (l) => es(l).bind((h) => nu(h, [
      "fixed",
      "relative",
      "empty"
    ])), _i = (l, m, h) => {
      je(l, "width", m + h);
    }, fg = (l) => ii(l) + "px", _s = (l) => hh(l, ii, dh) + "%", Al = (l) => es(l).exists((m) => gh.test(m)), yy = (l) => es(l).exists((m) => Du.test(m)), ou = (l) => es(l).isNone(), bh = J(gh), su = sr("col"), u1 = (l) => es(l).getOrThunk(() => oa(l) + "px"), zi = (l) => mg(l).getOrThunk(() => ph(l) + "px"), $s = (l) => rn(Wo.justColumns(l), (m) => re.from(m.element)), Ru = (l) => {
      const m = Tu().browser, h = m.isChromium() || m.isFirefox();
      return su(l) ? h : !0;
    }, pm = (l, m, h, v, T, O) => l.filter(v).fold(() => O(fh(h, m)), ($) => T($)), mc = (l, m, h, v) => {
      const T = sd(l), O = Wo.hasColumns(l) ? $s(l) : T, $ = [re.some(ua.edge(m))].concat(rn(ua.positions(T, m), (Q) => Q.map((ge) => ge.x))), W = U(ia);
      return rn(O, (Q, ge) => pm(Q, ge, $, W, (Re) => {
        if (Ru(Re))
          return h(Re);
        {
          const Et = yu(T[ge], Qe);
          return pm(Et, ge, $, W, (an) => v(re.some(ii(an))), v);
        }
      }, v));
    }, d1 = (l) => l.map((m) => m + "px").getOr(""), bm = (l, m) => mc(l, m, u1, d1), Md = (l, m, h) => mc(l, m, dc, (v) => v.fold(() => h.minCellWidth(), (T) => T / h.pixelWidth() * 100)), ui = (l, m, h) => mc(l, m, oa, (v) => v.getOrThunk(h.minCellWidth)), Pd = (l, m, h, v, T) => {
      const O = cg(l), $ = [re.some(h.edge(m))].concat(rn(h.positions(O, m), (W) => W.map((Q) => Q.y)));
      return rn(O, (W, Q) => pm(W, Q, $, U(wc), v, T));
    }, Ne = (l, m, h) => Pd(l, m, h, ph, (v) => v.getOrThunk(Vr)), Pc = (l, m, h) => Pd(l, m, h, zi, d1), al = (l, m) => () => rr(l) ? m(l) : parseFloat(Ka(l, "width").getOr("0")), ru = (l) => {
      const m = al(l, ii), h = J(0);
      return {
        width: m,
        pixelWidth: m,
        getWidths: (T, O) => ui(T, l, O),
        getCellDelta: h,
        singleColumnWidth: J([0]),
        minCellWidth: h,
        setElementWidth: st,
        adjustTableWidth: st,
        isRelative: !0,
        label: "none"
      };
    }, Ai = (l) => {
      const m = al(l, (Q) => parseFloat(_s(Q))), h = al(l, ii);
      return {
        width: m,
        pixelWidth: h,
        getWidths: (Q, ge) => Md(Q, l, ge),
        getCellDelta: (Q) => Q / h() * 100,
        singleColumnWidth: (Q, ge) => [100 - Q],
        minCellWidth: () => _r() / h() * 100,
        setElementWidth: Xb,
        adjustTableWidth: (Q) => {
          const ge = m(), Re = Q / 100 * ge, Et = ge + Re;
          Xb(l, Et);
        },
        isRelative: !0,
        label: "percent"
      };
    }, Pa = (l) => {
      const m = al(l, ii);
      return {
        width: m,
        pixelWidth: m,
        getWidths: ($, W) => ui($, l, W),
        getCellDelta: Qe,
        singleColumnWidth: ($, W) => [Math.max(_r(), $ + W) - $],
        minCellWidth: _r,
        setElementWidth: Mt,
        adjustTableWidth: ($) => {
          const W = m() + $;
          Mt(l, W);
        },
        isRelative: !1,
        label: "pixel"
      };
    }, _a = (l, m) => bh().exec(m) !== null ? Ai(l) : Pa(l), di = {
      getTableSize: (l) => es(l).fold(() => ru(l), (h) => _a(l, h)),
      pixelSize: Pa,
      percentageSize: Ai,
      noneSize: ru
    }, Nu = (l, m, h, v, T, O) => ({
      minRow: l,
      minCol: m,
      maxRow: h,
      maxCol: v,
      allCells: T,
      selectedCells: O
    }), w = (l, m) => {
      const h = l.grid.columns;
      let T = l.grid.rows, O = h, $ = 0, W = 0;
      const Q = [], ge = [];
      return Xe(l.access, (Re) => {
        if (Q.push(Re), m(Re)) {
          ge.push(Re);
          const Et = Re.row, an = Et + Re.rowspan - 1, tn = Re.column, ft = tn + Re.colspan - 1;
          Et < T ? T = Et : an > $ && ($ = an), tn < O ? O = tn : ft > W && (W = ft);
        }
      }), Nu(T, O, $, W, Q, ge);
    }, k = (l, m, h) => {
      const v = l[h].element, T = ve.fromTag("td");
      Hs(T, ve.fromTag("br")), (m ? Hs : mr)(v, T);
    }, H = (l, m, h, v) => {
      const T = bt(l, (W) => W.section !== "colgroup"), O = m.grid.columns, $ = m.grid.rows;
      for (let W = 0; W < $; W++) {
        let Q = !1;
        for (let ge = 0; ge < O; ge++)
          W < h.minRow || W > h.maxRow || ge < h.minCol || ge > h.maxCol || (Wo.getAt(m, W, ge).filter(v).isNone() ? k(T, Q, W) : Q = !0);
      }
    }, q = (l, m, h, v) => {
      Xe(h.columns, ($) => {
        ($.column < m.minCol || $.column > m.maxCol) && Pr($.element);
      });
      const T = bt(Nc(l, "tr"), ($) => $.dom.childElementCount === 0);
      Ye(T, Pr), (m.minCol === m.maxCol || m.minRow === m.maxRow) && Ye(Nc(l, "th,td"), ($) => {
        ie($, "rowspan"), ie($, "colspan");
      }), ie(l, od), ie(l, "data-snooker-col-series"), di.getTableSize(l).adjustTableWidth(v);
    }, we = (l, m, h, v) => {
      if (v.minCol === 0 && m.grid.columns === v.maxCol + 1)
        return 0;
      const T = ui(m, l, h), O = $e(T, (ge, Re) => ge + Re, 0), Q = $e(T.slice(v.minCol, v.maxCol + 1), (ge, Re) => ge + Re, 0) / O * h.pixelWidth() - h.pixelWidth();
      return h.getCellDelta(Q);
    }, rt = (l, m) => {
      const h = (an) => go(an.element, m), v = Ac(l), T = Sl(v), O = di.getTableSize(l), $ = Wo.generate(T), W = w($, h), Q = "th:not(" + m + "),td:not(" + m + ")", ge = Ii(v, "th,td", (an) => go(an, Q));
      Ye(ge, Pr), H(T, $, W, h);
      const Re = Wo.fromTable(l), Et = we(l, Re, O, W);
      return q(v, W, $, Et), v;
    }, $t = " ", oo = ((l, m) => {
      const h = (O) => {
        if (!l(O))
          throw new Error("Can only get " + m + " value of a " + m + " node");
        return v(O).getOr("");
      }, v = (O) => l(O) ? re.from(O.dom.nodeValue) : re.none();
      return {
        get: h,
        getOption: v,
        set: (O, $) => {
          if (!l(O))
            throw new Error("Can only set raw " + m + " value of a " + m + " node");
          O.dom.nodeValue = $;
        }
      };
    })(ga, "text"), Jn = (l) => oo.get(l), Fr = (l) => oo.getOption(l), Sr = (l, m) => oo.set(l, m), Ws = (l) => xs(l) === "img" ? 1 : Fr(l).fold(() => lo(l).length, (m) => m.length), Yc = (l) => Fr(l).filter((m) => m.trim().length !== 0 || m.indexOf($t) > -1).isSome(), au = (l) => Zn(l) && wr(l, "contenteditable") === "false", Vi = [
      "img",
      "br"
    ], Ol = (l) => Yc(l) || mn(Vi, xs(l)) || au(l), vh = (l) => Zr(l, Ol), Dl = (l) => cf(l, Ol), cf = (l, m) => {
      const h = (v) => {
        const T = lo(v);
        for (let O = T.length - 1; O >= 0; O--) {
          const $ = T[O];
          if (m($))
            return re.some($);
          const W = h($);
          if (W.isSome())
            return W;
        }
        return re.none();
      };
      return h(l);
    }, lf = {
      scope: [
        "row",
        "col"
      ]
    }, gg = (l) => () => {
      const m = ve.fromTag("td", l.dom);
      return Hs(m, ve.fromTag("br", l.dom)), m;
    }, uf = (l) => () => ve.fromTag("col", l.dom), Aa = (l) => () => ve.fromTag("colgroup", l.dom), Mu = (l) => () => ve.fromTag("tr", l.dom), df = (l, m, h) => {
      const v = vu(l, m);
      return Xe(h, (T, O) => {
        T === null ? ie(v, O) : Vs(v, O, T);
      }), v;
    }, as = (l) => l, Ur = (l, m, h) => vh(l).map((T) => {
      const O = h.join(","), $ = Io(T, O, (W) => wt(W, l));
      return kn($, (W, Q) => {
        const ge = Ta(Q);
        return Hs(W, ge), ge;
      }, m);
    }).getOr(m), Zs = (l, m) => {
      Xe(lf, (h, v) => de(l, v).filter((T) => mn(h, T)).each((T) => Vs(m, v, T)));
    }, Bc = (l, m, h) => {
      const v = ($, W) => {
        cc($.element, W), pr(W, "height"), $.colspan !== 1 && pr(W, "width");
      }, T = ($) => {
        const W = ve.fromTag(xs($.element), m.dom), Q = h.getOr([
          "strong",
          "em",
          "b",
          "i",
          "span",
          "font",
          "h1",
          "h2",
          "h3",
          "h4",
          "h5",
          "h6",
          "p",
          "div"
        ]), ge = Q.length > 0 ? Ur($.element, W, Q) : W;
        return Hs(ge, ve.fromTag("br")), v($, W), Zs($.element, W), l($.element, W), W;
      };
      return {
        col: ($) => {
          const W = ve.fromTag(xs($.element), m.dom);
          return v($, W), l($.element, W), W;
        },
        colgroup: Aa(m),
        row: Mu(m),
        cell: T,
        replace: df,
        colGap: uf(m),
        gap: gg(m)
      };
    }, mf = (l) => ({
      col: uf(l),
      colgroup: Aa(l),
      row: Mu(l),
      cell: gg(l),
      replace: as,
      colGap: uf(l),
      gap: gg(l)
    }), m1 = (l, m) => {
      const v = document.createElement("div");
      return v.innerHTML = l, lo(ve.fromDom(v));
    }, Rl = (l) => rn(l, ve.fromDom), $c = (l) => (m) => m.options.get(l), Jb = "100%", Pu = (l) => {
      var m;
      const h = l.dom, v = (m = h.getParent(l.selection.getStart(), h.isBlock)) !== null && m !== void 0 ? m : l.getBody();
      return dh(ve.fromDom(v)) + "px";
    }, ff = (l, m) => bg(l) || !cl(l) ? m : gf(l) ? {
      ...m,
      width: Pu(l)
    } : {
      ...m,
      width: Jb
    }, hg = (l, m) => bg(l) || cl(l) ? m : gf(l) ? {
      ...m,
      width: Pu(l)
    } : {
      ...m,
      width: Jb
    }, yh = (l) => {
      const m = l.options.register;
      m("table_clone_elements", { processor: "string[]" }), m("table_use_colgroups", {
        processor: "boolean",
        default: !0
      }), m("table_header_type", {
        processor: (h) => {
          const v = mn([
            "section",
            "cells",
            "sectionCells",
            "auto"
          ], h);
          return v ? {
            value: h,
            valid: v
          } : {
            valid: !1,
            message: "Must be one of: section, cells, sectionCells or auto."
          };
        },
        default: "section"
      }), m("table_sizing_mode", {
        processor: "string",
        default: "auto"
      }), m("table_default_attributes", {
        processor: "object",
        default: { border: "1" }
      }), m("table_default_styles", {
        processor: "object",
        default: { "border-collapse": "collapse" }
      }), m("table_column_resizing", {
        processor: (h) => {
          const v = mn([
            "preservetable",
            "resizetable"
          ], h);
          return v ? {
            value: h,
            valid: v
          } : {
            valid: !1,
            message: "Must be preservetable, or resizetable."
          };
        },
        default: "preservetable"
      }), m("table_resize_bars", {
        processor: "boolean",
        default: !0
      }), m("table_style_by_css", {
        processor: "boolean",
        default: !0
      }), m("table_merge_content_on_paste", {
        processor: "boolean",
        default: !0
      });
    }, vm = (l) => re.from(l.options.get("table_clone_elements")), vk = (l) => {
      const m = l.options.get("object_resizing");
      return mn(m.split(","), "table");
    }, pg = $c("table_header_type"), Cy = $c("table_column_resizing"), Mw = (l) => Cy(l) === "preservetable", pa = (l) => Cy(l) === "resizetable", Ch = $c("table_sizing_mode"), ym = (l) => Ch(l) === "relative", gf = (l) => Ch(l) === "fixed", bg = (l) => Ch(l) === "responsive", vg = $c("table_resize_bars"), cl = $c("table_style_by_css"), sa = $c("table_merge_content_on_paste"), ad = (l) => {
      const m = l.options, h = m.get("table_default_attributes");
      return m.isSet("table_default_attributes") ? h : hg(l, h);
    }, wy = (l) => {
      const m = l.options, h = m.get("table_default_styles");
      return m.isSet("table_default_styles") ? h : ff(l, h);
    }, f1 = $c("table_use_colgroups"), Qb = (l) => ar(l, "[contenteditable]"), hf = (l, m = !1) => rr(l) ? l.dom.isContentEditable : Qb(l).fold(J(m), (h) => g1(h) === "true"), g1 = (l) => l.dom.contentEditable, e0 = (l) => ve.fromDom(l.getBody()), Bd = (l) => (m) => wt(m, e0(l)), cd = (l) => {
      ie(l, "data-mce-style");
      const m = (h) => ie(h, "data-mce-style");
      Ye(Wc(l), m), Ye(ef(l), m), Ye(wl(l), m);
    }, Nl = (l) => ve.fromDom(l.selection.getStart()), pf = (l) => l.getBoundingClientRect().width, bf = (l) => l.getBoundingClientRect().height, Pw = (l, m) => {
      const h = l.dom.getStyle(m, "width") || l.dom.getAttrib(m, "width");
      return re.from(h).filter(Qu);
    }, t0 = (l) => /^(\d+(\.\d+)?)%$/.test(l), h1 = (l) => /^(\d+(\.\d+)?)px$/.test(l), n0 = (l) => qa(l, sr("table")).exists(hf), Bw = (l, m) => {
      const h = m.column, v = m.column + m.colspan - 1, T = m.row, O = m.row + m.rowspan - 1;
      return h <= l.finishCol && v >= l.startCol && T <= l.finishRow && O >= l.startRow;
    }, o0 = (l, m) => m.column >= l.startCol && m.column + m.colspan - 1 <= l.finishCol && m.row >= l.startRow && m.row + m.rowspan - 1 <= l.finishRow, p1 = (l, m) => {
      let h = !0;
      const v = ht(o0, m);
      for (let T = m.startRow; T <= m.finishRow; T++)
        for (let O = m.startCol; O <= m.finishCol; O++)
          h = h && Wo.getAt(l, T, O).exists(v);
      return h ? re.some(m) : re.none();
    }, b1 = (l, m) => eo(Math.min(l.row, m.row), Math.min(l.column, m.column), Math.max(l.row + l.rowspan - 1, m.row + m.rowspan - 1), Math.max(l.column + l.colspan - 1, m.column + m.colspan - 1)), cs = (l, m, h) => {
      const v = Wo.findItem(l, m, wt), T = Wo.findItem(l, h, wt);
      return v.bind((O) => T.map(($) => b1(O, $)));
    }, to = (l, m, h) => cs(l, m, h).bind((v) => p1(l, v)), Cm = (l, m, h, v) => Wo.findItem(l, m, wt).bind((T) => {
      const O = h > 0 ? T.row + T.rowspan - 1 : T.row, $ = v > 0 ? T.column + T.colspan - 1 : T.column;
      return Wo.getAt(l, O + h, $ + v).map((Q) => Q.element);
    }), s0 = (l, m, h) => cs(l, m, h).map((v) => {
      const T = Wo.filterItems(l, ht(Bw, v));
      return rn(T, (O) => O.element);
    }), v1 = (l, m) => {
      const h = (v, T) => on(T, v);
      return Wo.findItem(l, m, h).map((v) => v.element);
    }, yk = (l, m, h) => Zc(l).bind((v) => {
      const T = Ty(v);
      return Cm(T, l, m, h);
    }), Sy = (l, m, h) => {
      const v = Ty(l);
      return s0(v, m, h);
    }, vr = (l, m, h, v, T) => {
      const O = Ty(l), $ = wt(l, h) ? re.some(m) : v1(O, m), W = wt(l, T) ? re.some(v) : v1(O, v);
      return $.bind((Q) => W.bind((ge) => s0(O, Q, ge)));
    }, xy = (l, m, h) => {
      const v = Ty(l);
      return to(v, m, h);
    }, Ty = Wo.fromTable;
    var Ey = [
      "body",
      "p",
      "div",
      "article",
      "aside",
      "figcaption",
      "figure",
      "footer",
      "header",
      "nav",
      "section",
      "ol",
      "ul",
      "li",
      "table",
      "thead",
      "tbody",
      "tfoot",
      "caption",
      "tr",
      "td",
      "th",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "blockquote",
      "pre",
      "address"
    ], mt = () => {
      const l = (ge) => ve.fromDom(ge.dom.cloneNode(!1)), m = (ge) => Dn(ge).dom, h = (ge) => dr(ge) ? xs(ge) === "body" ? !0 : mn(Ey, xs(ge)) : !1, v = (ge) => dr(ge) ? mn([
        "br",
        "img",
        "hr",
        "input"
      ], xs(ge)) : !1, T = (ge) => dr(ge) && wr(ge, "contenteditable") === "false", O = (ge, Re) => ge.dom.compareDocumentPosition(Re.dom), $ = (ge, Re) => {
        const Et = ze(ge);
        Sa(Re, Et);
      }, W = (ge) => {
        const Re = xs(ge);
        return mn([
          "script",
          "noscript",
          "iframe",
          "noframes",
          "noembed",
          "title",
          "style",
          "textarea",
          "xmp"
        ], Re);
      }, Q = (ge) => dr(ge) ? de(ge, "lang") : re.none();
      return {
        up: J({
          selector: ri,
          closest: ar,
          predicate: Us,
          all: Ra
        }),
        down: J({
          selector: gr,
          predicate: en
        }),
        styles: J({
          get: vo,
          getRaw: Ka,
          set: je,
          remove: pr
        }),
        attrs: J({
          get: wr,
          set: Vs,
          remove: ie,
          copyTo: $
        }),
        insert: J({
          before: xa,
          after: zr,
          afterAll: Rs,
          append: Hs,
          appendAll: ca,
          prepend: mr,
          wrap: nl
        }),
        remove: J({
          unwrap: yc,
          remove: Pr
        }),
        create: J({
          nu: ve.fromTag,
          clone: l,
          text: ve.fromText
        }),
        query: J({
          comparePosition: O,
          prevSibling: ac,
          nextSibling: vc
        }),
        property: J({
          children: lo,
          name: xs,
          parent: zo,
          document: m,
          isText: ga,
          isComment: Ts,
          isElement: dr,
          isSpecial: W,
          getLanguage: Q,
          getText: Jn,
          setText: Sr,
          isBoundary: h,
          isEmptyTag: v,
          isNonEditable: T
        }),
        eq: wt,
        is: Ln
      };
    };
    const r0 = (l, m, h, v) => {
      const T = h[0], O = h.slice(1);
      return v(l, m, T, O);
    }, Ck = (l, m, h) => h.length > 0 ? r0(l, m, h, y1) : re.none(), y1 = (l, m, h, v) => {
      const T = m(l, h);
      return kn(v, (O, $) => {
        const W = m(l, $);
        return wk(l, O, W);
      }, T);
    }, wk = (l, m, h) => m.bind((v) => h.filter(ht(l.eq, v))), wh = (l, m) => ht(l.eq, m), ky = (l, m, h, v = gn) => {
      const T = [m].concat(l.up().all(m)), O = [h].concat(l.up().all(h)), $ = (Re) => ss(Re, v).fold(() => Re, (an) => Re.slice(0, an + 1)), W = $(T), Q = $(O), ge = F(W, (Re) => it(Q, wh(l, Re)));
      return {
        firstpath: W,
        secondpath: Q,
        shared: ge
      };
    }, wm = Ck, Sk = ky, $d = mt(), cr = (l, m) => wm($d, (h, v) => l(v), m), Fd = (l, m, h) => Sk($d, l, m, h), _y = (l) => ri(l, "table"), Bu = (l, m, h) => {
      const v = (T) => (O) => h !== void 0 && h(O) || wt(O, T);
      return wt(l, m) ? re.some({
        boxes: re.some([l]),
        start: l,
        finish: m
      }) : _y(l).bind((T) => _y(m).bind((O) => {
        if (wt(T, O))
          return re.some({
            boxes: Sy(T, l, m),
            start: l,
            finish: m
          });
        if (on(T, O)) {
          const $ = Io(m, "td,th", v(T)), W = $.length > 0 ? $[$.length - 1] : m;
          return re.some({
            boxes: vr(T, l, T, m, O),
            start: l,
            finish: W
          });
        } else if (on(O, T)) {
          const $ = Io(l, "td,th", v(O)), W = $.length > 0 ? $[$.length - 1] : l;
          return re.some({
            boxes: vr(O, l, T, m, O),
            start: l,
            finish: W
          });
        } else
          return Fd(l, m).shared.bind(($) => ar($, "table", h).bind((W) => {
            const Q = Io(m, "td,th", v(W)), ge = Q.length > 0 ? Q[Q.length - 1] : m, Re = Io(l, "td,th", v(W)), Et = Re.length > 0 ? Re[Re.length - 1] : l;
            return re.some({
              boxes: vr(W, l, T, m, O),
              start: Et,
              finish: ge
            });
          }));
      }));
    }, Sm = (l, m) => {
      const h = gr(l, m);
      return h.length > 0 ? re.some(h) : re.none();
    }, Ay = (l, m) => F(l, (h) => go(h, m)), yg = (l, m, h) => Ga(l, m).bind((v) => Ga(l, h).bind((T) => cr(_y, [
      v,
      T
    ]).map((O) => ({
      first: v,
      last: T,
      table: O
    })))), $w = (l, m) => ri(l, "table").bind((h) => Ga(h, m).bind((v) => Bu(v, l).bind((T) => T.boxes.map((O) => ({
      boxes: O,
      start: T.start,
      finish: T.finish
    }))))), a0 = (l, m, h, v, T) => Ay(l, T).bind((O) => yk(O, m, h).bind(($) => $w($, v))), Oy = (l, m) => Sm(l, m), xk = (l, m, h) => yg(l, m, h).bind((v) => {
      const T = (Q) => wt(l, Q), O = "thead,tfoot,tbody,table", $ = ri(v.first, O, T), W = ri(v.last, O, T);
      return $.bind((Q) => W.bind((ge) => wt(Q, ge) ? xy(v.table, v.first, v.last) : re.none()));
    }), Dy = Qe, Cg = (l) => {
      const m = (v, T) => de(v, T).exists((O) => parseInt(O, 10) > 1), h = (v) => m(v, "rowspan") || m(v, "colspan");
      return l.length > 0 && lt(l, h) ? re.some(l) : re.none();
    }, Z4 = (l, m, h) => m.length <= 1 ? re.none() : xk(l, h.firstSelectedSelector, h.lastSelectedSelector).map((v) => ({
      bounds: v,
      cells: m
    })), Ry = "data-mce-selected", wg = "td[" + Ry + "],th[" + Ry + "]", Fc = "[" + Ry + "]", An = "data-mce-first-selected", Tk = "td[" + An + "],th[" + An + "]", Ny = "data-mce-last-selected", Ek = "td[" + Ny + "],th[" + Ny + "]", Fw = Fc, Sg = {
      selected: Ry,
      selectedSelector: wg,
      firstSelected: An,
      firstSelectedSelector: Tk,
      lastSelected: Ny,
      lastSelectedSelector: Ek
    }, Sh = (l, m, h) => ({
      element: h,
      mergable: Z4(m, l, Sg),
      unmergable: Cg(l),
      selection: Dy(l)
    }), C1 = (l, m, h) => ({
      element: l,
      clipboard: m,
      generators: h
    }), xh = (l, m, h, v) => ({
      selection: Dy(l),
      clipboard: h,
      generators: v
    }), c0 = (l) => Zc(l).bind((m) => Oy(m, Sg.firstSelectedSelector)).fold(J(l), (m) => m[0]), xm = (l) => (m, h) => {
      const v = xs(m), T = v === "col" || v === "colgroup" ? c0(m) : m;
      return ar(T, l, h);
    }, id = xm("th,td,caption"), w1 = xm("th,td"), cu = (l) => Rl(l.model.table.getSelectedCells()), i0 = (l) => bt(cu(l), (m) => go(m, Sg.selectedSelector)), Iw = (l) => Zc(l[0]).map((m) => {
      const h = rt(m, Fw);
      return cd(h), [h];
    }), Th = (l, m) => rn(m, (h) => l.selection.serializer.serialize(h.dom, {})).join(""), Tm = (l) => rn(l, (m) => m.dom.innerText).join(""), kk = (l, m) => {
      l.on("BeforeGetContent", (h) => {
        const v = (T) => {
          h.preventDefault(), Iw(T).each((O) => {
            h.content = h.format === "text" ? Tm(O) : Th(l, O);
          });
        };
        if (h.selection === !0) {
          const T = i0(l);
          T.length >= 1 && v(T);
        }
      }), l.on("BeforeSetContent", (h) => {
        if (h.selection === !0 && h.paste === !0) {
          const v = cu(l);
          ae(v).each((T) => {
            Zc(T).each((O) => {
              const $ = bt(m1(h.content), (Q) => xs(Q) !== "meta"), W = sr("table");
              if (sa(l) && $.length === 1 && W($[0])) {
                h.preventDefault();
                const Q = ve.fromDom(l.getDoc()), ge = mf(Q), Re = C1(T, $[0], ge);
                m.pasteCells(O, Re).each(() => {
                  l.focus();
                });
              }
            });
          });
        }
      });
    }, Eh = (l, m) => ({
      element: l,
      offset: m
    }), xg = (l, m, h) => l.property().isText(m) && l.property().getText(m).trim().length === 0 || l.property().isComment(m) ? h(m).bind((v) => xg(l, v, h).orThunk(() => re.some(v))) : re.none(), $u = (l, m) => l.property().isText(m) ? l.property().getText(m).length : l.property().children(m).length, il = (l, m) => {
      const h = xg(l, m, l.query().prevSibling).getOr(m);
      if (l.property().isText(h))
        return Eh(h, $u(l, h));
      const v = l.property().children(h);
      return v.length > 0 ? il(l, v[v.length - 1]) : Eh(h, $u(l, h));
    }, _k = il, Lw = mt(), Hw = (l) => _k(Lw, l), My = (l, m) => {
      ia(l) || gt(l).each((v) => {
        const T = v.value / 2;
        _i(l, T, v.unit), _i(m, T, v.unit);
      });
    }, ll = (l) => rn(l, J(0)), kh = (l, m, h, v, T) => T(l.slice(0, m)).concat(v).concat(T(l.slice(h))), l0 = (l) => (m, h, v, T) => {
      if (l(v)) {
        const O = Math.max(T, m[h] - Math.abs(v)), $ = Math.abs(O - m[h]);
        return v >= 0 ? $ : -$;
      } else
        return v;
    }, u0 = l0((l) => l < 0), Ak = l0(De), zw = () => {
      const l = (W, Q, ge, Re, Et) => {
        const an = u0(W, Q, Re, Et);
        return kh(W, Q, ge + 1, [
          an,
          0
        ], ll);
      }, m = (W, Q, ge, Re) => {
        const Et = (100 + ge) / 100, an = Math.max(Re, (W[Q] + ge) / Et);
        return rn(W, (tn, ft) => (ft === Q ? an : tn / Et) - tn);
      }, h = (W, Q, ge, Re, Et, an) => an ? m(W, Q, Re, Et) : l(W, Q, ge, Re, Et);
      return {
        resizeTable: (W, Q) => W(Q),
        clampTableDelta: u0,
        calcLeftEdgeDeltas: h,
        calcMiddleDeltas: (W, Q, ge, Re, Et, an, tn) => h(W, ge, Re, Et, an, tn),
        calcRightEdgeDeltas: (W, Q, ge, Re, Et, an) => {
          if (an)
            return m(W, ge, Re, Et);
          {
            const tn = u0(W, ge, Re, Et);
            return ll(W.slice(0, ge)).concat([tn]);
          }
        },
        calcRedestributedWidths: (W, Q, ge, Re) => {
          if (Re) {
            const an = (Q + ge) / Q, tn = rn(W, (ft) => ft / an);
            return {
              delta: an * 100 - 100,
              newSizes: tn
            };
          } else
            return {
              delta: ge,
              newSizes: W
            };
        }
      };
    }, Py = () => {
      const l = ($, W, Q, ge, Re) => {
        const Et = ge >= 0 ? Q : W, an = Ak($, Et, ge, Re);
        return kh($, W, Q + 1, [
          an,
          -an
        ], ll);
      };
      return {
        resizeTable: ($, W, Q) => {
          Q && $(W);
        },
        clampTableDelta: ($, W, Q, ge, Re) => {
          if (Re) {
            if (Q >= 0)
              return Q;
            {
              const Et = $e($, (an, tn) => an + tn - ge, 0);
              return Math.max(-Et, Q);
            }
          } else
            return u0($, W, Q, ge);
        },
        calcLeftEdgeDeltas: l,
        calcMiddleDeltas: ($, W, Q, ge, Re, Et) => l($, Q, ge, Re, Et),
        calcRightEdgeDeltas: ($, W, Q, ge, Re, Et) => {
          if (Et)
            return ll($);
          {
            const an = ge / $.length;
            return rn($, J(an));
          }
        },
        calcRedestributedWidths: ($, W, Q, ge) => ({
          delta: 0,
          newSizes: $
        })
      };
    }, _h = (l) => Wo.fromTable(l).grid, Ah = sr("th"), d0 = (l) => lt(l, (m) => Ah(m.element)), Ok = (l, m) => l && m ? "sectionCells" : l ? "section" : "cells", m0 = (l) => {
      const m = l.section === "thead", h = $i(Oh(l.cells), "th");
      return l.section === "tfoot" ? { type: "footer" } : m || h ? {
        type: "header",
        subType: Ok(m, h)
      } : { type: "body" };
    }, Oh = (l) => {
      const m = bt(l, (h) => Ah(h.element));
      return m.length === 0 ? re.some("td") : m.length === l.length ? re.some("th") : re.none();
    }, Dk = (l) => {
      const m = rn(l, (T) => m0(T).type), h = mn(m, "header"), v = mn(m, "footer");
      if (!h && !v)
        return re.some("body");
      {
        const T = mn(m, "body");
        return h && !T && !v ? re.some("header") : !h && !T && v ? re.some("footer") : re.none();
      }
    }, S1 = (l) => Vn(l.all, (m) => {
      const h = m0(m);
      return h.type === "header" ? re.from(h.subType) : re.none();
    }), By = (l, m, h) => Ve(h(l.element, m), !0, l.isLocked), ul = (l, m) => l.section !== m ? Rt(l.element, l.cells, m, l.isNew) : l, f0 = () => ({
      transformRow: ul,
      transformCell: (l, m, h) => {
        const v = h(l.element, m), T = xs(v) !== "td" ? Dc(v, "td") : v;
        return Ve(T, l.isNew, l.isLocked);
      }
    }), Vw = () => ({
      transformRow: ul,
      transformCell: By
    }), g0 = () => ({
      transformRow: (l, m) => ul(l, m === "thead" ? "tbody" : m),
      transformCell: By
    }), vf = {
      getTableSectionType: (l, m) => {
        const h = Wo.fromTable(l);
        switch (S1(h).getOr(m)) {
          case "section":
            return f0();
          case "sectionCells":
            return Vw();
          case "cells":
            return g0();
        }
      },
      section: f0,
      sectionCells: Vw,
      cells: g0,
      fallback: () => ({
        transformRow: Qe,
        transformCell: By
      })
    }, Id = (l, m, h, v) => {
      h === v ? ie(l, m) : Vs(l, m, h);
    }, $y = (l, m, h) => {
      kt(_n(l, m)).fold(() => mr(l, h), (v) => zr(v, h));
    }, Dh = (l, m) => {
      const h = Jo(l, m).getOrThunk(() => {
        const v = ve.fromTag(m, On(l).dom);
        return m === "thead" ? $y(l, "caption,colgroup", v) : m === "colgroup" ? $y(l, "caption", v) : Hs(l, v), v;
      });
      return Ia(h), h;
    }, p0 = (l, m) => {
      const h = [], v = [], T = (tn) => rn(tn, (ft) => {
        ft.isNew && h.push(ft.element);
        const cn = ft.element;
        return Ia(cn), Ye(ft.cells, (ut) => {
          ut.isNew && v.push(ut.element), Id(ut.element, "colspan", ut.colspan, 1), Id(ut.element, "rowspan", ut.rowspan, 1), Hs(cn, ut.element);
        }), cn;
      }), O = (tn) => at(tn, (ft) => rn(ft.cells, (cn) => (Id(cn.element, "span", cn.colspan, 1), cn.element))), $ = (tn, ft) => {
        const cn = Dh(l, ft), $n = (ft === "colgroup" ? O : T)(tn);
        ca(cn, $n);
      }, W = (tn) => {
        Jo(l, tn).each(Pr);
      }, Q = (tn, ft) => {
        tn.length > 0 ? $(tn, ft) : W(ft);
      }, ge = [], Re = [], Et = [], an = [];
      return Ye(m, (tn) => {
        switch (tn.section) {
          case "thead":
            ge.push(tn);
            break;
          case "tbody":
            Re.push(tn);
            break;
          case "tfoot":
            Et.push(tn);
            break;
          case "colgroup":
            an.push(tn);
            break;
        }
      }), Q(an, "colgroup"), Q(ge, "thead"), Q(Re, "tbody"), Q(Et, "tfoot"), {
        newRows: h,
        newCells: v
      };
    }, Uw = (l) => rn(l, (m) => {
      const h = Ta(m.element);
      return Ye(m.cells, (v) => {
        const T = Ac(v.element);
        Id(T, "colspan", v.colspan, 1), Id(T, "rowspan", v.rowspan, 1), Hs(h, T);
      }), h;
    }), xr = (l, m) => rn(l, (h) => Ya(h, m)), Rk = (l, m) => l[m], ba = (l, m) => {
      if (l.length === 0)
        return 0;
      const h = l[0];
      return ss(l, (T) => !m(h.element, T.element)).getOr(l.length);
    }, Ww = (l, m, h, v) => {
      const T = Rk(l, m), O = T.section === "colgroup", $ = ba(T.cells.slice(h), v), W = O ? 1 : ba(xr(l.slice(m), h), v);
      return {
        colspan: $,
        rowspan: W
      };
    }, Wr = (l, m) => {
      const h = rn(l, (T) => rn(T.cells, gn)), v = (T, O, $, W) => {
        for (let Q = T; Q < T + $; Q++)
          for (let ge = O; ge < O + W; ge++)
            h[Q][ge] = !0;
      };
      return rn(l, (T, O) => {
        const $ = at(T.cells, (W, Q) => {
          if (h[O][Q] === !1) {
            const ge = Ww(l, O, Q, m);
            return v(O, Q, ge.rowspan, ge.colspan), [Ju(W.element, ge.rowspan, ge.colspan, W.isNew)];
          } else
            return [];
        });
        return _e(T.element, $, T.section, T.isNew);
      });
    }, Rh = (l, m, h) => {
      const v = [];
      Ye(l.colgroups, (T) => {
        const O = [];
        for (let $ = 0; $ < l.grid.columns; $++) {
          const W = Wo.getColumnAt(l, $).map((Q) => Ve(Q.element, h, !1)).getOrThunk(() => Ve(m.colGap(), !0, !1));
          O.push(W);
        }
        v.push(Rt(T.element, O, "colgroup", h));
      });
      for (let T = 0; T < l.grid.rows; T++) {
        const O = [];
        for (let Q = 0; Q < l.grid.columns; Q++) {
          const ge = Wo.getAt(l, T, Q).map((Re) => Ve(Re.element, h, Re.isLocked)).getOrThunk(() => Ve(m.gap(), !0, !1));
          O.push(ge);
        }
        const $ = l.all[T], W = Rt($.element, O, $.section, h);
        v.push(W);
      }
      return v;
    }, Ha = (l, m) => Rh(l, m, !1), jr = (l) => Wr(l, wt), Ml = (l, m) => Vn(l.all, (h) => F(h.cells, (v) => wt(m, v.element))), Fy = (l, m, h) => {
      const v = rn(m.selection, (O) => Qm(O).bind(($) => Ml(l, $)).filter(h)), T = hr(v);
      return um(T.length > 0, T);
    }, Ic = (l, m, h, v, T) => (O, $, W, Q) => {
      const ge = Wo.fromTable(O), Re = re.from(Q?.section).getOrThunk(vf.fallback);
      return m(ge, $).map((an) => {
        const tn = Ha(ge, W), ft = l(tn, an, wt, T(W), Re), cn = ka(ft.grid), ut = jr(ft.grid);
        return {
          info: an,
          grid: ut,
          cursor: ft.cursor,
          lockedColumns: cn
        };
      }).bind((an) => {
        const tn = p0(O, an.grid), ft = re.from(Q?.sizing).getOrThunk(() => di.getTableSize(O)), cn = re.from(Q?.resize).getOrThunk(Py);
        return h(O, an.grid, an.info, {
          sizing: ft,
          resize: cn,
          section: Re
        }), v(O), ie(O, od), an.lockedColumns.length > 0 && Vs(O, od, an.lockedColumns.join(",")), re.some({
          cursor: an.cursor,
          newRows: tn.newRows,
          newCells: tn.newCells
        });
      });
    }, x1 = (l, m) => Qm(m.element).bind((h) => Ml(l, h).map((v) => ({
      ...v,
      generators: m.generators,
      clipboard: m.clipboard
    }))), Nh = (l, m) => Fy(l, m, De).map((h) => ({
      cells: h,
      generators: m.generators,
      clipboard: m.clipboard
    })), Ld = (l, m) => m.mergable, Mh = (l, m) => m.unmergable, yf = (l, m) => Fy(l, m, De), Em = (l, m) => Fy(l, m, (h) => !h.isLocked), Nk = (l, m) => Ml(l, m).exists((h) => !h.isLocked), Zw = (l, m) => lt(m, (h) => Nk(l, h)), q4 = (l, m) => Ld(l, m).filter((h) => Zw(l, h.cells)), G4 = (l, m) => Mh(l, m).filter((h) => Zw(l, h)), Fu = (l, m, h, v) => {
      const T = ta(l).rows;
      if (T.length === 0)
        return l;
      for (let O = m.startRow; O <= m.finishRow; O++)
        for (let $ = m.startCol; $ <= m.finishCol; $++) {
          const W = T[O], Q = Ya(W, $).isLocked;
          nd(W, $, Ve(v(), !1, Q));
        }
      return l;
    }, mi = (l, m, h, v) => {
      const T = ta(l).rows;
      let O = !0;
      for (let $ = 0; $ < T.length; $++)
        for (let W = 0; W < li(T[0]); W++) {
          const Q = T[$], ge = Ya(Q, W), Re = ge.element, Et = h(Re, m);
          Et && !O ? nd(Q, W, Ve(v(), !0, ge.isLocked)) : Et && (O = !1);
        }
      return l;
    }, Mk = (l, m) => $e(l, (h, v) => it(h, (T) => m(T.element, v.element)) ? h : h.concat([v]), []), Pk = (l, m, h, v) => (m > 0 && m < l[0].cells.length && Ye(l, (T) => {
      const O = T.cells[m - 1];
      let $ = 0;
      const W = v();
      for (; T.cells.length > m + $ && h(O.element, T.cells[m + $].element); )
        nd(T, m + $, Ve(W, !0, T.cells[m + $].isLocked)), $++;
    }), l), Cf = (l, m, h, v) => {
      const T = ta(l).rows;
      if (m > 0 && m < T.length) {
        const O = T[m - 1].cells, $ = Mk(O, h);
        Ye($, (W) => {
          let Q = re.none();
          for (let ge = m; ge < T.length; ge++)
            for (let Re = 0; Re < li(T[0]); Re++) {
              const Et = T[ge], an = Ya(Et, Re);
              h(an.element, W.element) && (Q.isNone() && (Q = re.some(v())), Q.each((ft) => {
                nd(Et, Re, Ve(ft, !0, an.isLocked));
              }));
            }
        });
      }
      return l;
    }, T1 = (l) => {
      const m = (O) => O(l), h = J(l), v = () => T, T = {
        tag: !0,
        inner: l,
        fold: (O, $) => $(l),
        isValue: De,
        isError: gn,
        map: (O) => Hd.value(O(l)),
        mapError: v,
        bind: m,
        exists: m,
        forall: m,
        getOr: h,
        or: v,
        getOrThunk: h,
        orThunk: v,
        getOrDie: h,
        each: (O) => {
          O(l);
        },
        toOptional: () => re.some(l)
      };
      return T;
    }, b0 = (l) => {
      const m = () => h, h = {
        tag: !1,
        inner: l,
        fold: (v, T) => v(l),
        isValue: gn,
        isError: De,
        map: m,
        mapError: (v) => Hd.error(v(l)),
        bind: m,
        exists: gn,
        forall: De,
        getOr: Qe,
        or: Qe,
        getOrThunk: Ht,
        orThunk: Ht,
        getOrDie: Tt(String(l)),
        each: st,
        toOptional: re.none
      };
      return h;
    }, Hd = {
      value: T1,
      error: b0,
      fromOption: (l, m) => l.fold(() => b0(m), T1)
    }, Ph = (l, m, h) => {
      if (l.row >= m.length || l.column > li(m[0]))
        return Hd.error("invalid start address out of table bounds, row: " + l.row + ", column: " + l.column);
      const v = m.slice(l.row), T = v[0].cells.slice(l.column), O = li(h[0]), $ = h.length;
      return Hd.value({
        rowDelta: v.length - $,
        colDelta: T.length - O
      });
    }, Bh = (l, m) => {
      const h = li(l[0]), v = li(m[0]);
      return {
        rowDelta: 0,
        colDelta: h - v
      };
    }, $h = (l, m) => {
      const h = l.length, v = m.length;
      return {
        rowDelta: h - v,
        colDelta: 0
      };
    }, Tg = (l, m, h, v) => {
      const T = m.section === "colgroup" ? h.col : h.cell;
      return Gn(l, (O) => Ve(T(), !0, v(O)));
    }, jw = (l, m, h, v) => {
      const T = l[l.length - 1];
      return l.concat(Gn(m, () => {
        const O = T.section === "colgroup" ? h.colgroup : h.row, $ = fm(T, O, Qe), W = Tg($.cells.length, $, h, (Q) => Ie(v, Q.toString()));
        return rg($, W);
      }));
    }, da = (l, m, h, v) => rn(l, (T) => {
      const O = Tg(m, T, h, gn);
      return jc(T, v, O);
    }), qw = (l, m, h) => rn(l, (v) => $e(h, (T, O) => {
      const $ = Tg(1, v, m, De)[0];
      return Eu(T, O, $);
    }, v)), Fh = (l, m, h) => {
      const v = m.colDelta < 0 ? da : Qe, T = m.rowDelta < 0 ? jw : Qe, O = ka(l), $ = li(l[0]), W = it(O, (Re) => Re === $ - 1), Q = v(l, Math.abs(m.colDelta), h, W ? $ - 1 : $), ge = ka(Q);
      return T(Q, Math.abs(m.rowDelta), h, ee(ge, De));
    }, Gw = (l, m, h, v) => {
      const T = Ya(l[m], h), O = ht(v, T.element), $ = l[m];
      return l.length > 1 && li($) > 1 && (h > 0 && O(ha($, h - 1)) || h < $.cells.length - 1 && O(ha($, h + 1)) || m > 0 && O(ha(l[m - 1], h)) || m < l.length - 1 && O(ha(l[m + 1], h)));
    }, y0 = (l, m, h, v, T, O) => {
      const $ = l.row, W = l.column, Q = h.length, ge = li(h[0]), Re = $ + Q, Et = W + ge + O.length, an = ee(O, De);
      for (let tn = $; tn < Re; tn++) {
        let ft = 0;
        for (let cn = W; cn < Et; cn++) {
          if (an[cn]) {
            ft++;
            continue;
          }
          Gw(m, tn, cn, T) && mi(m, ha(m[tn], cn), T, v.cell);
          const ut = cn - W - ft, $n = Ya(h[tn - $], ut), wo = $n.element, Ho = v.replace(wo);
          nd(m[tn], cn, Ve(Ho, !0, $n.isLocked));
        }
      }
      return m;
    }, Xc = (l, m, h) => {
      const v = li(m[0]), T = ta(m).cols.length + l.row, O = Gn(v - l.column, (W) => W + l.column), $ = F(O, (W) => lt(h, (Q) => Q !== W)).getOr(v - 1);
      return {
        row: T,
        column: $
      };
    }, Pl = (l, m, h) => bt(h, (v) => v >= l.column && v <= li(m[0]) + l.column), Kw = (l, m, h, v, T) => {
      const O = ka(m), $ = Xc(l, m, O), W = ta(h).rows, Q = Pl($, W, O);
      return Ph($, m, W).map((Re) => {
        const Et = {
          ...Re,
          colDelta: Re.colDelta - Q.length
        }, an = Fh(m, Et, v), tn = ka(an), ft = Pl($, W, tn);
        return y0($, an, W, v, T, ft);
      });
    }, C0 = (l, m, h, v, T) => {
      Pk(m, l, T, v.cell);
      const O = $h(h, m), $ = Fh(h, O, v), W = $h(m, $), Q = Fh(m, W, v);
      return rn(Q, (ge, Re) => jc(ge, l, $[Re].cells));
    }, Eg = (l, m, h, v, T) => {
      Cf(m, l, T, v.cell);
      const O = ka(m), $ = Bh(m, h), W = {
        ...$,
        colDelta: $.colDelta - O.length
      }, Q = Fh(m, W, v), {
        cols: ge,
        rows: Re
      } = ta(Q), Et = ka(Q), an = Bh(h, m), tn = {
        ...an,
        colDelta: an.colDelta + Et.length
      }, ft = qw(h, v, Et), cn = Fh(ft, tn, v);
      return [
        ...ge,
        ...Re.slice(0, l),
        ...cn,
        ...Re.slice(l, Re.length)
      ];
    }, Bk = (l, m, h, v) => fm(l, (T) => v(T, h), m), Yw = (l, m, h, v, T) => {
      const { rows: O, cols: $ } = ta(l), W = O.slice(0, m), Q = O.slice(m), ge = Bk(O[h], (Re, Et) => m > 0 && m < O.length && v(ha(O[m - 1], Et), ha(O[m], Et)) ? Ya(O[m], Et) : Ve(T(Re.element, v), !0, Re.isLocked), v, T);
      return [
        ...$,
        ...W,
        ge,
        ...Q
      ];
    }, Iy = (l, m, h, v, T, O, $) => {
      if (h === "colgroup" || !v) {
        const W = Ya(l, T);
        return Ve($(W.element, O), !0, !1);
      } else
        return Ya(l, m);
    }, dl = (l, m, h, v, T) => rn(l, (O) => {
      const $ = m > 0 && m < li(O) && v(ha(O, m - 1), ha(O, m)), W = Iy(O, m, O.section, $, h, v, T);
      return Eu(O, m, W);
    }), w0 = (l, m) => at(l, (h) => {
      const v = h.cells, T = kn(m, (O, $) => $ >= 0 && $ < O.length ? O.slice(0, $).concat(O.slice($ + 1)) : O, v);
      return T.length > 0 ? [Rt(h.element, T, h.section, h.isNew)] : [];
    }), va = (l, m, h) => {
      const { rows: v, cols: T } = ta(l);
      return [
        ...T,
        ...v.slice(0, m),
        ...v.slice(h + 1)
      ];
    }, ld = (l, m, h, v) => ha(l[m], h) !== void 0 && m > 0 && v(ha(l[m - 1], h), ha(l[m], h)), Ih = (l, m, h) => m > 0 && h(ha(l, m - 1), ha(l, m)), wf = (l, m, h, v) => ld(l, m, h, v) || Ih(l[m], h, v), kg = (l, m) => lt(m, Qe) && d0(l.cells) ? De : (v, T, O) => !(xs(v.element) === "th" && m[O]), _g = (l, m) => lt(m, Qe) && d0(l) ? De : (v, T, O) => !(xs(v.element) === "th" && m[T]), km = (l, m, h, v) => {
      const T = ($) => $ === "row" ? wc(m) : ia(m), O = ($) => T($) ? `${$}group` : $;
      return l ? Ah(m) ? O(h) : null : v && Ah(m) ? O(h === "row" ? "col" : "row") : null;
    }, Xw = (l, m) => (h, v, T) => re.some(km(l, h.element, "col", m[T])), Ag = (l, m) => (h, v) => re.some(km(l, h.element, "row", m[v])), Sf = (l, m, h) => Ve(h(l.element, m), !0, l.isLocked), Og = (l, m, h, v, T, O, $) => {
      const W = (Q) => it(m, (ge) => h(Q.element, ge.element));
      return rn(l, (Q, ge) => rf(Q, (Re, Et) => {
        if (W(Re)) {
          const an = $(Re, ge, Et) ? T(Re, h, v) : Re;
          return O(an, ge, Et).each((tn) => {
            rc(an.element, { scope: re.from(tn) });
          }), an;
        } else
          return Re;
      }));
    }, Jw = (l, m, h) => at(l, (v, T) => wf(l, T, m, h) ? [] : [Ya(v, m)]), $k = (l, m, h) => {
      const v = l[m];
      return at(v.cells, (T, O) => wf(l, m, O, h) ? [] : [T]);
    }, Ly = (l, m, h, v, T) => {
      const O = ta(l).rows, $ = at(m, (Re) => Jw(O, Re, v)), W = rn(O, (Re) => d0(Re.cells)), Q = _g($, W), ge = Ag(h, W);
      return Og(l, $, v, T, Sf, ge, Q);
    }, Fk = (l, m, h, v, T, O, $) => {
      const { cols: W, rows: Q } = ta(l), ge = Q[m[0]], Re = at(m, (ut) => $k(Q, ut, T)), Et = rn(ge.cells, (ut, $n) => d0(Jw(Q, $n, T))), an = [...Q];
      Ye(m, (ut) => {
        an[ut] = $.transformRow(Q[ut], h);
      });
      const tn = [
        ...W,
        ...an
      ], ft = kg(ge, Et), cn = Xw(v, Et);
      return Og(tn, Re, T, O, $.transformCell, cn, ft);
    }, S0 = (l, m, h, v) => {
      const T = ta(l).rows, O = rn(m, ($) => Ya(T[$.row], $.column));
      return Og(l, O, h, v, Sf, re.none, De);
    }, ml = { generate: (l) => {
      if (!Bt(l))
        throw new Error("cases must be an array");
      if (l.length === 0)
        throw new Error("there must be at least one case");
      const m = [], h = {};
      return Ye(l, (v, T) => {
        const O = Yt(v);
        if (O.length !== 1)
          throw new Error("one and only one name per case");
        const $ = O[0], W = v[$];
        if (h[$] !== void 0)
          throw new Error("duplicate key detected:" + $);
        if ($ === "cata")
          throw new Error("cannot have a case named cata (sorry)");
        if (!Bt(W))
          throw new Error("case arguments must be an array");
        m.push($), h[$] = (...Q) => {
          const ge = Q.length;
          if (ge !== W.length)
            throw new Error("Wrong number of arguments to case " + $ + ". Expected " + W.length + " (" + W + "), got " + ge);
          return {
            fold: (...Et) => {
              if (Et.length !== l.length)
                throw new Error("Wrong number of arguments to fold. Expected " + l.length + ", got " + Et.length);
              return Et[T].apply(null, Q);
            },
            match: (Et) => {
              const an = Yt(Et);
              if (m.length !== an.length)
                throw new Error("Wrong number of arguments to match. Expected: " + m.join(",") + `
Actual: ` + an.join(","));
              if (!lt(m, (ft) => mn(an, ft)))
                throw new Error("Not all branches were specified when using match. Specified: " + an.join(", ") + `
Required: ` + m.join(", "));
              return Et[$].apply(null, Q);
            },
            log: (Et) => {
            }
          };
        };
      }), h;
    } }, Lh = { ...ml.generate([
      { none: [] },
      { only: ["index"] },
      {
        left: [
          "index",
          "next"
        ]
      },
      {
        middle: [
          "prev",
          "index",
          "next"
        ]
      },
      {
        right: [
          "prev",
          "index"
        ]
      }
    ]) }, eS = (l, m) => l.length === 0 ? Lh.none() : l.length === 1 ? Lh.only(0) : m === 0 ? Lh.left(0, 1) : m === l.length - 1 ? Lh.right(m - 1, m) : m > 0 && m < l.length - 1 ? Lh.middle(m - 1, m, m + 1) : Lh.none(), Ik = (l, m, h, v, T) => {
      const O = l.slice(0), $ = eS(l, m), W = J(rn(O, J(0))), Q = (an) => v.singleColumnWidth(O[an], h), ge = (an, tn) => T.calcLeftEdgeDeltas(O, an, tn, h, v.minCellWidth(), v.isRelative), Re = (an, tn, ft) => T.calcMiddleDeltas(O, an, tn, ft, h, v.minCellWidth(), v.isRelative), Et = (an, tn) => T.calcRightEdgeDeltas(O, an, tn, h, v.minCellWidth(), v.isRelative);
      return $.fold(W, Q, ge, Re, Et);
    }, E1 = (l, m, h) => {
      let v = 0;
      for (let T = l; T < m; T++)
        v += h[T] !== void 0 ? h[T] : 0;
      return v;
    }, xf = (l, m) => {
      const h = Wo.justCells(l);
      return rn(h, (v) => {
        const T = E1(v.column, v.column + v.colspan, m);
        return {
          element: v.element,
          width: T,
          colspan: v.colspan
        };
      });
    }, x0 = (l, m) => {
      const h = Wo.justColumns(l);
      return rn(h, (v, T) => ({
        element: v.element,
        width: m[T],
        colspan: v.colspan
      }));
    }, gs = (l, m) => {
      const h = Wo.justCells(l);
      return rn(h, (v) => {
        const T = E1(v.row, v.row + v.rowspan, m);
        return {
          element: v.element,
          height: T,
          rowspan: v.rowspan
        };
      });
    }, fl = (l, m) => rn(l.all, (h, v) => ({
      element: h.element,
      height: m[v]
    })), ud = (l) => kn(l, (m, h) => m + h, 0), zy = (l, m) => Wo.hasColumns(l) ? x0(l, m) : xf(l, m), Qs = (l, m, h) => {
      const v = zy(l, m);
      Ye(v, (T) => {
        h.setElementWidth(T.element, T.width);
      });
    }, k1 = (l, m, h, v, T) => {
      const O = Wo.fromTable(l), $ = T.getCellDelta(m), W = T.getWidths(O, T), Q = h === O.grid.columns - 1, ge = v.clampTableDelta(W, h, $, T.minCellWidth(), Q), Re = Ik(W, h, ge, T, v), Et = rn(Re, (an, tn) => an + W[tn]);
      Qs(O, Et, T), v.resizeTable(T.adjustTableWidth, ge, Q);
    }, Vy = (l, m, h, v) => {
      const T = Wo.fromTable(l), O = Ne(T, l, v), $ = rn(O, (Re, Et) => h === Et ? Math.max(m + Re, Vr()) : Re), W = gs(T, $), Q = fl(T, $);
      Ye(Q, (Re) => {
        Nd(Re.element, Re.height);
      }), Ye(W, (Re) => {
        Nd(Re.element, Re.height);
      });
      const ge = ud($);
      Nd(l, ge);
    }, Ja = (l, m, h, v, T) => {
      const O = Wo.generate(m), $ = v.getWidths(O, v), W = v.pixelWidth(), { newSizes: Q, delta: ge } = T.calcRedestributedWidths($, W, h.pixelDelta, v.isRelative);
      Qs(O, Q, v), v.adjustTableWidth(ge);
    }, zd = (l, m, h, v) => {
      const T = Wo.generate(m), O = v.getWidths(T, v);
      Qs(T, O, v);
    }, Tf = (l) => $e(l, (h, v) => it(h, (O) => O.column === v.column) ? h : h.concat([v]), []).sort((h, v) => h.column - v.column), Uy = sr("col"), T0 = sr("colgroup"), _1 = (l) => xs(l) === "tr" || T0(l), Wy = (l) => {
      const m = ks(l, "colspan", 1), h = ks(l, "rowspan", 1);
      return {
        element: l,
        colspan: m,
        rowspan: h
      };
    }, E0 = (l, m = Wy) => {
      const h = (W) => Uy(W.element) ? l.col(W) : l.cell(W), v = (W) => T0(W.element) ? l.colgroup(W) : l.row(W), T = (W) => {
        if (_1(W))
          return v({ element: W });
        {
          const Q = W, ge = h(m(Q));
          return O = re.some({
            item: Q,
            replacement: ge
          }), ge;
        }
      };
      let O = re.none();
      return { getOrInit: (W, Q) => O.fold(() => T(W), (ge) => Q(W, ge.item) ? ge.replacement : T(W)) };
    }, Vd = (l) => (m) => {
      const h = [], v = ($, W) => F(h, (Q) => W(Q.item, $)), T = ($) => {
        const W = l === "td" ? { scope: null } : {}, Q = m.replace($, l, W);
        return h.push({
          item: $,
          sub: Q
        }), Q;
      };
      return { replaceOrInit: ($, W) => {
        if (_1($) || Uy($))
          return $;
        {
          const Q = $;
          return v(Q, W).fold(() => T(Q), (ge) => W($, ge.item) ? ge.sub : T(Q));
        }
      } };
    }, _m = (l) => de(l, "scope").map((m) => m.substr(0, 3)), We = {
      modification: E0,
      transform: Vd,
      merging: (l) => ({
        unmerge: (v) => {
          const T = _m(v);
          return T.each((O) => Vs(v, "scope", O)), () => {
            const O = l.cell({
              element: v,
              colspan: 1,
              rowspan: 1
            });
            return pr(O, "width"), pr(v, "width"), T.each(($) => Vs(O, "scope", $)), O;
          };
        },
        merge: (v) => {
          const T = () => {
            const O = hr(rn(v, _m));
            if (O.length === 0)
              return re.none();
            {
              const $ = O[0], W = [
                "row",
                "col"
              ];
              return it(O, (ge) => ge !== $ && mn(W, ge)) ? re.none() : re.from($);
            }
          };
          return pr(v[0], "width"), T().fold(() => ie(v[0], "scope"), (O) => Vs(v[0], "scope", O + "group")), J(v[0]);
        }
      })
    }, A1 = [
      "body",
      "p",
      "div",
      "article",
      "aside",
      "figcaption",
      "figure",
      "footer",
      "header",
      "nav",
      "section",
      "ol",
      "ul",
      "table",
      "thead",
      "tfoot",
      "tbody",
      "caption",
      "tr",
      "td",
      "th",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "blockquote",
      "pre",
      "address"
    ], Hh = (l, m) => {
      const h = l.property().name(m);
      return mn([
        "ol",
        "ul"
      ], h);
    }, Bl = (l, m) => {
      const h = l.property().name(m);
      return mn(A1, h);
    }, Zy = (l, m) => mn([
      "br",
      "img",
      "hr",
      "input"
    ], l.property().name(m)), Ir = mt(), k0 = (l) => Bl(Ir, l), Am = (l) => Hh(Ir, l), jy = (l) => Zy(Ir, l), _0 = (l) => {
      const m = sr("br"), h = (Q) => lt(Q, (ge) => m(ge) || ga(ge) && Jn(ge).trim().length === 0), v = (Q) => xs(Q) === "li" || Us(Q, Am).isSome(), T = (Q) => vc(Q).map((ge) => k0(ge) ? !0 : jy(ge) ? xs(ge) !== "img" : !1).getOr(!1), O = (Q) => Dl(Q).bind((ge) => {
        const Re = T(ge);
        return zo(ge).map((Et) => Re === !0 || v(Et) || m(ge) || k0(Et) && !wt(Q, Et) ? [] : [ve.fromTag("br")]);
      }).getOr([]), W = (() => {
        const Q = at(l, (ge) => {
          const Re = lo(ge);
          return h(Re) ? [] : Re.concat(O(ge));
        });
        return Q.length === 0 ? [ve.fromTag("br")] : Q;
      })();
      Ia(l[0]), ca(l[0], W);
    }, qy = (l) => hf(l, !0), O1 = (l) => {
      Wc(l).length === 0 && Pr(l);
    }, zh = (l, m) => ({
      grid: l,
      cursor: m
    }), Gy = (l) => Vn(l, (m) => Vn(m.cells, (h) => {
      const v = h.element;
      return um(qy(v), v);
    })), Hk = (l, m, h) => {
      var v, T;
      const O = ta(l).rows;
      return re.from((T = (v = O[m]) === null || v === void 0 ? void 0 : v.cells[h]) === null || T === void 0 ? void 0 : T.element).filter(qy).orThunk(() => Gy(O));
    }, Oi = (l, m, h) => {
      const v = Hk(l, m, h);
      return zh(l, v);
    }, Qa = (l) => $e(l, (h, v) => it(h, (O) => O.row === v.row) ? h : h.concat([v]), []).sort((h, v) => h.row - v.row), Lc = (l, m, h, v) => {
      const T = m[0].row, O = Qa(m), $ = kn(O, (W, Q) => ({
        grid: Yw(W.grid, T, Q.row + W.delta, h, v.getOrInit),
        delta: W.delta + 1
      }), {
        grid: l,
        delta: 0
      }).grid;
      return Oi($, T, m[0].column);
    }, Di = (l, m, h, v) => {
      const T = Qa(m), O = T[T.length - 1], $ = O.row + O.rowspan, W = kn(T, (Q, ge) => Yw(Q, $, ge.row, h, v.getOrInit), l);
      return Oi(W, $, m[0].column);
    }, Jc = (l, m, h, v) => {
      const T = m.details, O = Tf(T), $ = O[0].column, W = kn(O, (Q, ge) => ({
        grid: dl(Q.grid, $, ge.column + Q.delta, h, v.getOrInit),
        delta: Q.delta + 1
      }), {
        grid: l,
        delta: 0
      }).grid;
      return Oi(W, T[0].row, $);
    }, fi = (l, m, h, v) => {
      const T = m.details, O = T[T.length - 1], $ = O.column + O.colspan, W = Tf(T), Q = kn(W, (ge, Re) => dl(ge, $, Re.column, h, v.getOrInit), l);
      return Oi(Q, T[0].row, $);
    }, ec = (l, m, h, v) => {
      const T = Tf(m), O = rn(T, (W) => W.column), $ = Ly(l, O, !0, h, v.replaceOrInit);
      return Oi($, m[0].row, m[0].column);
    }, Ky = (l, m, h, v) => {
      const T = S0(l, m, h, v.replaceOrInit);
      return Oi(T, m[0].row, m[0].column);
    }, D1 = (l, m, h, v) => {
      const T = Tf(m), O = rn(T, (W) => W.column), $ = Ly(l, O, !1, h, v.replaceOrInit);
      return Oi($, m[0].row, m[0].column);
    }, Yy = (l, m, h, v) => {
      const T = S0(l, m, h, v.replaceOrInit);
      return Oi(T, m[0].row, m[0].column);
    }, R1 = (l, m) => (h, v, T, O, $) => {
      const W = Qa(v), Q = rn(W, (Re) => Re.row), ge = Fk(h, Q, l, m, T, O.replaceOrInit, $);
      return Oi(ge, v[0].row, v[0].column);
    }, Xy = R1("thead", !0), tS = R1("tbody", !1), A0 = R1("tfoot", !1), Jy = (l, m, h, v) => {
      const T = Tf(m.details), O = w0(l, rn(T, (W) => W.column)), $ = O.length > 0 ? O[0].cells.length - 1 : 0;
      return Oi(O, T[0].row, Math.min(T[0].column, $));
    }, zk = (l, m, h, v) => {
      const T = Qa(m), O = va(l, T[0].row, T[T.length - 1].row), $ = O.length > 0 ? O.length - 1 : 0;
      return Oi(O, Math.min(m[0].row, $), m[0].column);
    }, Vk = (l, m, h, v) => {
      const T = m.cells;
      _0(T);
      const O = Fu(l, m.bounds, h, v.merge(T));
      return zh(O, re.from(T[0]));
    }, nS = (l, m, h, v) => {
      const O = kn(m, ($, W) => mi($, W, h, v.unmerge(W)), l);
      return zh(O, re.from(m[0]));
    }, Uk = (l, m, h, v) => {
      const O = ((Q, ge) => {
        const Re = Wo.fromTable(Q);
        return Rh(Re, ge, !0);
      })(m.clipboard, m.generators), $ = Bi(m.row, m.column);
      return Kw($, l, O, m.generators, h).fold(() => zh(l, re.some(m.element)), (Q) => Oi(Q, m.row, m.column));
    }, Vh = (l, m, h) => {
      const v = oh(l, h.section), T = Wo.generate(v);
      return Rh(T, m, !0);
    }, O0 = (l, m, h, v) => {
      const T = ta(l).rows, O = m.cells[0].column, $ = T[m.cells[0].row], W = Vh(m.clipboard, m.generators, $), Q = C0(O, l, W, m.generators, h);
      return Oi(Q, m.cells[0].row, m.cells[0].column);
    }, oS = (l, m, h, v) => {
      const T = ta(l).rows, O = m.cells[m.cells.length - 1].column + m.cells[m.cells.length - 1].colspan, $ = T[m.cells[0].row], W = Vh(m.clipboard, m.generators, $), Q = C0(O, l, W, m.generators, h);
      return Oi(Q, m.cells[0].row, m.cells[0].column);
    }, K4 = (l, m, h, v) => {
      const T = ta(l).rows, O = m.cells[0].row, $ = T[O], W = Vh(m.clipboard, m.generators, $), Q = Eg(O, l, W, m.generators, h);
      return Oi(Q, m.cells[0].row, m.cells[0].column);
    }, Ui = (l, m, h, v) => {
      const T = ta(l).rows, O = m.cells[m.cells.length - 1].row + m.cells[m.cells.length - 1].rowspan, $ = T[m.cells[0].row], W = Vh(m.clipboard, m.generators, $), Q = Eg(O, l, W, m.generators, h);
      return Oi(Q, m.cells[0].row, m.cells[0].column);
    }, Y4 = (l, m) => {
      const h = Wo.fromTable(l);
      return yf(h, m).bind((T) => {
        const O = T[T.length - 1], $ = T[0].column, W = O.column + O.colspan, Q = fo(rn(h.all, (ge) => bt(ge.cells, (Re) => Re.column >= $ && Re.column < W)));
        return Oh(Q);
      }).getOr("");
    }, dd = (l, m) => {
      const h = Wo.fromTable(l);
      return yf(h, m).bind(Oh).getOr("");
    }, Ut = (l, m) => {
      const h = Wo.fromTable(l);
      return yf(h, m).bind((T) => {
        const O = T[T.length - 1], $ = T[0].row, W = O.row + O.rowspan, Q = h.all.slice($, W);
        return Dk(Q);
      }).getOr("");
    }, Qy = (l, m, h, v) => zd(l, m, h, v.sizing), tc = (l, m, h, v) => Ja(l, m, h, v.sizing, v.resize), sS = (l, m) => it(m, (h) => h.column === 0 && h.isLocked), D0 = (l, m) => it(m, (h) => h.column + h.colspan >= l.grid.columns && h.isLocked), eC = (l, m) => {
      const h = sd(l), v = Tf(m);
      return $e(v, (T, O) => {
        const W = h[O.column].map(Hi).getOr(0);
        return T + W;
      }, 0);
    }, Wi = (l) => (m, h) => yf(m, h).filter((v) => !(l ? sS : D0)(m, v)).map((v) => ({
      details: v,
      pixelDelta: eC(m, v)
    })), Wk = (l, m) => Em(l, m).map((h) => ({
      details: h,
      pixelDelta: -eC(l, h)
    })), rS = (l) => (m, h) => Nh(m, h).filter((v) => !(l ? sS : D0)(m, v.cells)), Zi = We.transform("th"), Uh = We.transform("td"), N1 = Ic(Lc, yf, st, st, We.modification), Ud = Ic(Di, yf, st, st, We.modification), Iu = Ic(Jc, Wi(!0), tc, st, We.modification), Cn = Ic(fi, Wi(!1), tc, st, We.modification), $l = Ic(Jy, Wk, tc, O1, We.modification), aS = Ic(zk, yf, st, O1, We.modification), cS = Ic(ec, Em, st, st, Zi), tC = Ic(D1, Em, st, st, Uh), iS = Ic(Xy, Em, st, st, Zi), nC = Ic(tS, Em, st, st, Uh), oC = Ic(A0, Em, st, st, Uh), Zk = Ic(Ky, Em, st, st, Zi), sC = Ic(Yy, Em, st, st, Uh), jk = Ic(Vk, q4, Qy, st, We.merging), gi = Ic(nS, G4, Qy, st, We.merging), M1 = Ic(Uk, x1, Qy, st, We.modification), qk = Ic(O0, rS(!0), st, st, We.modification), Gk = Ic(oS, rS(!1), st, st, We.modification), rC = Ic(K4, Nh, st, st, We.modification), Kk = Ic(Ui, Nh, st, st, We.modification), lS = Y4, uS = dd, P1 = Ut, dS = (l, m) => l.dispatch("NewRow", { node: m }), aC = (l, m) => l.dispatch("NewCell", { node: m }), Dg = (l, m, h) => {
      l.dispatch("TableModified", {
        ...h,
        table: m
      });
    }, Yk = (l, m, h, v, T) => {
      l.dispatch("TableSelectionChange", {
        cells: m,
        start: h,
        finish: v,
        otherCells: T
      });
    }, Xk = (l) => {
      l.dispatch("TableSelectionClear");
    }, cC = (l, m, h, v, T) => {
      l.dispatch("ObjectResizeStart", {
        target: m,
        width: h,
        height: v,
        origin: T
      });
    }, Jk = (l, m, h, v, T) => {
      l.dispatch("ObjectResized", {
        target: m,
        width: h,
        height: v,
        origin: T
      });
    }, Om = {
      structure: !1,
      style: !0
    }, Go = {
      structure: !0,
      style: !1
    }, iC = {
      structure: !0,
      style: !0
    }, hi = (l, m) => ym(l) ? di.percentageSize(m) : gf(l) ? di.pixelSize(m) : di.getTableSize(m), R0 = (l, m, h) => {
      const v = (Ni) => xs(e0(Ni)) === "table", T = (Ni) => !v(l) || _h(Ni).rows > 1, O = (Ni) => !v(l) || _h(Ni).columns > 1, $ = vm(l), W = pa(l) ? st : My, Q = (Ni) => {
        switch (pg(l)) {
          case "section":
            return vf.section();
          case "sectionCells":
            return vf.sectionCells();
          case "cells":
            return vf.cells();
          default:
            return vf.getTableSectionType(Ni, "section");
        }
      }, ge = (Ni, o2) => o2.cursor.fold(() => {
        const mb = Wc(Ni);
        return ae(mb).filter(rr).map((Kd) => {
          h.clearSelectedCells(Ni.dom);
          const ni = l.dom.createRng();
          return ni.selectNode(Kd.dom), l.selection.setRng(ni), Vs(Kd, "data-mce-selected", "1"), ni;
        });
      }, (mb) => {
        const Kd = Hw(mb), ni = l.dom.createRng();
        return ni.setStart(Kd.element.dom, Kd.offset), ni.setEnd(Kd.element.dom, Kd.offset), l.selection.setRng(ni), h.clearSelectedCells(Ni.dom), re.some(ni);
      }), Re = (Ni, o2, mb, Kd) => (ni, fb, lx = !1) => {
        cd(ni);
        const ux = ve.fromDom(l.getDoc()), bp = Bc(mb, ux, $), dx = {
          sizing: hi(l, ni),
          resize: pa(l) ? zw() : Py(),
          section: Q(ni)
        };
        return o2(ni) ? Ni(ni, fb, bp, dx).bind((dv) => {
          m.refresh(ni.dom), Ye(dv.newRows, (zg) => {
            dS(l, zg.dom);
          }), Ye(dv.newCells, (zg) => {
            aC(l, zg.dom);
          });
          const mx = ge(ni, dv);
          return rr(ni) && (cd(ni), lx || Dg(l, ni.dom, Kd)), mx.map((zg) => ({
            rng: zg,
            effect: Kd
          }));
        }) : re.none();
      }, Et = Re(aS, T, st, Go), an = Re($l, O, st, Go), tn = Re(N1, De, st, Go), ft = Re(Ud, De, st, Go), cn = Re(Iu, De, W, Go), ut = Re(Cn, De, W, Go), $n = Re(jk, De, st, Go), wo = Re(gi, De, st, Go), Ho = Re(qk, De, st, Go), Mr = Re(Gk, De, st, Go), oc = Re(rC, De, st, Go), ma = Re(Kk, De, st, Go), Gi = Re(M1, De, st, iC), Lg = Re(Zk, De, st, Go), Hg = Re(sC, De, st, Go), n2 = Re(cS, De, st, Go), uv = Re(tC, De, st, Go), tr = Re(iS, De, st, Go), bi = Re(nC, De, st, Go), zc = Re(oC, De, st, Go);
      return {
        deleteRow: Et,
        deleteColumn: an,
        insertRowsBefore: tn,
        insertRowsAfter: ft,
        insertColumnsBefore: cn,
        insertColumnsAfter: ut,
        mergeCells: $n,
        unmergeCells: wo,
        pasteColsBefore: Ho,
        pasteColsAfter: Mr,
        pasteRowsBefore: oc,
        pasteRowsAfter: ma,
        pasteCells: Gi,
        makeCellsHeader: Lg,
        unmakeCellsHeader: Hg,
        makeColumnsHeader: n2,
        unmakeColumnsHeader: uv,
        makeRowsHeader: tr,
        makeRowsBody: bi,
        makeRowsFooter: zc,
        getTableRowType: P1,
        getTableCellType: uS,
        getTableColType: lS
      };
    }, lC = (l, m, h) => {
      const v = ks(l, m, 1);
      h === 1 || v <= 1 ? ie(l, m) : Vs(l, m, Math.min(h, v));
    }, uC = (l, m) => (h) => {
      const v = h.column + h.colspan - 1, T = h.column;
      return v >= l && T < m;
    }, N0 = (l, m, h) => {
      if (Wo.hasColumns(l)) {
        const v = bt(Wo.justColumns(l), uC(m, h)), T = rn(v, ($) => {
          const W = Ac($.element);
          return lC(W, "span", h - m), W;
        }), O = ve.fromTag("colgroup");
        return ca(O, T), [O];
      } else
        return [];
    }, mS = (l, m, h) => rn(l.all, (v) => {
      const T = bt(v.cells, uC(m, h)), O = rn(T, (W) => {
        const Q = Ac(W.element);
        return lC(Q, "colspan", h - m), Q;
      }), $ = ve.fromTag("tr");
      return ca($, O), $;
    }), Qk = (l, m) => {
      const h = Wo.fromTable(l);
      return Em(h, m).map((T) => {
        const O = T[T.length - 1], $ = T[0].column, W = O.column + O.colspan, Q = N0(h, $, W), ge = mS(h, $, W);
        return [
          ...Q,
          ...ge
        ];
      });
    }, e_ = (l, m, h) => {
      const v = Wo.fromTable(l);
      return yf(v, m).bind((O) => {
        const $ = Rh(v, h, !1), Q = ta($).rows.slice(O[0].row, O[O.length - 1].row + O[O.length - 1].rowspan), ge = at(Q, (Et) => {
          const an = bt(Et.cells, (tn) => !tn.isLocked);
          return an.length > 0 ? [{
            ...Et,
            cells: an
          }] : [];
        }), Re = jr(ge);
        return um(Re.length > 0, Re);
      }).map((O) => Uw(O));
    }, Wh = ml.generate([
      { invalid: ["raw"] },
      { pixels: ["value"] },
      { percent: ["value"] }
    ]), fS = (l, m, h) => {
      const v = h.substring(0, h.length - l.length), T = parseFloat(v);
      return v === T.toString() ? m(T) : Wh.invalid(h);
    }, Ef = {
      ...Wh,
      from: (l) => Fi(l, "%") ? fS("%", Wh.percent, l) : Fi(l, "px") ? fS("px", Wh.pixels, l) : Wh.invalid(l)
    }, t_ = (l, m) => rn(l, (h) => Ef.from(h).fold(() => h, (T) => T / m * 100 + "%", (T) => T + "%")), Zh = (l, m, h) => {
      const v = h / m;
      return rn(l, (T) => Ef.from(T).fold(() => T, ($) => $ * v + "px", ($) => $ / 100 * h + "px"));
    }, n_ = (l, m) => {
      const h = l.fold(() => J(""), (v) => {
        const T = v / m;
        return J(T + "px");
      }, () => {
        const v = 100 / m;
        return J(v + "%");
      });
      return Gn(m, h);
    }, dC = (l, m, h) => l.fold(() => m, (v) => Zh(m, h, v), (v) => t_(m, h)), gS = (l, m, h) => {
      const v = Ef.from(h), T = lt(l, (O) => O === "0px") ? n_(v, l.length) : dC(v, l, m);
      return pS(T);
    }, Rg = (l, m) => l.length === 0 ? m : kn(l, (h, v) => Ef.from(v).fold(J(0), Qe, Qe) + h, 0), o_ = (l, m) => {
      const h = Math.floor(l);
      return {
        value: h + m,
        remainder: l - h
      };
    }, hS = (l, m) => Ef.from(l).fold(J(l), (h) => h + m + "px", (h) => h + m + "%"), pS = (l) => {
      if (l.length === 0)
        return l;
      const m = kn(l, (v, T) => {
        const O = Ef.from(T).fold(() => ({
          value: T,
          remainder: 0
        }), ($) => o_($, "px"), ($) => ({
          value: $ + "%",
          remainder: 0
        }));
        return {
          output: [O.value].concat(v.output),
          remainder: v.remainder + O.remainder
        };
      }, {
        output: [],
        remainder: 0
      }), h = m.output;
      return h.slice(0, h.length - 1).concat([hS(h[h.length - 1], Math.round(m.remainder))]);
    }, jh = Ef.from, bS = (l, m, h) => {
      Ye(m, (v) => {
        const T = l.slice(v.column, v.colspan + v.column), O = Rg(T, _r());
        je(v.element, "width", O + h);
      });
    }, mC = (l, m, h) => {
      Ye(m, (v, T) => {
        const O = Rg([l[T]], _r());
        je(v.element, "width", O + h);
      });
    }, s_ = (l, m, h, v) => {
      Ye(h, (T) => {
        const O = l.slice(T.row, T.rowspan + T.row), $ = Rg(O, Vr());
        je(T.element, "height", $ + v);
      }), Ye(m, (T, O) => {
        je(T.element, "height", l[O]);
      });
    }, vS = (l) => jh(l).fold(J("px"), J("px"), J("%")), Wd = (l, m, h) => {
      const v = Wo.fromTable(l), T = v.all, O = Wo.justCells(v), $ = Wo.justColumns(v);
      m.each((W) => {
        const Q = vS(W), ge = ii(l), Re = bm(v, l), Et = gS(Re, ge, W);
        Wo.hasColumns(v) ? mC(Et, $, Q) : bS(Et, O, Q), je(l, "width", W);
      }), h.each((W) => {
        const Q = vS(W), ge = lg(l), Re = Pc(v, l, xn), Et = gS(Re, ge, W);
        s_(Et, T, O, Q), je(l, "height", W);
      });
    }, B1 = Al, $1 = yy, M0 = ou, F1 = (l) => {
      ie(l, "width");
    }, iu = (l) => {
      const m = _s(l);
      Wd(l, re.some(m), re.none()), F1(l);
    }, qh = (l) => {
      const m = fg(l);
      Wd(l, re.some(m), re.none()), F1(l);
    }, I1 = (l) => {
      pr(l, "width");
      const m = ef(l), h = m.length > 0 ? m : Wc(l);
      Ye(h, (v) => {
        pr(v, "width"), F1(v);
      }), F1(l);
    }, kf = {
      styles: {
        "border-collapse": "collapse",
        width: "100%"
      },
      attributes: { border: "1" },
      colGroups: !1
    }, P0 = () => ve.fromTag("th"), r_ = () => ve.fromTag("td"), a_ = () => ve.fromTag("col"), yS = (l, m, h, v) => {
      const T = ve.fromTag("tr");
      for (let O = 0; O < l; O++) {
        const $ = v < m || O < h ? P0() : r_();
        O < h && Vs($, "scope", "row"), v < m && Vs($, "scope", "col"), Hs($, ve.fromTag("br")), Hs(T, $);
      }
      return T;
    }, c_ = (l) => {
      const m = ve.fromTag("colgroup");
      return Gn(l, () => Hs(m, a_())), m;
    }, fC = (l, m, h, v) => Gn(l, (T) => yS(m, h, v, T)), i_ = (l, m, h, v, T, O = kf) => {
      const $ = ve.fromTag("table"), W = T !== "cells";
      yn($, O.styles), Sa($, O.attributes), O.colGroups && Hs($, c_(m));
      const Q = Math.min(l, h);
      if (W && h > 0) {
        const tn = ve.fromTag("thead");
        Hs($, tn);
        const cn = fC(h, m, T === "sectionCells" ? Q : 0, v);
        ca(tn, cn);
      }
      const ge = ve.fromTag("tbody");
      Hs($, ge);
      const Re = W ? l - Q : l, an = fC(Re, m, W ? 0 : h, v);
      return ca(ge, an), $;
    }, l_ = (l) => l.dom.innerHTML, CS = (l) => {
      const m = ve.fromTag("div"), h = ve.fromDom(l.dom.cloneNode(!0));
      return Hs(m, h), l_(m);
    }, u_ = (l, m) => {
      l.selection.select(m.dom, !0), l.selection.collapse(!0);
    }, wS = (l, m) => {
      Ga(m, "td,th").each(ht(u_, l));
    }, d_ = (l, m) => {
      Ye(gr(m, "tr"), (h) => {
        dS(l, h.dom), Ye(gr(h, "th,td"), (v) => {
          aC(l, v.dom);
        });
      });
    }, B0 = (l) => Fe(l) && l.indexOf("%") !== -1, m_ = (l, m, h, v, T) => {
      const O = wy(l), $ = {
        styles: O,
        attributes: ad(l),
        colGroups: f1(l)
      };
      return l.undoManager.ignore(() => {
        const W = i_(h, m, T, v, pg(l), $);
        Vs(W, "data-mce-id", "__mce");
        const Q = CS(W);
        l.insertContent(Q), l.addVisual();
      }), Ga(e0(l), 'table[data-mce-id="__mce"]').map((W) => (gf(l) ? qh(W) : bg(l) ? I1(W) : (ym(l) || B0(O.width)) && iu(W), cd(W), ie(W, "data-mce-id"), d_(l, W), wS(l, W), W.dom)).getOrNull();
    }, SS = (l, m, h, v = {}) => {
      const T = (O) => En(O) && O > 0;
      if (T(m) && T(h)) {
        const O = v.headerRows || 0, $ = v.headerColumns || 0;
        return m_(l, h, m, $, O);
      } else
        return null;
    };
    var Gh = tinymce.util.Tools.resolve("tinymce.FakeClipboard");
    const gC = "x-tinymce/dom-table-", hC = gC + "rows", pC = gC + "columns", xS = (l) => {
      const m = Gh.FakeClipboardItem(l);
      Gh.write([m]);
    }, bC = (l) => {
      var m;
      const h = (m = Gh.read()) !== null && m !== void 0 ? m : [];
      return Vn(h, (v) => re.from(v.getType(l)));
    }, f_ = (l) => {
      bC(l).isSome() && Gh.clear();
    }, $0 = (l) => {
      l.fold(g_, (m) => xS({ [hC]: m }));
    }, F0 = () => bC(hC), g_ = () => f_(hC), vC = (l) => {
      l.fold(h_, (m) => xS({ [pC]: m }));
    }, TS = () => bC(pC), h_ = () => f_(pC), yC = (l) => id(Nl(l), Bd(l)).filter(n0), p_ = (l) => w1(Nl(l), Bd(l)).filter(n0), Kh = (l, m) => {
      const h = Bd(l), v = () => yC(l).each((ut) => {
        Zc(ut, h).filter(U(h)).each(($n) => {
          const wo = ve.fromText("");
          if (zr($n, wo), Pr($n), l.dom.isEmpty(l.getBody()))
            l.setContent(""), l.selection.setCursorLocation();
          else {
            const Ho = l.dom.createRng();
            Ho.setStart(wo.dom, 0), Ho.setEnd(wo.dom, 0), l.selection.setRng(Ho), l.nodeChanged();
          }
        });
      }), T = (ut) => yC(l).each(($n) => {
        bg(l) || gf(l) || ym(l) || Zc($n, h).each((Ho) => {
          ut === "relative" && !B1(Ho) ? iu(Ho) : ut === "fixed" && !$1(Ho) ? qh(Ho) : ut === "responsive" && !M0(Ho) && I1(Ho), cd(Ho), Dg(l, Ho.dom, Go);
        });
      }), O = (ut) => Zc(ut, h), $ = (ut) => p_(l).bind(($n) => O($n).map((wo) => ut(wo, $n))), W = (ut, $n) => {
        $((wo) => {
          l.formatter.toggle("tableclass", { value: $n }, wo.dom), Dg(l, wo.dom, Om);
        });
      }, Q = (ut, $n) => {
        $((wo) => {
          const Ho = cu(l), oc = lt(Ho, (ma) => l.formatter.match("tablecellclass", { value: $n }, ma.dom)) ? l.formatter.remove : l.formatter.apply;
          Ye(Ho, (ma) => oc("tablecellclass", { value: $n }, ma.dom)), Dg(l, wo.dom, Om);
        });
      }, ge = () => {
        yC(l).each((ut) => {
          Zc(ut, h).each(($n) => {
            Jo($n, "caption").fold(() => {
              const wo = ve.fromTag("caption");
              Hs(wo, ve.fromText("Caption")), Fa($n, wo, 0), l.selection.setCursorLocation(wo.dom, 0);
            }, (wo) => {
              sr("caption")(ut) && dt("td", $n).each((Ho) => l.selection.setCursorLocation(Ho.dom, 0)), Pr(wo);
            }), Dg(l, $n.dom, Go);
          });
        });
      }, Re = (ut) => {
        l.focus();
      }, Et = (ut, $n = !1) => $((wo, Ho) => {
        const Mr = Sh(cu(l), wo, Ho);
        ut(wo, Mr, $n).each(Re);
      }), an = () => $((ut, $n) => {
        const wo = Sh(cu(l), ut, $n), Ho = Bc(st, ve.fromDom(l.getDoc()), re.none());
        return e_(ut, wo, Ho);
      }), tn = () => $((ut, $n) => {
        const wo = Sh(cu(l), ut, $n);
        return Qk(ut, wo);
      }), ft = (ut, $n) => $n().each((wo) => {
        const Ho = rn(wo, (Mr) => Ac(Mr));
        $((Mr, oc) => {
          const ma = mf(ve.fromDom(l.getDoc())), Gi = xh(cu(l), oc, Ho, ma);
          ut(Mr, Gi).each(Re);
        });
      }), cn = (ut) => ($n, wo) => Cs(wo, "type").each((Ho) => {
        Et(ut(Ho), wo.no_events);
      });
      Xe({
        mceTableSplitCells: () => Et(m.unmergeCells),
        mceTableMergeCells: () => Et(m.mergeCells),
        mceTableInsertRowBefore: () => Et(m.insertRowsBefore),
        mceTableInsertRowAfter: () => Et(m.insertRowsAfter),
        mceTableInsertColBefore: () => Et(m.insertColumnsBefore),
        mceTableInsertColAfter: () => Et(m.insertColumnsAfter),
        mceTableDeleteCol: () => Et(m.deleteColumn),
        mceTableDeleteRow: () => Et(m.deleteRow),
        mceTableCutCol: () => tn().each((ut) => {
          vC(ut), Et(m.deleteColumn);
        }),
        mceTableCutRow: () => an().each((ut) => {
          $0(ut), Et(m.deleteRow);
        }),
        mceTableCopyCol: () => tn().each((ut) => vC(ut)),
        mceTableCopyRow: () => an().each((ut) => $0(ut)),
        mceTablePasteColBefore: () => ft(m.pasteColsBefore, TS),
        mceTablePasteColAfter: () => ft(m.pasteColsAfter, TS),
        mceTablePasteRowBefore: () => ft(m.pasteRowsBefore, F0),
        mceTablePasteRowAfter: () => ft(m.pasteRowsAfter, F0),
        mceTableDelete: v,
        mceTableCellToggleClass: Q,
        mceTableToggleClass: W,
        mceTableToggleCaption: ge,
        mceTableSizingMode: (ut, $n) => T($n),
        mceTableCellType: cn((ut) => ut === "th" ? m.makeCellsHeader : m.unmakeCellsHeader),
        mceTableColType: cn((ut) => ut === "th" ? m.makeColumnsHeader : m.unmakeColumnsHeader),
        mceTableRowType: cn((ut) => {
          switch (ut) {
            case "header":
              return m.makeRowsHeader;
            case "footer":
              return m.makeRowsFooter;
            default:
              return m.makeRowsBody;
          }
        })
      }, (ut, $n) => l.addCommand($n, ut)), l.addCommand("mceInsertTable", (ut, $n) => {
        SS(l, $n.rows, $n.columns, $n.options);
      }), l.addCommand("mceTableApplyCellStyle", (ut, $n) => {
        const wo = (oc) => "tablecell" + oc.toLowerCase().replace("-", "");
        if (!Ee($n))
          return;
        const Ho = bt(cu(l), n0);
        if (Ho.length === 0)
          return;
        const Mr = ds($n, (oc, ma) => l.formatter.has(wo(ma)) && Fe(oc));
        nn(Mr) || (Xe(Mr, (oc, ma) => {
          const Gi = wo(ma);
          Ye(Ho, (Lg) => {
            oc === "" ? l.formatter.remove(Gi, { value: null }, Lg.dom, !0) : l.formatter.apply(Gi, { value: oc }, Lg.dom);
          });
        }), O(Ho[0]).each((oc) => Dg(l, oc.dom, Om)));
      });
    }, b_ = (l, m) => {
      const h = Bd(l), v = (T) => w1(Nl(l)).bind((O) => Zc(O, h).map(($) => {
        const W = Sh(cu(l), $, O);
        return T($, W);
      })).getOr("");
      Xe({
        mceTableRowType: () => v(m.getTableRowType),
        mceTableCellType: () => v(m.getTableCellType),
        mceTableColType: () => v(m.getTableColType)
      }, (T, O) => l.addQueryValueHandler(O, T));
    }, CC = ml.generate([
      { before: ["element"] },
      {
        on: [
          "element",
          "offset"
        ]
      },
      { after: ["element"] }
    ]), v_ = (l, m, h, v) => l.fold(m, h, v), y_ = (l) => l.fold(Qe, Qe, Qe), C_ = CC.before, ES = CC.on, w_ = CC.after, xc = {
      before: C_,
      on: ES,
      after: w_,
      cata: v_,
      getStart: y_
    }, Yh = { create: (l, m) => ({
      selection: l,
      kill: m
    }) }, I0 = (l, m) => {
      const h = l.document.createRange();
      return h.selectNode(m.dom), h;
    }, kS = (l, m) => {
      const h = l.document.createRange();
      return wC(h, m), h;
    }, wC = (l, m) => l.selectNodeContents(m.dom), _S = (l, m) => {
      m.fold((h) => {
        l.setStartBefore(h.dom);
      }, (h, v) => {
        l.setStart(h.dom, v);
      }, (h) => {
        l.setStartAfter(h.dom);
      });
    }, AS = (l, m) => {
      m.fold((h) => {
        l.setEndBefore(h.dom);
      }, (h, v) => {
        l.setEnd(h.dom, v);
      }, (h) => {
        l.setEndAfter(h.dom);
      });
    }, Ng = (l, m, h) => {
      const v = l.document.createRange();
      return _S(v, m), AS(v, h), v;
    }, L1 = (l, m, h, v, T) => {
      const O = l.document.createRange();
      return O.setStart(m.dom, h), O.setEnd(v.dom, T), O;
    }, S_ = (l) => ({
      left: l.left,
      top: l.top,
      right: l.right,
      bottom: l.bottom,
      width: l.width,
      height: l.height
    }), x_ = (l) => {
      const m = l.getClientRects(), h = m.length > 0 ? m[0] : l.getBoundingClientRect();
      return h.width > 0 || h.height > 0 ? re.some(h).map(S_) : re.none();
    }, H1 = ml.generate([
      {
        ltr: [
          "start",
          "soffset",
          "finish",
          "foffset"
        ]
      },
      {
        rtl: [
          "start",
          "soffset",
          "finish",
          "foffset"
        ]
      }
    ]), SC = (l, m, h) => m(ve.fromDom(h.startContainer), h.startOffset, ve.fromDom(h.endContainer), h.endOffset), OS = (l, m) => m.match({
      domRange: (h) => ({
        ltr: J(h),
        rtl: re.none
      }),
      relative: (h, v) => ({
        ltr: wu(() => Ng(l, h, v)),
        rtl: wu(() => re.some(Ng(l, v, h)))
      }),
      exact: (h, v, T, O) => ({
        ltr: wu(() => L1(l, h, v, T, O)),
        rtl: wu(() => re.some(L1(l, T, O, h, v)))
      })
    }), nc = (l, m) => {
      const h = m.ltr();
      return h.collapsed ? m.rtl().filter((T) => T.collapsed === !1).map((T) => H1.rtl(ve.fromDom(T.endContainer), T.endOffset, ve.fromDom(T.startContainer), T.startOffset)).getOrThunk(() => SC(l, H1.ltr, h)) : SC(l, H1.ltr, h);
    }, DS = (l, m) => {
      const h = OS(l, m);
      return nc(l, h);
    }, xC = (l, m) => DS(l, m).match({
      ltr: (v, T, O, $) => {
        const W = l.document.createRange();
        return W.setStart(v.dom, T), W.setEnd(O.dom, $), W;
      },
      rtl: (v, T, O, $) => {
        const W = l.document.createRange();
        return W.setStart(O.dom, $), W.setEnd(v.dom, T), W;
      }
    });
    H1.ltr, H1.rtl;
    const Xh = { create: (l, m, h, v) => ({
      start: l,
      soffset: m,
      finish: h,
      foffset: v
    }) }, RS = { create: (l, m, h, v) => ({
      start: xc.on(l, m),
      finish: xc.on(h, v)
    }) }, TC = (l, m) => {
      const h = xC(l, m);
      return Xh.create(ve.fromDom(h.startContainer), h.startOffset, ve.fromDom(h.endContainer), h.endOffset);
    }, z1 = RS.create, L0 = (l, m, h, v, T, O, $) => wt(h, T) && v === O ? re.none() : ar(h, "td,th", m).bind((W) => ar(T, "td,th", m).bind((Q) => Jh(l, m, W, Q, $))), Jh = (l, m, h, v, T) => wt(h, v) ? re.none() : Bu(h, v, m).bind((O) => {
      const $ = O.boxes.getOr([]);
      return $.length > 1 ? (T(l, $, O.start, O.finish), re.some(Yh.create(re.some(z1(h, 0, h, Ws(h))), !0))) : re.none();
    }), E_ = (l, m, h, v, T) => {
      const O = ($) => (T.clearBeforeUpdate(h), T.selectRange(h, $.boxes, $.start, $.finish), $.boxes);
      return a0(v, l, m, T.firstSelectedSelector, T.lastSelectedSelector).map(O);
    }, _f = (l, m) => ({
      item: l,
      mode: m
    }), NS = (l, m, h, v = Af) => l.property().parent(m).map((T) => _f(T, v)), Af = (l, m, h, v = Of) => h.sibling(l, m).map((T) => _f(T, v)), Of = (l, m, h, v = Of) => {
      const T = l.property().children(m);
      return h.first(T).map(($) => _f($, v));
    }, EC = [
      {
        current: NS,
        next: Af,
        fallback: re.none()
      },
      {
        current: Af,
        next: Of,
        fallback: re.some(NS)
      },
      {
        current: Of,
        next: Of,
        fallback: re.some(Af)
      }
    ], MS = (l, m, h, v, T = EC) => F(T, ($) => $.current === h).bind(($) => $.current(l, m, v, $.next).orThunk(() => $.fallback.bind((W) => MS(l, m, W, v)))), Df = {
      left: () => ({
        sibling: (h, v) => h.query().prevSibling(v),
        first: (h) => h.length > 0 ? re.some(h[h.length - 1]) : re.none()
      }),
      right: () => ({
        sibling: (h, v) => h.query().nextSibling(v),
        first: (h) => h.length > 0 ? re.some(h[0]) : re.none()
      })
    }, Zd = (l, m, h, v, T, O) => MS(l, m, v, T).bind((W) => O(W.item) ? re.none() : h(W.item) ? re.some(W.item) : Zd(l, W.item, h, W.mode, T, O)), V1 = (l, m, h, v) => Zd(l, m, h, Af, Df.left(), v), Qh = (l, m, h, v) => Zd(l, m, h, Af, Df.right(), v), _C = (l) => (m) => l.property().children(m).length === 0, Dm = (l, m, h) => U1(l, m, _C(l), h), md = (l, m, h) => H0(l, m, _C(l), h), U1 = V1, H0 = Qh, W1 = mt(), AC = (l, m) => Dm(W1, l, m), ep = (l, m) => md(W1, l, m), Z1 = (l, m, h) => U1(W1, l, m, h), OC = (l, m, h) => H0(W1, l, m, h), PS = (l, m, h) => Us(l, m, h).isSome(), Rf = ml.generate([
      { none: ["message"] },
      { success: [] },
      { failedUp: ["cell"] },
      { failedDown: ["cell"] }
    ]), z0 = (l, m, h) => {
      const v = l.getRect(m), T = l.getRect(h);
      return T.right > v.left && T.left < v.right;
    }, k_ = (l) => ar(l, "tr"), ya = {
      ...Rf,
      verify: (l, m, h, v, T, O, $) => ar(v, "td,th", $).bind((W) => ar(m, "td,th", $).map((Q) => wt(W, Q) ? wt(v, W) && Ws(W) === T ? O(Q) : Rf.none("in same cell") : cr(k_, [
        W,
        Q
      ]).fold(() => z0(l, Q, W) ? Rf.success() : O(Q), (ge) => O(Q)))).getOr(Rf.none("default")),
      cata: (l, m, h, v, T) => l.fold(m, h, v, T)
    }, tR = (l, m, h, v) => ({
      parent: l,
      children: m,
      element: h,
      index: v
    }), Rm = (l) => zo(l).bind((m) => {
      const h = lo(m);
      return $S(h, l).map((v) => tR(m, h, l, v));
    }), $S = (l, m) => ss(l, ht(wt, m)), V0 = sr("br"), Nf = (l, m, h) => m(l, h).bind((v) => ga(v) && Jn(v).trim().length === 0 ? Nf(v, m, h) : re.some(v)), Qc = (l, m, h) => h.traverse(m).orThunk(() => Nf(m, h.gather, l)).map(h.relative), tp = (l, m) => Fo(l, m).filter(V0).orThunk(() => Fo(l, m - 1).filter(V0)), j1 = (l, m, h, v) => tp(m, h).bind((T) => v.traverse(T).fold(() => Nf(T, v.gather, l).map(v.relative), (O) => Rm(O).map(($) => xc.on($.parent, $.index)))), np = (l, m, h, v) => (V0(m) ? Qc(l, m, v) : j1(l, m, h, v)).map((O) => ({
      start: O,
      finish: O
    })), RC = (l) => ya.cata(l, (m) => re.none(), () => re.none(), (m) => re.some(Eh(m, 0)), (m) => re.some(Eh(m, Ws(m)))), op = (l, m) => ({
      left: l.left,
      top: l.top + m,
      right: l.right,
      bottom: l.bottom + m
    }), Mg = (l, m) => ({
      left: l.left,
      top: l.top - m,
      right: l.right,
      bottom: l.bottom - m
    }), fd = (l, m, h) => ({
      left: l.left + m,
      top: l.top + h,
      right: l.right + m,
      bottom: l.bottom + h
    }), __ = (l) => l.top, A_ = (l) => l.bottom, Mf = (l, m, h) => h >= 0 && h < Ws(m) ? l.getRangedRect(m, h, m, h + 1) : h > 0 ? l.getRangedRect(m, h - 1, m, h) : re.none(), sp = (l) => ({
      left: l.left,
      top: l.top,
      right: l.right,
      bottom: l.bottom
    }), U0 = (l, m) => re.some(l.getRect(m)), jd = (l, m, h) => dr(m) ? U0(l, m).map(sp) : ga(m) ? Mf(l, m, h).map(sp) : re.none(), NC = (l, m) => dr(m) ? U0(l, m).map(sp) : ga(m) ? l.getRangedRect(m, 0, m, Ws(m)).map(sp) : re.none(), Tc = 5, Nm = 100, Lu = ml.generate([
      { none: [] },
      { retry: ["caret"] }
    ]), rp = (l, m) => l.left < m.left || Math.abs(m.right - l.left) < 1 || l.left > m.right, pi = (l, m, h) => qa(m, k0).fold(gn, (v) => NC(l, v).exists((T) => rp(h, T))), ji = (l, m, h, v, T) => {
      const O = op(T, Tc);
      return Math.abs(h.bottom - v.bottom) < 1 || h.top > T.bottom ? Lu.retry(O) : h.top === T.bottom ? Lu.retry(op(T, 1)) : pi(l, m, T) ? Lu.retry(fd(O, Tc, 0)) : Lu.none();
    }, Hu = {
      point: __,
      adjuster: (l, m, h, v, T) => {
        const O = Mg(T, Tc);
        return Math.abs(h.top - v.top) < 1 || h.bottom < T.top ? Lu.retry(O) : h.bottom === T.top ? Lu.retry(Mg(T, 1)) : pi(l, m, T) ? Lu.retry(fd(O, Tc, 0)) : Lu.none();
      },
      move: Mg,
      gather: AC
    }, W0 = {
      point: A_,
      adjuster: ji,
      move: op,
      gather: ep
    }, Fl = (l, m, h) => l.elementFromPoint(m, h).filter((v) => xs(v) === "table").isSome(), Pg = (l, m, h, v, T) => MC(l, m, h, m.move(v, Tc), T), MC = (l, m, h, v, T) => T === 0 ? re.some(v) : Fl(l, v.left, m.point(v)) ? Pg(l, m, h, v, T - 1) : l.situsFromPoint(v.left, m.point(v)).bind((O) => O.start.fold(re.none, ($) => NC(l, $).bind((W) => m.adjuster(l, $, W, h, v).fold(re.none, (Q) => MC(l, m, h, Q, T - 1))).orThunk(() => re.some(v)), re.none)), O_ = (l, m, h) => l.point(m) > h.getInnerHeight() ? re.some(l.point(m) - h.getInnerHeight()) : l.point(m) < 0 ? re.some(-l.point(m)) : re.none(), FS = (l, m, h) => {
      const v = l.move(h, Tc), T = MC(m, l, h, v, Nm).getOr(v);
      return O_(l, T, m).fold(() => m.situsFromPoint(T.left, l.point(T)), (O) => (m.scrollBy(0, O), m.situsFromPoint(T.left, l.point(T) - O)));
    }, q1 = {
      tryUp: ht(FS, Hu),
      tryDown: ht(FS, W0),
      getJumpSize: J(Tc)
    }, IS = 20, G1 = (l, m, h) => l.getSelection().bind((v) => np(m, v.finish, v.foffset, h).fold(() => re.some(Eh(v.finish, v.foffset)), (T) => {
      const O = l.fromSitus(T), $ = ya.verify(l, v.finish, v.foffset, O.finish, O.foffset, h.failure, m);
      return RC($);
    })), Z0 = (l, m, h, v, T, O) => O === 0 ? re.none() : R_(l, m, h, v, T).bind(($) => {
      const W = l.fromSitus($), Q = ya.verify(l, h, v, W.finish, W.foffset, T.failure, m);
      return ya.cata(Q, () => re.none(), () => re.some($), (ge) => wt(h, ge) && v === 0 ? D_(l, h, v, Mg, T) : Z0(l, m, ge, 0, T, O - 1), (ge) => wt(h, ge) && v === Ws(ge) ? D_(l, h, v, op, T) : Z0(l, m, ge, Ws(ge), T, O - 1));
    }), D_ = (l, m, h, v, T) => jd(l, m, h).bind((O) => LS(l, T, v(O, q1.getJumpSize()))), LS = (l, m, h) => {
      const v = Tu().browser;
      return v.isChromium() || v.isSafari() || v.isFirefox() ? m.retry(l, h) : re.none();
    }, R_ = (l, m, h, v, T) => jd(l, h, v).bind((O) => LS(l, T, O)), nR = (l, m, h) => G1(l, m, h).bind((v) => Z0(l, m, v.element, v.offset, h, IS).map(l.fromSitus)), HS = (l, m) => PS(l, (h) => zo(h).exists((v) => wt(v, m))), is = (l, m, h, v, T) => ar(v, "td,th", m).bind((O) => ar(O, "table", m).bind(($) => HS(T, $) ? nR(l, m, h).bind((W) => ar(W.finish, "td,th", m).map((Q) => ({
      start: O,
      finish: Q,
      range: W
    }))) : re.none())), gd = (l, m, h, v, T, O) => O(v, m).orThunk(() => is(l, m, h, v, T).map(($) => {
      const W = $.range;
      return Yh.create(re.some(z1(W.start, W.soffset, W.finish, W.foffset)), !0);
    })), Bg = (l, m) => ar(l, "tr", m).bind((h) => ar(h, "table", m).bind((v) => {
      const T = gr(v, "tr");
      return wt(h, T[0]) ? Z1(v, (O) => Dl(O).isSome(), m).map((O) => {
        const $ = Ws(O);
        return Yh.create(re.some(z1(O, $, O, $)), !0);
      }) : re.none();
    })), PC = (l, m) => ar(l, "tr", m).bind((h) => ar(h, "table", m).bind((v) => {
      const T = gr(v, "tr");
      return wt(h, T[T.length - 1]) ? OC(v, (O) => vh(O).isSome(), m).map((O) => Yh.create(re.some(z1(O, 0, O, 0)), !0)) : re.none();
    })), zS = (l, m, h, v, T, O, $) => is(l, h, v, T, O).bind((W) => Jh(m, h, W.start, W.finish, $)), K1 = (l) => {
      let m = l;
      return {
        get: () => m,
        set: (T) => {
          m = T;
        }
      };
    }, N_ = (l) => {
      const m = K1(re.none()), h = () => m.get().each(l);
      return {
        clear: () => {
          h(), m.set(re.none());
        },
        isSet: () => m.get().isSome(),
        get: () => m.get(),
        set: (W) => {
          h(), m.set(re.some(W));
        }
      };
    }, ap = () => {
      const l = N_(st);
      return {
        ...l,
        on: (h) => l.get().each(h)
      };
    }, j0 = (l, m) => ar(l, "td,th", m), Il = (l) => Ds(l).exists(hf), jI = (l, m, h, v) => {
      const T = ap(), O = T.clear, $ = (Re) => {
        T.on((Et) => {
          v.clearBeforeUpdate(m), j0(Re.target, h).each((an) => {
            Bu(Et, an, h).each((tn) => {
              const ft = tn.boxes.getOr([]);
              if (ft.length === 1) {
                const cn = ft[0], ut = g1(cn) === "false", $n = $i(Qb(Re.target), cn, wt);
                ut && $n && (v.selectRange(m, ft, cn, cn), l.selectContents(cn));
              } else ft.length > 1 && (v.selectRange(m, ft, tn.start, tn.finish), l.selectContents(an));
            });
          });
        });
      };
      return {
        clearstate: O,
        mousedown: (Re) => {
          v.clear(m), j0(Re.target, h).filter(Il).each(T.set);
        },
        mouseover: (Re) => {
          $(Re);
        },
        mouseup: (Re) => {
          $(Re), O();
        }
      };
    }, q0 = {
      traverse: vc,
      gather: ep,
      relative: xc.before,
      retry: q1.tryDown,
      failure: ya.failedDown
    }, cp = {
      traverse: ac,
      gather: AC,
      relative: xc.before,
      retry: q1.tryUp,
      failure: ya.failedUp
    }, Pf = (l) => (m) => m === l, G0 = Pf(38), K0 = Pf(40), $g = (l) => l >= 37 && l <= 40, M_ = {
      isBackward: Pf(37),
      isForward: Pf(39)
    }, VS = {
      isBackward: Pf(39),
      isForward: Pf(37)
    }, P_ = (l) => {
      const m = l !== void 0 ? l.dom : document, h = m.body.scrollLeft || m.documentElement.scrollLeft, v = m.body.scrollTop || m.documentElement.scrollTop;
      return ce(h, v);
    }, ip = (l, m, h) => {
      const T = (h !== void 0 ? h.dom : document).defaultView;
      T && T.scrollBy(l, m);
    }, Mm = ml.generate([
      { domRange: ["rng"] },
      {
        relative: [
          "startSitu",
          "finishSitu"
        ]
      },
      {
        exact: [
          "start",
          "soffset",
          "finish",
          "foffset"
        ]
      }
    ]), B_ = (l) => Mm.exact(l.start, l.soffset, l.finish, l.foffset), $_ = (l) => l.match({
      domRange: (m) => ve.fromDom(m.startContainer),
      relative: (m, h) => xc.getStart(m),
      exact: (m, h, v, T) => m
    }), US = Mm.domRange, BC = Mm.relative, $C = Mm.exact, FC = (l) => {
      const m = $_(l);
      return Kn(m);
    }, Y0 = Xh.create, Bf = {
      domRange: US,
      relative: BC,
      exact: $C,
      exactFromRange: B_,
      getWin: FC,
      range: Y0
    }, WS = (l, m, h) => {
      var v, T;
      return re.from((T = (v = l.dom).caretPositionFromPoint) === null || T === void 0 ? void 0 : T.call(v, m, h)).bind((O) => {
        if (O.offsetNode === null)
          return re.none();
        const $ = l.dom.createRange();
        return $.setStart(O.offsetNode, O.offset), $.collapse(), re.some($);
      });
    }, Y1 = (l, m, h) => {
      var v, T;
      return re.from((T = (v = l.dom).caretRangeFromPoint) === null || T === void 0 ? void 0 : T.call(v, m, h));
    }, IC = document.caretPositionFromPoint ? WS : document.caretRangeFromPoint ? Y1 : re.none, F_ = (l, m, h) => {
      const v = ve.fromDom(l.document);
      return IC(v, m, h).map((T) => Xh.create(ve.fromDom(T.startContainer), T.startOffset, ve.fromDom(T.endContainer), T.endOffset));
    }, X1 = (l, m) => {
      const h = xs(l);
      return h === "input" ? xc.after(l) : mn([
        "br",
        "img"
      ], h) ? m === 0 ? xc.before(l) : xc.after(l) : xc.on(l, m);
    }, I_ = (l, m) => {
      const h = l.fold(xc.before, X1, xc.after), v = m.fold(xc.before, X1, xc.after);
      return Bf.relative(h, v);
    }, ln = (l, m, h, v) => {
      const T = X1(l, m), O = X1(h, v);
      return Bf.relative(T, O);
    }, za = (l, m, h, v) => {
      const O = On(l).dom.createRange();
      return O.setStart(l.dom, m), O.setEnd(h.dom, v), O;
    }, Pm = (l, m, h, v) => {
      const T = za(l, m, h, v), O = wt(l, h) && m === v;
      return T.collapsed && !O;
    }, Oa = (l) => re.from(l.getSelection()), lu = (l, m) => {
      Oa(l).each((h) => {
        h.removeAllRanges(), h.addRange(m);
      });
    }, X0 = (l, m, h, v, T) => {
      const O = L1(l, m, h, v, T);
      lu(l, O);
    }, J1 = (l, m, h, v, T, O) => {
      m.collapse(h.dom, v), m.extend(T.dom, O);
    }, hd = (l, m) => DS(l, m).match({
      ltr: (h, v, T, O) => {
        X0(l, h, v, T, O);
      },
      rtl: (h, v, T, O) => {
        Oa(l).each(($) => {
          if ($.setBaseAndExtent)
            $.setBaseAndExtent(h.dom, v, T.dom, O);
          else if ($.extend)
            try {
              J1(l, $, h, v, T, O);
            } catch {
              X0(l, T, O, h, v);
            }
          else
            X0(l, T, O, h, v);
        });
      }
    }), J0 = (l, m, h, v, T) => {
      const O = ln(m, h, v, T);
      hd(l, O);
    }, Q0 = (l, m, h) => {
      const v = I_(m, h);
      hd(l, v);
    }, lp = (l) => {
      if (l.rangeCount > 0) {
        const m = l.getRangeAt(0), h = l.getRangeAt(l.rangeCount - 1);
        return re.some(Xh.create(ve.fromDom(m.startContainer), m.startOffset, ve.fromDom(h.endContainer), h.endOffset));
      } else
        return re.none();
    }, ZS = (l) => {
      if (l.anchorNode === null || l.focusNode === null)
        return lp(l);
      {
        const m = ve.fromDom(l.anchorNode), h = ve.fromDom(l.focusNode);
        return Pm(m, l.anchorOffset, h, l.focusOffset) ? re.some(Xh.create(m, l.anchorOffset, h, l.focusOffset)) : lp(l);
      }
    }, Q1 = (l, m, h = !0) => {
      const T = (h ? kS : I0)(l, m);
      lu(l, T);
    }, LC = (l) => Oa(l).filter((m) => m.rangeCount > 0).bind(ZS), HC = (l) => LC(l).map((m) => Bf.exact(m.start, m.soffset, m.finish, m.foffset)), L_ = (l, m) => {
      const h = xC(l, m);
      return x_(h);
    }, pd = (l, m, h) => F_(l, m, h), ev = (l) => {
      Oa(l).each((m) => m.removeAllRanges());
    }, up = (l) => ({
      elementFromPoint: (ut, $n) => ve.fromPoint(ve.fromDom(l.document), ut, $n),
      getRect: (ut) => ut.dom.getBoundingClientRect(),
      getRangedRect: (ut, $n, wo, Ho) => {
        const Mr = Bf.exact(ut, $n, wo, Ho);
        return L_(l, Mr);
      },
      getSelection: () => HC(l).map((ut) => TC(l, ut)),
      fromSitus: (ut) => {
        const $n = Bf.relative(ut.start, ut.finish);
        return TC(l, $n);
      },
      situsFromPoint: (ut, $n) => pd(l, ut, $n).map((wo) => RS.create(wo.start, wo.soffset, wo.finish, wo.foffset)),
      clearSelection: () => {
        ev(l);
      },
      collapseSelection: (ut = !1) => {
        HC(l).each(($n) => $n.fold((wo) => wo.collapse(ut), (wo, Ho) => {
          const Mr = ut ? wo : Ho;
          Q0(l, Mr, Mr);
        }, (wo, Ho, Mr, oc) => {
          const ma = ut ? wo : Mr, Gi = ut ? Ho : oc;
          J0(l, ma, Gi, ma, Gi);
        }));
      },
      setSelection: (ut) => {
        J0(l, ut.start, ut.soffset, ut.finish, ut.foffset);
      },
      setRelativeSelection: (ut, $n) => {
        Q0(l, ut, $n);
      },
      selectNode: (ut) => {
        Q1(l, ut, !1);
      },
      selectContents: (ut) => {
        Q1(l, ut);
      },
      getInnerHeight: () => l.innerHeight,
      getScrollY: () => P_(ve.fromDom(l.document)).top,
      scrollBy: (ut, $n) => {
        ip(ut, $n, ve.fromDom(l.document));
      }
    }), Hc = (l, m) => ({
      rows: l,
      cols: m
    }), Ba = (l, m, h, v) => {
      const T = up(l), O = jI(T, m, h, v);
      return {
        clearstate: O.clearstate,
        mousedown: O.mousedown,
        mouseover: O.mouseover,
        mouseup: O.mouseup
      };
    }, tv = (l) => qa(l, Zn).exists(hf), eb = (l, m) => tv(l) || tv(m), nv = (l, m, h, v) => {
      const T = up(l), O = () => (v.clear(m), re.none());
      return {
        keydown: (Q, ge, Re, Et, an, tn) => {
          const ft = Q.raw, cn = ft.which, ut = ft.shiftKey === !0;
          return Sm(m, v.selectedSelector).fold(() => ($g(cn) && !ut && v.clearBeforeUpdate(m), $g(cn) && ut && !eb(ge, Et) ? re.none : K0(cn) && ut ? ht(zS, T, m, h, q0, Et, ge, v.selectRange) : G0(cn) && ut ? ht(zS, T, m, h, cp, Et, ge, v.selectRange) : K0(cn) ? ht(gd, T, h, q0, Et, ge, PC) : G0(cn) ? ht(gd, T, h, cp, Et, ge, Bg) : re.none), (wo) => {
            const Ho = (Mr) => () => Vn(Mr, (ma) => E_(ma.rows, ma.cols, m, wo, v)).fold(() => yg(m, v.firstSelectedSelector, v.lastSelectedSelector).map((ma) => {
              const Gi = K0(cn) || tn.isForward(cn) ? xc.after : xc.before;
              return T.setRelativeSelection(xc.on(ma.first, 0), Gi(ma.table)), v.clear(m), Yh.create(re.none(), !0);
            }), (ma) => re.some(Yh.create(re.none(), !0)));
            return $g(cn) && ut && !eb(ge, Et) ? re.none : K0(cn) && ut ? Ho([Hc(1, 0)]) : G0(cn) && ut ? Ho([Hc(-1, 0)]) : tn.isBackward(cn) && ut ? Ho([
              Hc(0, -1),
              Hc(-1, 0)
            ]) : tn.isForward(cn) && ut ? Ho([
              Hc(0, 1),
              Hc(1, 0)
            ]) : $g(cn) && !ut ? O : re.none;
          })();
        },
        keyup: (Q, ge, Re, Et, an) => Sm(m, v.selectedSelector).fold(() => {
          const tn = Q.raw, ft = tn.which;
          return tn.shiftKey === !0 && $g(ft) && eb(ge, Et) ? L0(m, h, ge, Re, Et, an, v.selectRange) : re.none();
        }, re.none)
      };
    }, tb = (l, m, h, v) => {
      const T = up(l);
      return (O, $) => {
        v.clearBeforeUpdate(m), Bu(O, $, h).each((W) => {
          const Q = W.boxes.getOr([]);
          v.selectRange(m, Q, W.start, W.finish), T.selectContents($), T.collapseSelection();
        });
      };
    }, nb = (l, m) => {
      const h = wr(l, m);
      return h === void 0 || h === "" ? [] : h.split(" ");
    }, dp = (l, m, h) => {
      const T = nb(l, m).concat([h]);
      return Vs(l, m, T.join(" ")), !0;
    }, jS = (l, m, h) => {
      const v = bt(nb(l, m), (T) => T !== h);
      return v.length > 0 ? Vs(l, m, v.join(" ")) : ie(l, m), !1;
    }, ob = (l) => l.dom.classList !== void 0, qS = (l) => nb(l, "class"), GS = (l, m) => dp(l, "class", m), KS = (l, m) => jS(l, "class", m), uu = (l, m) => {
      ob(l) ? l.dom.classList.add(m) : GS(l, m);
    }, ei = (l) => {
      (ob(l) ? l.dom.classList : qS(l)).length === 0 && ie(l, "class");
    }, zu = (l, m) => {
      ob(l) ? l.dom.classList.remove(m) : KS(l, m), ei(l);
    }, qi = (l, m) => ob(l) && l.dom.classList.contains(m), sb = (l, m) => {
      Ye(m, (h) => {
        zu(l, h);
      });
    }, ov = (l) => (m) => {
      uu(m, l);
    }, YS = (l) => (m) => {
      sb(m, l);
    }, Bm = {
      byClass: (l) => {
        const m = ov(l.selected), h = YS([
          l.selected,
          l.lastSelected,
          l.firstSelected
        ]), v = (O) => {
          const $ = gr(O, l.selectedSelector);
          Ye($, h);
        };
        return {
          clearBeforeUpdate: v,
          clear: v,
          selectRange: (O, $, W, Q) => {
            v(O), Ye($, m), uu(W, l.firstSelected), uu(Q, l.lastSelected);
          },
          selectedSelector: l.selectedSelector,
          firstSelectedSelector: l.firstSelectedSelector,
          lastSelectedSelector: l.lastSelectedSelector
        };
      },
      byAttr: (l, m, h) => {
        const v = (Q) => {
          ie(Q, l.selected), ie(Q, l.firstSelected), ie(Q, l.lastSelected);
        }, T = (Q) => {
          Vs(Q, l.selected, "1");
        }, O = (Q) => {
          $(Q), h();
        }, $ = (Q) => {
          const ge = gr(Q, `${l.selectedSelector},${l.firstSelectedSelector},${l.lastSelectedSelector}`);
          Ye(ge, v);
        };
        return {
          clearBeforeUpdate: $,
          clear: O,
          selectRange: (Q, ge, Re, Et) => {
            O(Q), Ye(ge, T), Vs(Re, l.firstSelected, "1"), Vs(Et, l.lastSelected, "1"), m(ge, Re, Et);
          },
          selectedSelector: l.selectedSelector,
          firstSelectedSelector: l.firstSelectedSelector,
          lastSelectedSelector: l.lastSelectedSelector
        };
      }
    }, ab = (l, m, h, v) => {
      switch (l.tag) {
        case "none":
          return m();
        case "single":
          return v(l.element);
        case "multiple":
          return h(l.elements);
      }
    }, zC = () => ({ tag: "none" }), XS = (l) => ({
      tag: "multiple",
      elements: l
    }), JS = (l) => ({
      tag: "single",
      element: l
    }), VC = (l, m, h) => ({ get: () => Oy(l(), h).fold(() => m().fold(zC, JS), XS) }), sv = (l, m) => {
      const h = l.slice(0, m[m.length - 1].row + 1), v = jr(h);
      return at(v, (T) => {
        const O = T.cells.slice(0, m[m.length - 1].column + 1);
        return rn(O, ($) => $.element);
      });
    }, ir = (l, m) => {
      const h = l.slice(m[0].row + m[0].rowspan - 1, l.length), v = jr(h);
      return at(v, (T) => {
        const O = T.cells.slice(m[0].column + m[0].colspan - 1, T.cells.length);
        return rn(O, ($) => $.element);
      });
    }, $m = (l, m, h) => {
      const v = Wo.fromTable(l);
      return yf(v, m).map((O) => {
        const $ = Rh(v, h, !1), { rows: W } = ta($), Q = sv(W, O), ge = ir(W, O);
        return {
          upOrLeftCells: Q,
          downOrRightCells: ge
        };
      });
    }, QS = (l, m, h, v, T, O, $) => ({
      target: l,
      x: m,
      y: h,
      stop: v,
      prevent: T,
      kill: O,
      raw: $
    }), UC = (l) => {
      const m = ve.fromDom(sn(l).getOr(l.target)), h = () => l.stopPropagation(), v = () => l.preventDefault(), T = Pn(v, h);
      return QS(m, l.clientX, l.clientY, h, v, T, l);
    }, WC = (l, m) => (h) => {
      l(h) && m(UC(h));
    }, Fg = (l, m, h, v, T) => {
      const O = WC(h, v);
      return l.dom.addEventListener(m, O, T), { unbind: ht(jC, l, m, O, T) };
    }, ZC = (l, m, h, v) => Fg(l, m, h, v, !1), jC = (l, m, h, v) => {
      l.dom.removeEventListener(m, h, v);
    }, z_ = De, mp = (l, m, h) => ZC(l, m, z_, h), fp = UC, qC = (l) => !qi(ve.fromDom(l.target), "ephox-snooker-resizer-bar"), GC = (l, m) => {
      const h = VC(() => ve.fromDom(l.getBody()), () => w1(Nl(l), Bd(l)), Sg.selectedSelector), v = (Q, ge, Re) => {
        Zc(ge).each((an) => {
          const tn = vm(l), ft = Bc(st, ve.fromDom(l.getDoc()), tn), cn = cu(l), ut = $m(an, { selection: cn }, ft);
          Yk(l, Q, ge, Re, ut);
        });
      }, T = () => Xk(l), O = Bm.byAttr(Sg, v, T);
      return l.on("init", (Q) => {
        const ge = l.getWin(), Re = e0(l), Et = Bd(l), an = () => {
          const tr = l.selection, bi = ve.fromDom(tr.getStart()), zc = ve.fromDom(tr.getEnd());
          cr(Zc, [
            bi,
            zc
          ]).fold(() => O.clear(Re), st);
        }, tn = Ba(ge, Re, Et, O), ft = nv(ge, Re, Et, O), cn = tb(ge, Re, Et, O), ut = (tr) => tr.raw.shiftKey === !0;
        l.on("TableSelectorChange", (tr) => cn(tr.start, tr.finish));
        const $n = (tr, bi) => {
          ut(tr) && (bi.kill && tr.kill(), bi.selection.each((zc) => {
            const zl = Bf.relative(zc.start, zc.finish), hl = xC(ge, zl);
            l.selection.setRng(hl);
          }));
        }, wo = (tr) => {
          const bi = fp(tr);
          if (bi.raw.shiftKey && $g(bi.raw.which)) {
            const zc = l.selection.getRng(), zl = ve.fromDom(zc.startContainer), hl = ve.fromDom(zc.endContainer);
            ft.keyup(bi, zl, zc.startOffset, hl, zc.endOffset).each((If) => {
              $n(bi, If);
            });
          }
        }, Ho = (tr) => {
          const bi = fp(tr);
          m.hide();
          const zc = l.selection.getRng(), zl = ve.fromDom(zc.startContainer), hl = ve.fromDom(zc.endContainer), If = ig(M_, VS)(ve.fromDom(l.selection.getStart()));
          ft.keydown(bi, zl, zc.startOffset, hl, zc.endOffset, If).each((Ni) => {
            $n(bi, Ni);
          }), m.show();
        }, Mr = (tr) => tr.button === 0, oc = (tr) => tr.buttons === void 0 ? !0 : (tr.buttons & 1) !== 0, ma = (tr) => {
          tn.clearstate();
        }, Gi = (tr) => {
          Mr(tr) && qC(tr) && tn.mousedown(fp(tr));
        }, Lg = (tr) => {
          oc(tr) && qC(tr) && tn.mouseover(fp(tr));
        }, Hg = (tr) => {
          Mr(tr) && qC(tr) && tn.mouseup(fp(tr));
        }, uv = (() => {
          const tr = K1(ve.fromDom(Re)), bi = K1(0);
          return { touchEnd: (zl) => {
            const hl = ve.fromDom(zl.target);
            if (sr("td")(hl) || sr("th")(hl)) {
              const If = tr.get(), Ni = bi.get();
              wt(If, hl) && zl.timeStamp - Ni < 300 && (zl.preventDefault(), cn(hl, hl));
            }
            tr.set(hl), bi.set(zl.timeStamp);
          } };
        })();
        l.on("dragstart", ma), l.on("mousedown", Gi), l.on("mouseover", Lg), l.on("mouseup", Hg), l.on("touchend", uv.touchEnd), l.on("keyup", wo), l.on("keydown", Ho), l.on("NodeChange", an);
      }), l.on("PreInit", () => {
        l.serializer.addTempAttr(Sg.firstSelected), l.serializer.addTempAttr(Sg.lastSelected);
      }), {
        getSelectedCells: () => ab(h.get(), J([]), (Q) => rn(Q, (ge) => ge.dom), (Q) => [Q.dom]),
        clearSelectedCells: (Q) => O.clear(ve.fromDom(Q))
      };
    }, Vu = (l) => {
      let m = [];
      return {
        bind: (O) => {
          if (O === void 0)
            throw new Error("Event bind error: undefined handler");
          m.push(O);
        },
        unbind: (O) => {
          m = bt(m, ($) => $ !== O);
        },
        trigger: (...O) => {
          const $ = {};
          Ye(l, (W, Q) => {
            $[W] = O[Q];
          }), Ye(m, (W) => {
            W($);
          });
        }
      };
    }, $f = (l) => {
      const m = In(l, (v) => ({
        bind: v.bind,
        unbind: v.unbind
      })), h = In(l, (v) => v.trigger);
      return {
        registry: m,
        trigger: h
      };
    }, V_ = (l, m) => {
      let h = null;
      const v = () => {
        fn(h) || (clearTimeout(h), h = null);
      };
      return {
        cancel: v,
        throttle: (...O) => {
          v(), h = setTimeout(() => {
            h = null, l.apply(null, O);
          }, m);
        }
      };
    }, cb = (l) => l.slice(0).sort(), U_ = (l, m) => {
      throw new Error("All required keys (" + cb(l).join(", ") + ") were not specified. Specified keys were: " + cb(m).join(", ") + ".");
    }, gl = (l) => {
      throw new Error("Unsupported keys for object: " + cb(l).join(", "));
    }, ti = (l, m) => {
      if (!Bt(m))
        throw new Error("The " + l + " fields must be an array. Was: " + m + ".");
      Ye(m, (h) => {
        if (!Fe(h))
          throw new Error("The value " + h + " in the " + l + " fields was not a string.");
      });
    }, Ig = (l, m) => {
      throw new Error("All values need to be of type: " + m + ". Keys (" + cb(l).join(", ") + ") were not.");
    }, oR = (l) => {
      const m = cb(l);
      F(m, (v, T) => T < m.length - 1 && v === m[T + 1]).each((v) => {
        throw new Error("The field: " + v + " occurs more than once in the combined fields: [" + m.join(", ") + "].");
      });
    }, ex = (l, m) => W_(l, m, {
      validate: Qt,
      label: "function"
    }), W_ = (l, m, h) => {
      if (m.length === 0)
        throw new Error("You must specify at least one required field.");
      return ti("required", m), oR(m), (v) => {
        const T = Yt(v);
        lt(m, (W) => mn(T, W)) || U_(m, T), l(m, T);
        const $ = bt(m, (W) => !h.validate(v[W], W));
        return $.length > 0 && Ig($, h.label), v;
      };
    }, ts = (l, m) => {
      const h = bt(m, (v) => !mn(l, v));
      h.length > 0 && gl(h);
    }, KC = (l) => ex(ts, l), tx = KC([
      "compare",
      "extract",
      "mutate",
      "sink"
    ]), YC = KC([
      "element",
      "start",
      "stop",
      "destroy"
    ]), Z_ = KC([
      "forceDrop",
      "drop",
      "move",
      "delayDrop"
    ]), j_ = () => {
      let l = re.none();
      const m = () => {
        l = re.none();
      }, h = (O, $) => {
        const W = l.map((Q) => O.compare(Q, $));
        return l = re.some($), W;
      }, v = (O, $) => {
        $.extract(O).each((Q) => {
          h($, Q).each((Re) => {
            T.trigger.move(Re);
          });
        });
      }, T = $f({ move: Vu(["info"]) });
      return {
        onEvent: v,
        reset: m,
        events: T.registry
      };
    }, nx = () => {
      const l = $f({ move: Vu(["info"]) });
      return {
        onEvent: st,
        reset: st,
        events: l.registry
      };
    }, q_ = () => {
      const l = nx(), m = j_();
      let h = l;
      return {
        on: () => {
          h.reset(), h = m;
        },
        off: () => {
          h.reset(), h = l;
        },
        isOn: () => h === m,
        onEvent: (W, Q) => {
          h.onEvent(W, Q);
        },
        events: m.events
      };
    }, Tn = (l, m, h) => {
      let v = !1;
      const T = $f({
        start: Vu([]),
        stop: Vu([])
      }), O = q_(), $ = () => {
        ft.stop(), O.isOn() && (O.off(), T.trigger.stop());
      }, W = V_($, 200), Q = (ut) => {
        ft.start(ut), O.on(), T.trigger.start();
      }, ge = (ut) => {
        W.cancel(), O.onEvent(ut, m);
      };
      O.events.move.bind((ut) => {
        m.mutate(l, ut.info);
      });
      const Re = () => {
        v = !0;
      }, Et = () => {
        v = !1;
      }, an = () => v, tn = (ut) => (...$n) => {
        v && ut.apply(null, $n);
      }, ft = m.sink(Z_({
        forceDrop: $,
        drop: tn($),
        move: tn(ge),
        delayDrop: tn(W.throttle)
      }), h), cn = () => {
        ft.destroy();
      };
      return {
        element: ft.element,
        go: Q,
        on: Re,
        off: Et,
        isActive: an,
        destroy: cn,
        events: T.registry
      };
    }, Ff = (l) => {
      const m = l.replace(/\./g, "-");
      return { resolve: (v) => m + "-" + v };
    }, ib = Ff("ephox-dragster").resolve, lb = (l) => {
      const m = {
        layerClass: ib("blocker"),
        ...l
      }, h = ve.fromTag("div");
      return Vs(h, "role", "presentation"), yn(h, {
        position: "fixed",
        left: "0px",
        top: "0px",
        width: "100%",
        height: "100%"
      }), uu(h, ib("blocker")), uu(h, m.layerClass), {
        element: J(h),
        destroy: () => {
          Pr(h);
        }
      };
    };
    var K_ = tx({
      compare: (l, m) => ce(m.left - l.left, m.top - l.top),
      extract: (l) => re.some(ce(l.x, l.y)),
      sink: (l, m) => {
        const h = lb(m), v = mp(h.element(), "mousedown", l.forceDrop), T = mp(h.element(), "mouseup", l.drop), O = mp(h.element(), "mousemove", l.move), $ = mp(h.element(), "mouseout", l.delayDrop), W = () => {
          h.destroy(), T.unbind(), O.unbind(), $.unbind(), v.unbind();
        }, Q = (Re) => {
          Hs(Re, h.element());
        }, ge = () => {
          Pr(h.element());
        };
        return YC({
          element: h.element,
          start: Q,
          stop: ge,
          destroy: W
        });
      },
      mutate: (l, m) => {
        l.mutate(m.left, m.top);
      }
    });
    const sx = (l, m = {}) => {
      var h;
      const v = (h = m.mode) !== null && h !== void 0 ? h : K_;
      return Tn(l, v, m);
    }, Fm = Ff("ephox-snooker").resolve, rx = () => {
      const l = $f({
        drag: Vu([
          "xDelta",
          "yDelta"
        ])
      });
      return {
        mutate: (h, v) => {
          l.trigger.drag(h, v);
        },
        events: l.registry
      };
    }, Y_ = () => {
      const l = $f({
        drag: Vu([
          "xDelta",
          "yDelta",
          "target"
        ])
      });
      let m = re.none();
      const h = rx();
      return h.events.drag.bind((O) => {
        m.each(($) => {
          l.trigger.drag(O.xDelta, O.yDelta, $);
        });
      }), {
        assign: (O) => {
          m = re.some(O);
        },
        get: () => m,
        mutate: h.mutate,
        events: l.registry
      };
    }, ub = (l, m, h, v, T) => {
      const O = ve.fromTag("div");
      return yn(O, {
        position: "absolute",
        left: m - v / 2 + "px",
        top: h + "px",
        height: T + "px",
        width: v + "px"
      }), Sa(O, {
        "data-column": l,
        role: "presentation"
      }), O;
    }, X_ = (l, m, h, v, T) => {
      const O = ve.fromTag("div");
      return yn(O, {
        position: "absolute",
        left: m + "px",
        top: h - T / 2 + "px",
        height: T + "px",
        width: v + "px"
      }), Sa(O, {
        "data-row": l,
        role: "presentation"
      }), O;
    }, ax = Fm("resizer-bar"), XC = Fm("resizer-rows"), cx = Fm("resizer-cols"), rv = 7, J_ = (l, m) => at(l.all, (h, v) => m(h.element) ? [v] : []), Q_ = (l, m) => {
      const h = [];
      return Gn(l.grid.columns, (v) => {
        Wo.getColumnAt(l, v).map((O) => O.element).forall(m) && h.push(v);
      }), bt(h, (v) => {
        const T = Wo.filterItems(l, (O) => O.column === v);
        return lt(T, (O) => m(O.element));
      });
    }, gp = (l) => {
      const m = gr(l.parent(), "." + ax);
      Ye(m, Pr);
    }, JC = (l, m, h) => {
      const v = l.origin();
      Ye(m, (T) => {
        T.each((O) => {
          const $ = h(v, O);
          uu($, ax), Hs(l.parent(), $);
        });
      });
    }, ix = (l, m, h, v) => {
      JC(l, m, (T, O) => {
        const $ = ub(O.col, O.x - T.left, h.top - T.top, rv, v);
        return uu($, cx), $;
      });
    }, eA = (l, m, h, v) => {
      JC(l, m, (T, O) => {
        const $ = X_(O.row, h.left - T.left, O.y - T.top, v, rv);
        return uu($, XC), $;
      });
    }, tA = (l, m, h, v, T) => {
      const O = Bn(h), $ = m.isResizable, W = v.length > 0 ? xn.positions(v, h) : [], Q = W.length > 0 ? J_(l, $) : [], ge = bt(W, (tn, ft) => it(Q, (cn) => ft === cn));
      eA(m, ge, O, Hi(h));
      const Re = T.length > 0 ? ua.positions(T, h) : [], Et = Re.length > 0 ? Q_(l, $) : [], an = bt(Re, (tn, ft) => it(Et, (cn) => ft === cn));
      ix(m, an, O, x(h));
    }, av = (l, m) => {
      if (gp(l), l.isResizable(m)) {
        const h = Wo.fromTable(m), v = cg(h), T = sd(h);
        tA(h, l, m, v, T);
      }
    }, qd = (l, m) => {
      const h = gr(l.parent(), "." + ax);
      Ye(h, m);
    }, cv = (l) => {
      qd(l, (m) => {
        je(m, "display", "none");
      });
    }, Ps = (l) => {
      qd(l, (m) => {
        je(m, "display", "block");
      });
    }, nA = (l) => qi(l, XC), Im = (l) => qi(l, cx), Gd = Fm("resizer-bar-dragging"), iv = (l) => {
      const m = Y_(), h = sx(m, {});
      let v = re.none();
      const T = (ft, cn) => re.from(wr(ft, cn));
      m.events.drag.bind((ft) => {
        T(ft.target, "data-row").each((cn) => {
          const ut = ea(ft.target, "top");
          je(ft.target, "top", ut + ft.yDelta + "px");
        }), T(ft.target, "data-column").each((cn) => {
          const ut = ea(ft.target, "left");
          je(ft.target, "left", ut + ft.xDelta + "px");
        });
      });
      const O = (ft, cn) => {
        const ut = ea(ft, cn), $n = ks(ft, "data-initial-" + cn, 0);
        return ut - $n;
      };
      h.events.stop.bind(() => {
        m.get().each((ft) => {
          v.each((cn) => {
            T(ft, "data-row").each((ut) => {
              const $n = O(ft, "top");
              ie(ft, "data-initial-top"), tn.trigger.adjustHeight(cn, $n, parseInt(ut, 10));
            }), T(ft, "data-column").each((ut) => {
              const $n = O(ft, "left");
              ie(ft, "data-initial-left"), tn.trigger.adjustWidth(cn, $n, parseInt(ut, 10));
            }), av(l, cn);
          });
        });
      });
      const $ = (ft, cn) => {
        tn.trigger.startAdjust(), m.assign(ft), Vs(ft, "data-initial-" + cn, ea(ft, cn)), uu(ft, Gd), je(ft, "opacity", "0.2"), h.go(l.parent());
      }, W = mp(l.parent(), "mousedown", (ft) => {
        nA(ft.target) && $(ft.target, "top"), Im(ft.target) && $(ft.target, "left");
      }), Q = (ft) => wt(ft, l.view()), ge = (ft) => ar(ft, "table", Q).filter(hf), Re = mp(l.view(), "mouseover", (ft) => {
        ge(ft.target).fold(() => {
          rr(ft.target) && gp(l);
        }, (cn) => {
          h.isActive() && (v = re.some(cn), av(l, cn));
        });
      }), Et = () => {
        W.unbind(), Re.unbind(), h.destroy(), gp(l);
      }, an = (ft) => {
        av(l, ft);
      }, tn = $f({
        adjustHeight: Vu([
          "table",
          "delta",
          "row"
        ]),
        adjustWidth: Vu([
          "table",
          "delta",
          "column"
        ]),
        startAdjust: Vu([])
      });
      return {
        destroy: Et,
        refresh: an,
        on: h.on,
        off: h.off,
        hideBars: ht(cv, l),
        showBars: ht(Ps, l),
        events: tn.registry
      };
    }, lv = { create: (l, m, h) => {
      const v = xn, T = ua, O = iv(l), $ = $f({
        beforeResize: Vu([
          "table",
          "type"
        ]),
        afterResize: Vu([
          "table",
          "type"
        ]),
        startDrag: Vu([])
      });
      return O.events.adjustHeight.bind((W) => {
        const Q = W.table;
        $.trigger.beforeResize(Q, "row");
        const ge = v.delta(W.delta, Q);
        Vy(Q, ge, W.row, v), $.trigger.afterResize(Q, "row");
      }), O.events.startAdjust.bind((W) => {
        $.trigger.startDrag();
      }), O.events.adjustWidth.bind((W) => {
        const Q = W.table;
        $.trigger.beforeResize(Q, "col");
        const ge = T.delta(W.delta, Q), Re = h(Q);
        k1(Q, ge, W.column, m, Re), $.trigger.afterResize(Q, "col");
      }), {
        on: O.on,
        off: O.off,
        refreshBars: O.refresh,
        hideBars: O.hideBars,
        showBars: O.showBars,
        destroy: O.destroy,
        events: $.registry
      };
    } }, QC = {
      only: (l, m) => {
        const h = Za(l) ? Mn(l) : l;
        return {
          parent: J(h),
          view: J(l),
          origin: J(ce(0, 0)),
          isResizable: m
        };
      },
      detached: (l, m, h) => {
        const v = () => Bn(m);
        return {
          parent: J(m),
          view: J(l),
          origin: v,
          isResizable: h
        };
      },
      body: (l, m, h) => ({
        parent: J(m),
        view: J(l),
        origin: J(ce(0, 0)),
        isResizable: h
      })
    }, oA = () => {
      const l = ve.fromTag("div");
      return yn(l, {
        position: "static",
        height: "0",
        width: "0",
        padding: "0",
        margin: "0",
        border: "0"
      }), Hs(B(), l), l;
    }, e2 = (l, m) => l.inline ? QC.body(ve.fromDom(l.getBody()), oA(), m) : QC.only(ve.fromDom(l.getDoc()), m), sA = (l, m) => {
      l.inline && Pr(m.parent());
    }, ls = (l) => Zt(l) && l.nodeName === "TABLE", Hl = "bar-", Hm = (l) => wr(l, "data-mce-resize") !== "false", rA = (l) => {
      const m = Wo.fromTable(l);
      Wo.hasColumns(m) || Ye(Wc(l), (h) => {
        const v = vo(h, "width");
        je(h, "width", v), ie(h, "width");
      });
    }, pp = (l) => {
      const m = ap(), h = ap(), v = ap();
      let T, O;
      const $ = (ft) => hi(l, ft), W = () => Mw(l) ? Py() : zw(), Q = (ft) => _h(ft).columns, ge = (ft, cn, ut) => {
        const $n = Fi(cn, "e");
        if (O === "" && iu(ft), ut !== T && O !== "") {
          je(ft, "width", O);
          const wo = W(), Ho = $(ft), Mr = Mw(l) || $n ? Q(ft) - 1 : 0;
          k1(ft, ut - T, Mr, wo, Ho);
        } else if (t0(O)) {
          const wo = parseFloat(O.replace("%", "")), Ho = ut * wo / T;
          je(ft, "width", Ho + "%");
        }
        h1(O) && rA(ft);
      }, Re = () => {
        h.on((ft) => {
          ft.destroy();
        }), v.on((ft) => {
          sA(l, ft);
        });
      };
      return l.on("init", () => {
        const ft = e2(l, Hm);
        if (v.set(ft), vk(l) && vg(l)) {
          const cn = W(), ut = lv.create(ft, cn, $);
          ut.on(), ut.events.startDrag.bind(($n) => {
            m.set(l.selection.getRng());
          }), ut.events.beforeResize.bind(($n) => {
            const wo = $n.table.dom;
            cC(l, wo, pf(wo), bf(wo), Hl + $n.type);
          }), ut.events.afterResize.bind(($n) => {
            const wo = $n.table, Ho = wo.dom;
            cd(wo), m.on((Mr) => {
              l.selection.setRng(Mr), l.focus();
            }), Jk(l, Ho, pf(Ho), bf(Ho), Hl + $n.type), l.undoManager.add();
          }), h.set(ut);
        }
      }), l.on("ObjectResizeStart", (ft) => {
        const cn = ft.target;
        if (ls(cn)) {
          const ut = ve.fromDom(cn);
          Ye(l.dom.select(".mce-clonedresizable"), ($n) => {
            l.dom.addClass($n, "mce-" + Cy(l) + "-columns");
          }), !$1(ut) && gf(l) ? qh(ut) : !B1(ut) && ym(l) && iu(ut), M0(ut) && ai(ft.origin, Hl) && iu(ut), T = ft.width, O = bg(l) ? "" : Pw(l, cn).getOr("");
        }
      }), l.on("ObjectResized", (ft) => {
        const cn = ft.target;
        if (ls(cn)) {
          const ut = ve.fromDom(cn), $n = ft.origin;
          ai($n, "corner-") && ge(ut, $n, ft.width), cd(ut), Dg(l, ut.dom, Om);
        }
      }), l.on("SwitchMode", () => {
        h.on((ft) => {
          l.mode.isReadOnly() ? ft.hideBars() : ft.showBars();
        });
      }), l.on("dragstart dragend", (ft) => {
        h.on((cn) => {
          ft.type === "dragstart" ? (cn.hideBars(), cn.off()) : (cn.on(), cn.showBars());
        });
      }), l.on("remove", () => {
        Re();
      }), {
        refresh: (ft) => {
          h.on((cn) => cn.refreshBars(ve.fromDom(ft)));
        },
        hide: () => {
          h.on((ft) => ft.hideBars());
        },
        show: () => {
          h.on((ft) => ft.showBars());
        }
      };
    }, ws = (l) => {
      yh(l);
      const m = pp(l), h = GC(l, m), v = R0(l, m, h);
      return Kh(l, v), b_(l, v), kk(l, v), {
        getSelectedCells: h.getSelectedCells,
        clearSelectedCells: h.clearSelectedCells
      };
    }, aA = (l) => ({ table: ws(l) });
    var t2 = () => {
      vt.add("dom", aA);
    };
    t2();
  })()), sG;
}
var aG;
function MY() {
  return aG || (aG = 1, NY()), oG;
}
MY();
var cG = {}, iG = {}, lG;
function PY() {
  return lG || (lG = 1, (function() {
    const vt = Object.getPrototypeOf, Ot = (t, s, a) => {
      var i;
      return a(t, s.prototype) ? !0 : ((i = t.constructor) === null || i === void 0 ? void 0 : i.name) === s.name;
    }, Pt = (t) => {
      const s = typeof t;
      return t === null ? "null" : s === "object" && Array.isArray(t) ? "array" : s === "object" && Ot(t, String, (a, i) => i.isPrototypeOf(a)) ? "string" : s;
    }, yt = (t) => (s) => Pt(s) === t, Nt = (t) => (s) => typeof s === t, Wt = (t) => (s) => t === s, Fe = (t, s) => Bt(t) && Ot(t, s, (a, i) => vt(a) === i), Ee = yt("string"), Bt = yt("object"), fn = (t) => Fe(t, Object), dn = yt("array"), Sn = Wt(null), Ft = Nt("boolean"), Zt = Wt(void 0), Qt = (t) => t == null, En = (t) => !Qt(t), st = Nt("function"), Pn = Nt("number"), Kt = (t, s) => {
      if (dn(t)) {
        for (let a = 0, i = t.length; a < i; ++a)
          if (!s(t[a]))
            return !1;
        return !0;
      }
      return !1;
    }, J = () => {
    }, Qe = (t) => () => t(), xo = (t, s) => (...a) => t(s.apply(null, a)), ht = (t, s) => (a) => t(s(a)), U = (t) => () => t, Tt = (t) => t, Ht = (t, s) => t === s;
    function gn(t, ...s) {
      return (...a) => {
        const i = s.concat(a);
        return t.apply(null, i);
      };
    }
    const De = (t) => (s) => !t(s), re = (t) => () => {
      throw new Error(t);
    }, ho = (t) => t(), Te = U(!1), Oe = U(!0);
    class A {
      constructor(s, a) {
        this.tag = s, this.value = a;
      }
      static some(s) {
        return new A(!0, s);
      }
      static none() {
        return A.singletonNone;
      }
      fold(s, a) {
        return this.tag ? a(this.value) : s();
      }
      isSome() {
        return this.tag;
      }
      isNone() {
        return !this.tag;
      }
      map(s) {
        return this.tag ? A.some(s(this.value)) : A.none();
      }
      bind(s) {
        return this.tag ? s(this.value) : A.none();
      }
      exists(s) {
        return this.tag && s(this.value);
      }
      forall(s) {
        return !this.tag || s(this.value);
      }
      filter(s) {
        return !this.tag || s(this.value) ? this : A.none();
      }
      getOr(s) {
        return this.tag ? this.value : s;
      }
      or(s) {
        return this.tag ? this : s;
      }
      getOrThunk(s) {
        return this.tag ? this.value : s();
      }
      orThunk(s) {
        return this.tag ? this : s();
      }
      getOrDie(s) {
        if (this.tag)
          return this.value;
        throw new Error(s ?? "Called getOrDie on None");
      }
      static from(s) {
        return En(s) ? A.some(s) : A.none();
      }
      getOrNull() {
        return this.tag ? this.value : null;
      }
      getOrUndefined() {
        return this.value;
      }
      each(s) {
        this.tag && s(this.value);
      }
      toArray() {
        return this.tag ? [this.value] : [];
      }
      toString() {
        return this.tag ? `some(${this.value})` : "none()";
      }
    }
    A.singletonNone = new A(!1);
    const mn = Array.prototype.slice, it = Array.prototype.indexOf, Gn = Array.prototype.push, rn = (t, s) => it.call(t, s), Ye = (t, s) => {
      const a = rn(t, s);
      return a === -1 ? A.none() : A.some(a);
    }, io = (t, s) => rn(t, s) > -1, jo = (t, s) => {
      for (let a = 0, i = t.length; a < i; a++) {
        const d = t[a];
        if (s(d, a))
          return !0;
      }
      return !1;
    }, bt = (t, s) => {
      const a = [];
      for (let i = 0; i < t; i++)
        a.push(s(i));
      return a;
    }, kn = (t, s) => {
      const a = [];
      for (let i = 0; i < t.length; i += s) {
        const d = mn.call(t, i, i + s);
        a.push(d);
      }
      return a;
    }, $e = (t, s) => {
      const a = t.length, i = new Array(a);
      for (let d = 0; d < a; d++) {
        const g = t[d];
        i[d] = s(g, d);
      }
      return i;
    }, ot = (t, s) => {
      for (let a = 0, i = t.length; a < i; a++) {
        const d = t[a];
        s(d, a);
      }
    }, F = (t, s) => {
      for (let a = t.length - 1; a >= 0; a--) {
        const i = t[a];
        s(i, a);
      }
    }, ss = (t, s) => {
      const a = [], i = [];
      for (let d = 0, g = t.length; d < g; d++) {
        const p = t[d];
        (s(p, d) ? a : i).push(p);
      }
      return {
        pass: a,
        fail: i
      };
    }, fo = (t, s) => {
      const a = [];
      for (let i = 0, d = t.length; i < d; i++) {
        const g = t[i];
        s(g, i) && a.push(g);
      }
      return a;
    }, at = (t, s, a) => (F(t, (i, d) => {
      a = s(a, i, d);
    }), a), lt = (t, s, a) => (ot(t, (i, d) => {
      a = s(a, i, d);
    }), a), Rn = (t, s, a) => {
      for (let i = 0, d = t.length; i < d; i++) {
        const g = t[i];
        if (s(g, i))
          return A.some(g);
        if (a(g, i))
          break;
      }
      return A.none();
    }, ee = (t, s) => Rn(t, s, Te), pe = (t, s) => {
      for (let a = 0, i = t.length; a < i; a++) {
        const d = t[a];
        if (s(d, a))
          return A.some(a);
      }
      return A.none();
    }, ye = (t) => {
      const s = [];
      for (let a = 0, i = t.length; a < i; ++a) {
        if (!dn(t[a]))
          throw new Error("Arr.flatten item " + a + " was not an array, input: " + t);
        Gn.apply(s, t[a]);
      }
      return s;
    }, ae = (t, s) => ye($e(t, s)), kt = (t, s) => {
      for (let a = 0, i = t.length; a < i; ++a) {
        const d = t[a];
        if (s(d, a) !== !0)
          return !1;
      }
      return !0;
    }, Vn = (t) => {
      const s = mn.call(t, 0);
      return s.reverse(), s;
    }, Yt = (t, s) => fo(t, (a) => !io(s, a)), Ct = (t, s) => {
      const a = {};
      for (let i = 0, d = t.length; i < d; i++) {
        const g = t[i];
        a[String(g)] = s(g, i);
      }
      return a;
    }, Xe = (t) => [t], In = (t, s) => {
      const a = mn.call(t, 0);
      return a.sort(s), a;
    }, hn = (t, s) => s >= 0 && s < t.length ? A.some(t[s]) : A.none(), Xn = (t) => hn(t, 0), Xo = (t) => hn(t, t.length - 1), ds = st(Array.from) ? Array.from : (t) => mn.call(t), No = (t, s) => {
      for (let a = 0; a < t.length; a++) {
        const i = s(t[a], a);
        if (i.isSome())
          return i;
      }
      return A.none();
    }, Ao = Object.keys, Cs = Object.hasOwnProperty, Ie = (t, s) => {
      const a = Ao(t);
      for (let i = 0, d = a.length; i < d; i++) {
        const g = a[i], p = t[g];
        s(p, g);
      }
    }, et = (t, s) => nn(t, (a, i) => ({
      k: i,
      v: s(a, i)
    })), nn = (t, s) => {
      const a = {};
      return Ie(t, (i, d) => {
        const g = s(i, d);
        a[g.k] = g.v;
      }), a;
    }, qt = (t) => (s, a) => {
      t[a] = s;
    }, ko = (t, s, a, i) => {
      Ie(t, (d, g) => {
        (s(d, g) ? a : i)(d, g);
      });
    }, rs = (t, s) => {
      const a = {}, i = {};
      return ko(t, s, qt(a), qt(i)), {
        t: a,
        f: i
      };
    }, Gs = (t, s) => {
      const a = {};
      return ko(t, s, qt(a), J), a;
    }, Yr = (t, s) => {
      const a = [];
      return Ie(t, (i, d) => {
        a.push(s(i, d));
      }), a;
    }, Ss = (t, s) => {
      const a = Ao(t);
      for (let i = 0, d = a.length; i < d; i++) {
        const g = a[i], p = t[g];
        if (s(p, g, t))
          return A.some(p);
      }
      return A.none();
    }, or = (t) => Yr(t, Tt), Dt = (t, s) => Lo(t, s) ? A.from(t[s]) : A.none(), Lo = (t, s) => Cs.call(t, s), Or = (t, s) => Lo(t, s) && t[s] !== void 0 && t[s] !== null, aa = (t, s, a = Ht) => t.exists((i) => a(i, s)), Xr = (t, s, a = Ht) => fa(t, s, a).getOr(t.isNone() && s.isNone()), Jr = (t) => {
      const s = [], a = (i) => {
        s.push(i);
      };
      for (let i = 0; i < t.length; i++)
        t[i].each(a);
      return s;
    }, xs = (t) => {
      const s = [];
      for (let a = 0; a < t.length; a++) {
        const i = t[a];
        if (i.isSome())
          s.push(i.getOrDie());
        else
          return A.none();
      }
      return A.some(s);
    }, fa = (t, s, a) => t.isSome() && s.isSome() ? A.some(a(t.getOrDie(), s.getOrDie())) : A.none(), Qr = (t, s, a, i) => t.isSome() && s.isSome() && a.isSome() ? A.some(i(t.getOrDie(), s.getOrDie(), a.getOrDie())) : A.none(), Ts = (t, s) => t != null ? A.some(s(t)) : A.none(), Zn = (t, s) => t ? A.some(s) : A.none(), dr = (t, s) => t + s, ga = (t, s) => t.substring(s), Za = (t, s, a) => s === "" || t.length >= s.length && t.substr(a, a + s.length) === s, _c = (t, s) => Vs(t, s) ? ga(t, s.length) : t, sr = (t, s) => Sa(t, s) ? t : dr(t, s), Ks = (t, s, a = 0, i) => {
      const d = t.indexOf(s, a);
      return d !== -1 ? Zt(i) ? !0 : d + s.length <= i : !1;
    }, Vs = (t, s) => Za(t, s, 0), Sa = (t, s) => Za(t, s, t.length - s.length), wr = ((t) => (s) => s.replace(t, ""))(/^\s+|\s+$/g), de = (t) => t.length > 0, ie = (t) => !de(t), ze = (t) => t.style !== void 0 && st(t.style.getPropertyValue), Je = (t, s) => {
      const i = (s || document).createElement("div");
      if (i.innerHTML = t, !i.hasChildNodes() || i.childNodes.length > 1) {
        const d = "HTML does not have a single root node";
        throw new Error(d);
      }
      return _o(i.childNodes[0]);
    }, Nn = (t, s) => {
      const i = (s || document).createElement(t);
      return _o(i);
    }, Wn = (t, s) => {
      const i = (s || document).createTextNode(t);
      return _o(i);
    }, _o = (t) => {
      if (t == null)
        throw new Error("Node cannot be null or undefined");
      return { dom: t };
    }, ve = {
      fromHtml: Je,
      fromTag: Nn,
      fromText: Wn,
      fromDom: _o,
      fromPoint: (t, s, a) => A.from(t.dom.elementFromPoint(s, a)).map(_o)
    }, go = typeof window < "u" ? window : Function("return this;")(), ue = (t, s) => {
      let a = s ?? go;
      for (let i = 0; i < t.length && a !== void 0 && a !== null; ++i)
        a = a[t[i]];
      return a;
    }, he = (t, s) => {
      const a = t.split(".");
      return ue(a, s);
    }, dt = (t, s) => he(t, s), wt = (t, s) => {
      const a = dt(t, s);
      if (a == null)
        throw new Error(t + " not available on this browser");
      return a;
    }, on = Object.getPrototypeOf, Ln = (t) => wt("HTMLElement", t), On = (t) => {
      const s = he("ownerDocument.defaultView", t);
      return Bt(t) && (Ln(s).prototype.isPrototypeOf(t) || /^HTML\w*Element$/.test(on(t).constructor.name));
    }, Dn = 9, Mn = 11, Kn = 1, zo = 3, Ds = (t) => t.dom.nodeName.toLowerCase(), Ra = (t) => t.dom.nodeType, ac = (t) => (s) => Ra(s) === t, vc = (t) => lo(t) && On(t.dom), lo = ac(Kn), Fo = ac(zo), ms = ac(Dn), xa = ac(Mn), zr = (t) => (s) => lo(s) && Ds(s) === t, mr = (t, s) => {
      const a = t.dom;
      if (a.nodeType !== Kn)
        return !1;
      {
        const i = a;
        if (i.matches !== void 0)
          return i.matches(s);
        if (i.msMatchesSelector !== void 0)
          return i.msMatchesSelector(s);
        if (i.webkitMatchesSelector !== void 0)
          return i.webkitMatchesSelector(s);
        if (i.mozMatchesSelector !== void 0)
          return i.mozMatchesSelector(s);
        throw new Error("Browser lacks native selectors");
      }
    }, Hs = (t) => t.nodeType !== Kn && t.nodeType !== Dn && t.nodeType !== Mn || t.childElementCount === 0, Fa = (t, s) => {
      const a = s === void 0 ? document : s.dom;
      return Hs(a) ? [] : $e(a.querySelectorAll(t), ve.fromDom);
    }, nl = (t, s) => {
      const a = s === void 0 ? document : s.dom;
      return Hs(a) ? A.none() : A.from(a.querySelector(t)).map(ve.fromDom);
    }, Rs = (t, s) => t.dom === s.dom, ca = (t, s) => {
      const a = t.dom, i = s.dom;
      return a === i ? !1 : a.contains(i);
    }, Ia = (t) => ve.fromDom(t.dom.ownerDocument), Pr = (t) => ms(t) ? t : Ia(t), yc = (t) => ve.fromDom(Pr(t).dom.documentElement), Uc = (t) => ve.fromDom(Pr(t).dom.defaultView), Ta = (t) => A.from(t.dom.parentNode).map(ve.fromDom), Ac = (t) => Ta(t), Oc = (t) => A.from(t.dom.parentElement).map(ve.fromDom), vu = (t, s) => {
      const a = st(s) ? s : Te;
      let i = t.dom;
      const d = [];
      for (; i.parentNode !== null && i.parentNode !== void 0; ) {
        const g = i.parentNode, p = ve.fromDom(g);
        if (d.push(p), a(p) === !0)
          break;
        i = g;
      }
      return d;
    }, Dc = (t) => A.from(t.dom.offsetParent).map(ve.fromDom), yl = (t) => A.from(t.dom.nextSibling).map(ve.fromDom), ja = (t) => $e(t.dom.childNodes, ve.fromDom), wi = (t, s) => {
      const a = t.dom.childNodes;
      return A.from(a[s]).map(ve.fromDom);
    }, Bi = (t) => wi(t, 0), Cl = (t, s) => ({
      element: t,
      offset: s
    }), Ju = (t, s) => {
      const a = ja(t);
      return a.length > 0 && s < a.length ? Cl(a[s], 0) : Cl(t, s);
    }, Z = (t) => xa(t) && En(t.dom.host), fe = st(Element.prototype.attachShadow) && st(Node.prototype.getRootNode), _e = U(fe), Ve = fe ? (t) => ve.fromDom(t.dom.getRootNode()) : Pr, Rt = (t) => Z(t) ? t : ve.fromDom(Pr(t).dom.body), eo = (t) => Ns(t).isSome(), Ns = (t) => {
      const s = Ve(t);
      return Z(s) ? A.some(s) : A.none();
    }, Is = (t) => ve.fromDom(t.dom.host), Os = (t) => {
      if (_e() && En(t.target)) {
        const s = ve.fromDom(t.target);
        if (lo(s) && Ys(s) && t.composed && t.composedPath) {
          const a = t.composedPath();
          if (a)
            return Xn(a);
        }
      }
      return A.from(t.target);
    }, Ys = (t) => En(t.dom.shadowRoot), qo = (t) => {
      const s = Fo(t) ? t.dom.parentNode : t.dom;
      if (s == null || s.ownerDocument === null)
        return !1;
      const a = s.ownerDocument;
      return Ns(ve.fromDom(s)).fold(() => a.body.contains(s), ht(qo, Is));
    }, fr = () => Na(ve.fromDom(document)), Na = (t) => {
      const s = t.dom.body;
      if (s == null)
        throw new Error("Body is not available yet");
      return ve.fromDom(s);
    }, ol = (t, s, a) => {
      if (Ee(a) || Ft(a) || Pn(a))
        t.setAttribute(s, a + "");
      else
        throw new Error("Attribute value was not simple");
    }, sn = (t, s, a) => {
      ol(t.dom, s, a);
    }, Ql = (t, s) => {
      const a = t.dom;
      Ie(s, (i, d) => {
        ol(a, d, i);
      });
    }, rr = (t, s) => {
      const a = t.dom.getAttribute(s);
      return a === null ? void 0 : a;
    }, B = (t, s) => A.from(rr(t, s)), K = (t, s) => {
      const a = t.dom;
      return a && a.hasAttribute ? a.hasAttribute(s) : !1;
    }, se = (t, s) => {
      t.dom.removeAttribute(s);
    }, Ue = (t) => lt(t.dom.attributes, (s, a) => (s[a.name] = a.value, s), {}), en = (t, s, a) => {
      if (!Ee(a))
        throw new Error("CSS value must be a string: " + a);
      ze(t) && t.style.setProperty(s, a);
    }, Io = (t, s) => {
      ze(t) && t.style.removeProperty(s);
    }, _n = (t, s, a) => {
      const i = t.dom;
      en(i, s, a);
    }, gr = (t, s) => {
      const a = t.dom;
      Ie(s, (i, d) => {
        en(a, d, i);
      });
    }, _t = (t, s) => {
      const a = t.dom;
      Ie(s, (i, d) => {
        i.fold(() => {
          Io(a, d);
        }, (g) => {
          en(a, d, g);
        });
      });
    }, Us = (t, s) => {
      const a = t.dom, d = window.getComputedStyle(a).getPropertyValue(s);
      return d === "" && !qo(t) ? qa(a, s) : d;
    }, qa = (t, s) => ze(t) ? t.style.getPropertyValue(s) : "", Xs = (t, s) => {
      const a = t.dom, i = qa(a, s);
      return A.from(i).filter((d) => d.length > 0);
    }, Zr = (t) => {
      const s = {}, a = t.dom;
      if (ze(a))
        for (let i = 0; i < a.style.length; i++) {
          const d = a.style.item(i);
          s[d] = a.style[d];
        }
      return s;
    }, ri = (t, s, a) => {
      const i = ve.fromTag(t);
      return _n(i, s, a), Xs(i, s).isSome();
    }, Jo = (t, s) => {
      const a = t.dom;
      Io(a, s), aa(B(t, "style").map(wr), "") && se(t, "style");
    }, Ga = (t) => t.dom.offsetWidth, ar = (t, s) => {
      const a = (C, S) => {
        if (!Pn(S) && !S.match(/^[0-9]+$/))
          throw new Error(t + ".set accepts only positive integer values. Value was " + S);
        const _ = C.dom;
        ze(_) && (_.style[t] = S + "px");
      }, i = (C) => {
        const S = s(C);
        if (S <= 0 || S === null) {
          const _ = Us(C, t);
          return parseFloat(_) || 0;
        }
        return S;
      }, d = i, g = (C, S) => lt(S, (_, D) => {
        const P = Us(C, D), L = P === void 0 ? 0 : parseInt(P, 10);
        return isNaN(L) ? _ : _ + L;
      }, 0);
      return {
        set: a,
        get: i,
        getOuter: d,
        aggregate: g,
        max: (C, S, _) => {
          const D = g(C, _);
          return S > D ? S - D : 0;
        }
      };
    }, $i = ar("height", (t) => {
      const s = t.dom;
      return qo(t) ? s.getBoundingClientRect().height : s.offsetHeight;
    }), hr = (t) => $i.get(t), yu = (t) => $i.getOuter(t), um = (t, s) => {
      const a = [
        "margin-top",
        "border-top-width",
        "padding-top",
        "padding-bottom",
        "border-bottom-width",
        "margin-bottom"
      ], i = $i.max(t, s, a);
      _n(t, "max-height", i + "px");
    }, Xm = (t, s) => ({
      left: t,
      top: s,
      translate: (i, d) => Xm(t + i, s + d)
    }), Es = Xm, ai = (t) => {
      const s = t.getBoundingClientRect();
      return Es(s.left, s.top);
    }, Fi = (t, s) => t !== void 0 ? t : s !== void 0 ? s : 0, Cc = (t) => {
      const s = t.dom.ownerDocument, a = s.body, i = s.defaultView, d = s.documentElement;
      if (a === t.dom)
        return Es(a.offsetLeft, a.offsetTop);
      const g = Fi(i?.pageYOffset, d.scrollTop), p = Fi(i?.pageXOffset, d.scrollLeft), C = Fi(d.clientTop, a.clientTop), S = Fi(d.clientLeft, a.clientLeft);
      return Rc(t).translate(p - S, g - C);
    }, Rc = (t) => {
      const s = t.dom, i = s.ownerDocument.body;
      return i === s ? Es(i.offsetLeft, i.offsetTop) : qo(t) ? ai(s) : Es(0, 0);
    }, Qu = ar("width", (t) => t.dom.offsetWidth), Qo = (t, s) => Qu.set(t, s), j = (t) => Qu.get(t), oe = (t) => Qu.getOuter(t), Le = (t, s) => {
      const a = [
        "margin-left",
        "border-left-width",
        "padding-left",
        "padding-right",
        "border-right-width",
        "margin-right"
      ], i = Qu.max(t, s, a);
      _n(t, "max-width", i + "px");
    }, je = (t) => {
      let s = !1, a;
      return (...i) => (s || (s = !0, a = t.apply(null, i)), a);
    }, yn = (t, s, a, i) => {
      const d = t.isiOS() && /ipad/i.test(a) === !0, g = t.isiOS() && !d, p = t.isiOS() || t.isAndroid(), C = p || i("(pointer:coarse)"), S = d || !g && p && i("(min-device-width:768px)"), _ = g || p && !S, D = s.isSafari() && t.isiOS() && /safari/i.test(a) === !1, P = !_ && !S && !D;
      return {
        isiPad: U(d),
        isiPhone: U(g),
        isTablet: U(S),
        isPhone: U(_),
        isTouch: U(C),
        isAndroid: t.isAndroid,
        isiOS: t.isiOS,
        isWebView: U(D),
        isDesktop: U(P)
      };
    }, vo = (t, s) => {
      for (let a = 0; a < t.length; a++) {
        const i = t[a];
        if (i.test(s))
          return i;
      }
    }, Dr = (t, s) => {
      const a = vo(t, s);
      if (!a)
        return {
          major: 0,
          minor: 0
        };
      const i = (d) => Number(s.replace(a, "$" + d));
      return cc(i(1), i(2));
    }, Ka = (t, s) => {
      const a = String(s).toLowerCase();
      return t.length === 0 ? pr() : Dr(t, a);
    }, pr = () => cc(0, 0), cc = (t, s) => ({
      major: t,
      minor: s
    }), ks = {
      nu: cc,
      detect: Ka,
      unknown: pr
    }, Br = (t, s) => No(s.brands, (a) => {
      const i = a.brand.toLowerCase();
      return ee(t, (d) => {
        var g;
        return i === ((g = d.brand) === null || g === void 0 ? void 0 : g.toLowerCase());
      }).map((d) => ({
        current: d.name,
        version: ks.nu(parseInt(a.version, 10), 0)
      }));
    }), ia = (t, s) => {
      const a = String(s).toLowerCase();
      return ee(t, (i) => i.search(a));
    }, wc = (t, s) => ia(t, s).map((a) => {
      const i = ks.detect(a.versionRegexes, s);
      return {
        current: a.name,
        version: i
      };
    }), ea = (t, s) => ia(t, s).map((a) => {
      const i = ks.detect(a.versionRegexes, s);
      return {
        current: a.name,
        version: i
      };
    }), _r = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/, Vr = (t) => (s) => Ks(s, t), Nc = [
      {
        name: "Edge",
        versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
        search: (t) => Ks(t, "edge/") && Ks(t, "chrome") && Ks(t, "safari") && Ks(t, "applewebkit")
      },
      {
        name: "Chromium",
        brand: "Chromium",
        versionRegexes: [
          /.*?chrome\/([0-9]+)\.([0-9]+).*/,
          _r
        ],
        search: (t) => Ks(t, "chrome") && !Ks(t, "chromeframe")
      },
      {
        name: "IE",
        versionRegexes: [
          /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
          /.*?rv:([0-9]+)\.([0-9]+).*/
        ],
        search: (t) => Ks(t, "msie") || Ks(t, "trident")
      },
      {
        name: "Opera",
        versionRegexes: [
          _r,
          /.*?opera\/([0-9]+)\.([0-9]+).*/
        ],
        search: Vr("opera")
      },
      {
        name: "Firefox",
        versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
        search: Vr("firefox")
      },
      {
        name: "Safari",
        versionRegexes: [
          _r,
          /.*?cpu os ([0-9]+)_([0-9]+).*/
        ],
        search: (t) => (Ks(t, "safari") || Ks(t, "mobile/")) && Ks(t, "applewebkit")
      }
    ], Ii = [
      {
        name: "Windows",
        search: Vr("win"),
        versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: "iOS",
        search: (t) => Ks(t, "iphone") || Ks(t, "ipad"),
        versionRegexes: [
          /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
          /.*cpu os ([0-9]+)_([0-9]+).*/,
          /.*cpu iphone os ([0-9]+)_([0-9]+).*/
        ]
      },
      {
        name: "Android",
        search: Vr("android"),
        versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: "macOS",
        search: Vr("mac os x"),
        versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
      },
      {
        name: "Linux",
        search: Vr("linux"),
        versionRegexes: []
      },
      {
        name: "Solaris",
        search: Vr("sunos"),
        versionRegexes: []
      },
      {
        name: "FreeBSD",
        search: Vr("freebsd"),
        versionRegexes: []
      },
      {
        name: "ChromeOS",
        search: Vr("cros"),
        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
      }
    ], Jm = {
      browsers: U(Nc),
      oses: U(Ii)
    }, Qm = "Edge", Wc = "Chromium", ef = "IE", Zc = "Opera", wl = "Firefox", tf = "Safari", Cu = () => dm({
      current: void 0,
      version: ks.unknown()
    }), dm = (t) => {
      const s = t.current, a = t.version, i = (d) => () => s === d;
      return {
        current: s,
        version: a,
        isEdge: i(Qm),
        isChromium: i(Wc),
        isIE: i(ef),
        isOpera: i(Zc),
        isFirefox: i(wl),
        isSafari: i(tf)
      };
    }, Sl = {
      unknown: Cu,
      nu: dm
    }, oh = "Windows", wu = "iOS", sh = "Android", rh = "Linux", ah = "macOS", Ad = "Solaris", o1 = "FreeBSD", le = "ChromeOS", Su = () => Si({
      current: void 0,
      version: ks.unknown()
    }), Si = (t) => {
      const s = t.current, a = t.version, i = (d) => () => s === d;
      return {
        current: s,
        version: a,
        isWindows: i(oh),
        isiOS: i(wu),
        isAndroid: i(sh),
        isMacOS: i(ah),
        isLinux: i(rh),
        isSolaris: i(Ad),
        isFreeBSD: i(o1),
        isChromeOS: i(le)
      };
    }, Od = {
      unknown: Su,
      nu: Si
    }, s1 = { detect: (t, s, a) => {
      const i = Jm.browsers(), d = Jm.oses(), g = s.bind((S) => Br(i, S)).orThunk(() => wc(i, t)).fold(Sl.unknown, Sl.nu), p = ea(d, t).fold(Od.unknown, Od.nu), C = yn(p, g, t, a);
      return {
        browser: g,
        os: p,
        deviceType: C
      };
    } }, fs = (t) => window.matchMedia(t).matches;
    let ic = je(() => s1.detect(navigator.userAgent, A.from(navigator.userAgentData), fs));
    const xl = () => ic(), xi = (t, s, a, i, d, g, p) => ({
      target: t,
      x: s,
      y: a,
      stop: i,
      prevent: d,
      kill: g,
      raw: p
    }), xu = (t) => {
      const s = ve.fromDom(Os(t).getOr(t.target)), a = () => t.stopPropagation(), i = () => t.preventDefault(), d = xo(i, a);
      return xi(s, t.clientX, t.clientY, a, i, d, t);
    }, sl = (t, s) => (a) => {
      t(a) && s(xu(a));
    }, lc = (t, s, a, i, d) => {
      const g = sl(a, i);
      return t.dom.addEventListener(s, g, d), { unbind: gn(r1, t, s, g, d) };
    }, Tl = (t, s, a, i) => lc(t, s, a, i, !1), ch = (t, s, a, i) => lc(t, s, a, i, !0), r1 = (t, s, a, i) => {
      t.dom.removeEventListener(s, a, i);
    }, Li = (t, s) => {
      Ta(t).each((i) => {
        i.dom.insertBefore(s.dom, t.dom);
      });
    }, El = (t, s) => {
      yl(t).fold(() => {
        Ta(t).each((d) => {
          Sc(d, s);
        });
      }, (i) => {
        Li(i, s);
      });
    }, ng = (t, s) => {
      Bi(t).fold(() => {
        Sc(t, s);
      }, (i) => {
        t.dom.insertBefore(s.dom, i.dom);
      });
    }, Sc = (t, s) => {
      t.dom.appendChild(s.dom);
    }, Ea = (t, s, a) => {
      wi(t, a).fold(() => {
        Sc(t, s);
      }, (i) => {
        Li(i, s);
      });
    }, ed = (t, s) => {
      ot(s, (a) => {
        Sc(t, a);
      });
    }, mm = (t) => {
      t.dom.textContent = "", ot(ja(t), (s) => {
        rl(s);
      });
    }, rl = (t) => {
      const s = t.dom;
      s.parentNode !== null && s.parentNode.removeChild(s);
    }, Mc = (t) => {
      const s = t !== void 0 ? t.dom : document, a = s.body.scrollLeft || s.documentElement.scrollLeft, i = s.body.scrollTop || s.documentElement.scrollTop;
      return Es(a, i);
    }, ih = (t, s, a) => {
      const d = (a !== void 0 ? a.dom : document).defaultView;
      d && d.scrollTo(t, s);
    }, a1 = (t) => {
      const s = t === void 0 ? window : t;
      return xl().browser.isFirefox() ? A.none() : A.from(s.visualViewport);
    }, nf = (t, s, a, i) => ({
      x: t,
      y: s,
      width: a,
      height: i,
      right: t + a,
      bottom: s + i
    }), of = (t) => {
      const s = t === void 0 ? window : t, a = s.document, i = Mc(ve.fromDom(a));
      return a1(s).fold(() => {
        const d = s.document.documentElement, g = d.clientWidth, p = d.clientHeight;
        return nf(i.left, i.top, g, p);
      }, (d) => nf(Math.max(d.pageLeft, i.left), Math.max(d.pageTop, i.top), d.width, d.height));
    }, Dd = () => ve.fromDom(document), kl = (t, s) => t.view(s).fold(U([]), (i) => {
      const d = t.owner(i), g = kl(t, d);
      return [i].concat(g);
    }), lh = (t, s) => {
      const a = s.owner(t), i = kl(s, a);
      return A.some(i);
    };
    var c1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      view: (t) => {
        var s;
        return (t.dom === document ? A.none() : A.from((s = t.dom.defaultView) === null || s === void 0 ? void 0 : s.frameElement)).map(ve.fromDom);
      },
      owner: (t) => Ia(t)
    });
    const Tu = (t) => {
      const s = Dd(), a = Mc(s);
      return lh(t, c1).fold(gn(Cc, t), (d) => {
        const g = Rc(t), p = at(d, (C, S) => {
          const _ = Rc(S);
          return {
            left: C.left + _.left,
            top: C.top + _.top
          };
        }, {
          left: 0,
          top: 0
        });
        return Es(p.left + g.left + a.left, p.top + g.top + a.top);
      });
    }, sg = (t, s, a) => ({
      point: t,
      width: s,
      height: a
    }), td = (t, s, a, i) => ({
      x: t,
      y: s,
      width: a,
      height: i
    }), Rr = (t, s, a, i) => ({
      x: t,
      y: s,
      width: a,
      height: i,
      right: t + a,
      bottom: s + i
    }), Ar = (t) => {
      const s = Cc(t), a = oe(t), i = yu(t);
      return Rr(s.left, s.top, a, i);
    }, ci = (t) => {
      const s = Tu(t), a = oe(t), i = yu(t);
      return Rr(s.left, s.top, a, i);
    }, sf = (t, s) => {
      const a = Math.max(t.x, s.x), i = Math.max(t.y, s.y), d = Math.min(t.right, s.right), g = Math.min(t.bottom, s.bottom), p = d - a, C = g - i;
      return Rr(a, i, p, C);
    }, uh = (t, s) => lt(s, (a, i) => sf(a, i), t), La = () => of(window);
    var _l = tinymce.util.Tools.resolve("tinymce.ThemeManager");
    const ii = (t) => {
      const s = (g) => g(t), a = U(t), i = () => d, d = {
        tag: !0,
        inner: t,
        fold: (g, p) => p(t),
        isValue: Oe,
        isError: Te,
        map: (g) => Mo.value(g(t)),
        mapError: i,
        bind: s,
        exists: s,
        forall: s,
        getOr: a,
        or: i,
        getOrThunk: a,
        orThunk: i,
        getOrDie: a,
        each: (g) => {
          g(t);
        },
        toOptional: () => A.some(t)
      };
      return d;
    }, Hi = (t) => {
      const s = () => a, a = {
        tag: !1,
        inner: t,
        fold: (i, d) => i(t),
        isValue: Te,
        isError: Oe,
        map: s,
        mapError: (i) => Mo.error(i(t)),
        bind: s,
        exists: Te,
        forall: Oe,
        getOr: Tt,
        or: Tt,
        getOrThunk: ho,
        orThunk: ho,
        getOrDie: re(String(t)),
        each: J,
        toOptional: A.none
      };
      return a;
    }, Mo = {
      value: ii,
      error: Hi,
      fromOption: (t, s) => t.fold(() => Hi(s), ii)
    };
    var jc;
    (function(t) {
      t[t.Error = 0] = "Error", t[t.Value = 1] = "Value";
    })(jc || (jc = {}));
    const Eu = (t, s, a) => t.stype === jc.Error ? s(t.serror) : a(t.svalue), nd = (t) => {
      const s = [], a = [];
      return ot(t, (i) => {
        Eu(i, (d) => a.push(d), (d) => s.push(d));
      }), {
        values: s,
        errors: a
      };
    }, rg = (t, s) => t.stype === jc.Error ? {
      stype: jc.Error,
      serror: s(t.serror)
    } : t, rf = (t, s) => t.stype === jc.Value ? {
      stype: jc.Value,
      svalue: s(t.svalue)
    } : t, Ya = (t, s) => t.stype === jc.Value ? s(t.svalue) : t, ha = (t, s) => t.stype === jc.Error ? s(t.serror) : t, li = (t) => ({
      stype: jc.Value,
      svalue: t
    }), ta = (t) => ({
      stype: jc.Error,
      serror: t
    }), na = {
      fromResult: (t) => t.fold(ta, li),
      toResult: (t) => Eu(t, Mo.error, Mo.value),
      svalue: li,
      partition: nd,
      serror: ta,
      bind: Ya,
      bindError: ha,
      map: rf,
      mapError: rg,
      fold: Eu
    }, ka = (t, s, a, i) => ({
      tag: "field",
      key: t,
      newKey: s,
      presence: a,
      prop: i
    }), Ti = (t, s) => ({
      tag: "custom",
      newKey: t,
      instantiator: s
    }), gm = (t, s, a) => {
      switch (t.tag) {
        case "field":
          return s(t.key, t.newKey, t.presence, t.prop);
        case "custom":
          return a(t.newKey, t.instantiator);
      }
    }, la = (t, s) => s, ag = (t, s) => fn(t) && fn(s) ? Ms(t, s) : s, af = (t) => (...s) => {
      if (s.length === 0)
        throw new Error("Can't merge zero objects");
      const a = {};
      for (let i = 0; i < s.length; i++) {
        const d = s[i];
        for (const g in d)
          Lo(d, g) && (a[g] = t(a[g], d[g]));
      }
      return a;
    }, Ms = af(ag), Ei = af(la), bs = () => ({
      tag: "required",
      process: {}
    }), qc = (t) => ({
      tag: "defaultedThunk",
      process: t
    }), ku = (t) => qc(U(t)), _u = () => ({
      tag: "option",
      process: {}
    }), Wo = (t) => ({
      tag: "mergeWithThunk",
      process: t
    }), sd = (t) => Wo(U(t)), mh = (t, s) => t.length > 0 ? na.svalue(Ms(s, Ei.apply(void 0, t))) : na.svalue(s), cg = (t) => xo(na.serror, ye)(t), i1 = {
      consolidateObj: (t, s) => {
        const a = na.partition(t);
        return a.errors.length > 0 ? cg(a.errors) : mh(a.values, s);
      },
      consolidateArr: (t) => {
        const s = na.partition(t);
        return s.errors.length > 0 ? cg(s.errors) : na.svalue(s.values);
      }
    }, Rd = (t) => Bt(t) && Ao(t).length > 100 ? " removed due to size" : JSON.stringify(t, null, 2), lg = (t) => {
      const s = t.length > 10 ? t.slice(0, 10).concat([{
        path: [],
        getErrorInfo: U("... (only showing first ten failures)")
      }]) : t;
      return $e(s, (a) => "Failed path: (" + a.path.join(" > ") + `)
` + a.getErrorInfo());
    }, x = (t, s) => na.serror([{
      path: t,
      getErrorInfo: s
    }]), R = (t, s, a) => x(t, () => 'Could not find valid *required* value for "' + s + '" in ' + Rd(a)), z = (t, s) => x(t, () => 'Choice schema did not contain choice key: "' + s + '"'), ce = (t, s, a) => x(t, () => 'The chosen schema: "' + a + '" did not exist in branches: ' + Rd(s)), be = (t, s) => x(t, () => "There are unsupported fields: [" + s.join(", ") + "] specified"), At = (t, s) => x(t, U(s)), Bn = (t) => {
      const s = (i, d) => na.bindError(t(d), (g) => At(i, g)), a = U("val");
      return {
        extract: s,
        toString: a
      };
    }, To = Bn(na.svalue), Co = (t, s, a, i) => Dt(s, a).fold(() => R(t, a, s), i), ao = (t, s, a, i) => {
      const d = Dt(t, s).getOrThunk(() => a(t));
      return i(d);
    }, Nr = (t, s, a) => a(Dt(t, s)), Ma = (t, s, a, i) => {
      const d = Dt(t, s).map((g) => g === !0 ? a(t) : g);
      return i(d);
    }, ki = (t, s, a, i, d) => {
      const g = (C) => d.extract(s.concat([i]), C), p = (C) => C.fold(() => na.svalue(A.none()), (S) => {
        const _ = d.extract(s.concat([i]), S);
        return na.map(_, A.some);
      });
      switch (t.tag) {
        case "required":
          return Co(s, a, i, g);
        case "defaultedThunk":
          return ao(a, i, t.process, g);
        case "option":
          return Nr(a, i, p);
        case "defaultedOptionThunk":
          return Ma(a, i, t.process, p);
        case "mergeWithThunk":
          return ao(a, i, U({}), (C) => {
            const S = Ms(t.process(a), C);
            return g(S);
          });
      }
    }, eu = (t, s, a) => {
      const i = {}, d = [];
      for (const g of a)
        gm(g, (p, C, S, _) => {
          const D = ki(S, t, s, p, _);
          na.fold(D, (P) => {
            d.push(...P);
          }, (P) => {
            i[C] = P;
          });
        }, (p, C) => {
          i[p] = C(s);
        });
      return d.length > 0 ? na.serror(d) : na.svalue(i);
    }, uc = (t) => ({
      extract: (i, d) => t().extract(i, d),
      toString: () => t().toString()
    }), by = (t) => Ao(Gs(t, En)), br = (t) => {
      const s = jn(t), a = at(t, (d, g) => gm(g, (p) => Ms(d, { [p]: !0 }), U(d)), {});
      return {
        extract: (d, g) => {
          const p = Ft(g) ? [] : by(g), C = fo(p, (S) => !Or(a, S));
          return C.length === 0 ? s.extract(d, g) : be(d, C);
        },
        toString: s.toString
      };
    }, jn = (t) => ({
      extract: (i, d) => eu(i, d, t),
      toString: () => `obj{
` + $e(t, (d) => gm(d, (g, p, C, S) => g + " -> " + S.toString(), (g, p) => "state(" + g + ")")).join(`
`) + "}"
    }), tu = (t) => ({
      extract: (i, d) => {
        const g = $e(d, (p, C) => t.extract(i.concat(["[" + C + "]"]), p));
        return i1.consolidateArr(g);
      },
      toString: () => "array(" + t.toString() + ")"
    }), xn = (t, s) => {
      const a = s !== void 0 ? s : Tt;
      return {
        extract: (g, p) => {
          const C = [];
          for (const S of t) {
            const _ = S.extract(g, p);
            if (_.stype === jc.Value)
              return {
                stype: jc.Value,
                svalue: a(_.svalue)
              };
            C.push(_);
          }
          return i1.consolidateArr(C);
        },
        toString: () => "oneOf(" + $e(t, (g) => g.toString()).join(", ") + ")"
      };
    }, Au = (t, s) => {
      const a = (g, p) => tu(Bn(t)).extract(g, p);
      return {
        extract: (g, p) => {
          const C = Ao(p), S = a(g, C);
          return na.bind(S, (_) => {
            const D = $e(_, (P) => ka(P, P, bs(), s));
            return jn(D).extract(g, p);
          });
        },
        toString: () => "setOf(" + s.toString() + ")"
      };
    }, vy = (t, s) => {
      const a = je(s);
      return {
        extract: (g, p) => a().extract(g, p),
        toString: () => a().toString()
      };
    }, Ou = xo(tu, jn), ua = U(To), hm = (t, s) => Bn((a) => {
      const i = typeof a;
      return t(a) ? na.svalue(a) : na.serror(`Expected type: ${s} but got: ${i}`);
    }), ug = hm(Pn, "number"), Xa = hm(Ee, "string"), nu = hm(Ft, "boolean"), gh = hm(st, "function"), Du = (t) => {
      if (Object(t) !== t)
        return !0;
      switch ({}.toString.call(t).slice(8, -1)) {
        case "Boolean":
        case "Number":
        case "String":
        case "Date":
        case "RegExp":
        case "Blob":
        case "FileList":
        case "ImageData":
        case "ImageBitmap":
        case "ArrayBuffer":
          return !0;
        case "Array":
        case "Object":
          return Object.keys(t).every((s) => Du(t[s]));
        default:
          return !1;
      }
    }, l1 = Bn((t) => Du(t) ? na.svalue(t) : na.serror("Expected value to be acceptable for sending via postMessage")), hh = (t, s, a, i) => Dt(a, i).fold(() => ce(t, a, i), (g) => g.extract(t.concat(["branch: " + i]), s)), Mt = (t, s) => ({
      extract: (d, g) => Dt(g, t).fold(() => z(d, t), (C) => hh(d, g, s, C)),
      toString: () => "chooseOn(" + t + "). Possible values: " + Ao(s)
    }), Xb = () => tu(To), Nd = (t) => Bn((s) => t(s).fold(na.serror, na.svalue)), rd = (t, s) => Au((a) => na.fromResult(t(a)), s), dg = (t, s, a) => {
      const i = s.extract([t], a);
      return na.mapError(i, (d) => ({
        input: a,
        errors: d
      }));
    }, $r = (t, s, a) => na.toResult(dg(t, s, a)), Js = (t) => t.fold((s) => {
      throw new Error(Kc(s));
    }, Tt), Gc = (t, s, a) => Js($r(t, s, a)), Kc = (t) => `Errors: 
` + lg(t.errors).join(`
`) + `

Input object: ` + Rd(t.input), es = (t, s) => Mt(t, et(s, jn)), mg = (t, s) => vy(t, s), dc = ka, oa = Ti, ph = (t) => Nd((s) => io(t, s) ? Mo.value(s) : Mo.error(`Unsupported value: "${s}", choose one of "${t.join(", ")}".`)), gt = (t) => dc(t, t, bs(), ua()), _i = (t, s) => dc(t, t, bs(), s), fg = (t) => _i(t, ug), _s = (t) => _i(t, Xa), Al = (t, s) => dc(t, t, bs(), ph(s)), yy = (t) => _i(t, nu), ou = (t) => _i(t, gh), bh = (t, s) => dc(t, t, _u(), Bn((a) => na.serror("The field: " + t + " is forbidden. " + s))), su = (t, s) => dc(t, t, bs(), jn(s)), u1 = (t, s) => dc(t, t, bs(), Ou(s)), zi = (t, s) => dc(t, t, bs(), tu(s)), $s = (t) => dc(t, t, _u(), ua()), Ru = (t, s) => dc(t, t, _u(), s), pm = (t) => Ru(t, ug), mc = (t) => Ru(t, Xa), d1 = (t, s) => Ru(t, ph(s)), bm = (t) => Ru(t, gh), Md = (t, s) => Ru(t, tu(s)), ui = (t, s) => Ru(t, jn(s)), Pd = (t, s) => Ru(t, br(s)), Ne = (t, s) => dc(t, t, ku(s), ua()), Pc = (t, s, a) => dc(t, t, ku(s), a), al = (t, s) => Pc(t, s, ug), ru = (t, s) => Pc(t, s, Xa), Ai = (t, s, a) => Pc(t, s, ph(a)), Pa = (t, s) => Pc(t, s, nu), _a = (t, s) => Pc(t, s, gh), Nw = (t, s) => Pc(t, s, l1), di = (t, s, a) => Pc(t, s, tu(a)), Nu = (t, s, a) => Pc(t, s, jn(a)), w = (t) => {
      let s = t;
      return {
        get: () => s,
        set: (d) => {
          s = d;
        }
      };
    }, H = { generate: (t) => {
      if (!dn(t))
        throw new Error("cases must be an array");
      if (t.length === 0)
        throw new Error("there must be at least one case");
      const s = [], a = {};
      return ot(t, (i, d) => {
        const g = Ao(i);
        if (g.length !== 1)
          throw new Error("one and only one name per case");
        const p = g[0], C = i[p];
        if (a[p] !== void 0)
          throw new Error("duplicate key detected:" + p);
        if (p === "cata")
          throw new Error("cannot have a case named cata (sorry)");
        if (!dn(C))
          throw new Error("case arguments must be an array");
        s.push(p), a[p] = (...S) => {
          const _ = S.length;
          if (_ !== C.length)
            throw new Error("Wrong number of arguments to case " + p + ". Expected " + C.length + " (" + C + "), got " + _);
          return {
            fold: (...P) => {
              if (P.length !== t.length)
                throw new Error("Wrong number of arguments to fold. Expected " + t.length + ", got " + P.length);
              return P[d].apply(null, S);
            },
            match: (P) => {
              const L = Ao(P);
              if (s.length !== L.length)
                throw new Error("Wrong number of arguments to match. Expected: " + s.join(",") + `
Actual: ` + L.join(","));
              if (!kt(s, (Y) => io(L, Y)))
                throw new Error("Not all branches were specified when using match. Specified: " + L.join(", ") + `
Required: ` + s.join(", "));
              return P[p].apply(null, S);
            },
            log: (P) => {
            }
          };
        };
      }), a;
    } };
    H.generate([
      {
        bothErrors: [
          "error1",
          "error2"
        ]
      },
      {
        firstError: [
          "error1",
          "value2"
        ]
      },
      {
        secondError: [
          "value1",
          "error2"
        ]
      },
      {
        bothValues: [
          "value1",
          "value2"
        ]
      }
    ]);
    const q = (t) => {
      const s = [], a = [];
      return ot(t, (i) => {
        i.fold((d) => {
          s.push(d);
        }, (d) => {
          a.push(d);
        });
      }), {
        errors: s,
        values: a
      };
    }, we = (t, s) => {
      const a = {};
      return Ie(t, (i, d) => {
        io(s, d) || (a[d] = i);
      }), a;
    }, rt = (t, s) => ({ [t]: s }), $t = (t) => {
      const s = {};
      return ot(t, (a) => {
        s[a.key] = a.value;
      }), s;
    }, pn = (t, s) => we(t, s), oo = (t, s) => rt(t, s), Jn = (t) => $t(t), Fr = (t, s) => t.length === 0 ? Mo.value(s) : Mo.value(Ms(s, Ei.apply(void 0, t))), Sr = (t) => Mo.error(ye(t)), Ws = (t, s) => {
      const a = q(t);
      return a.errors.length > 0 ? Sr(a.errors) : Fr(a.values, s);
    }, Yc = (t) => st(t) ? t : Te, au = (t, s, a) => {
      let i = t.dom;
      const d = Yc(a);
      for (; i.parentNode; ) {
        i = i.parentNode;
        const g = ve.fromDom(i), p = s(g);
        if (p.isSome())
          return p;
        if (d(g))
          break;
      }
      return A.none();
    }, Vi = (t, s, a) => {
      const i = s(t), d = Yc(a);
      return i.orThunk(() => d(t) ? A.none() : au(t, s, d));
    }, Ol = (t, s) => Rs(t.element, s.event.target), vh = {
      can: Oe,
      abort: Te,
      run: J
    }, Dl = (t) => {
      if (!Or(t, "can") && !Or(t, "abort") && !Or(t, "run"))
        throw new Error("EventHandler defined by: " + JSON.stringify(t, null, 2) + " does not have can, abort, or run!");
      return {
        ...vh,
        ...t
      };
    }, cf = (t, s) => (...a) => lt(t, (i, d) => i && s(d).apply(void 0, a), !0), lf = (t, s) => (...a) => lt(t, (i, d) => i || s(d).apply(void 0, a), !1), gg = (t) => st(t) ? {
      can: Oe,
      abort: Te,
      run: t
    } : t, uf = (t) => {
      const s = cf(t, (d) => d.can), a = lf(t, (d) => d.abort);
      return {
        can: s,
        abort: a,
        run: (...d) => {
          ot(t, (g) => {
            g.run.apply(void 0, d);
          });
        }
      };
    }, Aa = U, Mu = Aa("touchstart"), df = Aa("touchmove"), as = Aa("touchend"), Ur = Aa("touchcancel"), Zs = Aa("mousedown"), Bc = Aa("mousemove"), mf = Aa("mouseout"), m1 = Aa("mouseup"), Rl = Aa("mouseover"), $c = Aa("focusin"), Jb = Aa("focusout"), Pu = Aa("keydown"), ff = Aa("keyup"), hg = Aa("input"), yh = Aa("change"), vm = Aa("click"), vk = Aa("transitioncancel"), pg = Aa("transitionend"), Cy = Aa("transitionstart"), Mw = Aa("selectstart"), pa = (t) => U("alloy." + t), Ch = { tap: pa("tap") }, ym = pa("focus"), gf = pa("blur.post"), bg = pa("paste.post"), vg = pa("receive"), cl = pa("execute"), sa = pa("focus.item"), ad = Ch.tap, wy = pa("longpress"), f1 = pa("sandbox.close"), Qb = pa("typeahead.cancel"), hf = pa("system.init"), g1 = pa("system.touchmove"), e0 = pa("system.touchend"), Bd = pa("system.scroll"), cd = pa("system.resize"), Nl = pa("system.attached"), pf = pa("system.detached"), bf = pa("system.dismissRequested"), Pw = pa("system.repositionRequested"), t0 = pa("focusmanager.shifted"), h1 = pa("slotcontainer.visibility"), n0 = pa("system.external.element.scroll"), Bw = pa("change.tab"), o0 = pa("dismiss.tab"), p1 = pa("highlight"), b1 = pa("dehighlight"), cs = (t, s) => {
      v1(t, t.element, s, {});
    }, to = (t, s, a) => {
      v1(t, t.element, s, a);
    }, Cm = (t) => {
      cs(t, cl());
    }, s0 = (t, s, a) => {
      v1(t, s, a, {});
    }, v1 = (t, s, a, i) => {
      const d = {
        target: s,
        ...i
      };
      t.getSystem().triggerEvent(a, s, d);
    }, yk = (t, s, a, i) => {
      const d = {
        ...i,
        target: s
      };
      t.getSystem().triggerEvent(a, s, d);
    }, Sy = (t, s, a, i) => {
      t.getSystem().triggerEvent(a, s, i.event);
    }, vr = (t) => Jn(t), xy = (t, s) => ({
      key: t,
      value: Dl({ abort: s })
    }), Ty = (t, s) => ({
      key: t,
      value: Dl({ can: s })
    }), Ey = (t) => ({
      key: t,
      value: Dl({
        run: (s, a) => {
          a.event.prevent();
        }
      })
    }), mt = (t, s) => ({
      key: t,
      value: Dl({ run: s })
    }), r0 = (t, s, a) => ({
      key: t,
      value: Dl({
        run: (i, d) => {
          s.apply(void 0, [
            i,
            d
          ].concat(a));
        }
      })
    }), Ck = (t) => (s) => mt(t, s), y1 = (t) => (s) => ({
      key: t,
      value: Dl({
        run: (a, i) => {
          Ol(a, i) && s(a, i);
        }
      })
    }), wk = (t, s) => mt(t, (a, i) => {
      a.getSystem().getByUid(s).each((d) => {
        Sy(d, d.element, t, i);
      });
    }), wh = (t, s, a) => {
      const i = s.partUids[a];
      return wk(t, i);
    }, ky = (t, s) => mt(t, (a, i) => {
      const d = i.event, g = a.getSystem().getByDom(d.target).getOrThunk(() => Vi(d.target, (C) => a.getSystem().getByDom(C).toOptional(), Te).getOr(a));
      s(a, g, i);
    }), wm = (t) => mt(t, (s, a) => {
      a.cut();
    }), Sk = (t) => mt(t, (s, a) => {
      a.stop();
    }), $d = (t, s) => y1(t)(s), cr = y1(Nl()), Fd = y1(pf()), _y = y1(hf()), Bu = Ck(cl()), Sm = (t, s) => {
      const i = (s || document).createElement("div");
      return i.innerHTML = t, ja(ve.fromDom(i));
    }, Ay = (t) => t.dom.innerHTML, yg = (t, s) => {
      const i = Ia(t).dom, d = ve.fromDom(i.createDocumentFragment()), g = Sm(s, i);
      ed(d, g), mm(t), Sc(t, d);
    }, $w = (t) => {
      const s = ve.fromTag("div"), a = ve.fromDom(t.dom.cloneNode(!0));
      return Sc(s, a), Ay(s);
    }, a0 = (t, s) => ve.fromDom(t.dom.cloneNode(s)), Oy = (t) => a0(t, !1), xk = (t) => a0(t, !0), Dy = (t) => {
      if (Z(t))
        return "#shadow-root";
      {
        const s = Oy(t);
        return $w(s);
      }
    }, Cg = (t) => Dy(t), Z4 = (t, s, a) => Rs(s, t.element) && !Rs(s, a), Ry = vr([Ty(ym(), (t, s) => {
      const a = s.event, i = a.originator, d = a.target;
      return !Z4(t, i, d);
    })]);
    var wg = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      events: Ry
    });
    let Fc = 0;
    const An = (t) => {
      const a = (/* @__PURE__ */ new Date()).getTime(), i = Math.floor(Math.random() * 1e9);
      return Fc++, t + "_" + i + Fc + String(a);
    }, Tk = U("alloy-id-"), Ny = U("data-alloy-id"), Ek = Tk(), Fw = Ny(), Sg = (t, s) => {
      const a = An(Ek + t);
      return Sh(s, a), a;
    }, Sh = (t, s) => {
      Object.defineProperty(t.dom, Fw, {
        value: s,
        writable: !0
      });
    }, C1 = (t) => {
      const s = lo(t) ? t.dom[Fw] : null;
      return A.from(s);
    }, xh = (t) => An(t), c0 = Tt, xm = (t) => {
      const s = (d) => `The component must be in a context to execute: ${d}` + (t ? `
` + Cg(t().element) + " is not in context." : ""), a = (d) => () => {
        throw new Error(s(d));
      }, i = (d) => () => {
      };
      return {
        debugInfo: U("fake"),
        triggerEvent: i("triggerEvent"),
        triggerFocus: i("triggerFocus"),
        triggerEscape: i("triggerEscape"),
        broadcast: i("broadcast"),
        broadcastOn: i("broadcastOn"),
        broadcastEvent: i("broadcastEvent"),
        build: a("build"),
        buildOrPatch: a("buildOrPatch"),
        addToWorld: a("addToWorld"),
        removeFromWorld: a("removeFromWorld"),
        addToGui: a("addToGui"),
        removeFromGui: a("removeFromGui"),
        getByUid: a("getByUid"),
        getByDom: a("getByDom"),
        isConnected: Te
      };
    }, id = xm(), w1 = (t, s, a) => {
      const i = a.toString(), d = i.indexOf(")") + 1, g = i.indexOf("("), p = i.substring(g + 1, d - 1).split(/,\s*/);
      return t.toFunctionAnnotation = () => ({
        name: s,
        parameters: cu(p.slice(0, 1).concat(p.slice(3)))
      }), t;
    }, cu = (t) => $e(t, (s) => Sa(s, "/*") ? s.substring(0, s.length - 2) : s), i0 = (t, s) => {
      const a = t.toString(), i = a.indexOf(")") + 1, d = a.indexOf("("), g = a.substring(d + 1, i - 1).split(/,\s*/);
      return t.toFunctionAnnotation = () => ({
        name: s,
        parameters: cu(g)
      }), t;
    }, Iw = (t, s) => {
      const a = s.toString(), i = a.indexOf(")") + 1, d = a.indexOf("("), g = a.substring(d + 1, i - 1).split(/,\s*/);
      return t.toFunctionAnnotation = () => ({
        name: "OVERRIDE",
        parameters: cu(g.slice(1))
      }), t;
    }, Th = An("alloy-premade"), Tm = (t) => (Object.defineProperty(t.element.dom, Th, {
      value: t.uid,
      writable: !0
    }), oo(Th, t)), kk = (t) => Lo(t.dom, Th), Eh = (t) => Dt(t, Th), xg = (t) => Iw((s, ...a) => t(s.getApis(), s, ...a), t), $u = { init: () => il({ readState: U("No State required") }) }, il = (t) => t, _k = (t, s) => {
      const a = $e(s, (d) => ui(d.name(), [
        gt("config"),
        Ne("state", $u)
      ])), i = $r("component.behaviours", jn(a), t.behaviours).fold((d) => {
        throw new Error(Kc(d) + `
Complete spec:
` + JSON.stringify(t, null, 2));
      }, Tt);
      return {
        list: s,
        data: et(i, (d) => {
          const g = d.map((p) => ({
            config: p.config,
            state: p.state.init(p.config)
          }));
          return U(g);
        })
      };
    }, Lw = (t) => t.list, Hw = (t) => t.data, My = (t, s) => {
      const a = {};
      return Ie(t, (i, d) => {
        Ie(i, (g, p) => {
          const C = Dt(a, p).getOr([]);
          a[p] = C.concat([s(d, g)]);
        });
      }), a;
    }, ll = (t) => ({
      classes: Zt(t.classes) ? [] : t.classes,
      attributes: Zt(t.attributes) ? {} : t.attributes,
      styles: Zt(t.styles) ? {} : t.styles
    }), kh = (t, s) => ({
      ...t,
      attributes: {
        ...t.attributes,
        ...s.attributes
      },
      styles: {
        ...t.styles,
        ...s.styles
      },
      classes: t.classes.concat(s.classes)
    }), l0 = (t, s, a, i) => {
      const d = { ...s };
      ot(a, (D) => {
        d[D.name()] = D.exhibit(t, i);
      });
      const g = My(d, (D, P) => ({
        name: D,
        modification: P
      })), p = (D) => at(D, (P, L) => ({
        ...L.modification,
        ...P
      }), {}), C = at(g.classes, (D, P) => P.modification.concat(D), []), S = p(g.attributes), _ = p(g.styles);
      return ll({
        classes: C,
        attributes: S,
        styles: _
      });
    }, u0 = (t, s, a, i) => {
      try {
        const d = In(a, (g, p) => {
          const C = g[s], S = p[s], _ = i.indexOf(C), D = i.indexOf(S);
          if (_ === -1)
            throw new Error("The ordering for " + t + " does not have an entry for " + C + `.
Order specified: ` + JSON.stringify(i, null, 2));
          if (D === -1)
            throw new Error("The ordering for " + t + " does not have an entry for " + S + `.
Order specified: ` + JSON.stringify(i, null, 2));
          return _ < D ? -1 : D < _ ? 1 : 0;
        });
        return Mo.value(d);
      } catch (d) {
        return Mo.error([d]);
      }
    }, Ak = (t, s) => ({
      handler: t,
      purpose: s
    }), zw = (t, s) => ({
      cHandler: t,
      purpose: s
    }), Py = (t, s) => zw(gn.apply(void 0, [t.handler].concat(s)), t.purpose), _h = (t) => t.cHandler, Ah = (t, s) => ({
      name: t,
      handler: s
    }), d0 = (t, s) => {
      const a = {};
      return ot(t, (i) => {
        a[i.name()] = i.handlers(s);
      }), a;
    }, Ok = (t, s, a) => {
      const i = {
        ...a,
        ...d0(s, t)
      };
      return My(i, Ah);
    }, m0 = (t, s, a, i) => {
      const d = Ok(t, a, i);
      return By(d, s);
    }, Oh = (t) => {
      const s = gg(t);
      return (a, i, ...d) => {
        const g = [
          a,
          i
        ].concat(d);
        s.abort.apply(void 0, g) ? i.stop() : s.can.apply(void 0, g) && s.run.apply(void 0, g);
      };
    }, Dk = (t, s) => Mo.error(["The event (" + t + `) has more than one behaviour that listens to it.
When this occurs, you must specify an event ordering for the behaviours in your spec (e.g. [ "listing", "toggling" ]).
The behaviours that can trigger it are: ` + JSON.stringify($e(s, (a) => a.name), null, 2)]), S1 = (t, s, a) => {
      const i = s[a];
      return i ? u0("Event: " + a, "name", t, i).map((d) => {
        const g = $e(d, (p) => p.handler);
        return uf(g);
      }) : Dk(a, t);
    }, By = (t, s) => {
      const a = Yr(t, (i, d) => (i.length === 1 ? Mo.value(i[0].handler) : S1(i, s, d)).map((p) => {
        const C = Oh(p), S = i.length > 1 ? fo(s[d], (_) => jo(i, (D) => D.name === _)).join(" > ") : i[0].name;
        return oo(d, Ak(C, S));
      }));
      return Ws(a, {});
    }, ul = "alloy.base.behaviour", f0 = jn([
      dc("dom", "dom", bs(), jn([
        gt("tag"),
        Ne("styles", {}),
        Ne("classes", []),
        Ne("attributes", {}),
        $s("value"),
        $s("innerHtml")
      ])),
      gt("components"),
      gt("uid"),
      Ne("events", {}),
      Ne("apis", {}),
      dc("eventOrder", "eventOrder", sd({
        [cl()]: [
          "disabling",
          ul,
          "toggling",
          "typeaheadevents"
        ],
        [ym()]: [
          ul,
          "focusing",
          "keying"
        ],
        [hf()]: [
          ul,
          "disabling",
          "toggling",
          "representing"
        ],
        [hg()]: [
          ul,
          "representing",
          "streaming",
          "invalidating"
        ],
        [pf()]: [
          ul,
          "representing",
          "item-events",
          "tooltipping"
        ],
        [Zs()]: [
          "focusing",
          ul,
          "item-type-events"
        ],
        [Mu()]: [
          "focusing",
          ul,
          "item-type-events"
        ],
        [Rl()]: [
          "item-type-events",
          "tooltipping"
        ],
        [vg()]: [
          "receiving",
          "reflecting",
          "tooltipping"
        ]
      }), ua()),
      $s("domModification")
    ]), Vw = (t) => $r("custom.definition", f0, t), g0 = (t) => ({
      ...t.dom,
      uid: t.uid,
      domChildren: $e(t.components, (s) => s.element)
    }), j4 = (t) => t.domModification.fold(() => ll({}), ll), h0 = (t) => t.events, vf = (t, s) => {
      const a = rr(t, s);
      return a === void 0 || a === "" ? [] : a.split(" ");
    }, Id = (t, s, a) => {
      const d = vf(t, s).concat([a]);
      return sn(t, s, d.join(" ")), !0;
    }, $y = (t, s, a) => {
      const i = fo(vf(t, s), (d) => d !== a);
      return i.length > 0 ? sn(t, s, i.join(" ")) : se(t, s), !1;
    }, Dh = (t) => t.dom.classList !== void 0, p0 = (t) => vf(t, "class"), Uw = (t, s) => Id(t, "class", s), xr = (t, s) => $y(t, "class", s), Rk = (t, s) => io(p0(t), s) ? xr(t, s) : Uw(t, s), ba = (t, s) => {
      Dh(t) ? t.dom.classList.add(s) : Uw(t, s);
    }, Ww = (t) => {
      (Dh(t) ? t.dom.classList : p0(t)).length === 0 && se(t, "class");
    }, Wr = (t, s) => {
      Dh(t) ? t.dom.classList.remove(s) : xr(t, s), Ww(t);
    }, Rh = (t, s) => {
      const a = Dh(t) ? t.dom.classList.toggle(s) : Rk(t, s);
      return Ww(t), a;
    }, Ha = (t, s) => Dh(t) && t.dom.classList.contains(s), jr = (t, s) => {
      ot(s, (a) => {
        ba(t, a);
      });
    }, Ml = (t, s) => {
      ot(s, (a) => {
        Wr(t, a);
      });
    }, Fy = (t, s) => {
      ot(s, (a) => {
        Rh(t, a);
      });
    }, Ic = (t, s) => kt(s, (a) => Ha(t, a)), x1 = (t) => {
      const s = t.dom.classList, a = new Array(s.length);
      for (let i = 0; i < s.length; i++) {
        const d = s.item(i);
        d !== null && (a[i] = d);
      }
      return a;
    }, Nh = (t) => Dh(t) ? x1(t) : p0(t), Ld = (t) => t.dom.value, Mh = (t, s) => {
      if (s === void 0)
        throw new Error("Value.set was undefined");
      t.dom.value = s;
    }, yf = (t, s, a) => wi(t, s).map((d) => {
      if (a.exists((p) => !Rs(p, d))) {
        const p = a.map(Ds).getOr("span"), C = ve.fromTag(p);
        return Li(d, C), C;
      } else
        return d;
    }), Em = (t, s, a) => {
      a.fold(() => Sc(t, s), (i) => {
        Rs(i, s) || (Li(i, s), rl(i));
      });
    }, Nk = (t, s, a) => {
      const i = $e(s, a), d = ja(t);
      return ot(d.slice(i.length), rl), i;
    }, Zw = (t, s, a, i) => {
      const d = wi(t, s), g = i(a, d), p = yf(t, s, d);
      return Em(t, g.element, p), g;
    }, q4 = (t, s, a) => Nk(t, s, (i, d) => Zw(t, d, i, a)), G4 = (t, s) => Nk(t, s, (a, i) => {
      const d = wi(t, i);
      return Em(t, a, d), a;
    }), Fu = (t, s) => {
      const a = Ao(t), i = Ao(s), d = Yt(i, a), g = rs(t, (p, C) => !Lo(s, C) || p !== s[C]).t;
      return {
        toRemove: d,
        toSet: g
      };
    }, mi = (t, s) => {
      const {
        class: a,
        style: i,
        ...d
      } = Ue(s), {
        toSet: g,
        toRemove: p
      } = Fu(t.attributes, d), C = () => {
        ot(p, (Be) => se(s, Be)), Ql(s, g);
      }, S = Zr(s), {
        toSet: _,
        toRemove: D
      } = Fu(t.styles, S), P = () => {
        ot(D, (Be) => Jo(s, Be)), gr(s, _);
      }, L = Nh(s), V = Yt(L, t.classes), Y = Yt(t.classes, L), me = () => {
        jr(s, Y), Ml(s, V);
      }, Pe = (Be) => {
        yg(s, Be);
      }, xe = () => {
        const Be = t.domChildren;
        G4(s, Be);
      }, Ce = () => {
        const Be = s, St = t.value.getOrUndefined();
        St !== Ld(Be) && Mh(Be, St ?? "");
      };
      return C(), me(), P(), t.innerHtml.fold(xe, Pe), Ce(), s;
    }, Mk = (t) => {
      const s = ve.fromTag(t.tag);
      Ql(s, t.attributes), jr(s, t.classes), gr(s, t.styles), t.innerHtml.each((i) => yg(s, i));
      const a = t.domChildren;
      return ed(s, a), t.value.each((i) => {
        Mh(s, i);
      }), s;
    }, Pk = (t, s) => {
      try {
        const a = mi(t, s);
        return A.some(a);
      } catch {
        return A.none();
      }
    }, Cf = (t) => t.innerHtml.isSome() && t.domChildren.length > 0, T1 = (t, s) => {
      const a = (d) => Ds(d) === t.tag && !Cf(t) && !kk(d), i = s.filter(a).bind((d) => Pk(t, d)).getOrThunk(() => Mk(t));
      return Sh(i, t.uid), i;
    }, b0 = (t) => {
      const s = Dt(t, "behaviours").getOr({});
      return ae(Ao(s), (a) => {
        const i = s[a];
        return En(i) ? [i.me] : [];
      });
    }, v0 = (t, s) => _k(t, s), Hd = (t) => {
      const s = b0(t);
      return v0(t, s);
    }, Ph = (t, s, a) => {
      const i = g0(t), d = j4(t), g = { "alloy.base.modification": d }, p = s.length > 0 ? l0(a, g, s, i) : d;
      return kh(i, p);
    }, Bh = (t, s, a) => {
      const i = { "alloy.base.behaviour": h0(t) };
      return m0(a, t.eventOrder, s, i).getOrDie();
    }, $h = (t, s) => {
      const a = () => Be, i = w(id), d = Js(Vw(t)), g = Hd(t), p = Lw(g), C = Hw(g), S = Ph(d, p, C), _ = T1(S, s), D = Bh(d, p, C), P = w(d.components), L = (St) => {
        i.set(St);
      }, V = () => {
        i.set(xm(a));
      }, Y = () => {
        const St = ja(_), ct = ae(St, (tt) => i.get().getByDom(tt).fold(() => [], Xe));
        P.set(ct);
      }, me = (St) => {
        const ct = C;
        return (st(ct[St.name()]) ? ct[St.name()] : () => {
          throw new Error("Could not find " + St.name() + " in " + JSON.stringify(t, null, 2));
        })();
      }, Pe = (St) => st(C[St.name()]), xe = () => d.apis, Ce = (St) => C[St]().map((ct) => ct.state.readState()).getOr("not enabled"), Be = {
        uid: t.uid,
        getSystem: i.get,
        config: me,
        hasConfigured: Pe,
        spec: t,
        readState: Ce,
        getApis: xe,
        connect: L,
        disconnect: V,
        element: _,
        syncComponents: Y,
        components: P.get,
        events: D
      };
      return Be;
    }, Tg = (t, s) => {
      const a = Dt(t, "components").getOr([]);
      return s.fold(() => $e(a, Xc), (i) => $e(a, (d, g) => y0(d, wi(i, g))));
    }, jw = (t, s) => {
      const {
        events: a,
        ...i
      } = c0(t), d = Tg(i, s), g = {
        ...i,
        events: {
          ...wg,
          ...a
        },
        components: d
      };
      return Mo.value($h(g, s));
    }, da = (t) => {
      const s = ve.fromText(t);
      return qw({ element: s });
    }, qw = (t) => {
      const s = Gc("external.component", br([
        gt("element"),
        $s("uid")
      ]), t), a = w(xm()), i = (C) => {
        a.set(C);
      }, d = () => {
        a.set(xm(() => p));
      }, g = s.uid.getOrThunk(() => xh("external"));
      Sh(s.element, g);
      const p = {
        uid: g,
        getSystem: a.get,
        config: A.none,
        hasConfigured: Te,
        connect: i,
        disconnect: d,
        getApis: () => ({}),
        element: s.element,
        spec: t,
        readState: U("No state"),
        syncComponents: J,
        components: U([]),
        events: {}
      };
      return Tm(p);
    }, Fh = xh, Gw = (t) => Lo(t, "uid"), y0 = (t, s) => Eh(t).getOrThunk(() => {
      const a = Gw(t) ? t : {
        uid: Fh(""),
        ...t
      };
      return jw(a, s).getOrDie();
    }), Xc = (t) => y0(t, A.none()), Pl = Tm;
    var Kw = (t, s, a, i, d) => t(a, i) ? A.some(a) : st(d) && d(a) ? A.none() : s(a, i, d);
    const C0 = (t, s, a) => {
      let i = t.dom;
      const d = st(a) ? a : Te;
      for (; i.parentNode; ) {
        i = i.parentNode;
        const g = ve.fromDom(i);
        if (s(g))
          return A.some(g);
        if (d(g))
          break;
      }
      return A.none();
    }, Eg = (t, s, a) => Kw((d, g) => g(d), C0, t, s, a), Bk = (t, s) => {
      const a = (d) => s(ve.fromDom(d));
      return ee(t.dom.childNodes, a).map(ve.fromDom);
    }, Yw = (t, s) => {
      const a = (i) => {
        for (let d = 0; d < i.childNodes.length; d++) {
          const g = ve.fromDom(i.childNodes[d]);
          if (s(g))
            return A.some(g);
          const p = a(i.childNodes[d]);
          if (p.isSome())
            return p;
        }
        return A.none();
      };
      return a(t.dom);
    }, Iy = (t, s, a) => Eg(t, s, a).isSome(), dl = (t, s, a) => C0(t, (i) => mr(i, s), a), w0 = (t, s) => Bk(t, (a) => mr(a, s)), va = (t, s) => nl(s, t), ld = (t, s, a) => Kw((d, g) => mr(d, g), dl, t, s, a), Ih = "aria-controls", wf = (t) => Eg(t, (a) => {
      if (!lo(a))
        return !1;
      const i = rr(a, "id");
      return i !== void 0 && i.indexOf(Ih) > -1;
    }).bind((a) => {
      const i = rr(a, "id"), d = Ve(a);
      return va(d, `[${Ih}="${i}"]`);
    }), kg = () => {
      const t = An(Ih);
      return {
        id: t,
        link: (i) => {
          sn(i, Ih, t);
        },
        unlink: (i) => {
          se(i, Ih);
        }
      };
    }, _g = (t, s) => wf(s).exists((a) => km(t, a)), km = (t, s) => Iy(s, (a) => Rs(a, t.element), Te) || _g(t, s), Xw = "unknown";
    var Ag;
    (function(t) {
      t[t.STOP = 0] = "STOP", t[t.NORMAL = 1] = "NORMAL", t[t.LOGGING = 2] = "LOGGING";
    })(Ag || (Ag = {}));
    const Sf = w({}), Og = (t, s) => {
      const a = [], i = (/* @__PURE__ */ new Date()).getTime();
      return {
        logEventCut: (d, g, p) => {
          a.push({
            outcome: "cut",
            target: g,
            purpose: p
          });
        },
        logEventStopped: (d, g, p) => {
          a.push({
            outcome: "stopped",
            target: g,
            purpose: p
          });
        },
        logNoParent: (d, g, p) => {
          a.push({
            outcome: "no-parent",
            target: g,
            purpose: p
          });
        },
        logEventNoHandlers: (d, g) => {
          a.push({
            outcome: "no-handlers-left",
            target: g
          });
        },
        logEventResponse: (d, g, p) => {
          a.push({
            outcome: "response",
            purpose: p,
            target: g
          });
        },
        write: () => {
          const d = (/* @__PURE__ */ new Date()).getTime();
          io([
            "mousemove",
            "mouseover",
            "mouseout",
            hf()
          ], t);
        }
      };
    }, Jw = (t, s, a) => {
      switch (Dt(Sf.get(), t).orThunk(() => {
        const d = Ao(Sf.get());
        return No(d, (g) => t.indexOf(g) > -1 ? A.some(Sf.get()[g]) : A.none());
      }).getOr(Ag.NORMAL)) {
        case Ag.NORMAL:
          return a(Hy());
        case Ag.LOGGING: {
          const d = Og(t, s), g = a(d);
          return d.write(), g;
        }
        case Ag.STOP:
          return !0;
      }
    }, $k = [
      "alloy/data/Fields",
      "alloy/debugging/Debugging"
    ], Ly = () => {
      const t = new Error();
      if (t.stack !== void 0) {
        const s = t.stack.split(`
`);
        return ee(s, (a) => a.indexOf("alloy") > 0 && !jo($k, (i) => a.indexOf(i) > -1)).getOr(Xw);
      } else
        return Xw;
    }, Fk = {
      logEventCut: J,
      logEventStopped: J,
      logNoParent: J,
      logEventNoHandlers: J,
      logEventResponse: J,
      write: J
    }, S0 = (t, s, a) => Jw(t, s, a), Hy = U(Fk), ml = U([
      gt("menu"),
      gt("selectedMenu")
    ]), Qw = U([
      gt("item"),
      gt("selectedItem")
    ]);
    U(jn(Qw().concat(ml())));
    const Lh = U(jn(Qw())), eS = su("initSize", [
      gt("numColumns"),
      gt("numRows")
    ]), Ik = () => _i("markers", Lh()), E1 = () => su("markers", [gt("backgroundMenu")].concat(ml()).concat(Qw())), xf = (t) => su("markers", $e(t, gt)), x0 = (t, s, a) => (Ly(), dc(s, s, a, Nd((i) => Mo.value((...d) => i.apply(void 0, d))))), gs = (t) => x0("onHandler", t, ku(J)), fl = (t) => x0("onKeyboardHandler", t, ku(A.none)), ud = (t) => x0("onHandler", t, bs()), zy = (t) => x0("onKeyboardHandler", t, bs()), Qs = (t, s) => oa(t, U(s)), k1 = (t) => oa(t, Tt), Vy = U(eS), Ja = (t, s, a, i, d, g, p, C = !1) => ({
      x: t,
      y: s,
      bubble: a,
      direction: i,
      placement: d,
      restriction: g,
      label: `${p}-${d}`,
      alwaysFit: C
    }), zd = H.generate([
      { southeast: [] },
      { southwest: [] },
      { northeast: [] },
      { northwest: [] },
      { south: [] },
      { north: [] },
      { east: [] },
      { west: [] }
    ]), Tf = (t, s, a, i, d, g, p, C, S) => t.fold(s, a, i, d, g, p, C, S), Uy = (t, s, a, i) => t.fold(s, s, i, i, s, i, a, a), T0 = (t, s, a, i) => t.fold(s, i, s, i, a, a, s, i), _1 = zd.southeast, Wy = zd.southwest, E0 = zd.northeast, Vd = zd.northwest, _m = zd.south, Lk = zd.north, We = zd.east, A1 = zd.west, Hh = (t, s, a, i) => {
      const d = t + s;
      return d > i ? a : d < a ? i : d;
    }, Bl = (t, s, a) => Math.min(Math.max(t, s), a), Zy = (t, s) => {
      switch (s) {
        case 1:
          return t.x;
        case 0:
          return t.x + t.width;
        case 2:
          return t.y;
        case 3:
          return t.y + t.height;
      }
    }, Ir = (t, s) => Ct([
      "left",
      "right",
      "top",
      "bottom"
    ], (a) => Dt(s, a).map((i) => Zy(t, i))), k0 = (t, s, a) => {
      const i = (S, _) => s[S].map((D) => {
        const P = S === "top" || S === "bottom", L = P ? a.top : a.left, Y = (S === "left" || S === "top" ? Math.max : Math.min)(D, _) + L;
        return P ? Bl(Y, t.y, t.bottom) : Bl(Y, t.x, t.right);
      }).getOr(_), d = i("left", t.x), g = i("top", t.y), p = i("right", t.right), C = i("bottom", t.bottom);
      return Rr(d, g, p - d, C - g);
    }, Am = "layout", jy = (t) => t.x, _0 = (t, s) => t.x + t.width / 2 - s.width / 2, qy = (t, s) => t.x + t.width - s.width, O1 = (t, s) => t.y - s.height, zh = (t) => t.y + t.height, Gy = (t, s) => t.y + t.height / 2 - s.height / 2, Hk = (t) => t.x + t.width, Oi = (t, s) => t.x - s.width, Qa = (t, s, a) => Ja(jy(t), zh(t), a.southeast(), _1(), "southeast", Ir(t, {
      left: 1,
      top: 3
    }), Am), Lc = (t, s, a) => Ja(qy(t, s), zh(t), a.southwest(), Wy(), "southwest", Ir(t, {
      right: 0,
      top: 3
    }), Am), Di = (t, s, a) => Ja(jy(t), O1(t, s), a.northeast(), E0(), "northeast", Ir(t, {
      left: 1,
      bottom: 2
    }), Am), Jc = (t, s, a) => Ja(qy(t, s), O1(t, s), a.northwest(), Vd(), "northwest", Ir(t, {
      right: 0,
      bottom: 2
    }), Am), fi = (t, s, a) => Ja(_0(t, s), O1(t, s), a.north(), Lk(), "north", Ir(t, { bottom: 2 }), Am), ec = (t, s, a) => Ja(_0(t, s), zh(t), a.south(), _m(), "south", Ir(t, { top: 3 }), Am), Ky = (t, s, a) => Ja(Hk(t), Gy(t, s), a.east(), We(), "east", Ir(t, { left: 0 }), Am), D1 = (t, s, a) => Ja(Oi(t, s), Gy(t, s), a.west(), A1(), "west", Ir(t, { right: 1 }), Am), Yy = () => [
      Qa,
      Lc,
      Di,
      Jc,
      ec,
      fi,
      Ky,
      D1
    ], R1 = () => [
      Lc,
      Qa,
      Jc,
      Di,
      ec,
      fi,
      Ky,
      D1
    ], Xy = () => [
      Di,
      Jc,
      Qa,
      Lc,
      fi,
      ec
    ], tS = () => [
      Jc,
      Di,
      Lc,
      Qa,
      fi,
      ec
    ], A0 = () => [
      Qa,
      Lc,
      Di,
      Jc,
      ec,
      fi
    ], Jy = () => [
      Lc,
      Qa,
      Jc,
      Di,
      ec,
      fi
    ], zk = (t, s) => s.universal ? t : fo(t, (a) => io(s.channels, a));
    var nS = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      events: (t) => vr([mt(vg(), (s, a) => {
        const i = t.channels, d = Ao(i), g = a, p = zk(d, g);
        ot(p, (C) => {
          const S = i[C], _ = S.schema, D = Gc("channel[" + C + `] data
Receiver: ` + Cg(s.element), _, g.data);
          S.onReceive(s, D);
        });
      })])
    }), Uk = [_i("channels", rd(Mo.value, br([
      ud("onReceive"),
      Ne("schema", ua())
    ])))];
    const Vh = (t, s, a) => Bu((i) => {
      a(i, t, s);
    }), O0 = (t, s, a) => _y((i, d) => {
      a(i, t, s);
    }), oS = (t, s, a, i, d, g) => {
      const p = br(t), C = ui(s, [Pd("config", t)]);
      return dd(p, C, s, a, i, d, g);
    }, K4 = (t, s, a, i, d, g) => {
      const p = t, C = ui(s, [Ru("config", t)]);
      return dd(p, C, s, a, i, d, g);
    }, Ui = (t, s, a) => w1((d, ...g) => {
      const p = [d].concat(g);
      return d.config({ name: U(t) }).fold(() => {
        throw new Error("We could not find any behaviour configuration for: " + t + ". Using API: " + a);
      }, (C) => {
        const S = Array.prototype.slice.call(p, 1);
        return s.apply(void 0, [
          d,
          C.config,
          C.state
        ].concat(S));
      });
    }, a, s), Y4 = (t) => ({
      key: t,
      value: void 0
    }), dd = (t, s, a, i, d, g, p) => {
      const C = (P) => Or(P, a) ? P[a]() : A.none(), S = et(d, (P, L) => Ui(a, P, L)), D = {
        ...et(g, (P, L) => i0(P, L)),
        ...S,
        revoke: gn(Y4, a),
        config: (P) => {
          const L = Gc(a + "-config", t, P);
          return {
            key: a,
            value: {
              config: L,
              me: D,
              configAsRaw: je(() => Gc(a + "-config", t, P)),
              initialConfig: P,
              state: p
            }
          };
        },
        schema: U(s),
        exhibit: (P, L) => fa(C(P), Dt(i, "exhibit"), (V, Y) => Y(L, V.config, V.state)).getOrThunk(() => ll({})),
        name: U(a),
        handlers: (P) => C(P).map((L) => Dt(i, "events").getOr(() => ({}))(L.config, L.state)).getOr({})
      };
      return D;
    }, Ut = (t) => Jn(t), Qy = br([
      gt("fields"),
      gt("name"),
      Ne("active", {}),
      Ne("apis", {}),
      Ne("state", $u),
      Ne("extra", {})
    ]), tc = (t) => {
      const s = Gc("Creating behaviour: " + t.name, Qy, t);
      return oS(s.fields, s.name, s.active, s.apis, s.extra, s.state);
    }, sS = br([
      gt("branchKey"),
      gt("branches"),
      gt("name"),
      Ne("active", {}),
      Ne("apis", {}),
      Ne("state", $u),
      Ne("extra", {})
    ]), D0 = (t) => {
      const s = Gc("Creating behaviour: " + t.name, sS, t);
      return K4(es(s.branchKey, s.branches), s.name, s.active, s.apis, s.extra, s.state);
    }, eC = U(void 0), Wi = tc({
      fields: Uk,
      name: "receiving",
      active: nS
    });
    var rS = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      exhibit: (t, s) => ll({
        classes: [],
        styles: s.useFixed() ? {} : { position: "relative" }
      })
    });
    const Zi = (t, s = !1) => t.dom.focus({ preventScroll: s }), Uh = (t) => t.dom.blur(), N1 = (t) => {
      const s = Ve(t).dom;
      return t.dom === s.activeElement;
    }, Ud = (t = Dd()) => A.from(t.dom.activeElement).map(ve.fromDom), Iu = (t) => Ud(Ve(t)).filter((s) => t.dom.contains(s.dom)), Cn = (t, s) => {
      const a = Ve(s), i = Ud(a).bind((g) => {
        const p = (C) => Rs(g, C);
        return p(s) ? A.some(s) : Yw(s, p);
      }), d = t(s);
      return i.each((g) => {
        Ud(a).filter((p) => Rs(p, g)).fold(() => {
          Zi(g);
        }, J);
      }), d;
    }, $l = (t, s, a, i, d) => {
      const g = (p) => p + "px";
      return {
        position: t,
        left: s.map(g),
        top: a.map(g),
        right: i.map(g),
        bottom: d.map(g)
      };
    }, aS = (t) => ({
      ...t,
      position: A.some(t.position)
    }), cS = (t, s) => {
      _t(t, aS(s));
    }, tC = H.generate([
      { none: [] },
      {
        relative: [
          "x",
          "y",
          "width",
          "height"
        ]
      },
      {
        fixed: [
          "x",
          "y",
          "width",
          "height"
        ]
      }
    ]), iS = (t, s, a, i, d, g) => {
      const p = s.rect, C = p.x - a, S = p.y - i, _ = p.width, D = p.height, P = d - (C + _), L = g - (S + D), V = A.some(C), Y = A.some(S), me = A.some(P), Pe = A.some(L), xe = A.none();
      return Tf(s.direction, () => $l(t, V, Y, xe, xe), () => $l(t, xe, Y, me, xe), () => $l(t, V, xe, xe, Pe), () => $l(t, xe, xe, me, Pe), () => $l(t, V, Y, xe, xe), () => $l(t, V, xe, xe, Pe), () => $l(t, V, Y, xe, xe), () => $l(t, xe, Y, me, xe));
    }, nC = (t, s) => t.fold(() => {
      const a = s.rect;
      return $l("absolute", A.some(a.x), A.some(a.y), A.none(), A.none());
    }, (a, i, d, g) => iS("absolute", s, a, i, d, g), (a, i, d, g) => iS("fixed", s, a, i, d, g)), oC = (t, s) => {
      const a = gn(Tu, s), i = t.fold(a, a, () => {
        const p = Mc();
        return Tu(s).translate(-p.left, -p.top);
      }), d = oe(s), g = yu(s);
      return Rr(i.left, i.top, d, g);
    }, Zk = (t, s) => s.fold(() => t.fold(La, La, Rr), (a) => t.fold(U(a), U(a), () => {
      const i = sC(t, a.x, a.y);
      return Rr(i.left, i.top, a.width, a.height);
    })), sC = (t, s, a) => {
      const i = Es(s, a), d = () => {
        const g = Mc();
        return i.translate(-g.left, -g.top);
      };
      return t.fold(U(i), U(i), d);
    }, jk = (t, s, a, i) => t.fold(s, a, i);
    tC.none;
    const gi = tC.relative, M1 = tC.fixed, qk = (t, s) => ({
      anchorBox: t,
      origin: s
    }), Gk = (t, s) => qk(t, s), rC = "data-alloy-placement", Kk = (t, s) => {
      sn(t, rC, s);
    }, lS = (t) => B(t, rC), uS = (t) => se(t, rC), P1 = H.generate([
      { fit: ["reposition"] },
      {
        nofit: [
          "reposition",
          "visibleW",
          "visibleH",
          "isVisible"
        ]
      }
    ]), dS = (t, s) => {
      const {
        x: a,
        y: i,
        right: d,
        bottom: g
      } = s, { x: p, y: C, right: S, bottom: _, width: D, height: P } = t, L = p >= a && p <= d, V = C >= i && C <= g, Y = L && V, me = S <= d && S >= a, Pe = _ <= g && _ >= i, xe = me && Pe, Ce = Math.min(D, p >= a ? d - p : S - a), Be = Math.min(P, C >= i ? g - C : _ - i);
      return {
        originInBounds: Y,
        sizeInBounds: xe,
        visibleW: Ce,
        visibleH: Be
      };
    }, aC = (t, s) => {
      const {
        x: a,
        y: i,
        right: d,
        bottom: g
      } = s, { x: p, y: C, width: S, height: _ } = t, D = Math.max(a, d - S), P = Math.max(i, g - _), L = Bl(p, a, D), V = Bl(C, i, P), Y = Math.min(L + S, d) - L, me = Math.min(V + _, g) - V;
      return Rr(L, V, Y, me);
    }, Dg = (t, s, a) => {
      const i = U(s.bottom - a.y), d = U(a.bottom - s.y), g = Uy(t, d, d, i), p = U(s.right - a.x), C = U(a.right - s.x);
      return {
        maxWidth: T0(t, C, C, p),
        maxHeight: g
      };
    }, Yk = (t, s, a, i) => {
      const d = t.bubble, g = d.offset, p = k0(i, t.restriction, g), C = t.x + g.left, S = t.y + g.top, _ = Rr(C, S, s, a), { originInBounds: D, sizeInBounds: P, visibleW: L, visibleH: V } = dS(_, p), Y = D && P, me = Y ? _ : aC(_, p), Pe = me.width > 0 && me.height > 0, { maxWidth: xe, maxHeight: Ce } = Dg(t.direction, me, i), Be = {
        rect: me,
        maxHeight: Ce,
        maxWidth: xe,
        direction: t.direction,
        placement: t.placement,
        classes: {
          on: d.classesOn,
          off: d.classesOff
        },
        layout: t.label,
        testY: S
      };
      return Y || t.alwaysFit ? P1.fit(Be) : P1.nofit(Be, L, V, Pe);
    }, Xk = (t, s, a, i, d, g) => {
      const p = i.width, C = i.height, S = (D, P, L, V, Y) => {
        const me = D(a, i, d, t, g), Pe = Yk(me, p, C, g);
        return Pe.fold(U(Pe), (xe, Ce, Be, St) => (Y === St ? Be > V || Ce > L : !Y && St) ? Pe : P1.nofit(P, L, V, Y));
      };
      return lt(s, (D, P) => {
        const L = gn(S, P);
        return D.fold(U(D), L);
      }, P1.nofit({
        rect: a,
        maxHeight: i.height,
        maxWidth: i.width,
        direction: _1(),
        placement: "southeast",
        classes: {
          on: [],
          off: []
        },
        layout: "none",
        testY: a.y
      }, -1, -1, !1)).fold(Tt, Tt);
    }, cC = (t) => {
      const s = w(A.none()), a = () => s.get().each(t);
      return {
        clear: () => {
          a(), s.set(A.none());
        },
        isSet: () => s.get().isSome(),
        get: () => s.get(),
        set: (C) => {
          a(), s.set(A.some(C));
        }
      };
    }, Jk = () => cC((t) => t.destroy()), Om = () => cC((t) => t.unbind()), Go = () => {
      const t = cC(J);
      return {
        ...t,
        on: (a) => t.get().each(a)
      };
    }, iC = Oe, hi = (t, s, a) => Tl(t, s, iC, a), R0 = (t, s, a) => ch(t, s, iC, a), lC = xu, uC = [
      "top",
      "bottom",
      "right",
      "left"
    ], N0 = "data-alloy-transition-timer", mS = (t, s) => Ic(t, s.classes), Qk = (t, s, a) => a.exists((i) => {
      const d = t.mode;
      return d === "all" ? !0 : i[d] !== s[d];
    }), e_ = (t, s) => {
      const a = (i) => parseFloat(i).toFixed(3);
      return Ss(s, (i, d) => {
        const g = t[d].map(a), p = i.map(a);
        return !Xr(g, p);
      }).isSome();
    }, Wh = (t) => {
      const s = (g) => {
        const C = Us(t, g).split(/\s*,\s*/);
        return fo(C, de);
      }, a = (g) => {
        if (Ee(g) && /^[\d.]+/.test(g)) {
          const p = parseFloat(g);
          return Sa(g, "ms") ? p : p * 1e3;
        } else
          return 0;
      }, i = s("transition-delay"), d = s("transition-duration");
      return lt(d, (g, p, C) => {
        const S = a(i[C]) + a(p);
        return Math.max(g, S);
      }, 0);
    }, fS = (t, s) => {
      const a = Om(), i = Om();
      let d;
      const g = (_) => {
        var D;
        const P = (D = _.raw.pseudoElement) !== null && D !== void 0 ? D : "";
        return Rs(_.target, t) && ie(P) && io(uC, _.raw.propertyName);
      }, p = (_) => {
        if (Qt(_) || g(_)) {
          a.clear(), i.clear();
          const D = _?.raw.type;
          (Qt(D) || D === pg()) && (clearTimeout(d), se(t, N0), Ml(t, s.classes));
        }
      }, C = hi(t, Cy(), (_) => {
        g(_) && (C.unbind(), a.set(hi(t, pg(), p)), i.set(hi(t, vk(), p)));
      }), S = Wh(t);
      requestAnimationFrame(() => {
        d = setTimeout(p, S + 17), sn(t, N0, d);
      });
    }, X4 = (t, s) => {
      jr(t, s.classes), B(t, N0).each((a) => {
        clearTimeout(parseInt(a, 10)), se(t, N0);
      }), fS(t, s);
    }, Ef = (t, s, a, i, d, g) => {
      const p = Qk(i, d, g);
      if (p || mS(t, i)) {
        _n(t, "position", a.position);
        const C = oC(s, t), S = nC(s, {
          ...d,
          rect: C
        }), _ = Ct(uC, (D) => S[D]);
        e_(a, _) && (_t(t, _), p && X4(t, i), Ga(t));
      } else
        Ml(t, i.classes);
    }, t_ = (t) => ({
      width: oe(t),
      height: yu(t)
    }), Zh = (t, s, a, i) => {
      Jo(s, "max-height"), Jo(s, "max-width");
      const d = t_(s);
      return Xk(s, i.preference, t, d, a, i.bounds);
    }, n_ = (t, s) => {
      const a = s.classes;
      Ml(t, a.off), jr(t, a.on);
    }, dC = (t, s, a) => {
      const i = a.maxHeightFunction;
      i(t, s.maxHeight);
    }, gS = (t, s, a) => {
      const i = a.maxWidthFunction;
      i(t, s.maxWidth);
    }, Rg = (t, s, a) => {
      const i = nC(a.origin, s);
      a.transition.each((d) => {
        Ef(t, a.origin, i, d, s, a.lastPlacement);
      }), cS(t, i);
    }, o_ = (t, s) => {
      Kk(t, s.placement);
    }, hS = (t, s) => {
      um(t, Math.floor(s));
    }, pS = U((t, s) => {
      hS(t, s), gr(t, {
        "overflow-x": "hidden",
        "overflow-y": "auto"
      });
    }), jh = U((t, s) => {
      hS(t, s);
    }), bS = (t, s, a) => t[s] === void 0 ? a : t[s], mC = (t, s, a, i, d, g, p, C) => {
      const S = bS(p, "maxHeightFunction", pS()), _ = bS(p, "maxWidthFunction", J), D = t.anchorBox, P = t.origin, L = {
        bounds: Zk(P, g),
        origin: P,
        preference: i,
        maxHeightFunction: S,
        maxWidthFunction: _,
        lastPlacement: d,
        transition: C
      };
      return s_(D, s, a, L);
    }, s_ = (t, s, a, i) => {
      const d = Zh(t, s, a, i);
      return Rg(s, d, i), o_(s, d), n_(s, d), dC(s, d, i), gS(s, d, i), {
        layout: d.layout,
        placement: d.placement
      };
    }, vS = [
      "valignCentre",
      "alignLeft",
      "alignRight",
      "alignCentre",
      "top",
      "bottom",
      "left",
      "right",
      "inset"
    ], Wd = (t, s, a, i = 1) => {
      const d = t * i, g = s * i, p = (S) => Dt(a, S).getOr([]), C = (S, _, D) => {
        const P = Yt(vS, D);
        return {
          offset: Es(S, _),
          classesOn: ae(D, p),
          classesOff: ae(P, p)
        };
      };
      return {
        southeast: () => C(-t, s, [
          "top",
          "alignLeft"
        ]),
        southwest: () => C(t, s, [
          "top",
          "alignRight"
        ]),
        south: () => C(-t / 2, s, [
          "top",
          "alignCentre"
        ]),
        northeast: () => C(-t, -s, [
          "bottom",
          "alignLeft"
        ]),
        northwest: () => C(t, -s, [
          "bottom",
          "alignRight"
        ]),
        north: () => C(-t / 2, -s, [
          "bottom",
          "alignCentre"
        ]),
        east: () => C(t, -s / 2, [
          "valignCentre",
          "left"
        ]),
        west: () => C(-t, -s / 2, [
          "valignCentre",
          "right"
        ]),
        insetNortheast: () => C(d, g, [
          "top",
          "alignLeft",
          "inset"
        ]),
        insetNorthwest: () => C(-d, g, [
          "top",
          "alignRight",
          "inset"
        ]),
        insetNorth: () => C(-d / 2, g, [
          "top",
          "alignCentre",
          "inset"
        ]),
        insetSoutheast: () => C(d, -g, [
          "bottom",
          "alignLeft",
          "inset"
        ]),
        insetSouthwest: () => C(-d, -g, [
          "bottom",
          "alignRight",
          "inset"
        ]),
        insetSouth: () => C(-d / 2, -g, [
          "bottom",
          "alignCentre",
          "inset"
        ]),
        insetEast: () => C(-d, -g / 2, [
          "valignCentre",
          "right",
          "inset"
        ]),
        insetWest: () => C(d, -g / 2, [
          "valignCentre",
          "left",
          "inset"
        ])
      };
    }, B1 = () => Wd(0, 0, {}), $1 = Tt, M0 = (t, s) => (a) => F1(a) === "rtl" ? s : t, F1 = (t) => Us(t, "direction") === "rtl" ? "rtl" : "ltr";
    var iu;
    (function(t) {
      t.TopToBottom = "toptobottom", t.BottomToTop = "bottomtotop";
    })(iu || (iu = {}));
    const qh = "data-alloy-vertical-dir", I1 = (t) => Iy(t, (s) => lo(s) && rr(s, "data-alloy-vertical-dir") === iu.BottomToTop), kf = () => ui("layouts", [
      gt("onLtr"),
      gt("onRtl"),
      $s("onBottomLtr"),
      $s("onBottomRtl")
    ]), P0 = (t, s, a, i, d, g, p) => {
      const C = p.map(I1).getOr(!1), S = s.layouts.map((V) => V.onLtr(t)), _ = s.layouts.map((V) => V.onRtl(t)), D = C ? s.layouts.bind((V) => V.onBottomLtr.map((Y) => Y(t))).or(S).getOr(d) : S.getOr(a), P = C ? s.layouts.bind((V) => V.onBottomRtl.map((Y) => Y(t))).or(_).getOr(g) : _.getOr(i);
      return M0(D, P)(t);
    }, r_ = (t, s, a) => {
      const i = s.hotspot, d = oC(a, i.element), g = P0(t.element, s, A0(), Jy(), Xy(), tS(), A.some(s.hotspot.element));
      return A.some($1({
        anchorBox: d,
        bubble: s.bubble.getOr(B1()),
        overrides: s.overrides,
        layouts: g
      }));
    };
    var a_ = [
      gt("hotspot"),
      $s("bubble"),
      Ne("overrides", {}),
      kf(),
      Qs("placement", r_)
    ];
    const yS = (t, s, a) => {
      const i = sC(a, s.x, s.y), d = Rr(i.left, i.top, s.width, s.height), g = P0(t.element, s, Yy(), R1(), Yy(), R1(), A.none());
      return A.some($1({
        anchorBox: d,
        bubble: s.bubble,
        overrides: s.overrides,
        layouts: g
      }));
    };
    var c_ = [
      gt("x"),
      gt("y"),
      Ne("height", 0),
      Ne("width", 0),
      Ne("bubble", B1()),
      Ne("overrides", {}),
      kf(),
      Qs("placement", yS)
    ];
    const fC = H.generate([
      { screen: ["point"] },
      {
        absolute: [
          "point",
          "scrollLeft",
          "scrollTop"
        ]
      }
    ]), i_ = (t) => t.fold(Tt, (s, a, i) => s.translate(-a, -i)), l_ = (t) => t.fold(Tt, Tt), CS = (t) => lt(t, (s, a) => s.translate(a.left, a.top), Es(0, 0)), u_ = (t) => {
      const s = $e(t, i_);
      return CS(s);
    }, wS = (t) => {
      const s = $e(t, l_);
      return CS(s);
    }, d_ = fC.screen, B0 = fC.absolute, m_ = (t, s, a) => {
      const i = Uc(a.root).dom, d = (g) => {
        const p = Ia(g), C = Ia(t.element);
        return Rs(p, C);
      };
      return A.from(i.frameElement).map(ve.fromDom).filter(d).map(Cc);
    }, SS = (t, s, a) => {
      const i = Ia(t.element), d = Mc(i), g = m_(t, s, a).getOr(d);
      return B0(g, d.left, d.top);
    }, Gh = (t, s, a, i) => {
      const d = d_(Es(t, s));
      return A.some(sg(d, a, i));
    }, gC = (t, s, a, i, d) => t.map((g) => {
      const p = [
        s,
        g.point
      ], C = jk(i, () => wS(p), () => wS(p), () => u_(p)), S = td(C.left, C.top, g.width, g.height), _ = a.showAbove ? Xy() : A0(), D = a.showAbove ? tS() : Jy(), P = P0(d, a, _, D, _, D, A.none());
      return $1({
        anchorBox: S,
        bubble: a.bubble.getOr(B1()),
        overrides: a.overrides,
        layouts: P
      });
    }), hC = (t, s, a) => {
      const i = SS(t, a, s);
      return s.node.filter(qo).bind((d) => {
        const g = d.dom.getBoundingClientRect(), p = Gh(g.left, g.top, g.width, g.height), C = s.node.getOr(t.element);
        return gC(p, i, s, a, C);
      });
    };
    var pC = [
      gt("node"),
      gt("root"),
      $s("bubble"),
      kf(),
      Ne("overrides", {}),
      Ne("showAbove", !1),
      Qs("placement", hC)
    ];
    const xS = "\uFEFF", bC = " ", $0 = { create: (t, s, a, i) => ({
      start: t,
      soffset: s,
      finish: a,
      foffset: i
    }) }, F0 = H.generate([
      { before: ["element"] },
      {
        on: [
          "element",
          "offset"
        ]
      },
      { after: ["element"] }
    ]), g_ = (t, s, a, i) => t.fold(s, a, i), vC = (t) => t.fold(Tt, Tt, Tt), TS = F0.before, h_ = F0.on, yC = F0.after, p_ = {
      before: TS,
      on: h_,
      after: yC,
      cata: g_,
      getStart: vC
    }, Kh = H.generate([
      { domRange: ["rng"] },
      {
        relative: [
          "startSitu",
          "finishSitu"
        ]
      },
      {
        exact: [
          "start",
          "soffset",
          "finish",
          "foffset"
        ]
      }
    ]), b_ = (t) => Kh.exact(t.start, t.soffset, t.finish, t.foffset), CC = (t) => t.match({
      domRange: (s) => ve.fromDom(s.startContainer),
      relative: (s, a) => p_.getStart(s),
      exact: (s, a, i, d) => s
    }), v_ = Kh.domRange, y_ = Kh.relative, C_ = Kh.exact, ES = (t) => {
      const s = CC(t);
      return Uc(s);
    }, w_ = $0.create, xc = {
      domRange: v_,
      relative: y_,
      exact: C_,
      exactFromRange: b_,
      getWin: ES,
      range: w_
    }, J4 = (t, s) => {
      s.fold((a) => {
        t.setStartBefore(a.dom);
      }, (a, i) => {
        t.setStart(a.dom, i);
      }, (a) => {
        t.setStartAfter(a.dom);
      });
    }, Yh = (t, s) => {
      s.fold((a) => {
        t.setEndBefore(a.dom);
      }, (a, i) => {
        t.setEnd(a.dom, i);
      }, (a) => {
        t.setEndAfter(a.dom);
      });
    }, I0 = (t, s, a) => {
      const i = t.document.createRange();
      return J4(i, s), Yh(i, a), i;
    }, kS = (t, s, a, i, d) => {
      const g = t.document.createRange();
      return g.setStart(s.dom, a), g.setEnd(i.dom, d), g;
    }, wC = (t) => ({
      left: t.left,
      top: t.top,
      right: t.right,
      bottom: t.bottom,
      width: t.width,
      height: t.height
    }), _S = (t) => {
      const s = t.getClientRects(), a = s.length > 0 ? s[0] : t.getBoundingClientRect();
      return a.width > 0 || a.height > 0 ? A.some(a).map(wC) : A.none();
    }, AS = (t) => {
      const s = t.getBoundingClientRect();
      return s.width > 0 || s.height > 0 ? A.some(s).map(wC) : A.none();
    }, Ng = H.generate([
      {
        ltr: [
          "start",
          "soffset",
          "finish",
          "foffset"
        ]
      },
      {
        rtl: [
          "start",
          "soffset",
          "finish",
          "foffset"
        ]
      }
    ]), L1 = (t, s, a) => s(ve.fromDom(a.startContainer), a.startOffset, ve.fromDom(a.endContainer), a.endOffset), S_ = (t, s) => s.match({
      domRange: (a) => ({
        ltr: U(a),
        rtl: A.none
      }),
      relative: (a, i) => ({
        ltr: je(() => I0(t, a, i)),
        rtl: je(() => A.some(I0(t, i, a)))
      }),
      exact: (a, i, d, g) => ({
        ltr: je(() => kS(t, a, i, d, g)),
        rtl: je(() => A.some(kS(t, d, g, a, i)))
      })
    }), x_ = (t, s) => {
      const a = s.ltr();
      return a.collapsed ? s.rtl().filter((d) => d.collapsed === !1).map((d) => Ng.rtl(ve.fromDom(d.endContainer), d.endOffset, ve.fromDom(d.startContainer), d.startOffset)).getOrThunk(() => L1(t, Ng.ltr, a)) : L1(t, Ng.ltr, a);
    }, H1 = (t, s) => {
      const a = S_(t, s);
      return x_(t, a);
    }, SC = (t, s) => H1(t, s).match({
      ltr: (i, d, g, p) => {
        const C = t.document.createRange();
        return C.setStart(i.dom, d), C.setEnd(g.dom, p), C;
      },
      rtl: (i, d, g, p) => {
        const C = t.document.createRange();
        return C.setStart(g.dom, p), C.setEnd(i.dom, d), C;
      }
    });
    Ng.ltr, Ng.rtl;
    const OS = (t, s, a) => fo(vu(t, a), s), nc = (t, s) => Fa(s, t), DS = (t, s, a, i) => {
      const g = Ia(t).dom.createRange();
      return g.setStart(t.dom, s), g.setEnd(a.dom, i), g;
    }, xC = (t, s, a, i) => {
      const d = DS(t, s, a, i), g = Rs(t, a) && s === i;
      return d.collapsed && !g;
    }, Q4 = (t) => A.from(t.getSelection()), Xh = (t) => {
      if (t.rangeCount > 0) {
        const s = t.getRangeAt(0), a = t.getRangeAt(t.rangeCount - 1);
        return A.some($0.create(ve.fromDom(s.startContainer), s.startOffset, ve.fromDom(a.endContainer), a.endOffset));
      } else
        return A.none();
    }, T_ = (t) => {
      if (t.anchorNode === null || t.focusNode === null)
        return Xh(t);
      {
        const s = ve.fromDom(t.anchorNode), a = ve.fromDom(t.focusNode);
        return xC(s, t.anchorOffset, a, t.focusOffset) ? A.some($0.create(s, t.anchorOffset, a, t.focusOffset)) : Xh(t);
      }
    }, RS = (t) => Q4(t).filter((s) => s.rangeCount > 0).bind(T_), TC = (t, s) => {
      const a = SC(t, s);
      return _S(a);
    }, z1 = (t, s) => {
      const a = SC(t, s);
      return AS(a);
    }, Jh = ((t, s) => {
      const a = (g) => {
        if (!t(g))
          throw new Error("Can only get " + s + " value of a " + s + " node");
        return i(g).getOr("");
      }, i = (g) => t(g) ? A.from(g.dom.nodeValue) : A.none();
      return {
        get: a,
        getOption: i,
        set: (g, p) => {
          if (!t(g))
            throw new Error("Can only set raw " + s + " value of a " + s + " node");
          g.dom.nodeValue = p;
        }
      };
    })(Fo, "text"), E_ = (t) => Jh.get(t), _f = (t, s) => ({
      element: t,
      offset: s
    }), NS = (t, s) => {
      const a = ja(t);
      if (a.length === 0)
        return _f(t, s);
      if (s < a.length)
        return _f(a[s], 0);
      {
        const i = a[a.length - 1], d = Fo(i) ? E_(i).length : ja(i).length;
        return _f(i, d);
      }
    }, Af = (t, s) => Fo(t) ? _f(t, s) : NS(t, s), Of = (t) => t.foffset !== void 0, EC = (t, s) => s.getSelection.getOrThunk(() => () => RS(t))().map((i) => {
      if (Of(i)) {
        const d = Af(i.start, i.soffset), g = Af(i.finish, i.foffset);
        return xc.range(d.element, d.offset, g.element, g.offset);
      } else
        return i;
    }), MS = (t, s, a) => {
      const i = Uc(s.root).dom, d = SS(t, a, s), g = EC(i, s).bind((S) => {
        if (Of(S))
          return z1(i, xc.exactFromRange(S)).orThunk(() => {
            const D = ve.fromText(xS);
            Li(S.start, D);
            const P = TC(i, xc.exact(D, 0, D, 1));
            return rl(D), P;
          }).bind((D) => Gh(D.left, D.top, D.width, D.height));
        {
          const _ = et(S, (P) => P.dom.getBoundingClientRect()), D = {
            left: Math.min(_.firstCell.left, _.lastCell.left),
            right: Math.max(_.firstCell.right, _.lastCell.right),
            top: Math.min(_.firstCell.top, _.lastCell.top),
            bottom: Math.max(_.firstCell.bottom, _.lastCell.bottom)
          };
          return Gh(D.left, D.top, D.right - D.left, D.bottom - D.top);
        }
      }), C = EC(i, s).bind((S) => Of(S) ? lo(S.start) ? A.some(S.start) : Oc(S.start) : A.some(S.firstCell)).getOr(t.element);
      return gC(g, d, s, a, C);
    };
    var eR = [
      $s("getSelection"),
      gt("root"),
      $s("bubble"),
      kf(),
      Ne("overrides", {}),
      Ne("showAbove", !1),
      Qs("placement", MS)
    ];
    const kC = "link-layout", Df = (t) => t.x + t.width, Zd = (t, s) => t.x - s.width, V1 = (t, s) => t.y - s.height + t.height, Qh = (t) => t.y, _C = (t, s, a) => Ja(Df(t), Qh(t), a.southeast(), _1(), "southeast", Ir(t, {
      left: 0,
      top: 2
    }), kC), Dm = (t, s, a) => Ja(Zd(t, s), Qh(t), a.southwest(), Wy(), "southwest", Ir(t, {
      right: 1,
      top: 2
    }), kC), md = (t, s, a) => Ja(Df(t), V1(t, s), a.northeast(), E0(), "northeast", Ir(t, {
      left: 0,
      bottom: 3
    }), kC), U1 = (t, s, a) => Ja(Zd(t, s), V1(t, s), a.northwest(), Vd(), "northwest", Ir(t, {
      right: 1,
      bottom: 3
    }), kC), H0 = () => [
      _C,
      Dm,
      md,
      U1
    ], W1 = () => [
      Dm,
      _C,
      U1,
      md
    ], AC = (t, s, a) => {
      const i = oC(a, s.item.element), d = P0(t.element, s, H0(), W1(), H0(), W1(), A.none());
      return A.some($1({
        anchorBox: i,
        bubble: B1(),
        overrides: s.overrides,
        layouts: d
      }));
    };
    var ep = [
      gt("item"),
      kf(),
      Ne("overrides", {}),
      Qs("placement", AC)
    ], Z1 = es("type", {
      selection: eR,
      node: pC,
      hotspot: a_,
      submenu: ep,
      makeshift: c_
    });
    const OC = [
      zi("classes", Xa),
      Ai("mode", "all", [
        "all",
        "layout",
        "placement"
      ])
    ], PS = [
      Ne("useFixed", Te),
      $s("getBounds")
    ], Rf = [
      _i("anchor", Z1),
      ui("transition", OC)
    ], z0 = () => {
      const t = document.documentElement;
      return M1(0, 0, t.clientWidth, t.clientHeight);
    }, k_ = (t) => {
      const s = Cc(t.element), a = t.element.dom.getBoundingClientRect();
      return gi(s.left, s.top, a.width, a.height);
    }, BS = (t, s, a, i, d, g) => {
      const p = Gk(s.anchorBox, t);
      return mC(p, i.element, s.bubble, s.layouts, d, a, s.overrides, g);
    }, DC = (t, s, a, i, d) => {
      const g = A.none();
      ya(t, s, a, i, d, g);
    }, ya = (t, s, a, i, d, g) => {
      const p = Gc("placement.info", jn(Rf), d), C = p.anchor, S = i.element, _ = a.get(i.uid);
      Cn(() => {
        _n(S, "position", "fixed");
        const D = Xs(S, "visibility");
        _n(S, "visibility", "hidden");
        const P = s.useFixed() ? z0() : k_(t);
        C.placement(t, C, P).each((L) => {
          const V = g.orThunk(() => s.getBounds.map(ho)), Y = BS(P, L, V, i, _, p.transition);
          a.set(i.uid, Y);
        }), D.fold(() => {
          Jo(S, "visibility");
        }, (L) => {
          _n(S, "visibility", L);
        }), Xs(S, "left").isNone() && Xs(S, "top").isNone() && Xs(S, "right").isNone() && Xs(S, "bottom").isNone() && aa(Xs(S, "position"), "fixed") && Jo(S, "position");
      }, S);
    };
    var $S = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      position: DC,
      positionWithinBounds: ya,
      getMode: (t, s, a) => s.useFixed() ? "fixed" : "absolute",
      reset: (t, s, a, i) => {
        const d = i.element;
        ot([
          "position",
          "left",
          "right",
          "top",
          "bottom"
        ], (g) => Jo(d, g)), uS(d), a.clear(i.uid);
      }
    }), Nf = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      init: () => {
        let t = {};
        return il({
          readState: () => t,
          clear: (d) => {
            En(d) ? delete t[d] : t = {};
          },
          set: (d, g) => {
            t[d] = g;
          },
          get: (d) => Dt(t, d)
        });
      }
    });
    const Qc = tc({
      fields: PS,
      name: "positioning",
      active: rS,
      apis: $S,
      state: Nf
    }), tp = (t) => t.getSystem().isConnected(), j1 = (t) => {
      cs(t, pf());
      const s = t.components();
      ot(s, j1);
    }, np = (t) => {
      const s = t.components();
      ot(s, np), cs(t, Nl());
    }, RC = (t, s) => {
      t.getSystem().addToWorld(s), qo(t.element) && np(s);
    }, op = (t) => {
      j1(t), t.getSystem().removeFromWorld(t);
    }, Mg = (t, s) => {
      Sc(t.element, s.element);
    }, fd = (t) => {
      ot(t.components(), (s) => rl(s.element)), mm(t.element), t.syncComponents();
    }, __ = (t, s, a) => {
      const i = t.components();
      fd(t);
      const d = a(s), g = Yt(i, d);
      ot(g, (p) => {
        j1(p), t.getSystem().removeFromWorld(p);
      }), ot(d, (p) => {
        tp(p) ? Mg(t, p) : (t.getSystem().addToWorld(p), Mg(t, p), qo(t.element) && np(p));
      }), t.syncComponents();
    }, A_ = (t, s, a) => {
      const i = t.components(), d = ae(s, (C) => Eh(C).toArray());
      ot(i, (C) => {
        io(d, C) || op(C);
      });
      const g = a(s), p = Yt(i, g);
      ot(p, (C) => {
        tp(C) && op(C);
      }), ot(g, (C) => {
        tp(C) || RC(t, C);
      }), t.syncComponents();
    }, Mf = (t, s) => {
      sp(t, s, Sc);
    }, sp = (t, s, a) => {
      t.getSystem().addToWorld(s), a(t.element, s.element), qo(t.element) && np(s), t.syncComponents();
    }, U0 = (t) => {
      j1(t), rl(t.element), t.getSystem().removeFromWorld(t);
    }, jd = (t) => {
      const s = Ta(t.element).bind((a) => t.getSystem().getByDom(a).toOptional());
      U0(t), s.each((a) => {
        a.syncComponents();
      });
    }, NC = (t) => {
      const s = t.components();
      ot(s, U0), mm(t.element), t.syncComponents();
    }, Tc = (t, s) => {
      Lu(t, s, Sc);
    }, Nm = (t, s) => {
      Lu(t, s, El);
    }, Lu = (t, s, a) => {
      a(t, s.element);
      const i = ja(s.element);
      ot(i, (d) => {
        s.getByDom(d).each(np);
      });
    }, rp = (t) => {
      const s = ja(t.element);
      ot(s, (a) => {
        t.getByDom(a).each(j1);
      }), rl(t.element);
    }, pi = (t, s, a, i) => {
      a.get().each((p) => {
        NC(t);
      });
      const d = s.getAttachPoint(t);
      Mf(d, t);
      const g = t.getSystem().build(i);
      return Mf(t, g), a.set(g), g;
    }, ji = (t, s, a, i) => {
      const d = pi(t, s, a, i);
      return s.onOpen(t, d), d;
    }, Ri = (t, s, a, i) => a.get().map(() => pi(t, s, a, i)), Hu = (t, s, a, i, d) => {
      q1(t, s), ji(t, s, a, i), d(), G1(t, s);
    }, W0 = (t, s, a) => {
      a.get().each((i) => {
        NC(t), jd(t), s.onClose(t, i), a.clear();
      });
    }, Fl = (t, s, a) => a.isOpen(), Pg = (t, s, a, i) => Fl(t, s, a) && a.get().exists((d) => s.isPartOf(t, d, i)), MC = (t, s, a) => a.get(), O_ = (t, s, a, i) => {
      Xs(t.element, s).fold(() => {
        se(t.element, a);
      }, (d) => {
        sn(t.element, a, d);
      }), _n(t.element, s, i);
    }, FS = (t, s, a) => {
      B(t.element, a).fold(() => Jo(t.element, s), (i) => _n(t.element, s, i));
    }, q1 = (t, s, a) => {
      const i = s.getAttachPoint(t);
      _n(t.element, "position", Qc.getMode(i)), O_(t, "visibility", s.cloakVisibilityAttr, "hidden");
    }, IS = (t) => jo([
      "top",
      "left",
      "right",
      "bottom"
    ], (s) => Xs(t, s).isSome()), G1 = (t, s, a) => {
      IS(t.element) || Jo(t.element, "position"), FS(t, "visibility", s.cloakVisibilityAttr);
    };
    var Z0 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      cloak: q1,
      decloak: G1,
      open: ji,
      openWhileCloaked: Hu,
      close: W0,
      isOpen: Fl,
      isPartOf: Pg,
      getState: MC,
      setContent: Ri
    }), LS = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      events: (t, s) => vr([mt(f1(), (a, i) => {
        W0(a, t, s);
      })])
    }), R_ = [
      gs("onOpen"),
      gs("onClose"),
      gt("isPartOf"),
      gt("getAttachPoint"),
      Ne("cloakVisibilityAttr", "data-precloak-visibility")
    ], HS = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      init: () => {
        const t = Go(), s = U("not-implemented");
        return il({
          readState: s,
          isOpen: t.isSet,
          clear: t.clear,
          set: t.set,
          get: t.get
        });
      }
    });
    const is = tc({
      fields: R_,
      name: "sandboxing",
      active: LS,
      apis: Z0,
      state: HS
    }), gd = U("dismiss.popups"), Bg = U("reposition.popups"), PC = U("mouse.released"), zS = br([
      Ne("isExtraPart", Te),
      ui("fireEventInstead", [Ne("event", bf())])
    ]), K1 = (t) => {
      const s = Gc("Dismissal", zS, t);
      return {
        [gd()]: {
          schema: br([gt("target")]),
          onReceive: (a, i) => {
            is.isOpen(a) && (is.isPartOf(a, i.target) || s.isExtraPart(a, i.target) || s.fireEventInstead.fold(() => is.close(a), (g) => cs(a, g.event)));
          }
        }
      };
    }, N_ = br([
      ui("fireEventInstead", [Ne("event", Pw())]),
      ou("doReposition")
    ]), ap = (t) => {
      const s = Gc("Reposition", N_, t);
      return {
        [Bg()]: {
          onReceive: (a) => {
            is.isOpen(a) && s.fireEventInstead.fold(() => s.doReposition(a), (i) => cs(a, i.event));
          }
        }
      };
    }, j0 = (t, s, a) => {
      s.store.manager.onLoad(t, s, a);
    }, Il = (t, s, a) => {
      s.store.manager.onUnload(t, s, a);
    };
    var Pf = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      onLoad: j0,
      onUnload: Il,
      setValue: (t, s, a, i) => {
        s.store.manager.setValue(t, s, a, i);
      },
      getValue: (t, s, a) => s.store.manager.getValue(t, s, a),
      getState: (t, s, a) => a
    }), K0 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      events: (t, s) => {
        const a = t.resetOnDom ? [
          cr((i, d) => {
            j0(i, t, s);
          }),
          Fd((i, d) => {
            Il(i, t, s);
          })
        ] : [O0(t, s, j0)];
        return vr(a);
      }
    });
    const $g = () => {
      const t = w(null), s = () => ({
        mode: "memory",
        value: t.get()
      }), a = () => t.get() === null, i = () => {
        t.set(null);
      };
      return il({
        set: t.set,
        get: t.get,
        isNotSet: a,
        clear: i,
        readState: s
      });
    }, M_ = () => il({ readState: J }), VS = () => {
      const t = w({}), s = w({});
      return il({
        readState: () => ({
          mode: "dataset",
          dataByValue: t.get(),
          dataByText: s.get()
        }),
        lookup: (p) => Dt(t.get(), p).orThunk(() => Dt(s.get(), p)),
        update: (p) => {
          const C = t.get(), S = s.get(), _ = {}, D = {};
          ot(p, (P) => {
            _[P.value] = P, Dt(P, "meta").each((L) => {
              Dt(L, "text").each((V) => {
                D[V] = P;
              });
            });
          }), t.set({
            ...C,
            ..._
          }), s.set({
            ...S,
            ...D
          });
        },
        clear: () => {
          t.set({}), s.set({});
        }
      });
    };
    var ip = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      memory: $g,
      dataset: VS,
      manual: M_,
      init: (t) => t.store.manager.state(t)
    });
    const Mm = (t, s, a, i) => {
      const d = s.store;
      a.update([i]), d.setValue(t, i), s.onSetValue(t, i);
    }, B_ = (t, s, a) => {
      const i = s.store, d = i.getDataKey(t);
      return a.lookup(d).getOrThunk(() => i.getFallbackEntry(d));
    }, $_ = (t, s, a) => {
      s.store.initialValue.each((d) => {
        Mm(t, s, a, d);
      });
    }, US = (t, s, a) => {
      a.clear();
    };
    var BC = [
      $s("initialValue"),
      gt("getFallbackEntry"),
      gt("getDataKey"),
      gt("setValue"),
      Qs("manager", {
        setValue: Mm,
        getValue: B_,
        onLoad: $_,
        onUnload: US,
        state: VS
      })
    ];
    const $C = (t, s, a) => s.store.getValue(t), FC = (t, s, a, i) => {
      s.store.setValue(t, i), s.onSetValue(t, i);
    }, Y0 = (t, s, a) => {
      s.store.initialValue.each((i) => {
        s.store.setValue(t, i);
      });
    };
    var Bf = [
      gt("getValue"),
      Ne("setValue", J),
      $s("initialValue"),
      Qs("manager", {
        setValue: FC,
        getValue: $C,
        onLoad: Y0,
        onUnload: J,
        state: $u.init
      })
    ];
    const WS = (t, s, a, i) => {
      a.set(i), s.onSetValue(t, i);
    }, Y1 = (t, s, a) => a.get(), IC = (t, s, a) => {
      s.store.initialValue.each((i) => {
        a.isNotSet() && a.set(i);
      });
    }, F_ = (t, s, a) => {
      a.clear();
    };
    var X1 = [
      $s("initialValue"),
      Qs("manager", {
        setValue: WS,
        getValue: Y1,
        onLoad: IC,
        onUnload: F_,
        state: $g
      })
    ], I_ = [
      Pc("store", { mode: "memory" }, es("mode", {
        memory: X1,
        manual: Bf,
        dataset: BC
      })),
      gs("onSetValue"),
      Ne("resetOnDom", !1)
    ];
    const ln = tc({
      fields: I_,
      name: "representing",
      active: K0,
      apis: Pf,
      extra: {
        setValueFrom: (t, s) => {
          const a = ln.getValue(s);
          ln.setValue(t, a);
        }
      },
      state: ip
    }), za = (t, s) => Nu(t, {}, $e(s, (a) => bh(a.name(), "Cannot configure " + a.name() + " for " + t)).concat([oa("dump", Tt)])), Pm = (t) => t.dump, Oa = (t, s) => ({
      ...Ut(s),
      ...t.dump
    }), lu = {
      field: za,
      augment: Oa,
      get: Pm
    }, X0 = "placeholder", J1 = H.generate([
      {
        single: [
          "required",
          "valueThunk"
        ]
      },
      {
        multiple: [
          "required",
          "valueThunks"
        ]
      }
    ]), hd = (t) => Lo(t, "uiType"), J0 = (t, s, a, i) => t.exists((d) => d !== a.owner) ? J1.single(!0, U(a)) : Dt(i, a.name).fold(() => {
      throw new Error("Unknown placeholder component: " + a.name + `
Known: [` + Ao(i) + `]
Namespace: ` + t.getOr("none") + `
Spec: ` + JSON.stringify(a, null, 2));
    }, (d) => d.replace()), Q0 = (t, s, a, i) => hd(a) && a.uiType === X0 ? J0(t, s, a, i) : J1.single(!1, U(a)), lp = (t, s, a, i) => Q0(t, s, a, i).fold((g, p) => {
      const C = hd(a) ? p(s, a.config, a.validated) : p(s), S = Dt(C, "components").getOr([]), _ = ae(S, (D) => lp(t, s, D, i));
      return [{
        ...C,
        components: _
      }];
    }, (g, p) => {
      if (hd(a)) {
        const C = p(s, a.config, a.validated);
        return a.validated.preprocess.getOr(Tt)(C);
      } else
        return p(s);
    }), ZS = (t, s, a, i) => ae(a, (d) => lp(t, s, d, i)), Q1 = (t, s) => {
      let a = !1;
      const i = () => a, d = () => {
        if (a)
          throw new Error("Trying to use the same placeholder more than once: " + t);
        return a = !0, s;
      }, g = () => s.fold((p, C) => p, (p, C) => p);
      return {
        name: U(t),
        required: g,
        used: i,
        replace: d
      };
    }, LC = (t, s, a, i) => {
      const d = et(i, (p, C) => Q1(C, p)), g = ZS(t, s, a, d);
      return Ie(d, (p) => {
        if (p.used() === !1 && p.required())
          throw new Error("Placeholder: " + p.name() + ` was not found in components list
Namespace: ` + t.getOr("none") + `
Components: ` + JSON.stringify(s.components, null, 2));
      }), g;
    }, HC = J1.single, L_ = J1.multiple, pd = U(X0), ev = H.generate([
      { required: ["data"] },
      { external: ["data"] },
      { optional: ["data"] },
      { group: ["data"] }
    ]), up = Ne("factory", { sketch: Tt }), Hc = Ne("schema", []), Ba = gt("name"), tv = dc("pname", "pname", qc((t) => "<alloy." + An(t.name) + ">"), ua()), eb = oa("schema", () => [$s("preprocess")]), nv = Ne("defaults", U({})), tb = Ne("overrides", U({})), nb = jn([
      up,
      Hc,
      Ba,
      tv,
      nv,
      tb
    ]), dp = jn([
      up,
      Hc,
      Ba,
      nv,
      tb
    ]), jS = jn([
      up,
      Hc,
      Ba,
      tv,
      nv,
      tb
    ]), ob = jn([
      up,
      eb,
      Ba,
      gt("unit"),
      tv,
      nv,
      tb
    ]), qS = (t) => t.fold(A.some, A.none, A.some, A.some), GS = (t) => {
      const s = (a) => a.name;
      return t.fold(s, s, s, s);
    }, KS = (t) => t.fold(Tt, Tt, Tt, Tt), uu = (t, s) => (a) => {
      const i = Gc("Converting part type", s, a);
      return t(i);
    }, ei = uu(ev.required, nb), zu = uu(ev.external, dp), qi = uu(ev.optional, jS), sb = uu(ev.group, ob), ov = U("entirety");
    var YS = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      required: ei,
      external: zu,
      optional: qi,
      group: sb,
      asNamedPart: qS,
      name: GS,
      asCommon: KS,
      original: ov
    });
    const rb = (t, s, a, i) => Ms(s.defaults(t, a, i), a, { uid: t.partUids[s.name] }, s.overrides(t, a, i)), H_ = (t, s, a) => {
      const i = {}, d = {};
      return ot(a, (g) => {
        g.fold((p) => {
          i[p.pname] = HC(!0, (C, S, _) => p.factory.sketch(rb(C, p, S, _)));
        }, (p) => {
          const C = s.parts[p.name];
          d[p.name] = U(p.factory.sketch(rb(s, p, C[ov()]), C));
        }, (p) => {
          i[p.pname] = HC(!1, (C, S, _) => p.factory.sketch(rb(C, p, S, _)));
        }, (p) => {
          i[p.pname] = L_(!0, (C, S, _) => {
            const D = C[p.name];
            return $e(D, (P) => p.factory.sketch(Ms(p.defaults(C, P, _), P, p.overrides(C, P))));
          });
        });
      }), {
        internals: U(i),
        externals: U(d)
      };
    }, Bm = (t, s) => {
      const a = {};
      return ot(s, (i) => {
        qS(i).each((d) => {
          const g = ab(t, d.pname);
          a[d.name] = (p) => {
            const C = Gc("Part: " + d.name + " in " + t, jn(d.schema), p);
            return {
              ...g,
              config: p,
              validated: C
            };
          };
        });
      }), a;
    }, ab = (t, s) => ({
      uiType: pd(),
      owner: t,
      name: s
    }), zC = (t, s, a) => ({
      uiType: pd(),
      owner: t,
      name: s,
      config: a,
      validated: {}
    }), XS = (t) => ae(t, (s) => s.fold(A.none, A.some, A.none, A.none).map((a) => su(a.name, a.schema.concat([k1(ov())]))).toArray()), JS = (t) => $e(t, GS), VC = (t, s, a) => H_(t, s, a), sv = (t, s, a) => LC(A.some(t), s, s.components, a), ir = (t, s, a) => {
      const i = s.partUids[a];
      return t.getSystem().getByUid(i).toOptional();
    }, $m = (t, s, a) => ir(t, s, a).getOrDie("Could not find part: " + a), QS = (t, s, a) => {
      const i = {}, d = s.partUids, g = t.getSystem();
      return ot(a, (p) => {
        i[p] = U(g.getByUid(d[p]));
      }), i;
    }, UC = (t, s) => {
      const a = t.getSystem();
      return et(s.partUids, (i, d) => U(a.getByUid(i)));
    }, WC = (t) => Ao(t.partUids), Fg = (t, s, a) => {
      const i = {}, d = s.partUids, g = t.getSystem();
      return ot(a, (p) => {
        i[p] = U(g.getByUid(d[p]).getOrDie());
      }), i;
    }, ZC = (t, s) => {
      const a = JS(s);
      return Jn($e(a, (i) => ({
        key: i,
        value: t + "-" + i
      })));
    }, jC = (t) => dc("partUids", "partUids", Wo((s) => ZC(s.uid, t)), ua());
    var z_ = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      generate: Bm,
      generateOne: zC,
      schemas: XS,
      names: JS,
      substitutes: VC,
      components: sv,
      defaultUids: ZC,
      defaultUidsSchema: jC,
      getAllParts: UC,
      getAllPartNames: WC,
      getPart: ir,
      getPartOrDie: $m,
      getParts: QS,
      getPartsOrDie: Fg
    });
    const mp = (t, s) => (t.length > 0 ? [su("parts", t)] : []).concat([
      gt("uid"),
      Ne("dom", {}),
      Ne("components", []),
      k1("originalSpec"),
      Ne("debug.sketcher", {})
    ]).concat(s), fp = (t, s, a, i, d) => {
      const g = mp(i, d);
      return Gc(t + " [SpecSchema]", br(g.concat(s)), a);
    }, qC = (t, s, a, i) => {
      const d = $f(i), g = fp(t, s, d, [], []);
      return a(g, d);
    }, GC = (t, s, a, i, d) => {
      const g = $f(d), p = XS(a), C = jC(a), S = fp(t, s, g, p, [C]), _ = VC(t, S, a), D = sv(t, S, _.internals());
      return i(S, D, g, _.externals());
    }, Vu = (t) => Lo(t, "uid"), $f = (t) => Vu(t) ? t : {
      ...t,
      uid: xh("uid")
    }, V_ = (t) => t.uid !== void 0, cb = br([
      gt("name"),
      gt("factory"),
      gt("configFields"),
      Ne("apis", {}),
      Ne("extraApis", {})
    ]), U_ = br([
      gt("name"),
      gt("factory"),
      gt("configFields"),
      gt("partFields"),
      Ne("apis", {}),
      Ne("extraApis", {})
    ]), gl = (t) => {
      const s = Gc("Sketcher for " + t.name, cb, t), a = (g) => qC(s.name, s.configFields, s.factory, g), i = et(s.apis, xg), d = et(s.extraApis, (g, p) => i0(g, p));
      return {
        name: s.name,
        configFields: s.configFields,
        sketch: a,
        ...i,
        ...d
      };
    }, ti = (t) => {
      const s = Gc("Sketcher for " + t.name, U_, t), a = (p) => GC(s.name, s.configFields, s.partFields, s.factory, p), i = Bm(s.name, s.partFields), d = et(s.apis, xg), g = et(s.extraApis, (p, C) => i0(p, C));
      return {
        name: s.name,
        partFields: s.partFields,
        configFields: s.configFields,
        sketch: a,
        parts: i,
        ...d,
        ...g
      };
    }, Ig = (t) => zr("input")(t) && rr(t, "type") !== "radio" || zr("textarea")(t);
    var ex = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      getCurrent: (t, s, a) => s.find(t)
    });
    const W_ = [gt("find")], ts = tc({
      fields: W_,
      name: "composing",
      apis: ex
    }), KC = [
      "input",
      "button",
      "textarea",
      "select"
    ], tx = (t, s, a) => {
      (s.disabled() ? ox : ib)(t, s);
    }, YC = (t, s) => s.useNative === !0 && io(KC, Ds(t.element)), Z_ = (t) => K(t.element, "disabled"), j_ = (t) => {
      sn(t.element, "disabled", "disabled");
    }, nx = (t) => {
      se(t.element, "disabled");
    }, q_ = (t) => rr(t.element, "aria-disabled") === "true", Tn = (t) => {
      sn(t.element, "aria-disabled", "true");
    }, Ff = (t) => {
      sn(t.element, "aria-disabled", "false");
    }, ox = (t, s, a) => {
      s.disableClass.each((d) => {
        ba(t.element, d);
      }), (YC(t, s) ? j_ : Tn)(t), s.onDisabled(t);
    }, ib = (t, s, a) => {
      s.disableClass.each((d) => {
        Wr(t.element, d);
      }), (YC(t, s) ? nx : Ff)(t), s.onEnabled(t);
    }, lb = (t, s) => YC(t, s) ? Z_(t) : q_(t);
    var sR = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      enable: ib,
      disable: ox,
      isDisabled: lb,
      onLoad: tx,
      set: (t, s, a, i) => {
        (i ? ox : ib)(t, s);
      }
    }), K_ = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      exhibit: (t, s) => ll({ classes: s.disabled() ? s.disableClass.toArray() : [] }),
      events: (t, s) => vr([
        xy(cl(), (a, i) => lb(a, t)),
        O0(t, s, tx)
      ])
    }), sx = [
      _a("disabled", Te),
      Ne("useNative", !0),
      $s("disableClass"),
      gs("onDisabled"),
      gs("onEnabled")
    ];
    const mo = tc({
      fields: sx,
      name: "disabling",
      active: K_,
      apis: sR
    }), Fm = (t, s, a, i) => {
      const d = nc(t.element, "." + s.highlightClass);
      ot(d, (g) => {
        jo(i, (C) => Rs(C.element, g)) || (Wr(g, s.highlightClass), t.getSystem().getByDom(g).each((C) => {
          s.onDehighlight(t, C), cs(C, b1());
        }));
      });
    }, rx = (t, s, a) => Fm(t, s, a, []), Y_ = (t, s, a, i) => {
      rv(t, s, a, i) && (Wr(i.element, s.highlightClass), s.onDehighlight(t, i), cs(i, b1()));
    }, ub = (t, s, a, i) => {
      Fm(t, s, a, [i]), rv(t, s, a, i) || (ba(i.element, s.highlightClass), s.onHighlight(t, i), cs(i, p1()));
    }, X_ = (t, s, a) => {
      gp(t, s).each((i) => {
        ub(t, s, a, i);
      });
    }, ax = (t, s, a) => {
      JC(t, s).each((i) => {
        ub(t, s, a, i);
      });
    }, XC = (t, s, a, i) => {
      Q_(t, s, a, i).fold((d) => {
        throw d;
      }, (d) => {
        ub(t, s, a, d);
      });
    }, cx = (t, s, a, i) => {
      const d = av(t, s);
      ee(d, i).each((p) => {
        ub(t, s, a, p);
      });
    }, rv = (t, s, a, i) => Ha(i.element, s.highlightClass), J_ = (t, s, a) => va(t.element, "." + s.highlightClass).bind((i) => t.getSystem().getByDom(i).toOptional()), Q_ = (t, s, a, i) => {
      const d = nc(t.element, "." + s.itemClass);
      return A.from(d[i]).fold(() => Mo.error(new Error("No element found with index " + i)), t.getSystem().getByDom);
    }, gp = (t, s, a) => va(t.element, "." + s.itemClass).bind((i) => t.getSystem().getByDom(i).toOptional()), JC = (t, s, a) => {
      const i = nc(t.element, "." + s.itemClass);
      return (i.length > 0 ? A.some(i[i.length - 1]) : A.none()).bind((g) => t.getSystem().getByDom(g).toOptional());
    }, ix = (t, s, a, i) => {
      const d = nc(t.element, "." + s.itemClass);
      return pe(d, (p) => Ha(p, s.highlightClass)).bind((p) => {
        const C = Hh(p, i, 0, d.length - 1);
        return t.getSystem().getByDom(d[C]).toOptional();
      });
    }, eA = (t, s, a) => ix(t, s, a, -1), tA = (t, s, a) => ix(t, s, a, 1), av = (t, s, a) => {
      const i = nc(t.element, "." + s.itemClass);
      return Jr($e(i, (d) => t.getSystem().getByDom(d).toOptional()));
    };
    var qd = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      dehighlightAll: rx,
      dehighlight: Y_,
      highlight: ub,
      highlightFirst: X_,
      highlightLast: ax,
      highlightAt: XC,
      highlightBy: cx,
      isHighlighted: rv,
      getHighlighted: J_,
      getFirst: gp,
      getLast: JC,
      getPrevious: eA,
      getNext: tA,
      getCandidates: av
    }), cv = [
      gt("highlightClass"),
      gt("itemClass"),
      gs("onHighlight"),
      gs("onDehighlight")
    ];
    const Ps = tc({
      fields: cv,
      name: "highlighting",
      apis: qd
    }), nA = [8], Im = [9], Gd = [13], iv = [27], Ll = [32], lv = [37], Lm = [38], hp = [39], db = [40], QC = (t, s, a) => {
      const i = Vn(t.slice(0, s)), d = Vn(t.slice(s + 1));
      return ee(i.concat(d), a);
    }, oA = (t, s, a) => {
      const i = Vn(t.slice(0, s));
      return ee(i, a);
    }, e2 = (t, s, a) => {
      const i = t.slice(0, s), d = t.slice(s + 1);
      return ee(d.concat(i), a);
    }, sA = (t, s, a) => {
      const i = t.slice(s + 1);
      return ee(i, a);
    }, ls = (t) => (s) => {
      const a = s.raw;
      return io(t, a.which);
    }, Hl = (t) => (s) => kt(t, (a) => a(s)), Hm = (t) => t.raw.shiftKey === !0, rA = (t) => t.raw.ctrlKey === !0, pp = De(Hm), ws = (t, s) => ({
      matches: t,
      classification: s
    }), aA = (t, s) => ee(t, (i) => i.matches(s)).map((i) => i.classification), t2 = (t, s, a) => {
      s.exists((d) => a.exists((g) => Rs(g, d))) || to(t, t0(), {
        prevFocus: s,
        newFocus: a
      });
    }, l = () => {
      const t = (a) => Iu(a.element);
      return {
        get: t,
        set: (a, i) => {
          const d = t(a);
          a.getSystem().triggerFocus(i, a.element);
          const g = t(a);
          t2(a, d, g);
        }
      };
    }, m = () => {
      const t = (a) => Ps.getHighlighted(a).map((i) => i.element);
      return {
        get: t,
        set: (a, i) => {
          const d = t(a);
          a.getSystem().getByDom(i).fold(J, (p) => {
            Ps.highlight(a, p);
          });
          const g = t(a);
          t2(a, d, g);
        }
      };
    };
    var h;
    (function(t) {
      t.OnFocusMode = "onFocus", t.OnEnterOrSpaceMode = "onEnterOrSpace", t.OnApiMode = "onApi";
    })(h || (h = {}));
    const v = (t, s, a, i, d) => {
      const g = () => t.concat([
        Ne("focusManager", l()),
        Pc("focusInside", "onFocus", Nd((_) => io([
          "onFocus",
          "onEnterOrSpace",
          "onApi"
        ], _) ? Mo.value(_) : Mo.error("Invalid value for focusInside"))),
        Qs("handler", S),
        Qs("state", s),
        Qs("sendFocusIn", d)
      ]), p = (_, D, P, L, V) => {
        const Y = P(_, D, L, V);
        return aA(Y, D.event).bind((me) => me(_, D, L, V));
      }, S = {
        schema: g,
        processKey: p,
        toEvents: (_, D) => {
          const P = _.focusInside !== h.OnFocusMode ? A.none() : d(_).map((Y) => mt(ym(), (me, Pe) => {
            Y(me, _, D), Pe.stop();
          })), L = (Y, me) => {
            const Pe = ls(Ll.concat(Gd))(me.event);
            _.focusInside === h.OnEnterOrSpaceMode && Pe && Ol(Y, me) && d(_).each((xe) => {
              xe(Y, _, D), me.stop();
            });
          }, V = [
            mt(Pu(), (Y, me) => {
              p(Y, me, a, _, D).fold(() => {
                L(Y, me);
              }, (Pe) => {
                me.stop();
              });
            }),
            mt(ff(), (Y, me) => {
              p(Y, me, i, _, D).each((Pe) => {
                me.stop();
              });
            })
          ];
          return vr(P.toArray().concat(V));
        }
      };
      return S;
    }, T = (t) => {
      const s = [
        $s("onEscape"),
        $s("onEnter"),
        Ne("selector", '[data-alloy-tabstop="true"]:not(:disabled)'),
        Ne("firstTabstop", 0),
        Ne("useTabstopAt", Oe),
        $s("visibilitySelector")
      ].concat([t]), a = (xe, Ce) => {
        const Be = xe.visibilitySelector.bind((St) => ld(Ce, St)).getOr(Ce);
        return hr(Be) > 0;
      }, i = (xe, Ce) => {
        const Be = nc(xe.element, Ce.selector), St = fo(Be, (ct) => a(Ce, ct));
        return A.from(St[Ce.firstTabstop]);
      }, d = (xe, Ce) => Ce.focusManager.get(xe).bind((Be) => ld(Be, Ce.selector)), g = (xe, Ce) => a(xe, Ce) && xe.useTabstopAt(Ce), p = (xe, Ce, Be) => {
        i(xe, Ce).each((St) => {
          Ce.focusManager.set(xe, St);
        });
      }, C = (xe, Ce, Be, St, ct) => ct(Ce, Be, (tt) => g(St, tt)).fold(() => St.cyclic ? A.some(!0) : A.none(), (tt) => (St.focusManager.set(xe, tt), A.some(!0))), S = (xe, Ce, Be, St) => {
        const ct = nc(xe.element, Be.selector);
        return d(xe, Be).bind((tt) => pe(ct, gn(Rs, tt)).bind((Xt) => C(xe, ct, Xt, Be, St)));
      }, _ = (xe, Ce, Be) => {
        const St = Be.cyclic ? QC : oA;
        return S(xe, Ce, Be, St);
      }, D = (xe, Ce, Be) => {
        const St = Be.cyclic ? e2 : sA;
        return S(xe, Ce, Be, St);
      }, P = (xe) => Ac(xe).bind(Bi).exists((Ce) => Rs(Ce, xe)), L = (xe, Ce, Be) => d(xe, Be).filter((St) => !Be.useTabstopAt(St)).bind((St) => (P(St) ? _ : D)(xe, Ce, Be)), V = (xe, Ce, Be) => Be.onEnter.bind((St) => St(xe, Ce)), Y = (xe, Ce, Be) => Be.onEscape.bind((St) => St(xe, Ce)), me = U([
        ws(Hl([
          Hm,
          ls(Im)
        ]), _),
        ws(ls(Im), D),
        ws(Hl([
          pp,
          ls(Gd)
        ]), V)
      ]), Pe = U([
        ws(ls(iv), Y),
        ws(ls(Im), L)
      ]);
      return v(s, $u.init, me, Pe, () => A.some(p));
    };
    var O = T(oa("cyclic", Te)), $ = T(oa("cyclic", Oe));
    const W = (t, s, a) => (s0(t, a, cl()), A.some(!0)), Q = (t, s, a) => Ig(a) && ls(Ll)(s.event) ? A.none() : W(t, s, a), ge = (t, s) => A.some(!0), Re = [
      Ne("execute", Q),
      Ne("useSpace", !1),
      Ne("useEnter", !0),
      Ne("useControlEnter", !1),
      Ne("useDown", !1)
    ], Et = (t, s, a) => a.execute(t, s, t.element), an = (t, s, a, i) => {
      const d = a.useSpace && !Ig(t.element) ? Ll : [], g = a.useEnter ? Gd : [], p = a.useDown ? db : [], C = d.concat(g).concat(p);
      return [ws(ls(C), Et)].concat(a.useControlEnter ? [ws(Hl([
        rA,
        ls(Gd)
      ]), Et)] : []);
    }, tn = (t, s, a, i) => a.useSpace && !Ig(t.element) ? [ws(ls(Ll), ge)] : [];
    var ft = v(Re, $u.init, an, tn, () => A.none());
    const cn = () => {
      const t = Go();
      return il({
        readState: () => t.get().map((d) => ({
          numRows: String(d.numRows),
          numColumns: String(d.numColumns)
        })).getOr({
          numRows: "?",
          numColumns: "?"
        }),
        setGridSize: (d, g) => {
          t.set({
            numRows: d,
            numColumns: g
          });
        },
        getNumRows: () => t.get().map((d) => d.numRows),
        getNumColumns: () => t.get().map((d) => d.numColumns)
      });
    };
    var $n = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      flatgrid: cn,
      init: (t) => t.state(t)
    });
    const wo = (t) => (s, a, i, d) => {
      const g = t(s.element);
      return ma(g, s, a, i, d);
    }, Ho = (t, s) => {
      const a = M0(t, s);
      return wo(a);
    }, Mr = (t, s) => {
      const a = M0(s, t);
      return wo(a);
    }, oc = (t) => (s, a, i, d) => ma(t, s, a, i, d), ma = (t, s, a, i, d) => i.focusManager.get(s).bind((p) => t(s.element, p, i, d)).map((p) => (i.focusManager.set(s, p), !0)), Gi = oc, Lg = oc, Hg = oc, n2 = (t) => t.offsetWidth <= 0 && t.offsetHeight <= 0, uv = (t) => !n2(t.dom), tr = (t, s) => pe(t, s).map((a) => ({
      index: a,
      candidates: t
    })), bi = (t, s, a) => {
      const i = (p) => Rs(p, s), d = nc(t, a), g = fo(d, uv);
      return tr(g, i);
    }, zc = (t, s) => pe(t, (a) => Rs(s, a)), zl = (t, s, a, i) => {
      const d = Math.floor(s / a), g = s % a;
      return i(d, g).bind((p) => {
        const C = p.row * a + p.column;
        return C >= 0 && C < t.length ? A.some(t[C]) : A.none();
      });
    }, hl = (t, s, a, i, d) => zl(t, s, i, (g, p) => {
      const S = g === a - 1 ? t.length - g * i : i, _ = Hh(p, d, 0, S - 1);
      return A.some({
        row: g,
        column: _
      });
    }), If = (t, s, a, i, d) => zl(t, s, i, (g, p) => {
      const C = Hh(g, d, 0, a - 1), _ = C === a - 1 ? t.length - C * i : i, D = Bl(p, 0, _ - 1);
      return A.some({
        row: C,
        column: D
      });
    }), Ni = (t, s, a, i) => hl(t, s, a, i, 1), o2 = (t, s, a, i) => hl(t, s, a, i, -1), mb = (t, s, a, i) => If(t, s, a, i, -1), Kd = (t, s, a, i) => If(t, s, a, i, 1), ni = [
      gt("selector"),
      Ne("execute", Q),
      fl("onEscape"),
      Ne("captureTab", !1),
      Vy()
    ], fb = (t, s, a) => {
      va(t.element, s.selector).each((i) => {
        s.focusManager.set(t, i);
      });
    }, lx = (t, s) => s.focusManager.get(t).bind((a) => ld(a, s.selector)), ux = (t, s, a, i) => lx(t, a).bind((d) => a.execute(t, s, d)), bp = (t) => (s, a, i, d) => bi(s, a, i.selector).bind((g) => t(g.candidates, g.index, d.getNumRows().getOr(i.initSize.numRows), d.getNumColumns().getOr(i.initSize.numColumns))), dx = (t, s, a) => a.captureTab ? A.some(!0) : A.none(), dv = (t, s, a) => a.onEscape(t, s), mx = bp(o2), zg = bp(Ni), aR = bp(mb), GI = bp(Kd), KI = U([
      ws(ls(lv), Ho(mx, zg)),
      ws(ls(hp), Mr(mx, zg)),
      ws(ls(Lm), Gi(aR)),
      ws(ls(db), Lg(GI)),
      ws(Hl([
        Hm,
        ls(Im)
      ]), dx),
      ws(Hl([
        pp,
        ls(Im)
      ]), dx),
      ws(ls(Ll.concat(Gd)), ux)
    ]), YI = U([
      ws(ls(iv), dv),
      ws(ls(Ll), ge)
    ]);
    var XI = v(ni, cn, KI, YI, () => A.some(fb));
    const cR = (t, s, a, i, d) => {
      const g = (C) => Ds(C) === "button" && rr(C, "disabled") === "disabled", p = (C, S, _) => d(C, S, i, 0, _.length - 1, _[S], (D) => g(_[D]) ? p(C, D, _) : A.from(_[D]));
      return bi(t, a, s).bind((C) => {
        const S = C.index, _ = C.candidates;
        return p(S, S, _);
      });
    }, iR = (t, s, a, i) => cR(t, s, a, i, (d, g, p, C, S, _, D) => {
      const P = Bl(g + p, C, S);
      return P === d ? A.from(_) : D(P);
    }), mv = (t, s, a, i) => cR(t, s, a, i, (d, g, p, C, S, _, D) => {
      const P = Hh(g, p, C, S);
      return P === d ? A.none() : D(P);
    }), cA = [
      gt("selector"),
      Ne("getInitial", A.none),
      Ne("execute", Q),
      fl("onEscape"),
      Ne("executeOnMove", !1),
      Ne("allowVertical", !0),
      Ne("allowHorizontal", !0),
      Ne("cycles", !0)
    ], JI = (t, s) => s.focusManager.get(t).bind((a) => ld(a, s.selector)), lR = (t, s, a) => JI(t, a).bind((i) => a.execute(t, s, i)), uR = (t, s, a) => {
      s.getInitial(t).orThunk(() => va(t.element, s.selector)).each((i) => {
        s.focusManager.set(t, i);
      });
    }, dR = (t, s, a) => (a.cycles ? mv : iR)(t, a.selector, s, -1), mR = (t, s, a) => (a.cycles ? mv : iR)(t, a.selector, s, 1), Uu = (t) => (s, a, i, d) => t(s, a, i, d).bind(() => i.executeOnMove ? lR(s, a, i) : A.some(!0)), QI = (t, s, a) => a.onEscape(t, s), eL = (t, s, a, i) => {
      const d = [...a.allowHorizontal ? lv : []].concat(a.allowVertical ? Lm : []), g = [...a.allowHorizontal ? hp : []].concat(a.allowVertical ? db : []);
      return [
        ws(ls(d), Uu(Ho(dR, mR))),
        ws(ls(g), Uu(Mr(dR, mR))),
        ws(ls(Gd), lR),
        ws(ls(Ll), lR)
      ];
    }, tL = U([
      ws(ls(Ll), ge),
      ws(ls(iv), QI)
    ]);
    var nL = v(cA, $u.init, eL, tL, () => A.some(uR));
    const fx = (t, s, a) => A.from(t[s]).bind((i) => A.from(i[a]).map((d) => ({
      rowIndex: s,
      columnIndex: a,
      cell: d
    }))), gb = (t, s, a, i) => {
      const g = t[s].length, p = Hh(a, i, 0, g - 1);
      return fx(t, s, p);
    }, gx = (t, s, a, i) => {
      const d = Hh(a, i, 0, t.length - 1), g = t[d].length, p = Bl(s, 0, g - 1);
      return fx(t, d, p);
    }, fR = (t, s, a, i) => {
      const g = t[s].length, p = Bl(a + i, 0, g - 1);
      return fx(t, s, p);
    }, hx = (t, s, a, i) => {
      const d = Bl(a + i, 0, t.length - 1), g = t[d].length, p = Bl(s, 0, g - 1);
      return fx(t, d, p);
    }, px = (t, s, a) => gb(t, s, a, 1), iA = (t, s, a) => gb(t, s, a, -1), oL = (t, s, a) => gx(t, a, s, -1), sL = (t, s, a) => gx(t, a, s, 1), rL = (t, s, a) => fR(t, s, a, -1), aL = (t, s, a) => fR(t, s, a, 1), cL = (t, s, a) => hx(t, a, s, -1), iL = (t, s, a) => hx(t, a, s, 1), gR = [
      su("selectors", [
        gt("row"),
        gt("cell")
      ]),
      Ne("cycles", !0),
      Ne("previousSelector", A.none),
      Ne("execute", Q)
    ], lA = (t, s, a) => {
      s.previousSelector(t).orThunk(() => {
        const d = s.selectors;
        return va(t.element, d.cell);
      }).each((d) => {
        s.focusManager.set(t, d);
      });
    }, lL = (t, s, a) => Iu(t.element).bind((i) => a.execute(t, s, i)), uL = (t, s) => $e(t, (a) => nc(a, s.selectors.cell)), bx = (t, s) => (a, i, d) => {
      const g = d.cycles ? t : s;
      return ld(i, d.selectors.row).bind((p) => {
        const C = nc(p, d.selectors.cell);
        return zc(C, i).bind((S) => {
          const _ = nc(a, d.selectors.row);
          return zc(_, p).bind((D) => {
            const P = uL(_, d);
            return g(P, D, S).map((L) => L.cell);
          });
        });
      });
    }, hR = bx(iA, rL), vp = bx(px, aL), pR = bx(oL, cL), dL = bx(sL, iL), uA = U([
      ws(ls(lv), Ho(hR, vp)),
      ws(ls(hp), Mr(hR, vp)),
      ws(ls(Lm), Gi(pR)),
      ws(ls(db), Lg(dL)),
      ws(ls(Ll.concat(Gd)), lL)
    ]), mL = U([ws(ls(Ll), ge)]);
    var bR = v(gR, $u.init, uA, mL, () => A.some(lA));
    const vR = [
      gt("selector"),
      Ne("execute", Q),
      Ne("moveOnTab", !1)
    ], dA = (t, s, a) => a.focusManager.get(t).bind((i) => a.execute(t, s, i)), yR = (t, s, a) => {
      va(t.element, s.selector).each((i) => {
        s.focusManager.set(t, i);
      });
    }, mA = (t, s, a) => mv(t, a.selector, s, -1), CR = (t, s, a) => mv(t, a.selector, s, 1), fL = (t, s, a, i) => a.moveOnTab ? Hg(mA)(t, s, a, i) : A.none(), gL = (t, s, a, i) => a.moveOnTab ? Hg(CR)(t, s, a, i) : A.none(), fA = U([
      ws(ls(Lm), Hg(mA)),
      ws(ls(db), Hg(CR)),
      ws(Hl([
        Hm,
        ls(Im)
      ]), fL),
      ws(Hl([
        pp,
        ls(Im)
      ]), gL),
      ws(ls(Gd), dA),
      ws(ls(Ll), dA)
    ]), hL = U([ws(ls(Ll), ge)]);
    var pL = v(vR, $u.init, fA, hL, () => A.some(yR));
    const bL = [
      fl("onSpace"),
      fl("onEnter"),
      fl("onShiftEnter"),
      fl("onLeft"),
      fl("onRight"),
      fl("onTab"),
      fl("onShiftTab"),
      fl("onUp"),
      fl("onDown"),
      fl("onEscape"),
      Ne("stopSpaceKeyup", !1),
      $s("focusIn")
    ], vL = (t, s, a) => [
      ws(ls(Ll), a.onSpace),
      ws(Hl([
        pp,
        ls(Gd)
      ]), a.onEnter),
      ws(Hl([
        Hm,
        ls(Gd)
      ]), a.onShiftEnter),
      ws(Hl([
        Hm,
        ls(Im)
      ]), a.onShiftTab),
      ws(Hl([
        pp,
        ls(Im)
      ]), a.onTab),
      ws(ls(Lm), a.onUp),
      ws(ls(db), a.onDown),
      ws(ls(lv), a.onLeft),
      ws(ls(hp), a.onRight),
      ws(ls(Ll), a.onSpace)
    ], wR = (t, s, a) => [
      ...a.stopSpaceKeyup ? [ws(ls(Ll), ge)] : [],
      ws(ls(iv), a.onEscape)
    ];
    var yL = v(bL, $u.init, vL, wR, (t) => t.focusIn);
    const CL = O.schema(), wL = $.schema(), SR = nL.schema(), SL = XI.schema(), xL = bR.schema(), xR = ft.schema(), TL = pL.schema(), EL = yL.schema();
    var vx = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      acyclic: CL,
      cyclic: wL,
      flow: SR,
      flatgrid: SL,
      matrix: xL,
      execution: xR,
      menu: TL,
      special: EL
    });
    const kL = (t) => Or(t, "setGridSize"), no = D0({
      branchKey: "mode",
      branches: vx,
      name: "keying",
      active: {
        events: (t, s) => t.handler.toEvents(t, s)
      },
      apis: {
        focusIn: (t, s, a) => {
          s.sendFocusIn(s).fold(() => {
            t.getSystem().triggerFocus(t.element, t.element);
          }, (i) => {
            i(t, s, a);
          });
        },
        setGridSize: (t, s, a, i, d) => {
          kL(a) && a.setGridSize(i, d);
        }
      },
      state: $n
    }), Ki = (t, s) => {
      Cn(() => {
        __(t, s, () => $e(s, t.getSystem().build));
      }, t.element);
    }, TR = (t, s) => {
      Cn(() => {
        A_(t, s, () => q4(t.element, s, t.getSystem().buildOrPatch));
      }, t.element);
    }, ER = (t, s, a, i) => {
      op(s);
      const d = Zw(t.element, a, i, t.getSystem().buildOrPatch);
      RC(t, d), t.syncComponents();
    }, yx = (t, s, a) => {
      const i = t.getSystem().build(a);
      sp(t, i, s);
    }, _L = (t, s, a, i) => {
      jd(s), yx(t, (d, g) => Ea(d, g, a), i);
    }, kR = (t, s, a, i) => (s.reuseDom ? TR : Ki)(t, i), _R = (t, s, a, i) => {
      yx(t, Sc, i);
    }, AL = (t, s, a, i) => {
      yx(t, ng, i);
    }, OL = (t, s, a, i) => {
      const d = Cx(t);
      ee(d, (p) => Rs(i.element, p.element)).each(jd);
    }, Cx = (t, s) => t.components(), AR = (t, s, a, i, d) => {
      const g = Cx(t);
      return A.from(g[i]).map((p) => (d.fold(() => jd(p), (C) => {
        (s.reuseDom ? ER : _L)(t, p, i, C);
      }), p));
    };
    var RL = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      append: _R,
      prepend: AL,
      remove: OL,
      replaceAt: AR,
      replaceBy: (t, s, a, i, d) => {
        const g = Cx(t);
        return pe(g, i).bind((p) => AR(t, s, a, p, d));
      },
      set: kR,
      contents: Cx
    });
    const Oo = tc({
      fields: [Pa("reuseDom", !0)],
      name: "replacing",
      apis: RL
    }), OR = (t, s) => {
      const a = vr(s);
      return tc({
        fields: [gt("enabled")],
        name: t,
        active: { events: U(a) }
      });
    }, Bo = (t, s) => {
      const a = OR(t, s);
      return {
        key: t,
        value: {
          config: {},
          me: a,
          configAsRaw: U({}),
          initialConfig: {},
          state: $u
        }
      };
    }, gA = (t, s) => {
      s.ignore || (Zi(t.element), s.onFocus(t));
    };
    var NL = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      focus: gA,
      blur: (t, s) => {
        s.ignore || Uh(t.element);
      },
      isFocused: (t) => N1(t.element)
    }), DR = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      exhibit: (t, s) => {
        const a = s.ignore ? {} : { attributes: { tabindex: "-1" } };
        return ll(a);
      },
      events: (t) => vr([mt(ym(), (s, a) => {
        gA(s, t), a.stop();
      })].concat(t.stopMousedown ? [mt(Zs(), (s, a) => {
        a.event.prevent();
      })] : []))
    }), yp = [
      gs("onFocus"),
      Ne("stopMousedown", !1),
      Ne("ignore", !1)
    ];
    const po = tc({
      fields: yp,
      name: "focusing",
      active: DR,
      apis: NL
    }), RR = (t) => ({ init: () => {
      const a = w(t);
      return {
        get: () => a.get(),
        set: (C) => a.set(C),
        clear: () => a.set(t),
        readState: () => a.get()
      };
    } }), hA = (t, s, a) => {
      const i = s.aria;
      i.update(t, i, a.get());
    }, PL = (t, s, a) => {
      s.toggleClass.each((i) => {
        a.get() ? ba(t.element, i) : Wr(t.element, i);
      });
    }, s2 = (t, s, a, i) => {
      const d = a.get();
      a.set(i), PL(t, s, a), hA(t, s, a), d !== i && s.onToggled(t, i);
    }, NR = (t, s, a) => {
      s2(t, s, a, !a.get());
    }, BL = (t, s, a) => {
      s2(t, s, a, !0);
    }, MR = (t, s, a) => {
      s2(t, s, a, !1);
    }, pA = (t, s, a) => a.get(), wx = (t, s, a) => {
      s2(t, s, a, s.selected);
    };
    var $L = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      onLoad: wx,
      toggle: NR,
      isOn: pA,
      on: BL,
      off: MR,
      set: s2
    }), PR = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      exhibit: () => ll({}),
      events: (t, s) => {
        const a = Vh(t, s, NR), i = O0(t, s, wx);
        return vr(ye([
          t.toggleOnExecute ? [a] : [],
          [i]
        ]));
      }
    });
    const IL = (t, s, a) => {
      sn(t.element, "aria-pressed", a), s.syncWithExpanded && fv(t, s, a);
    }, LL = (t, s, a) => {
      sn(t.element, "aria-selected", a);
    }, r2 = (t, s, a) => {
      sn(t.element, "aria-checked", a);
    }, fv = (t, s, a) => {
      sn(t.element, "aria-expanded", a);
    };
    var BR = [
      Ne("selected", !1),
      $s("toggleClass"),
      Ne("toggleOnExecute", !0),
      gs("onToggled"),
      Pc("aria", { mode: "none" }, es("mode", {
        pressed: [
          Ne("syncWithExpanded", !1),
          Qs("update", IL)
        ],
        checked: [Qs("update", r2)],
        expanded: [Qs("update", fv)],
        selected: [Qs("update", LL)],
        none: [Qs("update", J)]
      }))
    ];
    const Vo = tc({
      fields: BR,
      name: "toggling",
      active: PR,
      apis: $L,
      state: RR(!1)
    }), Vg = () => {
      const t = (s, a) => {
        a.stop(), Cm(s);
      };
      return [
        mt(vm(), t),
        mt(ad(), t),
        wm(Mu()),
        wm(Zs())
      ];
    }, zm = (t) => {
      const s = (a) => Bu((i, d) => {
        a(i), d.stop();
      });
      return vr(ye([
        t.map(s).toArray(),
        Vg()
      ]));
    }, $R = "alloy.item-hover", FR = "alloy.item-focus", bA = "alloy.item-toggled", Lf = (t) => {
      (Iu(t.element).isNone() || po.isFocused(t)) && (po.isFocused(t) || po.focus(t), to(t, $R, { item: t }));
    }, Sx = (t) => {
      to(t, FR, { item: t });
    }, HL = (t, s) => {
      to(t, bA, {
        item: t,
        state: s
      });
    }, vA = U($R), IR = U(FR), LR = U(bA), yA = (t) => t.toggling.map((s) => s.exclusive ? "menuitemradio" : "menuitemcheckbox").getOr("menuitem"), HR = (t) => ({
      aria: { mode: "checked" },
      ...Gs(t, (s, a) => a !== "exclusive"),
      onToggled: (s, a) => {
        st(t.onToggled) && t.onToggled(s, a), HL(s, a);
      }
    }), zL = (t) => ({
      dom: t.dom,
      domModification: {
        ...t.domModification,
        attributes: {
          role: yA(t),
          ...t.domModification.attributes,
          "aria-haspopup": t.hasSubmenu,
          ...t.hasSubmenu ? { "aria-expanded": !1 } : {}
        }
      },
      behaviours: lu.augment(t.itemBehaviours, [
        t.toggling.fold(Vo.revoke, (s) => Vo.config(HR(s))),
        po.config({
          ignore: t.ignoreFocus,
          stopMousedown: t.ignoreFocus,
          onFocus: (s) => {
            Sx(s);
          }
        }),
        no.config({ mode: "execution" }),
        ln.config({
          store: {
            mode: "memory",
            initialValue: t.data
          }
        }),
        Bo("item-type-events", [
          ...Vg(),
          mt(Rl(), Lf),
          mt(sa(), po.focus)
        ])
      ]),
      components: t.components,
      eventOrder: t.eventOrder
    }), VL = [
      gt("data"),
      gt("components"),
      gt("dom"),
      Ne("hasSubmenu", !1),
      $s("toggling"),
      lu.field("itemBehaviours", [
        Vo,
        po,
        no,
        ln
      ]),
      Ne("ignoreFocus", !1),
      Ne("domModification", {}),
      Qs("builder", zL),
      Ne("eventOrder", {})
    ], UL = (t) => ({
      dom: t.dom,
      components: t.components,
      events: vr([Sk(sa())])
    }), xx = [
      gt("dom"),
      gt("components"),
      Qs("builder", UL)
    ], a2 = U("item-widget"), c2 = U([ei({
      name: "widget",
      overrides: (t) => ({
        behaviours: Ut([ln.config({
          store: {
            mode: "manual",
            getValue: (s) => t.data,
            setValue: J
          }
        })])
      })
    })]), WL = (t) => {
      const s = VC(a2(), t, c2()), a = sv(a2(), t, s.internals()), i = (g) => ir(g, t, "widget").map((p) => (no.focusIn(p), p)), d = (g, p) => Ig(p.event.target) ? A.none() : (t.autofocus && p.setSource(g.element), A.none());
      return {
        dom: t.dom,
        components: a,
        domModification: t.domModification,
        events: vr([
          Bu((g, p) => {
            i(g).each((C) => {
              p.stop();
            });
          }),
          mt(Rl(), Lf),
          mt(sa(), (g, p) => {
            t.autofocus ? i(g) : po.focus(g);
          })
        ]),
        behaviours: lu.augment(t.widgetBehaviours, [
          ln.config({
            store: {
              mode: "memory",
              initialValue: t.data
            }
          }),
          po.config({
            ignore: t.ignoreFocus,
            onFocus: (g) => {
              Sx(g);
            }
          }),
          no.config({
            mode: "special",
            focusIn: t.autofocus ? (g) => {
              i(g);
            } : eC(),
            onLeft: d,
            onRight: d,
            onEscape: (g, p) => !po.isFocused(g) && !t.autofocus ? (po.focus(g), A.some(!0)) : (t.autofocus && p.setSource(g.element), A.none())
          })
        ])
      };
    }, ZL = [
      gt("uid"),
      gt("data"),
      gt("components"),
      gt("dom"),
      Ne("autofocus", !1),
      Ne("ignoreFocus", !1),
      lu.field("widgetBehaviours", [
        ln,
        po,
        no
      ]),
      Ne("domModification", {}),
      jC(c2()),
      Qs("builder", WL)
    ], zR = es("type", {
      widget: ZL,
      item: VL,
      separator: xx
    }), VR = (t, s) => ({
      mode: "flatgrid",
      selector: "." + t.markers.item,
      initSize: {
        numColumns: s.initSize.numColumns,
        numRows: s.initSize.numRows
      },
      focusManager: t.focusManager
    }), UR = (t, s) => ({
      mode: "matrix",
      selectors: {
        row: s.rowSelector,
        cell: "." + t.markers.item
      },
      previousSelector: s.previousSelector,
      focusManager: t.focusManager
    }), WR = (t, s) => ({
      mode: "menu",
      selector: "." + t.markers.item,
      moveOnTab: s.moveOnTab,
      focusManager: t.focusManager
    }), jL = U([sb({
      factory: {
        sketch: (t) => {
          const s = Gc("menu.spec item", zR, t);
          return s.builder(s);
        }
      },
      name: "items",
      unit: "item",
      defaults: (t, s) => Lo(s, "uid") ? s : {
        ...s,
        uid: xh("item")
      },
      overrides: (t, s) => ({
        type: s.type,
        ignoreFocus: t.fakeFocus,
        domModification: { classes: [t.markers.item] }
      })
    })]), CA = U([
      gt("value"),
      gt("items"),
      gt("dom"),
      gt("components"),
      Ne("eventOrder", {}),
      za("menuBehaviours", [
        Ps,
        ln,
        ts,
        no
      ]),
      Pc("movement", {
        mode: "menu",
        moveOnTab: !0
      }, es("mode", {
        grid: [
          Vy(),
          Qs("config", VR)
        ],
        matrix: [
          Qs("config", UR),
          gt("rowSelector"),
          Ne("previousSelector", A.none)
        ],
        menu: [
          Ne("moveOnTab", !0),
          Qs("config", WR)
        ]
      })),
      Ik(),
      Ne("fakeFocus", !1),
      Ne("focusManager", l()),
      gs("onHighlight"),
      gs("onDehighlight")
    ]), ZR = U("alloy.menu-focus"), qL = (t, s) => {
      const a = nc(t.element, '[role="menuitemradio"][aria-checked="true"]');
      ot(a, (i) => {
        Rs(i, s.element) || t.getSystem().getByDom(i).each((d) => {
          Vo.off(d);
        });
      });
    }, GL = (t, s, a, i) => ({
      uid: t.uid,
      dom: t.dom,
      markers: t.markers,
      behaviours: Oa(t.menuBehaviours, [
        Ps.config({
          highlightClass: t.markers.selectedItem,
          itemClass: t.markers.item,
          onHighlight: t.onHighlight,
          onDehighlight: t.onDehighlight
        }),
        ln.config({
          store: {
            mode: "memory",
            initialValue: t.value
          }
        }),
        ts.config({ find: A.some }),
        no.config(t.movement.config(t, t.movement))
      ]),
      events: vr([
        mt(IR(), (d, g) => {
          const p = g.event;
          d.getSystem().getByDom(p.target).each((C) => {
            Ps.highlight(d, C), g.stop(), to(d, ZR(), {
              menu: d,
              item: C
            });
          });
        }),
        mt(vA(), (d, g) => {
          const p = g.event.item;
          Ps.highlight(d, p);
        }),
        mt(LR(), (d, g) => {
          const { item: p, state: C } = g.event;
          C && rr(p.element, "role") === "menuitemradio" && qL(d, p);
        })
      ]),
      components: s,
      eventOrder: t.eventOrder,
      domModification: { attributes: { role: "menu" } }
    }), pb = ti({
      name: "Menu",
      configFields: CA(),
      partFields: jL(),
      factory: GL
    }), jR = (t) => nn(t, (s, a) => ({
      k: s,
      v: a
    })), qR = (t, s, a, i) => Dt(a, i).bind((d) => Dt(t, d).bind((g) => {
      const p = qR(t, s, a, g);
      return A.some([g].concat(p));
    })).getOr([]), KL = (t, s) => {
      const a = {};
      Ie(t, (p, C) => {
        ot(p, (S) => {
          a[S] = C;
        });
      });
      const i = s, d = jR(s), g = et(d, (p, C) => [C].concat(qR(a, i, d, C)));
      return et(a, (p) => Dt(g, p).getOr([p]));
    }, GR = () => {
      const t = w({}), s = w({}), a = w({}), i = Go(), d = w({}), g = () => {
        t.set({}), s.set({}), a.set({}), i.clear();
      }, p = () => i.get().isNone(), C = (ct, tt) => {
        s.set({
          ...s.get(),
          [ct]: {
            type: "prepared",
            menu: tt
          }
        });
      }, S = (ct, tt, Vt, Xt) => {
        i.set(ct), t.set(Vt), s.set(tt), d.set(Xt);
        const $o = KL(Xt, Vt);
        a.set($o);
      }, _ = (ct) => Ss(t.get(), (tt, Vt) => tt === ct), D = (ct, tt, Vt) => me(ct).bind((Xt) => _(ct).bind(($o) => tt($o).map((Hn) => ({
        triggeredMenu: Xt,
        triggeringItem: Hn,
        triggeringPath: Vt
      })))), P = (ct, tt) => {
        const Vt = fo(xe(ct).toArray(), (Xt) => me(Xt).isSome());
        return Dt(a.get(), ct).bind((Xt) => {
          const $o = Vn(Vt.concat(Xt)), Hn = ae($o, (co, bo) => D(co, tt, $o.slice(0, bo + 1)).fold(() => aa(i.get(), co) ? [] : [A.none()], (zs) => [A.some(zs)]));
          return xs(Hn);
        });
      }, L = (ct) => Dt(t.get(), ct).map((tt) => {
        const Vt = Dt(a.get(), ct).getOr([]);
        return [tt].concat(Vt);
      }), V = (ct) => Dt(a.get(), ct).bind((tt) => tt.length > 1 ? A.some(tt.slice(1)) : A.none()), Y = (ct) => Dt(a.get(), ct), me = (ct) => Pe(ct).bind(gv), Pe = (ct) => Dt(s.get(), ct), xe = (ct) => Dt(t.get(), ct);
      return {
        setMenuBuilt: C,
        setContents: S,
        expand: L,
        refresh: Y,
        collapse: V,
        lookupMenu: Pe,
        lookupItem: xe,
        otherMenus: (ct) => {
          const tt = d.get();
          return Yt(Ao(tt), ct);
        },
        getPrimary: () => i.get().bind(me),
        getMenus: () => s.get(),
        clear: g,
        isClear: p,
        getTriggeringPath: P
      };
    }, gv = (t) => t.type === "prepared" ? A.some(t.menu) : A.none(), KR = {
      init: GR,
      extractPreparedMenu: gv
    }, hv = An("tiered-menu-item-highlight"), Tx = An("tiered-menu-item-dehighlight");
    var Yi;
    (function(t) {
      t[t.HighlightMenuAndItem = 0] = "HighlightMenuAndItem", t[t.HighlightJustMenu = 1] = "HighlightJustMenu", t[t.HighlightNone = 2] = "HighlightNone";
    })(Yi || (Yi = {}));
    const YR = (t, s) => {
      const a = Go(), i = (Jt, Fn, So) => et(So, (ns, uo) => {
        const Ro = () => pb.sketch({
          ...ns,
          value: uo,
          markers: t.markers,
          fakeFocus: t.fakeFocus,
          onHighlight: (ur, Bs) => {
            to(ur, hv, {
              menuComp: ur,
              itemComp: Bs
            });
          },
          onDehighlight: (ur, Bs) => {
            to(ur, Tx, {
              menuComp: ur,
              itemComp: Bs
            });
          },
          focusManager: t.fakeFocus ? m() : l()
        });
        return uo === Fn ? {
          type: "prepared",
          menu: Jt.getSystem().build(Ro())
        } : {
          type: "notbuilt",
          nbMenu: Ro
        };
      }), d = KR.init(), g = (Jt) => {
        const Fn = i(Jt, t.data.primary, t.data.menus), So = S();
        return d.setContents(t.data.primary, Fn, t.data.expansions, So), d.getPrimary();
      }, p = (Jt) => ln.getValue(Jt).value, C = (Jt, Fn, So) => No(Fn, (ns) => {
        if (!ns.getSystem().isConnected())
          return A.none();
        const uo = Ps.getCandidates(ns);
        return ee(uo, (Ro) => p(Ro) === So);
      }), S = (Jt) => et(t.data.menus, (Fn, So) => ae(Fn.items, (ns) => ns.type === "separator" ? [] : [ns.data.value])), _ = Ps.highlight, D = (Jt, Fn) => {
        _(Jt, Fn), Ps.getHighlighted(Fn).orThunk(() => Ps.getFirst(Fn)).each((So) => {
          t.fakeFocus ? Ps.highlight(Fn, So) : s0(Jt, So.element, sa());
        });
      }, P = (Jt, Fn) => Jr($e(Fn, (So) => Jt.lookupMenu(So).bind((ns) => ns.type === "prepared" ? A.some(ns.menu) : A.none()))), L = (Jt, Fn, So) => {
        const ns = P(Fn, Fn.otherMenus(So));
        ot(ns, (uo) => {
          Ml(uo.element, [t.markers.backgroundMenu]), t.stayInDom || Oo.remove(Jt, uo);
        });
      }, V = (Jt) => a.get().getOrThunk(() => {
        const Fn = {}, So = nc(Jt.element, `.${t.markers.item}`), ns = fo(So, (uo) => rr(uo, "aria-haspopup") === "true");
        return ot(ns, (uo) => {
          Jt.getSystem().getByDom(uo).each((Ro) => {
            const ur = p(Ro);
            Fn[ur] = Ro;
          });
        }), a.set(Fn), Fn;
      }), Y = (Jt, Fn) => {
        const So = V(Jt);
        Ie(So, (ns, uo) => {
          const Ro = io(Fn, uo);
          sn(ns.element, "aria-expanded", Ro);
        });
      }, me = (Jt, Fn, So) => A.from(So[0]).bind((ns) => Fn.lookupMenu(ns).bind((uo) => {
        if (uo.type === "notbuilt")
          return A.none();
        {
          const Ro = uo.menu, ur = P(Fn, So.slice(1));
          return ot(ur, (Bs) => {
            ba(Bs.element, t.markers.backgroundMenu);
          }), qo(Ro.element) || Oo.append(Jt, Pl(Ro)), Ml(Ro.element, [t.markers.backgroundMenu]), D(Jt, Ro), L(Jt, Fn, So), A.some(Ro);
        }
      }));
      let Pe;
      (function(Jt) {
        Jt[Jt.HighlightSubmenu = 0] = "HighlightSubmenu", Jt[Jt.HighlightParent = 1] = "HighlightParent";
      })(Pe || (Pe = {}));
      const xe = (Jt, Fn, So) => {
        if (So.type === "notbuilt") {
          const ns = Jt.getSystem().build(So.nbMenu());
          return d.setMenuBuilt(Fn, ns), ns;
        } else
          return So.menu;
      }, Ce = (Jt, Fn, So = Pe.HighlightSubmenu) => {
        if (Fn.hasConfigured(mo) && mo.isDisabled(Fn))
          return A.some(Fn);
        {
          const ns = p(Fn);
          return d.expand(ns).bind((uo) => (Y(Jt, uo), A.from(uo[0]).bind((Ro) => d.lookupMenu(Ro).bind((ur) => {
            const Bs = xe(Jt, Ro, ur);
            return qo(Bs.element) || Oo.append(Jt, Pl(Bs)), t.onOpenSubmenu(Jt, Fn, Bs, Vn(uo)), So === Pe.HighlightSubmenu ? (Ps.highlightFirst(Bs), me(Jt, d, uo)) : (Ps.dehighlightAll(Bs), A.some(Fn));
          }))));
        }
      }, Be = (Jt, Fn) => {
        const So = p(Fn);
        return d.collapse(So).bind((ns) => (Y(Jt, ns), me(Jt, d, ns).map((uo) => (t.onCollapseMenu(Jt, Fn, uo), uo))));
      }, St = (Jt, Fn) => {
        const So = p(Fn);
        return d.refresh(So).bind((ns) => (Y(Jt, ns), me(Jt, d, ns)));
      }, ct = (Jt, Fn) => Ig(Fn.element) ? A.none() : Ce(Jt, Fn, Pe.HighlightSubmenu), tt = (Jt, Fn) => Ig(Fn.element) ? A.none() : Be(Jt, Fn), Vt = (Jt, Fn) => Be(Jt, Fn).orThunk(() => t.onEscape(Jt, Fn).map(() => Jt)), Xt = (Jt) => (Fn, So) => ld(So.getSource(), `.${t.markers.item}`).bind((ns) => Fn.getSystem().getByDom(ns).toOptional().bind((uo) => Jt(Fn, uo).map(Oe))), $o = vr([
        mt(ZR(), (Jt, Fn) => {
          const So = Fn.event.item;
          d.lookupItem(p(So)).each(() => {
            const ns = Fn.event.menu;
            Ps.highlight(Jt, ns);
            const uo = p(Fn.event.item);
            d.refresh(uo).each((Ro) => L(Jt, d, Ro));
          });
        }),
        Bu((Jt, Fn) => {
          const So = Fn.event.target;
          Jt.getSystem().getByDom(So).each((ns) => {
            p(ns).indexOf("collapse-item") === 0 && Be(Jt, ns), Ce(Jt, ns, Pe.HighlightSubmenu).fold(() => {
              t.onExecute(Jt, ns);
            }, J);
          });
        }),
        cr((Jt, Fn) => {
          g(Jt).each((So) => {
            Oo.append(Jt, Pl(So)), t.onOpenMenu(Jt, So), t.highlightOnOpen === Yi.HighlightMenuAndItem ? D(Jt, So) : t.highlightOnOpen === Yi.HighlightJustMenu && _(Jt, So);
          });
        }),
        mt(hv, (Jt, Fn) => {
          t.onHighlightItem(Jt, Fn.event.menuComp, Fn.event.itemComp);
        }),
        mt(Tx, (Jt, Fn) => {
          t.onDehighlightItem(Jt, Fn.event.menuComp, Fn.event.itemComp);
        }),
        ...t.navigateOnHover ? [mt(vA(), (Jt, Fn) => {
          const So = Fn.event.item;
          St(Jt, So), Ce(Jt, So, Pe.HighlightParent), t.onHover(Jt, So);
        })] : []
      ]), Hn = (Jt) => Ps.getHighlighted(Jt).bind(Ps.getHighlighted), co = (Jt) => {
        Hn(Jt).each((Fn) => {
          Be(Jt, Fn);
        });
      }, bo = (Jt) => {
        d.getPrimary().each((Fn) => {
          D(Jt, Fn);
        });
      }, zs = (Jt) => A.from(Jt.components()[0]).filter((Fn) => rr(Fn.element, "role") === "menu"), ys = {
        collapseMenu: co,
        highlightPrimary: bo,
        repositionMenus: (Jt) => {
          d.getPrimary().bind((So) => Hn(Jt).bind((ns) => {
            const uo = p(ns), Ro = or(d.getMenus()), ur = Jr($e(Ro, KR.extractPreparedMenu));
            return d.getTriggeringPath(uo, (Bs) => C(Jt, ur, Bs));
          }).map((ns) => ({
            primary: So,
            triggeringPath: ns
          }))).fold(() => {
            zs(Jt).each((So) => {
              t.onRepositionMenu(Jt, So, []);
            });
          }, ({ primary: So, triggeringPath: ns }) => {
            t.onRepositionMenu(Jt, So, ns);
          });
        }
      };
      return {
        uid: t.uid,
        dom: t.dom,
        markers: t.markers,
        behaviours: Oa(t.tmenuBehaviours, [
          no.config({
            mode: "special",
            onRight: Xt(ct),
            onLeft: Xt(tt),
            onEscape: Xt(Vt),
            focusIn: (Jt, Fn) => {
              d.getPrimary().each((So) => {
                s0(Jt, So.element, sa());
              });
            }
          }),
          Ps.config({
            highlightClass: t.markers.selectedMenu,
            itemClass: t.markers.menu
          }),
          ts.config({
            find: (Jt) => Ps.getHighlighted(Jt)
          }),
          Oo.config({})
        ]),
        eventOrder: t.eventOrder,
        apis: ys,
        events: $o
      };
    }, YL = U("collapse-item"), XL = (t, s, a) => ({
      primary: t,
      menus: s,
      expansions: a
    }), XR = (t, s) => ({
      primary: t,
      menus: oo(t, s),
      expansions: {}
    }), JL = (t) => ({
      value: An(YL()),
      meta: { text: t }
    }), Cp = gl({
      name: "TieredMenu",
      configFields: [
        zy("onExecute"),
        zy("onEscape"),
        ud("onOpenMenu"),
        ud("onOpenSubmenu"),
        gs("onRepositionMenu"),
        gs("onCollapseMenu"),
        Ne("highlightOnOpen", Yi.HighlightMenuAndItem),
        su("data", [
          gt("primary"),
          gt("menus"),
          gt("expansions")
        ]),
        Ne("fakeFocus", !1),
        gs("onHighlightItem"),
        gs("onDehighlightItem"),
        gs("onHover"),
        E1(),
        gt("dom"),
        Ne("navigateOnHover", !0),
        Ne("stayInDom", !1),
        za("tmenuBehaviours", [
          no,
          Ps,
          ts,
          Oo
        ]),
        Ne("eventOrder", {})
      ],
      apis: {
        collapseMenu: (t, s) => {
          t.collapseMenu(s);
        },
        highlightPrimary: (t, s) => {
          t.highlightPrimary(s);
        },
        repositionMenus: (t, s) => {
          t.repositionMenus(s);
        }
      },
      factory: YR,
      extraApis: {
        tieredData: XL,
        singleData: XR,
        collapseItem: JL
      }
    }), QL = (t, s, a, i, d) => {
      const g = () => t.lazySink(s), p = i.type === "horizontal" ? {
        layouts: {
          onLtr: () => A0(),
          onRtl: () => Jy()
        }
      } : {}, C = (_) => _.length === 2, S = (_) => C(_) ? p : {};
      return Cp.sketch({
        dom: { tag: "div" },
        data: i.data,
        markers: i.menu.markers,
        highlightOnOpen: i.menu.highlightOnOpen,
        fakeFocus: i.menu.fakeFocus,
        onEscape: () => (is.close(s), t.onEscape.map((_) => _(s)), A.some(!0)),
        onExecute: () => A.some(!0),
        onOpenMenu: (_, D) => {
          Qc.positionWithinBounds(g().getOrDie(), D, a, d());
        },
        onOpenSubmenu: (_, D, P, L) => {
          const V = g().getOrDie();
          Qc.position(V, P, {
            anchor: {
              type: "submenu",
              item: D,
              ...S(L)
            }
          });
        },
        onRepositionMenu: (_, D, P) => {
          const L = g().getOrDie();
          Qc.positionWithinBounds(L, D, a, d()), ot(P, (V) => {
            const Y = S(V.triggeringPath);
            Qc.position(L, V.triggeredMenu, {
              anchor: {
                type: "submenu",
                item: V.triggeringItem,
                ...Y
              }
            });
          });
        }
      });
    }, e6 = (t, s) => {
      const a = (L, V) => t.getRelated(L).exists((me) => km(me, V)), i = (L, V) => {
        is.setContent(L, V);
      }, d = (L, V, Y) => {
        const me = A.none;
        g(L, V, Y, me);
      }, g = (L, V, Y, me) => {
        const Pe = t.lazySink(L).getOrDie();
        is.openWhileCloaked(L, V, () => Qc.positionWithinBounds(Pe, L, Y, me())), ln.setValue(L, A.some({
          mode: "position",
          config: Y,
          getBounds: me
        }));
      }, p = (L, V, Y) => {
        C(L, V, Y, A.none);
      }, C = (L, V, Y, me) => {
        const Pe = QL(t, L, V, Y, me);
        is.open(L, Pe), ln.setValue(L, A.some({
          mode: "menu",
          menu: Pe
        }));
      }, S = (L) => {
        is.isOpen(L) && (ln.setValue(L, A.none()), is.close(L));
      }, _ = (L) => is.getState(L), D = (L) => {
        is.isOpen(L) && ln.getValue(L).each((V) => {
          switch (V.mode) {
            case "menu":
              is.getState(L).each(Cp.repositionMenus);
              break;
            case "position":
              const Y = t.lazySink(L).getOrDie();
              Qc.positionWithinBounds(Y, L, V.config, V.getBounds());
              break;
          }
        });
      }, P = {
        setContent: i,
        showAt: d,
        showWithinBounds: g,
        showMenuAt: p,
        showMenuWithinBounds: C,
        hide: S,
        getContent: _,
        reposition: D,
        isOpen: is.isOpen
      };
      return {
        uid: t.uid,
        dom: t.dom,
        behaviours: Oa(t.inlineBehaviours, [
          is.config({
            isPartOf: (L, V, Y) => km(V, Y) || a(L, Y),
            getAttachPoint: (L) => t.lazySink(L).getOrDie(),
            onOpen: (L) => {
              t.onShow(L);
            },
            onClose: (L) => {
              t.onHide(L);
            }
          }),
          ln.config({
            store: {
              mode: "memory",
              initialValue: A.none()
            }
          }),
          Wi.config({
            channels: {
              ...K1({
                isExtraPart: s.isExtraPart,
                ...t.fireDismissalEventInstead.map((L) => ({ fireEventInstead: { event: L.event } })).getOr({})
              }),
              ...ap({
                ...t.fireRepositionEventInstead.map((L) => ({ fireEventInstead: { event: L.event } })).getOr({}),
                doReposition: D
              })
            }
          })
        ]),
        eventOrder: t.eventOrder,
        apis: P
      };
    }, qr = gl({
      name: "InlineView",
      configFields: [
        gt("lazySink"),
        gs("onShow"),
        gs("onHide"),
        bm("onEscape"),
        za("inlineBehaviours", [
          is,
          ln,
          Wi
        ]),
        ui("fireDismissalEventInstead", [Ne("event", bf())]),
        ui("fireRepositionEventInstead", [Ne("event", Pw())]),
        Ne("getRelated", A.none),
        Ne("isExtraPart", Te),
        Ne("eventOrder", A.none)
      ],
      factory: e6,
      apis: {
        showAt: (t, s, a, i) => {
          t.showAt(s, a, i);
        },
        showWithinBounds: (t, s, a, i, d) => {
          t.showWithinBounds(s, a, i, d);
        },
        showMenuAt: (t, s, a, i) => {
          t.showMenuAt(s, a, i);
        },
        showMenuWithinBounds: (t, s, a, i, d) => {
          t.showMenuWithinBounds(s, a, i, d);
        },
        hide: (t, s) => {
          t.hide(s);
        },
        isOpen: (t, s) => t.isOpen(s),
        getContent: (t, s) => t.getContent(s),
        setContent: (t, s, a) => {
          t.setContent(s, a);
        },
        reposition: (t, s) => {
          t.reposition(s);
        }
      }
    });
    var bb = tinymce.util.Tools.resolve("tinymce.util.Delay");
    const Ec = gl({
      name: "Button",
      factory: (t) => {
        const s = zm(t.action), a = t.dom.tag, i = (g) => Dt(t.dom, "attributes").bind((p) => Dt(p, g)), d = () => {
          if (a === "button") {
            const g = i("type").getOr("button"), p = i("role").map((C) => ({ role: C })).getOr({});
            return {
              type: g,
              ...p
            };
          } else
            return { role: t.role.getOr(i("role").getOr("button")) };
        };
        return {
          uid: t.uid,
          dom: t.dom,
          components: t.components,
          events: s,
          behaviours: lu.augment(t.buttonBehaviours, [
            po.config({}),
            no.config({
              mode: "execution",
              useSpace: !0,
              useEnter: !0
            })
          ]),
          domModification: { attributes: d() },
          eventOrder: t.eventOrder
        };
      },
      configFields: [
        Ne("uid", void 0),
        gt("dom"),
        Ne("components", []),
        lu.field("buttonBehaviours", [
          po,
          no
        ]),
        $s("action"),
        $s("role"),
        Ne("eventOrder", {})
      ]
    }), t6 = (t) => {
      const s = t.dom.attributes !== void 0 ? t.dom.attributes : [];
      return lt(s, (a, i) => i.name === "class" ? a : {
        ...a,
        [i.name]: i.value
      }, {});
    }, n6 = (t) => Array.prototype.slice.call(t.dom.classList, 0), Ug = (t) => {
      const s = ve.fromHtml(t), a = ja(s), i = t6(s), d = n6(s), g = a.length === 0 ? {} : { innerHtml: Ay(s) };
      return {
        tag: Ds(s),
        classes: d,
        attributes: i,
        ...g
      };
    }, js = (t) => {
      const s = V_(t) && Or(t, "uid") ? t.uid : xh("memento");
      return {
        get: (g) => g.getSystem().getByUid(s).getOrDie(),
        getOpt: (g) => g.getSystem().getByUid(s).toOptional(),
        asSpec: () => ({
          ...t,
          uid: s
        })
      };
    };
    /*! @license DOMPurify 3.1.7 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.1.7/LICENSE */
    const {
      entries: wA,
      setPrototypeOf: SA,
      isFrozen: o6,
      getPrototypeOf: s6,
      getOwnPropertyDescriptor: r6
    } = Object;
    let {
      freeze: du,
      seal: Yd,
      create: QR
    } = Object, {
      apply: Ex,
      construct: xA
    } = typeof Reflect < "u" && Reflect;
    du || (du = function(s) {
      return s;
    }), Yd || (Yd = function(s) {
      return s;
    }), Ex || (Ex = function(s, a, i) {
      return s.apply(a, i);
    }), xA || (xA = function(s, a) {
      return new s(...a);
    });
    const kx = bd(Array.prototype.forEach), eN = bd(Array.prototype.pop), i2 = bd(Array.prototype.push), _x = bd(String.prototype.toLowerCase), Wg = bd(String.prototype.toString), tN = bd(String.prototype.match), l2 = bd(String.prototype.replace), vb = bd(String.prototype.indexOf), nN = bd(String.prototype.trim), Vm = bd(Object.prototype.hasOwnProperty), Vc = bd(RegExp.prototype.test), u2 = vd(TypeError);
    function bd(t) {
      return function(s) {
        for (var a = arguments.length, i = new Array(a > 1 ? a - 1 : 0), d = 1; d < a; d++)
          i[d - 1] = arguments[d];
        return Ex(t, s, i);
      };
    }
    function vd(t) {
      return function() {
        for (var s = arguments.length, a = new Array(s), i = 0; i < s; i++)
          a[i] = arguments[i];
        return xA(t, a);
      };
    }
    function yr(t, s) {
      let a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : _x;
      SA && SA(t, null);
      let i = s.length;
      for (; i--; ) {
        let d = s[i];
        if (typeof d == "string") {
          const g = a(d);
          g !== d && (o6(s) || (s[i] = g), d = g);
        }
        t[d] = !0;
      }
      return t;
    }
    function oN(t) {
      for (let s = 0; s < t.length; s++)
        Vm(t, s) || (t[s] = null);
      return t;
    }
    function wp(t) {
      const s = QR(null);
      for (const [a, i] of wA(t))
        Vm(t, a) && (Array.isArray(i) ? s[a] = oN(i) : i && typeof i == "object" && i.constructor === Object ? s[a] = wp(i) : s[a] = i);
      return s;
    }
    function d2(t, s) {
      for (; t !== null; ) {
        const i = r6(t, s);
        if (i) {
          if (i.get)
            return bd(i.get);
          if (typeof i.value == "function")
            return bd(i.value);
        }
        t = s6(t);
      }
      function a() {
        return null;
      }
      return a;
    }
    const Ax = du(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), TA = du(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), EA = du(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), a6 = du(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), pv = du(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), kA = du(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), _A = du(["#text"]), AA = du(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), Ox = du(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), sN = du(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), Dx = du(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), rN = Yd(/\{\{[\w\W]*|[\w\W]*\}\}/gm), c6 = Yd(/<%[\w\W]*|[\w\W]*%>/gm), OA = Yd(/\${[\w\W]*}/gm), aN = Yd(/^data-[\-\w.\u00B7-\uFFFF]/), i6 = Yd(/^aria-[\-\w]+$/), cN = Yd(
      /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
      // eslint-disable-line no-useless-escape
    ), l6 = Yd(/^(?:\w+script|data):/i), DA = Yd(
      /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
      // eslint-disable-line no-control-regex
    ), iN = Yd(/^html$/i), m2 = Yd(/^[a-z][.\w]*(-[.\w]+)+$/i);
    var f2 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      MUSTACHE_EXPR: rN,
      ERB_EXPR: c6,
      TMPLIT_EXPR: OA,
      DATA_ATTR: aN,
      ARIA_ATTR: i6,
      IS_ALLOWED_URI: cN,
      IS_SCRIPT_OR_DATA: l6,
      ATTR_WHITESPACE: DA,
      DOCTYPE_NAME: iN,
      CUSTOM_ELEMENT: m2
    });
    const bv = {
      element: 1,
      text: 3,
      // Deprecated
      progressingInstruction: 7,
      comment: 8,
      document: 9
    }, lN = function() {
      return typeof window > "u" ? null : window;
    }, u6 = function(s, a) {
      if (typeof s != "object" || typeof s.createPolicy != "function")
        return null;
      let i = null;
      const d = "data-tt-policy-suffix";
      a && a.hasAttribute(d) && (i = a.getAttribute(d));
      const g = "dompurify" + (i ? "#" + i : "");
      try {
        return s.createPolicy(g, {
          createHTML(p) {
            return p;
          },
          createScriptURL(p) {
            return p;
          }
        });
      } catch {
        return null;
      }
    };
    function uN() {
      let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : lN();
      const s = (os) => uN(os);
      if (s.version = "3.1.7", s.removed = [], !t || !t.document || t.document.nodeType !== bv.document)
        return s.isSupported = !1, s;
      let {
        document: a
      } = t;
      const i = a, d = i.currentScript, {
        DocumentFragment: g,
        HTMLTemplateElement: p,
        Node: C,
        Element: S,
        NodeFilter: _,
        NamedNodeMap: D = t.NamedNodeMap || t.MozNamedAttrMap,
        HTMLFormElement: P,
        DOMParser: L,
        trustedTypes: V
      } = t, Y = S.prototype, me = d2(Y, "cloneNode"), Pe = d2(Y, "remove"), xe = d2(Y, "nextSibling"), Ce = d2(Y, "childNodes"), Be = d2(Y, "parentNode");
      if (typeof p == "function") {
        const os = a.createElement("template");
        os.content && os.content.ownerDocument && (a = os.content.ownerDocument);
      }
      let St, ct = "";
      const {
        implementation: tt,
        createNodeIterator: Vt,
        createDocumentFragment: Xt,
        getElementsByTagName: $o
      } = a, {
        importNode: Hn
      } = i;
      let co = {};
      s.isSupported = typeof wA == "function" && typeof Be == "function" && tt && tt.createHTMLDocument !== void 0;
      const {
        MUSTACHE_EXPR: bo,
        ERB_EXPR: zs,
        TMPLIT_EXPR: ro,
        DATA_ATTR: ys,
        ARIA_ATTR: Jt,
        IS_SCRIPT_OR_DATA: Fn,
        ATTR_WHITESPACE: So,
        CUSTOM_ELEMENT: ns
      } = f2;
      let {
        IS_ALLOWED_URI: uo
      } = f2, Ro = null;
      const ur = yr({}, [...Ax, ...TA, ...EA, ...pv, ..._A]);
      let Bs = null;
      const Pi = yr({}, [...AA, ...Ox, ...sN, ...Dx]);
      let Hr = Object.seal(QR(null, {
        tagNameCheck: {
          writable: !0,
          configurable: !1,
          enumerable: !0,
          value: null
        },
        attributeNameCheck: {
          writable: !0,
          configurable: !1,
          enumerable: !0,
          value: null
        },
        allowCustomizedBuiltInElements: {
          writable: !0,
          configurable: !1,
          enumerable: !0,
          value: !1
        }
      })), Yl = null, im = null, Jp = !0, Qp = !0, jb = !1, mk = !0, e1 = !1, L4 = !0, qb = !1, H4 = !1, ij = !1, fk = !1, HI = !1, zI = !1, Eq = !0, kq = !1;
      const eY = "user-content-";
      let lj = !0, z4 = !1, gk = {}, hk = null;
      const _q = yr({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
      let Aq = null;
      const Oq = yr({}, ["audio", "video", "img", "source", "image", "track"]);
      let uj = null;
      const Dq = yr({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), VI = "http://www.w3.org/1998/Math/MathML", UI = "http://www.w3.org/2000/svg", Gb = "http://www.w3.org/1999/xhtml";
      let pk = Gb, dj = !1, mj = null;
      const tY = yr({}, [VI, UI, Gb], Wg);
      let V4 = null;
      const nY = ["application/xhtml+xml", "text/html"], oY = "text/html";
      let Xl = null, bk = null;
      const sY = a.createElement("form"), Rq = function(Ke) {
        return Ke instanceof RegExp || Ke instanceof Function;
      }, fj = function() {
        let Ke = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (!(bk && bk === Ke)) {
          if ((!Ke || typeof Ke != "object") && (Ke = {}), Ke = wp(Ke), V4 = // eslint-disable-next-line unicorn/prefer-includes
          nY.indexOf(Ke.PARSER_MEDIA_TYPE) === -1 ? oY : Ke.PARSER_MEDIA_TYPE, Xl = V4 === "application/xhtml+xml" ? Wg : _x, Ro = Vm(Ke, "ALLOWED_TAGS") ? yr({}, Ke.ALLOWED_TAGS, Xl) : ur, Bs = Vm(Ke, "ALLOWED_ATTR") ? yr({}, Ke.ALLOWED_ATTR, Xl) : Pi, mj = Vm(Ke, "ALLOWED_NAMESPACES") ? yr({}, Ke.ALLOWED_NAMESPACES, Wg) : tY, uj = Vm(Ke, "ADD_URI_SAFE_ATTR") ? yr(
            wp(Dq),
            // eslint-disable-line indent
            Ke.ADD_URI_SAFE_ATTR,
            // eslint-disable-line indent
            Xl
            // eslint-disable-line indent
          ) : Dq, Aq = Vm(Ke, "ADD_DATA_URI_TAGS") ? yr(
            wp(Oq),
            // eslint-disable-line indent
            Ke.ADD_DATA_URI_TAGS,
            // eslint-disable-line indent
            Xl
            // eslint-disable-line indent
          ) : Oq, hk = Vm(Ke, "FORBID_CONTENTS") ? yr({}, Ke.FORBID_CONTENTS, Xl) : _q, Yl = Vm(Ke, "FORBID_TAGS") ? yr({}, Ke.FORBID_TAGS, Xl) : {}, im = Vm(Ke, "FORBID_ATTR") ? yr({}, Ke.FORBID_ATTR, Xl) : {}, gk = Vm(Ke, "USE_PROFILES") ? Ke.USE_PROFILES : !1, Jp = Ke.ALLOW_ARIA_ATTR !== !1, Qp = Ke.ALLOW_DATA_ATTR !== !1, jb = Ke.ALLOW_UNKNOWN_PROTOCOLS || !1, mk = Ke.ALLOW_SELF_CLOSE_IN_ATTR !== !1, e1 = Ke.SAFE_FOR_TEMPLATES || !1, L4 = Ke.SAFE_FOR_XML !== !1, qb = Ke.WHOLE_DOCUMENT || !1, fk = Ke.RETURN_DOM || !1, HI = Ke.RETURN_DOM_FRAGMENT || !1, zI = Ke.RETURN_TRUSTED_TYPE || !1, ij = Ke.FORCE_BODY || !1, Eq = Ke.SANITIZE_DOM !== !1, kq = Ke.SANITIZE_NAMED_PROPS || !1, lj = Ke.KEEP_CONTENT !== !1, z4 = Ke.IN_PLACE || !1, uo = Ke.ALLOWED_URI_REGEXP || cN, pk = Ke.NAMESPACE || Gb, Hr = Ke.CUSTOM_ELEMENT_HANDLING || {}, Ke.CUSTOM_ELEMENT_HANDLING && Rq(Ke.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (Hr.tagNameCheck = Ke.CUSTOM_ELEMENT_HANDLING.tagNameCheck), Ke.CUSTOM_ELEMENT_HANDLING && Rq(Ke.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (Hr.attributeNameCheck = Ke.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), Ke.CUSTOM_ELEMENT_HANDLING && typeof Ke.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (Hr.allowCustomizedBuiltInElements = Ke.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), e1 && (Qp = !1), HI && (fk = !0), gk && (Ro = yr({}, _A), Bs = [], gk.html === !0 && (yr(Ro, Ax), yr(Bs, AA)), gk.svg === !0 && (yr(Ro, TA), yr(Bs, Ox), yr(Bs, Dx)), gk.svgFilters === !0 && (yr(Ro, EA), yr(Bs, Ox), yr(Bs, Dx)), gk.mathMl === !0 && (yr(Ro, pv), yr(Bs, sN), yr(Bs, Dx))), Ke.ADD_TAGS && (Ro === ur && (Ro = wp(Ro)), yr(Ro, Ke.ADD_TAGS, Xl)), Ke.ADD_ATTR && (Bs === Pi && (Bs = wp(Bs)), yr(Bs, Ke.ADD_ATTR, Xl)), Ke.ADD_URI_SAFE_ATTR && yr(uj, Ke.ADD_URI_SAFE_ATTR, Xl), Ke.FORBID_CONTENTS && (hk === _q && (hk = wp(hk)), yr(hk, Ke.FORBID_CONTENTS, Xl)), lj && (Ro["#text"] = !0), qb && yr(Ro, ["html", "head", "body"]), Ro.table && (yr(Ro, ["tbody"]), delete Yl.tbody), Ke.TRUSTED_TYPES_POLICY) {
            if (typeof Ke.TRUSTED_TYPES_POLICY.createHTML != "function")
              throw u2('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
            if (typeof Ke.TRUSTED_TYPES_POLICY.createScriptURL != "function")
              throw u2('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
            St = Ke.TRUSTED_TYPES_POLICY, ct = St.createHTML("");
          } else
            St === void 0 && (St = u6(V, d)), St !== null && typeof ct == "string" && (ct = St.createHTML(""));
          du && du(Ke), bk = Ke;
        }
      }, Nq = yr({}, ["mi", "mo", "mn", "ms", "mtext"]), Mq = yr({}, ["annotation-xml"]), rY = yr({}, ["title", "style", "font", "a", "script"]), Pq = yr({}, [...TA, ...EA, ...a6]), Bq = yr({}, [...pv, ...kA]), aY = function(Ke) {
        let Qn = Be(Ke);
        (!Qn || !Qn.tagName) && (Qn = {
          namespaceURI: pk,
          tagName: "template"
        });
        const Zo = _x(Ke.tagName), bc = _x(Qn.tagName);
        return mj[Ke.namespaceURI] ? Ke.namespaceURI === UI ? Qn.namespaceURI === Gb ? Zo === "svg" : Qn.namespaceURI === VI ? Zo === "svg" && (bc === "annotation-xml" || Nq[bc]) : !!Pq[Zo] : Ke.namespaceURI === VI ? Qn.namespaceURI === Gb ? Zo === "math" : Qn.namespaceURI === UI ? Zo === "math" && Mq[bc] : !!Bq[Zo] : Ke.namespaceURI === Gb ? Qn.namespaceURI === UI && !Mq[bc] || Qn.namespaceURI === VI && !Nq[bc] ? !1 : !Bq[Zo] && (rY[Zo] || !Pq[Zo]) : !!(V4 === "application/xhtml+xml" && mj[Ke.namespaceURI]) : !1;
      }, t1 = function(Ke) {
        i2(s.removed, {
          element: Ke
        });
        try {
          Be(Ke).removeChild(Ke);
        } catch {
          Pe(Ke);
        }
      }, U4 = function(Ke, Qn) {
        try {
          i2(s.removed, {
            attribute: Qn.getAttributeNode(Ke),
            from: Qn
          });
        } catch {
          i2(s.removed, {
            attribute: null,
            from: Qn
          });
        }
        if (Qn.removeAttribute(Ke), Ke === "is" && !Bs[Ke])
          if (fk || HI)
            try {
              t1(Qn);
            } catch {
            }
          else
            try {
              Qn.setAttribute(Ke, "");
            } catch {
            }
      }, $q = function(Ke) {
        let Qn = null, Zo = null;
        if (ij)
          Ke = "<remove></remove>" + Ke;
        else {
          const Jl = tN(Ke, /^[\r\n\t ]+/);
          Zo = Jl && Jl[0];
        }
        V4 === "application/xhtml+xml" && pk === Gb && (Ke = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + Ke + "</body></html>");
        const bc = St ? St.createHTML(Ke) : Ke;
        if (pk === Gb)
          try {
            Qn = new L().parseFromString(bc, V4);
          } catch {
          }
        if (!Qn || !Qn.documentElement) {
          Qn = tt.createDocument(pk, "template", null);
          try {
            Qn.documentElement.innerHTML = dj ? ct : bc;
          } catch {
          }
        }
        const Xu = Qn.body || Qn.documentElement;
        return Ke && Zo && Xu.insertBefore(a.createTextNode(Zo), Xu.childNodes[0] || null), pk === Gb ? $o.call(Qn, qb ? "html" : "body")[0] : qb ? Qn.documentElement : Xu;
      }, Fq = function(Ke) {
        return Vt.call(
          Ke.ownerDocument || Ke,
          Ke,
          // eslint-disable-next-line no-bitwise
          _.SHOW_ELEMENT | _.SHOW_COMMENT | _.SHOW_TEXT | _.SHOW_PROCESSING_INSTRUCTION | _.SHOW_CDATA_SECTION,
          null
        );
      }, Iq = function(Ke) {
        return Ke instanceof P && (typeof Ke.nodeName != "string" || typeof Ke.textContent != "string" || typeof Ke.removeChild != "function" || !(Ke.attributes instanceof D) || typeof Ke.removeAttribute != "function" || typeof Ke.setAttribute != "function" || typeof Ke.namespaceURI != "string" || typeof Ke.insertBefore != "function" || typeof Ke.hasChildNodes != "function");
      }, Lq = function(Ke) {
        return typeof C == "function" && Ke instanceof C;
      }, Kb = function(Ke, Qn, Zo) {
        co[Ke] && kx(co[Ke], (bc) => {
          bc.call(s, Qn, Zo, bk);
        });
      }, Hq = function(Ke) {
        let Qn = null;
        if (Kb("beforeSanitizeElements", Ke, null), Iq(Ke))
          return t1(Ke), !0;
        const Zo = Xl(Ke.nodeName);
        if (Kb("uponSanitizeElement", Ke, {
          tagName: Zo,
          allowedTags: Ro
        }), Ke.hasChildNodes() && !Lq(Ke.firstElementChild) && Vc(/<[/\w]/g, Ke.innerHTML) && Vc(/<[/\w]/g, Ke.textContent) || Ke.nodeType === bv.progressingInstruction || L4 && Ke.nodeType === bv.comment && Vc(/<[/\w]/g, Ke.data))
          return t1(Ke), !0;
        if (!Ro[Zo] || Yl[Zo]) {
          if (!Yl[Zo] && Vq(Zo) && (Hr.tagNameCheck instanceof RegExp && Vc(Hr.tagNameCheck, Zo) || Hr.tagNameCheck instanceof Function && Hr.tagNameCheck(Zo)))
            return !1;
          if (lj && !hk[Zo]) {
            const bc = Be(Ke) || Ke.parentNode, Xu = Ce(Ke) || Ke.childNodes;
            if (Xu && bc) {
              const Jl = Xu.length;
              for (let lm = Jl - 1; lm >= 0; --lm) {
                const n1 = me(Xu[lm], !0);
                n1.__removalCount = (Ke.__removalCount || 0) + 1, bc.insertBefore(n1, xe(Ke));
              }
            }
          }
          return t1(Ke), !0;
        }
        return Ke instanceof S && !aY(Ke) || (Zo === "noscript" || Zo === "noembed" || Zo === "noframes") && Vc(/<\/no(script|embed|frames)/i, Ke.innerHTML) ? (t1(Ke), !0) : (e1 && Ke.nodeType === bv.text && (Qn = Ke.textContent, kx([bo, zs, ro], (bc) => {
          Qn = l2(Qn, bc, " ");
        }), Ke.textContent !== Qn && (i2(s.removed, {
          element: Ke.cloneNode()
        }), Ke.textContent = Qn)), Kb("afterSanitizeElements", Ke, null), !1);
      }, zq = function(Ke, Qn, Zo) {
        if (Eq && (Qn === "id" || Qn === "name") && (Zo in a || Zo in sY))
          return !1;
        if (!(Qp && !im[Qn] && Vc(ys, Qn))) {
          if (!(Jp && Vc(Jt, Qn))) {
            if (!Bs[Qn] || im[Qn]) {
              if (
                // First condition does a very basic check if a) it's basically a valid custom element tagname AND
                // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
                // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
                !(Vq(Ke) && (Hr.tagNameCheck instanceof RegExp && Vc(Hr.tagNameCheck, Ke) || Hr.tagNameCheck instanceof Function && Hr.tagNameCheck(Ke)) && (Hr.attributeNameCheck instanceof RegExp && Vc(Hr.attributeNameCheck, Qn) || Hr.attributeNameCheck instanceof Function && Hr.attributeNameCheck(Qn)) || // Alternative, second condition checks if it's an `is`-attribute, AND
                // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
                Qn === "is" && Hr.allowCustomizedBuiltInElements && (Hr.tagNameCheck instanceof RegExp && Vc(Hr.tagNameCheck, Zo) || Hr.tagNameCheck instanceof Function && Hr.tagNameCheck(Zo)))
              ) return !1;
            } else if (!uj[Qn]) {
              if (!Vc(uo, l2(Zo, So, ""))) {
                if (!((Qn === "src" || Qn === "xlink:href" || Qn === "href") && Ke !== "script" && vb(Zo, "data:") === 0 && Aq[Ke])) {
                  if (!(jb && !Vc(Fn, l2(Zo, So, "")))) {
                    if (Zo)
                      return !1;
                  }
                }
              }
            }
          }
        }
        return !0;
      }, Vq = function(Ke) {
        return Ke !== "annotation-xml" && tN(Ke, ns);
      }, Uq = function(Ke) {
        Kb("beforeSanitizeAttributes", Ke, null);
        const {
          attributes: Qn
        } = Ke;
        if (!Qn)
          return;
        const Zo = {
          attrName: "",
          attrValue: "",
          keepAttr: !0,
          allowedAttributes: Bs
        };
        let bc = Qn.length;
        for (; bc--; ) {
          const Xu = Qn[bc], {
            name: Jl,
            namespaceURI: lm,
            value: n1
          } = Xu, W4 = Xl(Jl);
          let bu = Jl === "value" ? n1 : nN(n1);
          const iY = bu;
          if (Zo.attrName = W4, Zo.attrValue = bu, Zo.keepAttr = !0, Zo.forceKeepAttr = void 0, Kb("uponSanitizeAttribute", Ke, Zo), bu = Zo.attrValue, Zo.forceKeepAttr)
            continue;
          if (!Zo.keepAttr) {
            U4(Jl, Ke);
            continue;
          }
          if (!mk && Vc(/\/>/i, bu)) {
            U4(Jl, Ke);
            continue;
          }
          e1 && kx([bo, zs, ro], (Zq) => {
            bu = l2(bu, Zq, " ");
          });
          const Wq = Xl(Ke.nodeName);
          if (!zq(Wq, W4, bu)) {
            U4(Jl, Ke);
            continue;
          }
          if (kq && (W4 === "id" || W4 === "name") && (U4(Jl, Ke), bu = eY + bu), L4 && Vc(/((--!?|])>)|<\/(style|title)/i, bu)) {
            U4(Jl, Ke);
            continue;
          }
          if (St && typeof V == "object" && typeof V.getAttributeType == "function" && !lm)
            switch (V.getAttributeType(Wq, W4)) {
              case "TrustedHTML": {
                bu = St.createHTML(bu);
                break;
              }
              case "TrustedScriptURL": {
                bu = St.createScriptURL(bu);
                break;
              }
            }
          if (bu !== iY)
            try {
              lm ? Ke.setAttributeNS(lm, Jl, bu) : Ke.setAttribute(Jl, bu), Iq(Ke) ? t1(Ke) : eN(s.removed);
            } catch {
            }
        }
        Kb("afterSanitizeAttributes", Ke, null);
      }, cY = function os(Ke) {
        let Qn = null;
        const Zo = Fq(Ke);
        for (Kb("beforeSanitizeShadowDOM", Ke, null); Qn = Zo.nextNode(); )
          Kb("uponSanitizeShadowNode", Qn, null), !Hq(Qn) && (Qn.content instanceof g && os(Qn.content), Uq(Qn));
        Kb("afterSanitizeShadowDOM", Ke, null);
      };
      return s.sanitize = function(os) {
        let Ke = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, Qn = null, Zo = null, bc = null, Xu = null;
        if (dj = !os, dj && (os = "<!-->"), typeof os != "string" && !Lq(os))
          if (typeof os.toString == "function") {
            if (os = os.toString(), typeof os != "string")
              throw u2("dirty is not a string, aborting");
          } else
            throw u2("toString is not a function");
        if (!s.isSupported)
          return os;
        if (H4 || fj(Ke), s.removed = [], typeof os == "string" && (z4 = !1), z4) {
          if (os.nodeName) {
            const n1 = Xl(os.nodeName);
            if (!Ro[n1] || Yl[n1])
              throw u2("root node is forbidden and cannot be sanitized in-place");
          }
        } else if (os instanceof C)
          Qn = $q("<!---->"), Zo = Qn.ownerDocument.importNode(os, !0), Zo.nodeType === bv.element && Zo.nodeName === "BODY" || Zo.nodeName === "HTML" ? Qn = Zo : Qn.appendChild(Zo);
        else {
          if (!fk && !e1 && !qb && // eslint-disable-next-line unicorn/prefer-includes
          os.indexOf("<") === -1)
            return St && zI ? St.createHTML(os) : os;
          if (Qn = $q(os), !Qn)
            return fk ? null : zI ? ct : "";
        }
        Qn && ij && t1(Qn.firstChild);
        const Jl = Fq(z4 ? os : Qn);
        for (; bc = Jl.nextNode(); )
          Hq(bc) || (bc.content instanceof g && cY(bc.content), Uq(bc));
        if (z4)
          return os;
        if (fk) {
          if (HI)
            for (Xu = Xt.call(Qn.ownerDocument); Qn.firstChild; )
              Xu.appendChild(Qn.firstChild);
          else
            Xu = Qn;
          return (Bs.shadowroot || Bs.shadowrootmode) && (Xu = Hn.call(i, Xu, !0)), Xu;
        }
        let lm = qb ? Qn.outerHTML : Qn.innerHTML;
        return qb && Ro["!doctype"] && Qn.ownerDocument && Qn.ownerDocument.doctype && Qn.ownerDocument.doctype.name && Vc(iN, Qn.ownerDocument.doctype.name) && (lm = "<!DOCTYPE " + Qn.ownerDocument.doctype.name + `>
` + lm), e1 && kx([bo, zs, ro], (n1) => {
          lm = l2(lm, n1, " ");
        }), St && zI ? St.createHTML(lm) : lm;
      }, s.setConfig = function() {
        let os = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        fj(os), H4 = !0;
      }, s.clearConfig = function() {
        bk = null, H4 = !1;
      }, s.isValidAttribute = function(os, Ke, Qn) {
        bk || fj({});
        const Zo = Xl(os), bc = Xl(Ke);
        return zq(Zo, bc, Qn);
      }, s.addHook = function(os, Ke) {
        typeof Ke == "function" && (co[os] = co[os] || [], i2(co[os], Ke));
      }, s.removeHook = function(os) {
        if (co[os])
          return eN(co[os]);
      }, s.removeHooks = function(os) {
        co[os] && (co[os] = []);
      }, s.removeAllHooks = function() {
        co = {};
      }, s;
    }
    var d6 = uN();
    const dN = (t) => d6().sanitize(t);
    var Vl = tinymce.util.Tools.resolve("tinymce.util.I18n");
    const mN = {
      indent: !0,
      outdent: !0,
      "table-insert-column-after": !0,
      "table-insert-column-before": !0,
      "paste-column-after": !0,
      "paste-column-before": !0,
      "unordered-list": !0,
      "list-bull-circle": !0,
      "list-bull-default": !0,
      "list-bull-square": !0
    }, RA = "temporary-placeholder", g2 = (t) => () => Dt(t, RA).getOr("!not found!"), NA = (t, s) => {
      const a = t.toLowerCase();
      if (Vl.isRtl()) {
        const i = sr(a, "-rtl");
        return Lo(s, i) ? i : a;
      } else
        return a;
    }, MA = (t, s) => Dt(s, NA(t, s)), fN = (t, s) => {
      const a = s();
      return MA(t, a).getOrThunk(g2(a));
    }, m6 = (t, s, a) => {
      const i = s();
      return MA(t, i).or(a).getOrThunk(g2(i));
    }, f6 = (t) => Vl.isRtl() ? Lo(mN, t) : !1, Rx = () => Bo("add-focusable", [cr((t) => {
      w0(t.element, "svg").each((s) => sn(s, "focusable", "false"));
    })]), gN = (t, s, a, i) => {
      var d, g;
      const p = f6(s) ? ["tox-icon--flip"] : [], C = Dt(a, NA(s, a)).or(i).getOrThunk(g2(a));
      return {
        dom: {
          tag: t.tag,
          attributes: (d = t.attributes) !== null && d !== void 0 ? d : {},
          classes: t.classes.concat(p),
          innerHtml: C
        },
        behaviours: Ut([
          ...(g = t.behaviours) !== null && g !== void 0 ? g : [],
          Rx()
        ])
      };
    }, Xd = (t, s, a, i = A.none()) => gN(s, t, a(), i), PA = (t, s, a) => {
      const i = a(), d = ee(t, (g) => Lo(i, NA(g, i)));
      return gN(s, d.getOr(RA), i, A.none());
    }, hN = {
      success: "checkmark",
      error: "warning",
      err: "error",
      warning: "warning",
      warn: "warning",
      info: "info"
    }, BA = gl({
      name: "Notification",
      factory: (t) => {
        const s = js({
          dom: Ug(`<p>${dN(t.translationProvider(t.text))}</p>`),
          behaviours: Ut([Oo.config({})])
        }), a = (V) => ({
          dom: {
            tag: "div",
            classes: ["tox-bar"],
            styles: { width: `${V}%` }
          }
        }), i = (V) => ({
          dom: {
            tag: "div",
            classes: ["tox-text"],
            innerHtml: `${V}%`
          }
        }), d = js({
          dom: {
            tag: "div",
            classes: t.progress ? [
              "tox-progress-bar",
              "tox-progress-indicator"
            ] : ["tox-progress-bar"]
          },
          components: [
            {
              dom: {
                tag: "div",
                classes: ["tox-bar-container"]
              },
              components: [a(0)]
            },
            i(0)
          ],
          behaviours: Ut([Oo.config({})])
        }), C = {
          updateProgress: (V, Y) => {
            V.getSystem().isConnected() && d.getOpt(V).each((me) => {
              Oo.set(me, [
                {
                  dom: {
                    tag: "div",
                    classes: ["tox-bar-container"]
                  },
                  components: [a(Y)]
                },
                i(Y)
              ]);
            });
          },
          updateText: (V, Y) => {
            if (V.getSystem().isConnected()) {
              const me = s.get(V);
              Oo.set(me, [da(Y)]);
            }
          }
        }, S = ye([
          t.icon.toArray(),
          t.level.toArray(),
          t.level.bind((V) => A.from(hN[V])).toArray()
        ]), _ = js(Ec.sketch({
          dom: {
            tag: "button",
            classes: [
              "tox-notification__dismiss",
              "tox-button",
              "tox-button--naked",
              "tox-button--icon"
            ]
          },
          components: [Xd("close", {
            tag: "span",
            classes: ["tox-icon"],
            attributes: { "aria-label": t.translationProvider("Close") }
          }, t.iconProvider)],
          action: (V) => {
            t.onAction(V);
          }
        })), D = PA(S, {
          tag: "div",
          classes: ["tox-notification__icon"]
        }, t.iconProvider), P = {
          dom: {
            tag: "div",
            classes: ["tox-notification__body"]
          },
          components: [s.asSpec()],
          behaviours: Ut([Oo.config({})])
        }, L = [
          D,
          P
        ];
        return {
          uid: t.uid,
          dom: {
            tag: "div",
            attributes: { role: "alert" },
            classes: t.level.map((V) => [
              "tox-notification",
              "tox-notification--in",
              `tox-notification--${V}`
            ]).getOr([
              "tox-notification",
              "tox-notification--in"
            ])
          },
          behaviours: Ut([
            po.config({}),
            Bo("notification-events", [mt($c(), (V) => {
              _.getOpt(V).each(po.focus);
            })])
          ]),
          components: L.concat(t.progress ? [d.asSpec()] : []).concat(t.closeButton ? [_.asSpec()] : []),
          apis: C
        };
      },
      configFields: [
        $s("level"),
        gt("progress"),
        $s("icon"),
        gt("onAction"),
        gt("text"),
        gt("iconProvider"),
        gt("translationProvider"),
        Pa("closeButton", !0)
      ],
      apis: {
        updateProgress: (t, s, a) => {
          t.updateProgress(s, a);
        },
        updateText: (t, s, a) => {
          t.updateText(s, a);
        }
      }
    });
    var $A = (t, s, a) => {
      const i = s.backstage.shared, d = () => {
        const S = Ar(ve.fromDom(t.getContentAreaContainer())), _ = La(), D = Bl(_.x, S.x, S.right), P = Bl(_.y, S.y, S.bottom), L = Math.max(S.right, _.right), V = Math.max(S.bottom, _.bottom);
        return A.some(Rr(D, P, L - D, V - P));
      };
      return {
        open: (S, _) => {
          const D = () => {
            _(), qr.hide(L);
          }, P = Xc(BA.sketch({
            text: S.text,
            level: io([
              "success",
              "error",
              "warning",
              "warn",
              "info"
            ], S.type) ? S.type : void 0,
            progress: S.progressBar === !0,
            icon: S.icon,
            closeButton: S.closeButton,
            onAction: D,
            iconProvider: i.providers.icons,
            translationProvider: i.providers.translate
          })), L = Xc(qr.sketch({
            dom: {
              tag: "div",
              classes: ["tox-notifications-container"]
            },
            lazySink: i.getSink,
            fireDismissalEventInstead: {},
            ...i.header.isPositionedAtTop() ? {} : { fireRepositionEventInstead: {} }
          }));
          a.add(L), Pn(S.timeout) && S.timeout > 0 && bb.setEditorTimeout(t, () => {
            D();
          }, S.timeout);
          const Y = {
            close: D,
            reposition: () => {
              const me = Pl(P), Pe = { maxHeightFunction: jh() }, xe = t.notificationManager.getNotifications();
              if (xe[0] === Y) {
                const Ce = {
                  ...i.anchors.banner(),
                  overrides: Pe
                };
                qr.showWithinBounds(L, me, { anchor: Ce }, d);
              } else
                Ye(xe, Y).each((Ce) => {
                  const Be = xe[Ce - 1].getEl(), St = {
                    type: "node",
                    root: fr(),
                    node: A.some(ve.fromDom(Be)),
                    overrides: Pe,
                    layouts: {
                      onRtl: () => [ec],
                      onLtr: () => [ec]
                    }
                  };
                  qr.showWithinBounds(L, me, { anchor: St }, d);
                });
            },
            text: (me) => {
              BA.updateText(P, me);
            },
            settings: S,
            getEl: () => P.element.dom,
            progressBar: {
              value: (me) => {
                BA.updateProgress(P, me);
              }
            }
          };
          return Y;
        },
        close: (S) => {
          S.close();
        },
        getArgs: (S) => S.settings
      };
    }, vv = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils"), h6 = tinymce.util.Tools.resolve("tinymce.EditorManager"), yv = tinymce.util.Tools.resolve("tinymce.Env"), yd;
    (function(t) {
      t.default = "wrap", t.floating = "floating", t.sliding = "sliding", t.scrolling = "scrolling";
    })(yd || (yd = {}));
    var h2;
    (function(t) {
      t.auto = "auto", t.top = "top", t.bottom = "bottom";
    })(h2 || (h2 = {}));
    const lr = (t) => (s) => s.options.get(t), yb = (t) => (s) => A.from(t(s)), pN = (t) => {
      const s = yv.deviceType.isPhone(), a = yv.deviceType.isTablet() || s, i = t.options.register, d = (p) => Ee(p) || p === !1, g = (p) => Ee(p) || Pn(p);
      i("skin", {
        processor: (p) => Ee(p) || p === !1,
        default: "oxide"
      }), i("skin_url", { processor: "string" }), i("height", {
        processor: g,
        default: Math.max(t.getElement().offsetHeight, 400)
      }), i("width", {
        processor: g,
        default: vv.DOM.getStyle(t.getElement(), "width")
      }), i("min_height", {
        processor: "number",
        default: 100
      }), i("min_width", { processor: "number" }), i("max_height", { processor: "number" }), i("max_width", { processor: "number" }), i("style_formats", { processor: "object[]" }), i("style_formats_merge", {
        processor: "boolean",
        default: !1
      }), i("style_formats_autohide", {
        processor: "boolean",
        default: !1
      }), i("line_height_formats", {
        processor: "string",
        default: "1 1.1 1.2 1.3 1.4 1.5 2"
      }), i("font_family_formats", {
        processor: "string",
        default: "Andale Mono=andale mono,monospace;Arial=arial,helvetica,sans-serif;Arial Black=arial black,sans-serif;Book Antiqua=book antiqua,palatino,serif;Comic Sans MS=comic sans ms,sans-serif;Courier New=courier new,courier,monospace;Georgia=georgia,palatino,serif;Helvetica=helvetica,arial,sans-serif;Impact=impact,sans-serif;Symbol=symbol;Tahoma=tahoma,arial,helvetica,sans-serif;Terminal=terminal,monaco,monospace;Times New Roman=times new roman,times,serif;Trebuchet MS=trebuchet ms,geneva,sans-serif;Verdana=verdana,geneva,sans-serif;Webdings=webdings;Wingdings=wingdings,zapf dingbats"
      }), i("font_size_formats", {
        processor: "string",
        default: "8pt 10pt 12pt 14pt 18pt 24pt 36pt"
      }), i("font_size_input_default_unit", {
        processor: "string",
        default: "pt"
      }), i("block_formats", {
        processor: "string",
        default: "Paragraph=p;Heading 1=h1;Heading 2=h2;Heading 3=h3;Heading 4=h4;Heading 5=h5;Heading 6=h6;Preformatted=pre"
      }), i("content_langs", { processor: "object[]" }), i("removed_menuitems", {
        processor: "string",
        default: ""
      }), i("menubar", {
        processor: (p) => Ee(p) || Ft(p),
        default: !s
      }), i("menu", {
        processor: "object",
        default: {}
      }), i("toolbar", {
        processor: (p) => Ft(p) || Ee(p) || dn(p) ? {
          value: p,
          valid: !0
        } : {
          valid: !1,
          message: "Must be a boolean, string or array."
        },
        default: !0
      }), bt(9, (p) => {
        i("toolbar" + (p + 1), { processor: "string" });
      }), i("toolbar_mode", {
        processor: "string",
        default: a ? "scrolling" : "floating"
      }), i("toolbar_groups", {
        processor: "object",
        default: {}
      }), i("toolbar_location", {
        processor: "string",
        default: h2.auto
      }), i("toolbar_persist", {
        processor: "boolean",
        default: !1
      }), i("toolbar_sticky", {
        processor: "boolean",
        default: t.inline
      }), i("toolbar_sticky_offset", {
        processor: "number",
        default: 0
      }), i("fixed_toolbar_container", {
        processor: "string",
        default: ""
      }), i("fixed_toolbar_container_target", { processor: "object" }), i("ui_mode", {
        processor: "string",
        default: "combined"
      }), i("file_picker_callback", { processor: "function" }), i("file_picker_validator_handler", { processor: "function" }), i("file_picker_types", { processor: "string" }), i("typeahead_urls", {
        processor: "boolean",
        default: !0
      }), i("anchor_top", {
        processor: d,
        default: "#top"
      }), i("anchor_bottom", {
        processor: d,
        default: "#bottom"
      }), i("draggable_modal", {
        processor: "boolean",
        default: !1
      }), i("statusbar", {
        processor: "boolean",
        default: !0
      }), i("elementpath", {
        processor: "boolean",
        default: !0
      }), i("branding", {
        processor: "boolean",
        default: !0
      }), i("promotion", {
        processor: "boolean",
        default: !0
      }), i("resize", {
        processor: (p) => p === "both" || Ft(p),
        default: !yv.deviceType.isTouch()
      }), i("sidebar_show", { processor: "string" }), i("help_accessibility", {
        processor: "boolean",
        default: t.hasPlugin("help")
      }), i("default_font_stack", {
        processor: "string[]",
        default: []
      });
    }, p2 = lr("readonly"), FA = lr("height"), IA = lr("width"), LA = yb(lr("min_width")), HA = yb(lr("min_height")), Nx = yb(lr("max_width")), zA = yb(lr("max_height")), VA = yb(lr("style_formats")), bN = lr("style_formats_merge"), vN = lr("style_formats_autohide"), Mx = lr("content_langs"), Sp = lr("removed_menuitems"), Cv = lr("toolbar_mode"), yN = lr("toolbar_groups"), b2 = lr("toolbar_location"), CN = lr("fixed_toolbar_container"), p6 = lr("fixed_toolbar_container_target"), wN = lr("toolbar_persist"), UA = lr("toolbar_sticky_offset"), SN = lr("menubar"), v2 = lr("toolbar"), WA = lr("file_picker_callback"), Px = lr("file_picker_validator_handler"), xN = lr("font_size_input_default_unit"), ZA = lr("file_picker_types"), TN = lr("typeahead_urls"), wv = lr("anchor_top"), EN = lr("anchor_bottom"), kN = lr("draggable_modal"), Bx = lr("statusbar"), $x = lr("elementpath"), jA = lr("branding"), Fx = lr("resize"), _N = lr("paste_as_text"), AN = lr("sidebar_show"), Ix = lr("promotion"), ON = lr("help_accessibility"), DN = lr("default_font_stack"), qA = (t) => t.options.get("skin") === !1, Lx = (t) => t.options.get("menubar") !== !1, Hx = (t) => {
      const s = t.options.get("skin_url");
      if (qA(t))
        return s;
      if (s)
        return t.documentBaseURI.toAbsolute(s);
      {
        const a = t.options.get("skin");
        return h6.baseURL + "/skins/ui/" + a;
      }
    }, zx = (t) => A.from(t.options.get("skin_url")), RN = (t) => t.options.get("line_height_formats").split(" "), Vx = (t) => {
      const s = v2(t), a = Ee(s), i = dn(s) && s.length > 0;
      return !y2(t) && (i || a || s === !0);
    }, GA = (t) => {
      const s = bt(9, (i) => t.options.get("toolbar" + (i + 1))), a = fo(s, Ee);
      return Zn(a.length > 0, a);
    }, y2 = (t) => GA(t).fold(() => {
      const s = v2(t);
      return Kt(s, Ee) && s.length > 0;
    }, Oe), KA = (t) => b2(t) === h2.bottom, NN = (t) => {
      var s;
      if (!t.inline)
        return A.none();
      const a = (s = CN(t)) !== null && s !== void 0 ? s : "";
      if (a.length > 0)
        return va(fr(), a);
      const i = p6(t);
      return En(i) ? A.some(ve.fromDom(i)) : A.none();
    }, xp = (t) => t.inline && NN(t).isSome(), YA = (t) => NN(t).getOrThunk(() => Rt(Ve(ve.fromDom(t.getElement())))), XA = (t) => t.inline && !Lx(t) && !Vx(t) && !y2(t), C2 = (t) => (t.options.get("toolbar_sticky") || t.inline) && !xp(t) && !XA(t), Zg = (t) => !xp(t) && t.options.get("ui_mode") === "split", MN = (t) => {
      const s = t.options.get("menu");
      return et(s, (a) => ({
        ...a,
        items: a.items
      }));
    };
    var b6 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      get ToolbarMode() {
        return yd;
      },
      get ToolbarLocation() {
        return h2;
      },
      register: pN,
      getSkinUrl: Hx,
      getSkinUrlOption: zx,
      isReadOnly: p2,
      isSkinDisabled: qA,
      getHeightOption: FA,
      getWidthOption: IA,
      getMinWidthOption: LA,
      getMinHeightOption: HA,
      getMaxWidthOption: Nx,
      getMaxHeightOption: zA,
      getUserStyleFormats: VA,
      shouldMergeStyleFormats: bN,
      shouldAutoHideStyleFormats: vN,
      getLineHeightFormats: RN,
      getContentLanguages: Mx,
      getRemovedMenuItems: Sp,
      isMenubarEnabled: Lx,
      isMultipleToolbars: y2,
      isToolbarEnabled: Vx,
      isToolbarPersist: wN,
      getMultipleToolbarsOption: GA,
      getUiContainer: YA,
      useFixedContainer: xp,
      isSplitUiMode: Zg,
      getToolbarMode: Cv,
      isDraggableModal: kN,
      isDistractionFree: XA,
      isStickyToolbar: C2,
      getStickyToolbarOffset: UA,
      getToolbarLocation: b2,
      isToolbarLocationBottom: KA,
      getToolbarGroups: yN,
      getMenus: MN,
      getMenubar: SN,
      getToolbar: v2,
      getFilePickerCallback: WA,
      getFilePickerTypes: ZA,
      useTypeaheadUrls: TN,
      getAnchorTop: wv,
      getAnchorBottom: EN,
      getFilePickerValidatorHandler: Px,
      getFontSizeInputDefaultUnit: xN,
      useStatusBar: Bx,
      useElementPath: $x,
      promotionEnabled: Ix,
      useBranding: jA,
      getResize: Fx,
      getPasteAsText: _N,
      getSidebarShow: AN,
      useHelpAccessibility: ON,
      getDefaultFontStack: DN
    });
    const PN = "[data-mce-autocompleter]", BN = (t) => ld(t, PN), v6 = (t) => va(t, PN), JA = { setup: (t, s) => {
      const a = (d, g) => {
        to(d, Pu(), { raw: g });
      }, i = () => t.getMenu().bind(Ps.getHighlighted);
      s.on("keydown", (d) => {
        const g = d.which;
        t.isActive() && (t.isMenuOpen() ? g === 13 ? (i().each(Cm), d.preventDefault()) : g === 40 ? (i().fold(() => {
          t.getMenu().each(Ps.highlightFirst);
        }, (p) => {
          a(p, d);
        }), d.preventDefault(), d.stopImmediatePropagation()) : (g === 37 || g === 38 || g === 39) && i().each((p) => {
          a(p, d), d.preventDefault(), d.stopImmediatePropagation();
        }) : (g === 13 || g === 38 || g === 40) && t.cancelIfNecessary());
      }), s.on("NodeChange", (d) => {
        t.isActive() && !t.isProcessingAction() && BN(ve.fromDom(d.element)).isNone() && t.cancelIfNecessary();
      });
    } };
    var QA;
    (function(t) {
      t[t.CLOSE_ON_EXECUTE = 0] = "CLOSE_ON_EXECUTE", t[t.BUBBLE_TO_SANDBOX = 1] = "BUBBLE_TO_SANDBOX";
    })(QA || (QA = {}));
    var Um = QA;
    const e3 = "tox-menu-nav__js", Ux = "tox-collection__item", t3 = "tox-swatch", y6 = {
      normal: e3,
      color: t3
    }, $N = "tox-collection__item--enabled", C6 = "tox-collection__group-heading", FN = "tox-collection__item-icon", n3 = "tox-collection__item-label", w6 = "tox-collection__item-accessory", IN = "tox-collection__item-caret", S6 = "tox-collection__item-checkmark", Tp = "tox-collection__item--active", LN = "tox-collection__item-container", o3 = "tox-collection__item-container--column", HN = "tox-collection__item-container--row", x6 = "tox-collection__item-container--align-right", T6 = "tox-collection__item-container--align-left", zN = "tox-collection__item-container--valign-top", E6 = "tox-collection__item-container--valign-middle", s3 = "tox-collection__item-container--valign-bottom", Wx = (t) => Dt(y6, t).getOr(e3), VN = (t) => t === "color" ? "tox-swatches" : "tox-menu", w2 = (t) => ({
      backgroundMenu: "tox-background-menu",
      selectedMenu: "tox-selected-menu",
      selectedItem: "tox-collection__item--active",
      hasIcons: "tox-menu--has-icons",
      menu: VN(t),
      tieredMenu: "tox-tiered-menu"
    }), Hf = (t) => {
      const s = w2(t);
      return {
        backgroundMenu: s.backgroundMenu,
        selectedMenu: s.selectedMenu,
        menu: s.menu,
        selectedItem: s.selectedItem,
        item: Wx(t)
      };
    }, UN = (t, s, a) => {
      const i = w2(a);
      return {
        tag: "div",
        classes: ye([
          [
            i.menu,
            `tox-menu-${s}-column`
          ],
          t ? [i.hasIcons] : []
        ])
      };
    }, zf = [pb.parts.items({})], Sv = (t, s, a) => {
      const i = w2(a);
      return {
        dom: {
          tag: "div",
          classes: ye([[i.tieredMenu]])
        },
        markers: Hf(a)
      };
    }, WN = U([
      $s("data"),
      Ne("inputAttributes", {}),
      Ne("inputStyles", {}),
      Ne("tag", "input"),
      Ne("inputClasses", []),
      gs("onSetValue"),
      Ne("styles", {}),
      Ne("eventOrder", {}),
      za("inputBehaviours", [
        ln,
        po
      ]),
      Ne("selectOnFocus", !0)
    ]), ZN = (t) => Ut([po.config({
      onFocus: t.selectOnFocus ? (s) => {
        const a = s.element, i = Ld(a);
        a.dom.setSelectionRange(0, i.length);
      } : J
    })]), k6 = (t) => ({
      ...ZN(t),
      ...Oa(t.inputBehaviours, [ln.config({
        store: {
          mode: "manual",
          ...t.data.map((s) => ({ initialValue: s })).getOr({}),
          getValue: (s) => Ld(s.element),
          setValue: (s, a) => {
            Ld(s.element) !== a && Mh(s.element, a);
          }
        },
        onSetValue: t.onSetValue
      })])
    }), jN = (t) => ({
      tag: t.tag,
      attributes: {
        type: "text",
        ...t.inputAttributes
      },
      styles: t.inputStyles,
      classes: t.inputClasses
    }), S2 = (t, s) => ({
      uid: t.uid,
      dom: jN(t),
      components: [],
      behaviours: k6(t),
      eventOrder: t.eventOrder
    }), Cb = gl({
      name: "Input",
      configFields: WN(),
      factory: S2
    }), r3 = An("refetch-trigger-event"), Zx = An("redirect-menu-item-interaction"), qN = "tox-menu__searcher", xv = (t) => va(t.element, `.${qN}`).bind((s) => t.getSystem().getByDom(s).toOptional()), jx = xv, _6 = (t, s) => {
      ln.setValue(t, s.fetchPattern), t.element.dom.selectionStart = s.selectionStart, t.element.dom.selectionEnd = s.selectionEnd;
    }, a3 = (t) => {
      const s = ln.getValue(t), a = t.element.dom.selectionStart, i = t.element.dom.selectionEnd;
      return {
        fetchPattern: s,
        selectionStart: a,
        selectionEnd: i
      };
    }, GN = (t, s) => {
      B(s.element, "id").each((a) => sn(t.element, "aria-activedescendant", a));
    }, A6 = (t) => {
      const s = (d, g) => (g.cut(), A.none()), a = (d, g) => {
        const p = {
          interactionEvent: g.event,
          eventType: g.event.raw.type
        };
        return to(d, Zx, p), A.some(!0);
      }, i = "searcher-events";
      return {
        dom: {
          tag: "div",
          classes: [Ux]
        },
        components: [Cb.sketch({
          inputClasses: [
            qN,
            "tox-textfield"
          ],
          inputAttributes: {
            ...t.placeholder.map((d) => ({ placeholder: t.i18n(d) })).getOr({}),
            type: "search",
            "aria-autocomplete": "list"
          },
          inputBehaviours: Ut([
            Bo(i, [
              mt(hg(), (d) => {
                cs(d, r3);
              }),
              mt(Pu(), (d, g) => {
                g.event.raw.key === "Escape" && g.stop();
              })
            ]),
            no.config({
              mode: "special",
              onLeft: s,
              onRight: s,
              onSpace: s,
              onEnter: a,
              onEscape: a,
              onUp: a,
              onDown: a
            })
          ]),
          eventOrder: {
            keydown: [
              i,
              no.name()
            ]
          }
        })]
      };
    }, qx = "tox-collection--results__js", KN = (t) => {
      var s;
      return t.dom ? {
        ...t,
        dom: {
          ...t.dom,
          attributes: {
            ...(s = t.dom.attributes) !== null && s !== void 0 ? s : {},
            id: An("aria-item-search-result-id"),
            "aria-selected": "false"
          }
        }
      } : t;
    }, c3 = (t, s) => (a) => {
      const i = kn(a, s);
      return $e(i, (d) => ({
        dom: t,
        components: d
      }));
    }, O6 = (t) => ({
      dom: {
        tag: "div",
        classes: [
          "tox-menu",
          "tox-swatches-menu"
        ]
      },
      components: [{
        dom: {
          tag: "div",
          classes: ["tox-swatches"]
        },
        components: [pb.parts.items({
          preprocess: t !== "auto" ? c3({
            tag: "div",
            classes: ["tox-swatches__row"]
          }, t) : Tt
        })]
      }]
    }), D6 = (t) => ({
      dom: {
        tag: "div",
        classes: [
          "tox-menu",
          "tox-collection",
          "tox-collection--toolbar",
          "tox-collection--toolbar-lg"
        ]
      },
      components: [pb.parts.items({
        preprocess: c3({
          tag: "div",
          classes: ["tox-collection__group"]
        }, t)
      })]
    }), i3 = (t, s) => {
      const a = [];
      let i = [];
      return ot(t, (d, g) => {
        s(d, g) ? (i.length > 0 && a.push(i), i = [], (Lo(d.dom, "innerHtml") || d.components && d.components.length > 0) && i.push(d)) : i.push(d);
      }), i.length > 0 && a.push(i), $e(a, (d) => ({
        dom: {
          tag: "div",
          classes: ["tox-collection__group"]
        },
        components: d
      }));
    }, Gx = (t, s, a) => pb.parts.items({
      preprocess: (i) => {
        const d = $e(i, a);
        return t !== "auto" && t > 1 ? c3({
          tag: "div",
          classes: ["tox-collection__group"]
        }, t)(d) : i3(d, (g, p) => s[p].type === "separator");
      }
    }), YN = (t, s, a = !0) => ({
      dom: {
        tag: "div",
        classes: [
          "tox-menu",
          "tox-collection"
        ].concat(t === 1 ? ["tox-collection--list"] : ["tox-collection--grid"])
      },
      components: [Gx(t, s, Tt)]
    }), XN = (t, s, a = !0) => {
      const i = An("aria-controls-search-results");
      return {
        dom: {
          tag: "div",
          classes: [
            "tox-menu",
            "tox-collection",
            qx
          ].concat(t === 1 ? ["tox-collection--list"] : ["tox-collection--grid"]),
          attributes: { id: i }
        },
        components: [Gx(t, s, KN)]
      };
    }, x2 = (t, s, a) => {
      const i = An("aria-controls-search-results");
      return {
        dom: {
          tag: "div",
          classes: [
            "tox-menu",
            "tox-collection"
          ].concat(t === 1 ? ["tox-collection--list"] : ["tox-collection--grid"])
        },
        components: [
          A6({
            i18n: Vl.translate,
            placeholder: a.placeholder
          }),
          {
            dom: {
              tag: "div",
              classes: [
                ...t === 1 ? ["tox-collection--list"] : ["tox-collection--grid"],
                qx
              ],
              attributes: { id: i }
            },
            components: [Gx(t, s, KN)]
          }
        ]
      };
    }, JN = (t, s = !0) => ({
      dom: {
        tag: "div",
        classes: [
          "tox-collection",
          "tox-collection--horizontal"
        ]
      },
      components: [pb.parts.items({ preprocess: (a) => i3(a, (i, d) => t[d].type === "separator") })]
    }), Kx = (t) => jo(t, (s) => "icon" in s && s.icon !== void 0), jg = (t) => A.none(), QN = (t, s, a, i, d) => {
      const g = JN(a);
      return {
        value: t,
        dom: g.dom,
        components: g.components,
        items: a
      };
    }, l3 = (t, s, a, i, d) => {
      const g = () => d.menuType !== "searchable" ? YN(i, a) : d.searchMode.searchMode === "search-with-field" ? x2(i, a, d.searchMode) : XN(i, a);
      if (d.menuType === "color") {
        const p = O6(i);
        return {
          value: t,
          dom: p.dom,
          components: p.components,
          items: a
        };
      } else if (d.menuType === "normal" && i === "auto") {
        const p = YN(i, a);
        return {
          value: t,
          dom: p.dom,
          components: p.components,
          items: a
        };
      } else if (d.menuType === "normal" || d.menuType === "searchable") {
        const p = g();
        return {
          value: t,
          dom: p.dom,
          components: p.components,
          items: a
        };
      } else if (d.menuType === "listpreview" && i !== "auto") {
        const p = D6(i);
        return {
          value: t,
          dom: p.dom,
          components: p.components,
          items: a
        };
      } else
        return {
          value: t,
          dom: UN(s, i, d.menuType),
          components: zf,
          items: a
        };
    }, $a = _s("type"), Yx = _s("name"), Xx = _s("label"), Vf = _s("text"), u3 = _s("title"), eM = _s("icon"), T2 = _s("value"), tM = ou("fetch"), d3 = ou("getSubmenuItems"), Ep = ou("onAction"), nM = ou("onItemAction"), kp = _a("onSetup", () => J), oM = mc("name"), _p = mc("text"), mu = mc("icon"), Jx = mc("tooltip"), Qx = mc("label"), sM = mc("shortcut"), wb = bm("select"), eT = Pa("active", !1), m3 = Pa("borderless", !1), fu = Pa("enabled", !0), tT = Pa("primary", !1), f3 = (t) => Ne("columns", t), nT = Ne("meta", {}), oT = _a("onAction", J), qg = (t) => ru("type", t), sT = (t) => dc("name", "name", qc(() => An(`${t}-name`)), Xa), R6 = (t) => dc("value", "value", qc(() => An(`${t}-value`)), ua()), g3 = jn([
      $a,
      _p
    ]), rM = (t) => $r("separatormenuitem", g3, t), aM = jn([
      qg("autocompleteitem"),
      eT,
      fu,
      nT,
      T2,
      _p,
      mu
    ]), cM = (t) => $r("Autocompleter.Separator", g3, t), N6 = (t) => $r("Autocompleter.Item", aM, t), Tv = [
      fu,
      Jx,
      mu,
      _p,
      kp
    ], M6 = jn([
      $a,
      Ep
    ].concat(Tv)), iM = (t) => $r("toolbarbutton", M6, t), h3 = [eT].concat(Tv), P6 = jn(h3.concat([
      $a,
      Ep
    ])), p3 = (t) => $r("ToggleButton", P6, t), Ev = [
      _a("predicate", Te),
      Ai("scope", "node", [
        "node",
        "editor"
      ]),
      Ai("position", "selection", [
        "node",
        "selection",
        "line"
      ])
    ], lM = Tv.concat([
      qg("contextformbutton"),
      tT,
      Ep,
      oa("original", Tt)
    ]), B6 = h3.concat([
      qg("contextformbutton"),
      tT,
      Ep,
      oa("original", Tt)
    ]), $6 = Tv.concat([qg("contextformbutton")]), F6 = h3.concat([qg("contextformtogglebutton")]), I6 = es("type", {
      contextformbutton: lM,
      contextformtogglebutton: B6
    }), L6 = jn([
      qg("contextform"),
      _a("initValue", U("")),
      Qx,
      zi("commands", I6),
      Ru("launch", es("type", {
        contextformbutton: $6,
        contextformtogglebutton: F6
      }))
    ].concat(Ev)), rT = (t) => $r("ContextForm", L6, t), H6 = jn([
      qg("contexttoolbar"),
      _s("items")
    ].concat(Ev)), uM = (t) => $r("ContextToolbar", H6, t), z6 = [
      $a,
      _s("src"),
      mc("alt"),
      di("classes", [], Xa)
    ], dM = jn(z6), mM = [
      $a,
      Vf,
      oM,
      di("classes", ["tox-collection__item-label"], Xa)
    ], V6 = jn(mM), b3 = uc(() => Mt("type", {
      cardimage: dM,
      cardtext: V6,
      cardcontainer: fM
    })), fM = jn([
      $a,
      ru("direction", "horizontal"),
      ru("align", "left"),
      ru("valign", "middle"),
      zi("items", b3)
    ]), Sb = [
      fu,
      _p,
      sM,
      R6("menuitem"),
      nT
    ], gM = jn([
      $a,
      Qx,
      zi("items", b3),
      kp,
      oT
    ].concat(Sb)), U6 = (t) => $r("cardmenuitem", gM, t), W6 = jn([
      $a,
      eT,
      mu
    ].concat(Sb)), Z6 = (t) => $r("choicemenuitem", W6, t), hM = [
      $a,
      _s("fancytype"),
      oT
    ], pM = [Ne("initData", {})].concat(hM), bM = [
      bm("select"),
      Nu("initData", {}, [
        Pa("allowCustomColors", !0),
        ru("storageKey", "default"),
        Md("colors", ua())
      ])
    ].concat(hM), j6 = es("fancytype", {
      inserttable: pM,
      colorswatch: bM
    }), q6 = (t) => $r("fancymenuitem", j6, t), G6 = jn([
      $a,
      kp,
      oT,
      mu
    ].concat(Sb)), K6 = (t) => $r("menuitem", G6, t), Y6 = jn([
      $a,
      d3,
      kp,
      mu
    ].concat(Sb)), vM = (t) => $r("nestedmenuitem", Y6, t), X6 = jn([
      $a,
      mu,
      eT,
      kp,
      Ep
    ].concat(Sb)), J6 = (t) => $r("togglemenuitem", X6, t), E2 = (t, s, a) => {
      const i = nc(t.element, "." + a);
      if (i.length > 0) {
        const d = pe(i, (g) => {
          const p = g.dom.getBoundingClientRect().top, C = i[0].dom.getBoundingClientRect().top;
          return Math.abs(p - C) > s;
        }).getOr(i.length);
        return A.some({
          numColumns: d,
          numRows: Math.ceil(i.length / d)
        });
      } else
        return A.none();
    }, v3 = (t, s) => Ut([Bo(t, s)]), k2 = {
      namedEvents: v3,
      unnamedEvents: (t) => v3(An("unnamed-events"), t)
    }, y3 = An("tooltip.exclusive"), _2 = An("tooltip.show"), A2 = An("tooltip.hide"), C3 = (t, s, a) => {
      t.getSystem().broadcastOn([y3], {});
    };
    var yM = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      hideAllExclusive: C3,
      setComponents: (t, s, a, i) => {
        a.getTooltip().each((d) => {
          d.getSystem().isConnected() && Oo.set(d, i);
        });
      }
    }), e8 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      events: (t, s) => {
        const a = (d) => {
          s.getTooltip().each((g) => {
            jd(g), t.onHide(d, g), s.clearTooltip();
          }), s.clearTimer();
        }, i = (d) => {
          if (!s.isShowing()) {
            C3(d);
            const g = t.lazySink(d).getOrDie(), p = d.getSystem().build({
              dom: t.tooltipDom,
              components: t.tooltipComponents,
              events: vr(t.mode === "normal" ? [
                mt(Rl(), (C) => {
                  cs(d, _2);
                }),
                mt(mf(), (C) => {
                  cs(d, A2);
                })
              ] : []),
              behaviours: Ut([Oo.config({})])
            });
            s.setTooltip(p), Mf(g, p), t.onShow(d, p), Qc.position(g, p, { anchor: t.anchor(d) });
          }
        };
        return vr(ye([
          [
            mt(_2, (d) => {
              s.resetTimer(() => {
                i(d);
              }, t.delay);
            }),
            mt(A2, (d) => {
              s.resetTimer(() => {
                a(d);
              }, t.delay);
            }),
            mt(vg(), (d, g) => {
              const p = g;
              p.universal || io(p.channels, y3) && a(d);
            }),
            Fd((d) => {
              a(d);
            })
          ],
          t.mode === "normal" ? [
            mt($c(), (d) => {
              cs(d, _2);
            }),
            mt(gf(), (d) => {
              cs(d, A2);
            }),
            mt(Rl(), (d) => {
              cs(d, _2);
            }),
            mt(mf(), (d) => {
              cs(d, A2);
            })
          ] : [
            mt(p1(), (d, g) => {
              cs(d, _2);
            }),
            mt(b1(), (d) => {
              cs(d, A2);
            })
          ]
        ]));
      }
    }), t8 = [
      gt("lazySink"),
      gt("tooltipDom"),
      Ne("exclusive", !0),
      Ne("tooltipComponents", []),
      Ne("delay", 300),
      Ai("mode", "normal", [
        "normal",
        "follow-highlight"
      ]),
      Ne("anchor", (t) => ({
        type: "hotspot",
        hotspot: t,
        layouts: {
          onLtr: U([
            ec,
            fi,
            Qa,
            Di,
            Lc,
            Jc
          ]),
          onRtl: U([
            ec,
            fi,
            Qa,
            Di,
            Lc,
            Jc
          ])
        }
      })),
      gs("onHide"),
      gs("onShow")
    ], w3 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      init: () => {
        const t = Go(), s = Go(), a = () => {
          t.on(clearTimeout);
        }, i = (g, p) => {
          a(), t.set(setTimeout(g, p));
        }, d = U("not-implemented");
        return il({
          getTooltip: s.get,
          isShowing: s.isSet,
          setTooltip: s.set,
          clearTooltip: s.clear,
          clearTimer: a,
          resetTimer: i,
          readState: d
        });
      }
    });
    const CM = tc({
      fields: t8,
      name: "tooltipping",
      active: e8,
      state: w3,
      apis: yM
    }), n8 = (t) => t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), S3 = "silver.readonly", wM = jn([yy("readonly")]), aT = (t, s) => {
      const i = t.mainUi.outerContainer.element, d = [
        t.mainUi.mothership,
        ...t.uiMotherships
      ];
      s && ot(d, (g) => {
        g.broadcastOn([gd()], { target: i });
      }), ot(d, (g) => {
        g.broadcastOn([S3], { readonly: s });
      });
    }, SM = (t, s) => {
      t.on("init", () => {
        t.mode.isReadOnly() && aT(s, !0);
      }), t.on("SwitchMode", () => aT(s, t.mode.isReadOnly())), p2(t) && t.mode.set("readonly");
    }, fc = () => Wi.config({
      channels: {
        [S3]: {
          schema: wM,
          onReceive: (t, s) => {
            mo.set(t, s.readonly);
          }
        }
      }
    }), Zu = {
      item: (t) => mo.config({
        disabled: t,
        disableClass: "tox-collection__item--state-disabled"
      }),
      button: (t) => mo.config({ disabled: t }),
      splitButton: (t) => mo.config({
        disabled: t,
        disableClass: "tox-tbtn--disabled"
      }),
      toolbarButton: (t) => mo.config({
        disabled: t,
        disableClass: "tox-tbtn--disabled",
        useNative: !1
      })
    }, xb = (t, s) => {
      const a = t.getApi(s);
      return (i) => {
        i(a);
      };
    }, Gg = (t, s) => cr((a) => {
      xb(t, a)((d) => {
        const g = t.onSetup(d);
        st(g) && s.set(g);
      });
    }), Jd = (t, s) => Fd((a) => xb(t, a)(s.get())), cT = (t, s) => Bu((a, i) => {
      xb(t, a)(t.onAction), !t.triggersSubmenu && s === Um.CLOSE_ON_EXECUTE && (a.getSystem().isConnected() && cs(a, f1()), i.stop());
    }), x3 = {
      [cl()]: [
        "disabling",
        "alloy.base.behaviour",
        "toggling",
        "item-events"
      ]
    }, Tb = Jr, Uf = (t, s, a, i) => {
      const d = w(J);
      return {
        type: "item",
        dom: s.dom,
        components: Tb(s.optComponents),
        data: t.data,
        eventOrder: x3,
        hasSubmenu: t.triggersSubmenu,
        itemBehaviours: Ut([
          Bo("item-events", [
            cT(t, a),
            Gg(t, d),
            Jd(t, d)
          ]),
          Zu.item(() => !t.enabled || i.isDisabled()),
          fc(),
          Oo.config({})
        ].concat(t.itemBehaviours))
      };
    }, kv = (t) => ({
      value: t.value,
      meta: {
        text: t.text.getOr(""),
        ...t.meta
      }
    }), TM = (t) => {
      const s = yv.os.isMacOS() || yv.os.isiOS(), d = s ? {
        alt: "⌥",
        ctrl: "⌃",
        shift: "⇧",
        meta: "⌘",
        access: "⌃⌥"
      } : {
        meta: "Ctrl",
        access: "Shift+Alt"
      }, g = t.split("+"), p = $e(g, (C) => {
        const S = C.toLowerCase().trim();
        return Lo(d, S) ? d[S] : C;
      });
      return s ? p.join("") : p.join("+");
    }, Cd = (t, s, a = [FN]) => Xd(t, {
      tag: "div",
      classes: a
    }, s), Ul = (t) => ({
      dom: {
        tag: "div",
        classes: [n3]
      },
      components: [da(Vl.translate(t))]
    }), _v = (t, s) => ({
      dom: {
        tag: "div",
        classes: s,
        innerHtml: t
      }
    }), wd = (t, s) => ({
      dom: {
        tag: "div",
        classes: [n3]
      },
      components: [{
        dom: {
          tag: t.tag,
          styles: t.styles
        },
        components: [da(Vl.translate(s))]
      }]
    }), s8 = (t) => ({
      dom: {
        tag: "div",
        classes: [w6]
      },
      components: [da(TM(t))]
    }), Cr = (t) => Cd("checkmark", t, [S6]), r8 = (t) => Cd("chevron-right", t, [IN]), Eb = (t) => Cd("chevron-down", t, [IN]), O2 = (t, s) => {
      const a = t.direction === "vertical" ? o3 : HN, i = t.align === "left" ? T6 : x6;
      return {
        dom: {
          tag: "div",
          classes: [
            LN,
            a,
            i,
            (() => {
              switch (t.valign) {
                case "top":
                  return zN;
                case "middle":
                  return E6;
                case "bottom":
                  return s3;
              }
            })()
          ]
        },
        components: s
      };
    }, EM = (t, s, a) => ({
      dom: {
        tag: "img",
        classes: s,
        attributes: {
          src: t,
          alt: a.getOr("")
        }
      }
    }), T3 = (t, s, a) => {
      const i = "custom", d = "remove", g = t.ariaLabel, p = t.value, C = t.iconContent.map((_) => m6(_, s.icons, a));
      return {
        dom: (() => {
          const _ = t3, D = C.getOr(""), L = {
            tag: "div",
            attributes: g.map((V) => ({ title: s.translate(V) })).getOr({}),
            classes: [_]
          };
          return p === i ? {
            ...L,
            tag: "button",
            classes: [
              ...L.classes,
              "tox-swatches__picker-btn"
            ],
            innerHtml: D
          } : p === d ? {
            ...L,
            classes: [
              ...L.classes,
              "tox-swatch--remove"
            ],
            innerHtml: D
          } : En(p) ? {
            ...L,
            attributes: {
              ...L.attributes,
              "data-mce-color": p
            },
            styles: { "background-color": p },
            innerHtml: D
          } : L;
        })(),
        optComponents: []
      };
    }, iT = (t) => {
      const s = t.map((a) => ({
        attributes: {
          title: Vl.translate(a),
          id: An("menu-item")
        }
      })).getOr({});
      return {
        tag: "div",
        classes: [
          e3,
          Ux
        ],
        ...s
      };
    }, a8 = (t, s, a, i) => {
      const d = {
        tag: "div",
        classes: [FN]
      }, g = (L) => Xd(L, d, s.icons, i), p = () => A.some({ dom: d }), C = a ? t.iconContent.map(g).orThunk(p) : A.none(), S = t.checkMark, _ = A.from(t.meta).fold(() => Ul, (L) => Lo(L, "style") ? gn(wd, L.style) : Ul), D = t.htmlContent.fold(() => t.textContent.map(_), (L) => A.some(_v(L, [n3])));
      return {
        dom: iT(t.ariaLabel),
        optComponents: [
          C,
          D,
          t.shortcutContent.map(s8),
          S,
          t.caret
        ]
      };
    }, kb = (t, s, a, i = A.none()) => t.presets === "color" ? T3(t, s, i) : a8(t, s, a, i), kM = (t, s) => Dt(t, "tooltipWorker").map((a) => [CM.config({
      lazySink: s.getSink,
      tooltipDom: {
        tag: "div",
        classes: ["tox-tooltip-worker-container"]
      },
      tooltipComponents: [],
      anchor: (i) => ({
        type: "submenu",
        item: i,
        overrides: { maxHeightFunction: jh }
      }),
      mode: "follow-highlight",
      onShow: (i, d) => {
        a((g) => {
          CM.setComponents(i, [qw({ element: ve.fromDom(g) })]);
        });
      }
    })]).getOr([]), _M = (t) => vv.DOM.encode(t), E3 = (t, s) => {
      const a = Vl.translate(t), i = _M(a);
      if (s.length > 0) {
        const d = new RegExp(n8(s), "gi");
        return i.replace(d, (g) => `<span class="tox-autocompleter-highlight">${g}</span>`);
      } else
        return i;
    }, k3 = (t, s, a, i, d, g, p, C = !0) => {
      const S = kb({
        presets: i,
        textContent: A.none(),
        htmlContent: a ? t.text.map((_) => E3(_, s)) : A.none(),
        ariaLabel: t.text,
        iconContent: t.icon,
        shortcutContent: A.none(),
        checkMark: A.none(),
        caret: A.none(),
        value: t.value
      }, p.providers, C, t.icon);
      return Uf({
        data: kv(t),
        enabled: t.enabled,
        getApi: U({}),
        onAction: (_) => d(t.value, t.meta),
        onSetup: U(J),
        triggersSubmenu: !1,
        itemBehaviours: kM(t.meta, p)
      }, S, g, p.providers);
    }, _3 = (t, s) => $e(t, (a) => {
      switch (a.type) {
        case "cardcontainer":
          return O2(a, _3(a.items, s));
        case "cardimage":
          return EM(a.src, a.classes, a.alt);
        case "cardtext":
          const d = a.name.exists((g) => io(s.cardText.highlightOn, g)) ? A.from(s.cardText.matchText).getOr("") : "";
          return _v(E3(a.text, d), a.classes);
      }
    }), lT = (t, s, a, i) => {
      const d = (p) => ({
        isEnabled: () => !mo.isDisabled(p),
        setEnabled: (C) => {
          mo.set(p, !C), ot(nc(p.element, "*"), (S) => {
            p.getSystem().getByDom(S).each((_) => {
              _.hasConfigured(mo) && mo.set(_, !C);
            });
          });
        }
      }), g = {
        dom: iT(t.label),
        optComponents: [A.some({
          dom: {
            tag: "div",
            classes: [
              LN,
              HN
            ]
          },
          components: _3(t.items, i)
        })]
      };
      return Uf({
        data: kv({
          text: A.none(),
          ...t
        }),
        enabled: t.enabled,
        getApi: d,
        onAction: t.onAction,
        onSetup: t.onSetup,
        triggersSubmenu: !1,
        itemBehaviours: A.from(i.itemBehaviours).getOr([])
      }, g, s, a.providers);
    }, c8 = (t, s, a, i, d, g, p, C = !0) => {
      const S = (D) => ({
        setActive: (P) => {
          Vo.set(D, P);
        },
        isActive: () => Vo.isOn(D),
        isEnabled: () => !mo.isDisabled(D),
        setEnabled: (P) => mo.set(D, !P)
      }), _ = kb({
        presets: a,
        textContent: s ? t.text : A.none(),
        htmlContent: A.none(),
        ariaLabel: t.text,
        iconContent: t.icon,
        shortcutContent: s ? t.shortcut : A.none(),
        checkMark: s ? A.some(Cr(p.icons)) : A.none(),
        caret: A.none(),
        value: t.value
      }, p, C);
      return Ms(Uf({
        data: kv(t),
        enabled: t.enabled,
        getApi: S,
        onAction: (D) => i(t.value),
        onSetup: (D) => (D.setActive(d), J),
        triggersSubmenu: !1,
        itemBehaviours: []
      }, _, g, p), {
        toggling: {
          toggleClass: $N,
          toggleOnExecute: !1,
          selected: t.active,
          exclusive: !0
        }
      });
    }, AM = Bm(a2(), c2()), OM = (t) => ({ value: NM(t) }), DM = /^#?([a-f\d])([a-f\d])([a-f\d])$/i, RM = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i, A3 = (t) => DM.test(t) || RM.test(t), NM = (t) => _c(t, "#").toUpperCase(), i8 = (t) => A3(t) ? A.some({ value: NM(t) }) : A.none(), MM = (t) => ({ value: t.value.replace(DM, (a, i, d, g) => i + i + d + d + g + g) }), l8 = (t) => {
      const s = MM(t), a = RM.exec(s.value);
      return a === null ? [
        "FFFFFF",
        "FF",
        "FF",
        "FF"
      ] : a;
    }, uT = (t) => {
      const s = t.toString(16);
      return (s.length === 1 ? "0" + s : s).toUpperCase();
    }, Kg = (t) => {
      const s = uT(t.red) + uT(t.green) + uT(t.blue);
      return OM(s);
    }, PM = Math.min, BM = Math.max, D2 = Math.round, $M = /^\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/i, FM = /^\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?(?:\.\d+)?)\s*\)\s*$/i, Ap = (t, s, a, i) => ({
      red: t,
      green: s,
      blue: a,
      alpha: i
    }), O3 = (t) => {
      const s = parseInt(t, 10);
      return s.toString() === t && s >= 0 && s <= 255;
    }, IM = (t) => {
      let s, a, i;
      const d = (t.hue || 0) % 360;
      let g = t.saturation / 100, p = t.value / 100;
      if (g = BM(0, PM(g, 1)), p = BM(0, PM(p, 1)), g === 0)
        return s = a = i = D2(255 * p), Ap(s, a, i, 1);
      const C = d / 60, S = p * g, _ = S * (1 - Math.abs(C % 2 - 1)), D = p - S;
      switch (Math.floor(C)) {
        case 0:
          s = S, a = _, i = 0;
          break;
        case 1:
          s = _, a = S, i = 0;
          break;
        case 2:
          s = 0, a = S, i = _;
          break;
        case 3:
          s = 0, a = _, i = S;
          break;
        case 4:
          s = _, a = 0, i = S;
          break;
        case 5:
          s = S, a = 0, i = _;
          break;
        default:
          s = a = i = 0;
      }
      return s = D2(255 * (s + D)), a = D2(255 * (a + D)), i = D2(255 * (i + D)), Ap(s, a, i, 1);
    }, R2 = (t) => {
      const s = l8(t), a = parseInt(s[1], 16), i = parseInt(s[2], 16), d = parseInt(s[3], 16);
      return Ap(a, i, d, 1);
    }, LM = (t, s, a, i) => {
      const d = parseInt(t, 10), g = parseInt(s, 10), p = parseInt(a, 10), C = parseFloat(i);
      return Ap(d, g, p, C);
    }, D3 = (t) => {
      if (t === "transparent")
        return A.some(Ap(0, 0, 0, 0));
      const s = $M.exec(t);
      if (s !== null)
        return A.some(LM(s[1], s[2], s[3], "1"));
      const a = FM.exec(t);
      return a !== null ? A.some(LM(a[1], a[2], a[3], a[4])) : A.none();
    }, R3 = (t) => `rgba(${t.red},${t.green},${t.blue},${t.alpha})`, Sd = Ap(255, 0, 0, 1), u8 = (t) => {
      t.dispatch("SkinLoaded");
    }, N3 = (t, s) => {
      t.dispatch("SkinLoadError", s);
    }, HM = (t) => {
      t.dispatch("ResizeEditor");
    }, dT = (t, s) => {
      t.dispatch("ResizeContent", s);
    }, d8 = (t, s) => {
      t.dispatch("ScrollContent", s);
    }, M3 = (t, s) => {
      t.dispatch("TextColorChange", s);
    }, zM = (t, s) => {
      t.dispatch("AfterProgressState", { state: s });
    }, VM = (t, s) => t.dispatch("ResolveName", {
      name: s.nodeName.toLowerCase(),
      target: s
    }), m8 = (t, s) => {
      t.dispatch("ToggleToolbarDrawer", { state: s });
    }, f8 = (t, s) => {
      t.dispatch("StylesTextUpdate", s);
    }, g8 = (t, s) => {
      t.dispatch("AlignTextUpdate", s);
    }, h8 = (t, s) => {
      t.dispatch("FontSizeTextUpdate", s);
    }, p8 = (t, s) => {
      t.dispatch("FontSizeInputTextUpdate", s);
    }, UM = (t, s) => {
      t.dispatch("BlocksTextUpdate", s);
    }, WM = (t, s) => {
      t.dispatch("FontFamilyTextUpdate", s);
    }, N2 = (t, s) => () => {
      t(), s();
    }, Xi = (t) => Qd(t, "NodeChange", (s) => {
      s.setEnabled(t.selection.isEditable());
    }), b8 = (t, s) => (a) => {
      const i = Om(), d = () => {
        a.setActive(t.formatter.match(s));
        const g = t.formatter.formatChanged(s, a.setActive);
        i.set(g);
      };
      return t.initialized ? d() : t.once("init", d), () => {
        t.off("init", d), i.clear();
      };
    }, mT = (t, s) => (a) => {
      const i = Xi(t)(a), d = b8(t, s)(a);
      return () => {
        i(), d();
      };
    }, Qd = (t, s, a) => (i) => {
      const d = () => a(i), g = () => {
        a(i), t.on(s, d);
      };
      return t.initialized ? g() : t.once("init", g), () => {
        t.off("init", g), t.off(s, d);
      };
    }, ZM = (t) => (s) => () => {
      t.undoManager.transact(() => {
        t.focus(), t.execCommand("mceToggleFormat", !1, s.format);
      });
    }, Wl = (t, s) => () => t.execCommand(s);
    var Op = tinymce.util.Tools.resolve("tinymce.util.LocalStorage");
    const P3 = {}, B3 = (t, s = 10) => {
      const a = Op.getItem(t), i = Ee(a) ? JSON.parse(a) : [], g = ((_) => s - _.length < 0 ? _.slice(0, s) : _)(i), p = (_) => {
        Ye(g, _).each(C), g.unshift(_), g.length > s && g.pop(), Op.setItem(t, JSON.stringify(g));
      }, C = (_) => {
        g.splice(_, 1);
      };
      return {
        add: p,
        state: () => g.slice(0)
      };
    }, fT = (t) => Dt(P3, t).getOrThunk(() => {
      const s = `tinymce-custom-colors-${t}`, a = Op.getItem(s);
      if (Qt(a)) {
        const d = Op.getItem("tinymce-custom-colors");
        Op.setItem(s, En(d) ? d : "[]");
      }
      const i = B3(s, 10);
      return P3[t] = i, i;
    }), $3 = (t) => $e(fT(t).state(), (s) => ({
      type: "choiceitem",
      text: s,
      icon: "checkmark",
      value: s
    })), F3 = (t, s) => {
      fT(t).add(s);
    }, M2 = (t, s, a) => ({
      hue: t,
      saturation: s,
      value: a
    }), gT = (t) => {
      let s = 0, a = 0, i = 0;
      const d = t.red / 255, g = t.green / 255, p = t.blue / 255, C = Math.min(d, Math.min(g, p)), S = Math.max(d, Math.max(g, p));
      if (C === S)
        return i = C, M2(0, 0, i * 100);
      const _ = d === C ? g - p : p === C ? d - g : p - d;
      return s = d === C ? 3 : p === C ? 1 : 5, s = 60 * (s - _ / (S - C)), a = (S - C) / S, i = S, M2(Math.round(s), Math.round(a * 100), Math.round(i * 100));
    }, v8 = (t) => gT(R2(t)), jM = (t) => Kg(IM(t)), y8 = (t) => i8(t).orThunk(() => D3(t).map(Kg)).getOrThunk(() => {
      const s = document.createElement("canvas");
      s.height = 1, s.width = 1;
      const a = s.getContext("2d");
      a.clearRect(0, 0, s.width, s.height), a.fillStyle = "#FFFFFF", a.fillStyle = t, a.fillRect(0, 0, 1, 1);
      const i = a.getImageData(0, 0, 1, 1).data, d = i[0], g = i[1], p = i[2], C = i[3];
      return Kg(Ap(d, g, p, C));
    }), hT = "forecolor", pT = "hilitecolor", qM = 5, C8 = (t) => {
      const s = [];
      for (let a = 0; a < t.length; a += 2)
        s.push({
          text: t[a + 1],
          value: "#" + y8(t[a]).value,
          icon: "checkmark",
          type: "choiceitem"
        });
      return s;
    }, Wf = (t) => (s) => s.options.get(t), I3 = "#000000", w8 = (t) => {
      const s = t.options.register, a = (d) => Kt(d, Ee) ? {
        value: C8(d),
        valid: !0
      } : {
        valid: !1,
        message: "Must be an array of strings."
      }, i = (d) => Pn(d) && d > 0 ? {
        value: d,
        valid: !0
      } : {
        valid: !1,
        message: "Must be a positive number."
      };
      s("color_map", {
        processor: a,
        default: [
          "#BFEDD2",
          "Light Green",
          "#FBEEB8",
          "Light Yellow",
          "#F8CAC6",
          "Light Red",
          "#ECCAFA",
          "Light Purple",
          "#C2E0F4",
          "Light Blue",
          "#2DC26B",
          "Green",
          "#F1C40F",
          "Yellow",
          "#E03E2D",
          "Red",
          "#B96AD9",
          "Purple",
          "#3598DB",
          "Blue",
          "#169179",
          "Dark Turquoise",
          "#E67E23",
          "Orange",
          "#BA372A",
          "Dark Red",
          "#843FA1",
          "Dark Purple",
          "#236FA1",
          "Dark Blue",
          "#ECF0F1",
          "Light Gray",
          "#CED4D9",
          "Medium Gray",
          "#95A5A6",
          "Gray",
          "#7E8C8D",
          "Dark Gray",
          "#34495E",
          "Navy Blue",
          "#000000",
          "Black",
          "#ffffff",
          "White"
        ]
      }), s("color_map_background", { processor: a }), s("color_map_foreground", { processor: a }), s("color_cols", {
        processor: i,
        default: L3(t)
      }), s("color_cols_foreground", {
        processor: i,
        default: GM(t, hT)
      }), s("color_cols_background", {
        processor: i,
        default: GM(t, pT)
      }), s("custom_colors", {
        processor: "boolean",
        default: !0
      }), s("color_default_foreground", {
        processor: "string",
        default: I3
      }), s("color_default_background", {
        processor: "string",
        default: I3
      });
    }, bT = (t, s) => s === hT && t.options.isSet("color_map_foreground") ? Wf("color_map_foreground")(t) : s === pT && t.options.isSet("color_map_background") ? Wf("color_map_background")(t) : Wf("color_map")(t), L3 = (t, s = "default") => Math.max(qM, Math.ceil(Math.sqrt(bT(t, s).length))), GM = (t, s) => {
      const a = Wf("color_cols")(t), i = L3(t, s);
      return a === L3(t) ? i : a;
    }, KM = (t, s = "default") => Math.round(s === hT ? Wf("color_cols_foreground")(t) : s === pT ? Wf("color_cols_background")(t) : Wf("color_cols")(t)), YM = Wf("custom_colors"), S8 = Wf("color_default_foreground"), x8 = Wf("color_default_background"), XM = "rgba(0, 0, 0, 0)", T8 = (t) => D3(t).exists((s) => s.alpha !== 0), E8 = (t) => Vi(t, (s) => {
      if (lo(s)) {
        const a = Us(s, "background-color");
        return Zn(T8(a), a);
      } else
        return A.none();
    }).getOr(XM), JM = (t, s) => {
      const a = ve.fromDom(t.selection.getStart()), i = s === "hilitecolor" ? E8(a) : Us(a, "color");
      return D3(i).map((d) => "#" + Kg(d).value);
    }, k8 = (t, s, a) => {
      t.undoManager.transact(() => {
        t.focus(), t.formatter.apply(s, { value: a }), t.nodeChanged();
      });
    }, _8 = (t, s) => {
      t.undoManager.transact(() => {
        t.focus(), t.formatter.remove(s, { value: null }, void 0, !0), t.nodeChanged();
      });
    }, vT = (t) => {
      t.addCommand("mceApplyTextcolor", (s, a) => {
        k8(t, s, a);
      }), t.addCommand("mceRemoveTextcolor", (s) => {
        _8(t, s);
      });
    }, H3 = (t) => {
      const s = "choiceitem", a = {
        type: s,
        text: "Remove color",
        icon: "color-swatch-remove-color",
        value: "remove"
      };
      return t ? [
        a,
        {
          type: s,
          text: "Custom color",
          icon: "color-picker",
          value: "custom"
        }
      ] : [a];
    }, z3 = (t, s, a, i) => {
      a === "custom" ? nP(t)((g) => {
        g.each((p) => {
          F3(s, p), t.execCommand("mceApplyTextcolor", s, p), i(p);
        });
      }, JM(t, s).getOr(I3)) : a === "remove" ? (i(""), t.execCommand("mceRemoveTextcolor", s)) : (i(a), t.execCommand("mceApplyTextcolor", s, a));
    }, V3 = (t, s, a) => t.concat($3(s).concat(H3(a))), QM = (t, s, a) => (i) => {
      i(V3(t, s, a));
    }, U3 = (t, s, a) => {
      const i = s === "forecolor" ? "tox-icon-text-color__color" : "tox-icon-highlight-bg-color__color";
      t.setIconFill(i, a);
    }, eP = (t, s) => {
      t.setTooltip(s);
    }, tP = (t, s) => (a) => {
      const i = JM(t, s);
      return aa(i, a.toUpperCase());
    }, P2 = (t, s, a) => {
      if (ie(a))
        return s === "forecolor" ? "Text color" : "Background color";
      const i = s === "forecolor" ? "Text color {0}" : "Background color {0}", d = V3(bT(t, s), s, !1), g = ee(d, (p) => p.value === a).getOr({ text: "" }).text;
      return t.translate([
        i,
        t.translate(g)
      ]);
    }, W3 = (t, s, a, i) => {
      t.ui.registry.addSplitButton(s, {
        tooltip: P2(t, a, i.get()),
        presets: "color",
        icon: s === "forecolor" ? "text-color" : "highlight-bg-color",
        select: tP(t, a),
        columns: KM(t, a),
        fetch: QM(bT(t, a), a, YM(t)),
        onAction: (d) => {
          z3(t, a, i.get(), J);
        },
        onItemAction: (d, g) => {
          z3(t, a, g, (p) => {
            i.set(p), M3(t, {
              name: s,
              color: p
            });
          });
        },
        onSetup: (d) => {
          U3(d, s, i.get());
          const g = (p) => {
            p.name === s && (U3(d, p.name, p.color), eP(d, P2(t, a, p.color)));
          };
          return t.on("TextColorChange", g), N2(Xi(t)(d), () => {
            t.off("TextColorChange", g);
          });
        }
      });
    }, Z3 = (t, s, a, i, d) => {
      t.ui.registry.addNestedMenuItem(s, {
        text: i,
        icon: s === "forecolor" ? "text-color" : "highlight-bg-color",
        onSetup: (g) => (eP(g, P2(t, a, d.get())), U3(g, s, d.get()), Xi(t)(g)),
        getSubmenuItems: () => [{
          type: "fancymenuitem",
          fancytype: "colorswatch",
          select: tP(t, a),
          initData: { storageKey: a },
          onAction: (g) => {
            z3(t, a, g.value, (p) => {
              d.set(p), M3(t, {
                name: s,
                color: p
              });
            });
          }
        }]
      });
    }, nP = (t) => (s, a) => {
      let i = !1;
      const d = (C) => {
        const _ = C.getData().colorpicker;
        i ? (s(A.from(_)), C.close()) : t.windowManager.alert(t.translate([
          "Invalid hex color code: {0}",
          _
        ]));
      }, g = (C, S) => {
        S.name === "hex-valid" && (i = S.value);
      }, p = { colorpicker: a };
      t.windowManager.open({
        title: "Color Picker",
        size: "normal",
        body: {
          type: "panel",
          items: [{
            type: "colorpicker",
            name: "colorpicker",
            label: "Color"
          }]
        },
        buttons: [
          {
            type: "cancel",
            name: "cancel",
            text: "Cancel"
          },
          {
            type: "submit",
            name: "save",
            text: "Save",
            primary: !0
          }
        ],
        initialData: p,
        onAction: g,
        onSubmit: d,
        onClose: J,
        onCancel: () => {
          s(A.none());
        }
      });
    }, oP = (t) => {
      vT(t);
      const s = S8(t), a = x8(t), i = w(s), d = w(a);
      W3(t, "forecolor", "forecolor", i), W3(t, "backcolor", "hilitecolor", d), Z3(t, "forecolor", "forecolor", "Text color", i), Z3(t, "backcolor", "hilitecolor", "Background color", d);
    }, j3 = (t, s, a, i, d, g, p, C) => {
      const S = Kx(s), D = A8(s, a, i, d !== "color" ? "normal" : "color", g, p, C);
      return l3(t, S, D, i, { menuType: d });
    }, A8 = (t, s, a, i, d, g, p) => Jr($e(t, (C) => C.type === "choiceitem" ? Z6(C).fold(jg, (S) => A.some(c8(S, a === 1, i, s, g(S.value), d, p, Kx(t)))) : A.none())), yT = (t, s) => {
      const a = Hf(s);
      return t === 1 ? {
        mode: "menu",
        moveOnTab: !0
      } : t === "auto" ? {
        mode: "grid",
        selector: "." + a.item,
        initSize: {
          numColumns: 1,
          numRows: 1
        }
      } : {
        mode: "matrix",
        rowSelector: "." + (s === "color" ? "tox-swatches__row" : "tox-collection__group"),
        previousSelector: (d) => s === "color" ? va(d.element, "[aria-checked=true]") : A.none()
      };
    }, O8 = (t, s) => t === 1 ? {
      mode: "menu",
      moveOnTab: !1,
      selector: ".tox-collection__item"
    } : t === "auto" ? {
      mode: "flatgrid",
      selector: ".tox-collection__item",
      initSize: {
        numColumns: 1,
        numRows: 1
      }
    } : {
      mode: "matrix",
      selectors: {
        row: s === "color" ? ".tox-swatches__row" : ".tox-collection__group",
        cell: s === "color" ? `.${t3}` : `.${Ux}`
      }
    }, D8 = (t, s) => {
      const a = R8(t, s), i = s.colorinput.getColorCols(t.initData.storageKey), d = "color", p = {
        ...j3(An("menu-value"), a, (C) => {
          t.onAction({ value: C });
        }, i, d, Um.CLOSE_ON_EXECUTE, t.select.getOr(Te), s.shared.providers),
        markers: Hf(d),
        movement: yT(i, d)
      };
      return {
        type: "widget",
        data: { value: An("widget-id") },
        dom: {
          tag: "div",
          classes: ["tox-fancymenuitem"]
        },
        autofocus: !0,
        components: [AM.widget(pb.sketch(p))]
      };
    }, R8 = (t, s) => {
      const a = t.initData.allowCustomColors && s.colorinput.hasCustomColors();
      return t.initData.colors.fold(() => V3(s.colorinput.getColors(t.initData.storageKey), t.initData.storageKey, a), (i) => i.concat(H3(a)));
    }, sP = An("cell-over"), rP = An("cell-execute"), N8 = (t) => (s, a) => t.shared.providers.translate([
      "{0} columns, {1} rows",
      a,
      s
    ]), M8 = (t, s, a) => {
      const i = (p) => to(p, sP, {
        row: t,
        col: s
      }), d = (p) => to(p, rP, {
        row: t,
        col: s
      }), g = (p, C) => {
        C.stop(), d(p);
      };
      return Xc({
        dom: {
          tag: "div",
          attributes: {
            role: "button",
            "aria-label": a
          }
        },
        behaviours: Ut([
          Bo("insert-table-picker-cell", [
            mt(Rl(), po.focus),
            mt(cl(), d),
            mt(vm(), g),
            mt(ad(), g)
          ]),
          Vo.config({
            toggleClass: "tox-insert-table-picker__selected",
            toggleOnExecute: !1
          }),
          po.config({ onFocus: i })
        ])
      });
    }, CT = (t, s, a) => {
      const i = [];
      for (let d = 0; d < s; d++) {
        const g = [];
        for (let p = 0; p < a; p++) {
          const C = t(d + 1, p + 1);
          g.push(M8(d, p, C));
        }
        i.push(g);
      }
      return i;
    }, q3 = (t, s, a, i, d) => {
      for (let g = 0; g < i; g++)
        for (let p = 0; p < d; p++)
          Vo.set(t[g][p], g <= s && p <= a);
    }, G3 = (t) => ae(t, (s) => $e(s, Pl)), K3 = (t, s) => da(`${s}x${t}`), P8 = {
      inserttable: (t, s) => {
        const d = N8(s), g = CT(d, 10, 10), p = K3(0, 0), C = js({
          dom: {
            tag: "span",
            classes: ["tox-insert-table-picker__label"]
          },
          components: [p],
          behaviours: Ut([Oo.config({})])
        });
        return {
          type: "widget",
          data: { value: An("widget-id") },
          dom: {
            tag: "div",
            classes: ["tox-fancymenuitem"]
          },
          autofocus: !0,
          components: [AM.widget({
            dom: {
              tag: "div",
              classes: ["tox-insert-table-picker"]
            },
            components: G3(g).concat(C.asSpec()),
            behaviours: Ut([
              Bo("insert-table-picker", [
                cr((S) => {
                  Oo.set(C.get(S), [p]);
                }),
                ky(sP, (S, _, D) => {
                  const { row: P, col: L } = D.event;
                  q3(g, P, L, 10, 10), Oo.set(C.get(S), [K3(P + 1, L + 1)]);
                }),
                ky(rP, (S, _, D) => {
                  const { row: P, col: L } = D.event;
                  t.onAction({
                    numRows: P + 1,
                    numColumns: L + 1
                  }), cs(S, f1());
                })
              ]),
              no.config({
                initSize: {
                  numRows: 10,
                  numColumns: 10
                },
                mode: "flatgrid",
                selector: '[role="button"]'
              })
            ])
          })]
        };
      },
      colorswatch: D8
    }, Y3 = (t, s) => Dt(P8, t.fancytype).map((a) => a(t, s)), X3 = (t, s, a, i = !0, d = !1) => {
      const g = d ? Eb(a.icons) : r8(a.icons), p = (S) => ({
        isEnabled: () => !mo.isDisabled(S),
        setEnabled: (_) => mo.set(S, !_),
        setIconFill: (_, D) => {
          va(S.element, `svg path[class="${_}"], rect[class="${_}"]`).each((P) => {
            sn(P, "fill", D);
          });
        },
        setTooltip: (_) => {
          const D = a.translate(_);
          Ql(S.element, {
            "aria-label": D,
            title: D
          });
        }
      }), C = kb({
        presets: "normal",
        iconContent: t.icon,
        textContent: t.text,
        htmlContent: A.none(),
        ariaLabel: t.text,
        caret: A.some(g),
        checkMark: A.none(),
        shortcutContent: t.shortcut
      }, a, i);
      return Uf({
        data: kv(t),
        getApi: p,
        enabled: t.enabled,
        onAction: J,
        onSetup: t.onSetup,
        triggersSubmenu: !0,
        itemBehaviours: []
      }, C, s, a);
    }, wT = (t, s, a, i = !0) => {
      const d = (p) => ({
        isEnabled: () => !mo.isDisabled(p),
        setEnabled: (C) => mo.set(p, !C)
      }), g = kb({
        presets: "normal",
        iconContent: t.icon,
        textContent: t.text,
        htmlContent: A.none(),
        ariaLabel: t.text,
        caret: A.none(),
        checkMark: A.none(),
        shortcutContent: t.shortcut
      }, a, i);
      return Uf({
        data: kv(t),
        getApi: d,
        enabled: t.enabled,
        onAction: t.onAction,
        onSetup: t.onSetup,
        triggersSubmenu: !1,
        itemBehaviours: []
      }, g, s, a);
    }, aP = (t) => ({
      type: "separator",
      dom: {
        tag: "div",
        classes: [
          Ux,
          C6
        ]
      },
      components: t.text.map(da).toArray()
    }), B8 = (t, s, a, i = !0) => {
      const d = (p) => ({
        setActive: (C) => {
          Vo.set(p, C);
        },
        isActive: () => Vo.isOn(p),
        isEnabled: () => !mo.isDisabled(p),
        setEnabled: (C) => mo.set(p, !C)
      }), g = kb({
        iconContent: t.icon,
        textContent: t.text,
        htmlContent: A.none(),
        ariaLabel: t.text,
        checkMark: A.some(Cr(a.icons)),
        caret: A.none(),
        shortcutContent: t.shortcut,
        presets: "normal",
        meta: t.meta
      }, a, i);
      return Ms(Uf({
        data: kv(t),
        enabled: t.enabled,
        getApi: d,
        onAction: t.onAction,
        onSetup: t.onSetup,
        triggersSubmenu: !1,
        itemBehaviours: []
      }, g, s, a), {
        toggling: {
          toggleClass: $N,
          toggleOnExecute: !1,
          selected: t.active
        }
      });
    }, $8 = k3, cP = aP, F8 = wT, I8 = X3, L8 = B8, H8 = Y3, z8 = lT;
    var V8 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      getCoupled: (t, s, a, i) => a.getOrCreate(t, s, i),
      getExistingCoupled: (t, s, a, i) => a.getExisting(t, s, i)
    }), U8 = [_i("others", rd(Mo.value, ua()))], iP = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      init: () => {
        const t = {}, s = (g, p) => {
          if (Ao(g.others).length === 0)
            throw new Error("Cannot find any known coupled components");
          return Dt(t, p);
        }, a = (g, p, C) => s(p, C).getOrThunk(() => {
          const _ = Dt(p.others, C).getOrDie("No information found for coupled component: " + C)(g), D = g.getSystem().build(_);
          return t[C] = D, D;
        }), i = (g, p, C) => s(p, C).orThunk(() => (Dt(p.others, C).getOrDie("No information found for coupled component: " + C), A.none())), d = U({});
        return il({
          readState: d,
          getExisting: i,
          getOrCreate: a
        });
      }
    });
    const Ca = tc({
      fields: U8,
      name: "coupling",
      apis: V8,
      state: iP
    }), J3 = (t) => {
      let s = A.none(), a = [];
      const i = (_) => J3((D) => {
        d((P) => {
          D(_(P));
        });
      }), d = (_) => {
        p() ? S(_) : a.push(_);
      }, g = (_) => {
        p() || (s = A.some(_), C(a), a = []);
      }, p = () => s.isSome(), C = (_) => {
        ot(_, S);
      }, S = (_) => {
        s.each((D) => {
          setTimeout(() => {
            _(D);
          }, 0);
        });
      };
      return t(g), {
        get: d,
        map: i,
        isReady: p
      };
    }, W8 = {
      nu: J3,
      pure: (t) => J3((s) => {
        s(t);
      })
    }, Z8 = (t) => {
      setTimeout(() => {
        throw t;
      }, 0);
    }, Dp = (t) => {
      const s = (S) => {
        t().then(S, Z8);
      };
      return {
        map: (S) => Dp(() => t().then(S)),
        bind: (S) => Dp(() => t().then((_) => S(_).toPromise())),
        anonBind: (S) => Dp(() => t().then(() => S.toPromise())),
        toLazy: () => W8.nu(s),
        toCached: () => {
          let S = null;
          return Dp(() => (S === null && (S = t()), S));
        },
        toPromise: t,
        get: s
      };
    }, vi = {
      nu: (t) => Dp(() => new Promise(t)),
      pure: (t) => Dp(() => Promise.resolve(t))
    }, lP = U("sink"), uP = U(qi({
      name: lP(),
      overrides: U({
        dom: { tag: "div" },
        behaviours: Ut([Qc.config({ useFixed: Oe })]),
        events: vr([
          wm(Pu()),
          wm(Zs()),
          wm(vm())
        ])
      })
    })), dP = (t, s) => {
      const a = t.getHotspot(s).getOr(s), i = "hotspot", d = t.getAnchorOverrides();
      return t.layouts.fold(() => ({
        type: i,
        hotspot: a,
        overrides: d
      }), (g) => ({
        type: i,
        hotspot: a,
        overrides: d,
        layouts: g
      }));
    }, j8 = (t, s, a) => {
      const i = t.fetch;
      return i(a).map(s);
    }, q8 = (t, s, a, i, d, g, p) => {
      const C = j8(t, s, i), S = mP(i, t);
      return C.map((_) => _.bind((D) => A.from(Cp.sketch({
        ...g.menu(),
        uid: xh(""),
        data: D,
        highlightOnOpen: p,
        onOpenMenu: (P, L) => {
          const V = S().getOrDie();
          Qc.position(V, L, { anchor: a }), is.decloak(d);
        },
        onOpenSubmenu: (P, L, V) => {
          const Y = S().getOrDie();
          Qc.position(Y, V, {
            anchor: {
              type: "submenu",
              item: L
            }
          }), is.decloak(d);
        },
        onRepositionMenu: (P, L, V) => {
          const Y = S().getOrDie();
          Qc.position(Y, L, { anchor: a }), ot(V, (me) => {
            Qc.position(Y, me.triggeredMenu, {
              anchor: {
                type: "submenu",
                item: me.triggeringItem
              }
            });
          });
        },
        onEscape: () => (po.focus(i), is.close(d), A.some(!0))
      }))));
    }, ST = (t, s, a, i, d, g, p) => {
      const C = dP(t, a);
      return q8(t, s, C, a, i, d, p).map((_) => (_.fold(() => {
        is.isOpen(i) && is.close(i);
      }, (D) => {
        is.cloak(i), is.open(i, D), g(i);
      }), i));
    }, G8 = (t, s, a, i, d, g, p) => (is.close(i), vi.pure(i)), Q3 = (t, s, a, i, d, g) => {
      const p = Ca.getCoupled(a, "sandbox");
      return (is.isOpen(p) ? G8 : ST)(t, s, a, p, i, d, g);
    }, K8 = (t, s, a) => {
      const i = ts.getCurrent(s).getOr(s), d = j(t.element);
      a ? _n(i.element, "min-width", d + "px") : Qo(i.element, d);
    }, mP = (t, s) => t.getSystem().getByUid(s.uid + "-" + lP()).map((a) => () => Mo.value(a)).getOrThunk(() => s.lazySink.fold(() => () => Mo.error(new Error("No internal sink is specified, nor could an external sink be found")), (a) => () => a(t))), fP = (t) => {
      is.getState(t).each((s) => {
        Cp.repositionMenus(s);
      });
    }, eO = (t, s, a) => {
      const i = kg(), d = (C, S) => {
        const _ = dP(t, s);
        i.link(s.element), t.matchWidth && K8(_.hotspot, S, t.useMinWidth), t.onOpen(_, C, S), a !== void 0 && a.onOpen !== void 0 && a.onOpen(C, S);
      }, g = (C, S) => {
        i.unlink(s.element), a !== void 0 && a.onClose !== void 0 && a.onClose(C, S);
      }, p = mP(s, t);
      return {
        dom: {
          tag: "div",
          classes: t.sandboxClasses,
          attributes: {
            id: i.id,
            role: "listbox"
          }
        },
        behaviours: lu.augment(t.sandboxBehaviours, [
          ln.config({
            store: {
              mode: "memory",
              initialValue: s
            }
          }),
          is.config({
            onOpen: d,
            onClose: g,
            isPartOf: (C, S, _) => km(S, _) || km(s, _),
            getAttachPoint: () => p().getOrDie()
          }),
          ts.config({
            find: (C) => is.getState(C).bind((S) => ts.getCurrent(S))
          }),
          Wi.config({
            channels: {
              ...K1({ isExtraPart: Te }),
              ...ap({ doReposition: fP })
            }
          })
        ])
      };
    }, gP = (t) => {
      const s = Ca.getCoupled(t, "sandbox");
      fP(s);
    }, tO = () => [
      Ne("sandboxClasses", []),
      lu.field("sandboxBehaviours", [
        ts,
        Wi,
        is,
        ln
      ])
    ], Y8 = U([
      gt("dom"),
      gt("fetch"),
      gs("onOpen"),
      fl("onExecute"),
      Ne("getHotspot", A.some),
      Ne("getAnchorOverrides", U({})),
      kf(),
      za("dropdownBehaviours", [
        Vo,
        Ca,
        no,
        po
      ]),
      gt("toggleClass"),
      Ne("eventOrder", {}),
      $s("lazySink"),
      Ne("matchWidth", !1),
      Ne("useMinWidth", !1),
      $s("role")
    ].concat(tO())), X8 = U([
      zu({
        schema: [
          E1(),
          Ne("fakeFocus", !1)
        ],
        name: "menu",
        defaults: (t) => ({ onExecute: t.onExecute })
      }),
      uP()
    ]), J8 = (t, s, a, i) => {
      const d = (D) => Dt(t.dom, "attributes").bind((P) => Dt(P, D)), g = (D) => {
        is.getState(D).each((P) => {
          Cp.highlightPrimary(P);
        });
      }, p = (D, P, L) => Q3(t, Tt, D, i, P, L), C = (D) => {
        p(D, g, Yi.HighlightMenuAndItem).get(J);
      }, S = {
        expand: (D) => {
          Vo.isOn(D) || p(D, J, Yi.HighlightNone).get(J);
        },
        open: (D) => {
          Vo.isOn(D) || p(D, J, Yi.HighlightMenuAndItem).get(J);
        },
        refetch: (D) => Ca.getExistingCoupled(D, "sandbox").fold(() => p(D, J, Yi.HighlightMenuAndItem).map(J), (L) => ST(t, Tt, D, L, i, J, Yi.HighlightMenuAndItem).map(J)),
        isOpen: Vo.isOn,
        close: (D) => {
          Vo.isOn(D) && p(D, J, Yi.HighlightMenuAndItem).get(J);
        },
        repositionMenus: (D) => {
          Vo.isOn(D) && gP(D);
        }
      }, _ = (D, P) => (Cm(D), A.some(!0));
      return {
        uid: t.uid,
        dom: t.dom,
        components: s,
        behaviours: Oa(t.dropdownBehaviours, [
          Vo.config({
            toggleClass: t.toggleClass,
            aria: { mode: "expanded" }
          }),
          Ca.config({
            others: {
              sandbox: (D) => eO(t, D, {
                onOpen: () => Vo.on(D),
                onClose: () => Vo.off(D)
              })
            }
          }),
          no.config({
            mode: "special",
            onSpace: _,
            onEnter: _,
            onDown: (D, P) => {
              if (xd.isOpen(D)) {
                const L = Ca.getCoupled(D, "sandbox");
                g(L);
              } else
                xd.open(D);
              return A.some(!0);
            },
            onEscape: (D, P) => xd.isOpen(D) ? (xd.close(D), A.some(!0)) : A.none()
          }),
          po.config({})
        ]),
        events: zm(A.some(C)),
        eventOrder: {
          ...t.eventOrder,
          [cl()]: [
            "disabling",
            "toggling",
            "alloy.base.behaviour"
          ]
        },
        apis: S,
        domModification: {
          attributes: {
            "aria-haspopup": "true",
            ...t.role.fold(() => ({}), (D) => ({ role: D })),
            ...t.dom.tag === "button" ? { type: d("type").getOr("button") } : {}
          }
        }
      };
    }, xd = ti({
      name: "Dropdown",
      configFields: Y8(),
      partFields: X8(),
      factory: J8,
      apis: {
        open: (t, s) => t.open(s),
        refetch: (t, s) => t.refetch(s),
        expand: (t, s) => t.expand(s),
        close: (t, s) => t.close(s),
        isOpen: (t, s) => t.isOpen(s),
        repositionMenus: (t, s) => t.repositionMenus(s)
      }
    }), Q8 = (t) => {
      switch (t.searchMode) {
        case "no-search":
          return { menuType: "normal" };
        default:
          return {
            menuType: "searchable",
            searchMode: t
          };
      }
    }, e7 = (t) => {
      const s = ln.getValue(t), a = xv(t).map(a3);
      xd.refetch(s).get(() => {
        const i = Ca.getCoupled(s, "sandbox");
        a.each((d) => xv(i).each((g) => _6(g, d)));
      });
    }, t7 = (t, s) => {
      n7(t).each((a) => {
        yk(t, a.element, s.event.eventType, s.event.interactionEvent);
      });
    }, n7 = (t) => is.getState(t).bind(Ps.getHighlighted).bind(Ps.getHighlighted), o7 = (t) => Ha(t.element, qx) ? A.some(t.element) : va(t.element, "." + qx), nO = (t, s, a) => {
      jx(t).each((i) => {
        GN(i, a), o7(s).each((g) => {
          B(g, "id").each((p) => sn(i.element, "aria-controls", p));
        });
      }), sn(a.element, "aria-selected", "true");
    }, s7 = (t, s, a) => {
      sn(a.element, "aria-selected", "false");
    }, r7 = (t) => {
      jx(t).each((s) => po.focus(s));
    }, a7 = (t) => Ca.getExistingCoupled(t, "sandbox").bind(xv).map(a3).map((a) => a.fetchPattern).getOr("");
    var B2;
    (function(t) {
      t[t.ContentFocus = 0] = "ContentFocus", t[t.UiFocus = 1] = "UiFocus";
    })(B2 || (B2 = {}));
    const c7 = (t, s, a, i, d) => {
      const g = a.shared.providers, p = (C) => d ? {
        ...C,
        shortcut: A.none(),
        icon: C.text.isSome() ? A.none() : C.icon
      } : C;
      switch (t.type) {
        case "menuitem":
          return K6(t).fold(jg, (C) => A.some(F8(p(C), s, g, i)));
        case "nestedmenuitem":
          return vM(t).fold(jg, (C) => A.some(I8(p(C), s, g, i, d)));
        case "togglemenuitem":
          return J6(t).fold(jg, (C) => A.some(L8(p(C), s, g, i)));
        case "separator":
          return rM(t).fold(jg, (C) => A.some(cP(C)));
        case "fancymenuitem":
          return q6(t).fold(jg, (C) => H8(C, a));
        default:
          return A.none();
      }
    }, i7 = (t, s, a, i, d, g, p) => {
      const C = i === 1, S = !C || Kx(t);
      return Jr($e(t, (_) => {
        switch (_.type) {
          case "separator":
            return cM(_).fold(jg, (D) => A.some(cP(D)));
          case "cardmenuitem":
            return U6(_).fold(jg, (D) => A.some(z8({
              ...D,
              onAction: (P) => {
                D.onAction(P), a(D.value, D.meta);
              }
            }, d, g, {
              itemBehaviours: kM(D.meta, g),
              cardText: {
                matchText: s,
                highlightOn: p
              }
            })));
          case "autocompleteitem":
          default:
            return N6(_).fold(jg, (D) => A.some($8(D, s, C, "normal", a, d, g, S)));
        }
      }));
    }, hP = (t, s, a, i, d, g) => {
      const p = Kx(s), C = Jr($e(s, (D) => {
        const P = (V) => d ? !Lo(V, "text") : p, L = (V) => c7(V, a, i, P(V), d);
        return D.type === "nestedmenuitem" && D.getSubmenuItems().length <= 0 ? L({
          ...D,
          enabled: !1
        }) : L(D);
      })), S = Q8(g);
      return (d ? QN : l3)(t, p, C, 1, S);
    }, xT = (t) => Cp.singleData(t.value, t), l7 = (t, s, a, i) => {
      const d = yT(s, i), g = Hf(i);
      return {
        data: xT({
          ...t,
          movement: d,
          menuBehaviours: k2.unnamedEvents(s !== "auto" ? [] : [cr((p, C) => {
            E2(p, 4, g.item).each(({ numColumns: S, numRows: _ }) => {
              no.setGridSize(p, _, S);
            });
          })])
        }),
        menu: {
          markers: Hf(i),
          fakeFocus: a === B2.ContentFocus
        }
      };
    }, u7 = (t, s) => BN(ve.fromDom(s.startContainer)).map((a) => {
      const i = t.createRng();
      return i.selectNode(a.dom), i;
    }), d7 = { register: (t, s) => {
      const a = An("autocompleter"), i = w(!1), d = w(!1), g = Xc(qr.sketch({
        dom: {
          tag: "div",
          classes: ["tox-autocompleter"],
          attributes: { id: a }
        },
        components: [],
        fireDismissalEventInstead: {},
        inlineBehaviours: Ut([Bo("dismissAutocompleter", [
          mt(bf(), () => D()),
          mt(p1(), (Pe, xe) => {
            B(xe.event.target, "id").each((Ce) => sn(ve.fromDom(t.getBody()), "aria-activedescendant", Ce));
          })
        ])]),
        lazySink: s.getSink
      })), p = () => qr.isOpen(g), C = d.get, S = () => {
        if (p()) {
          qr.hide(g), t.dom.remove(a, !1);
          const Pe = ve.fromDom(t.getBody());
          B(Pe, "aria-owns").filter((xe) => xe === a).each(() => {
            se(Pe, "aria-owns"), se(Pe, "aria-activedescendant");
          });
        }
      }, _ = () => qr.getContent(g).bind((Pe) => hn(Pe.components(), 0)), D = () => t.execCommand("mceAutocompleterClose"), P = (Pe) => {
        const xe = No(Pe, (Ce) => A.from(Ce.columns)).getOr(1);
        return ae(Pe, (Ce) => {
          const Be = Ce.items;
          return i7(Be, Ce.matchText, (St, ct) => {
            const tt = t.selection.getRng();
            u7(t.dom, tt).each((Vt) => {
              const Xt = {
                hide: () => D(),
                reload: ($o) => {
                  S(), t.execCommand("mceAutocompleterReload", !1, { fetchOptions: $o });
                }
              };
              i.set(!0), Ce.onAction(Xt, Vt, St, ct), i.set(!1);
            });
          }, xe, Um.BUBBLE_TO_SANDBOX, s, Ce.highlightOn);
        });
      }, L = (Pe, xe) => {
        v6(ve.fromDom(t.getBody())).each((Ce) => {
          const Be = No(Pe, (St) => A.from(St.columns)).getOr(1);
          qr.showMenuAt(g, {
            anchor: {
              type: "node",
              root: ve.fromDom(t.getBody()),
              node: A.from(Ce)
            }
          }, l7(l3("autocompleter-value", !0, xe, Be, { menuType: "normal" }), Be, B2.ContentFocus, "normal"));
        }), _().each(Ps.highlightFirst);
      }, V = (Pe) => {
        const xe = P(Pe);
        xe.length > 0 ? (L(Pe, xe), sn(ve.fromDom(t.getBody()), "aria-owns", a), t.inline || Y()) : S();
      }, Y = () => {
        t.dom.get(a) && t.dom.remove(a, !1);
        const Pe = t.getDoc().documentElement, xe = t.selection.getNode(), Ce = xk(g.element);
        gr(Ce, {
          border: "0",
          clip: "rect(0 0 0 0)",
          height: "1px",
          margin: "-1px",
          overflow: "hidden",
          padding: "0",
          position: "absolute",
          width: "1px",
          top: `${xe.offsetTop}px`,
          left: `${xe.offsetLeft}px`
        }), t.dom.add(Pe, Ce.dom), va(Ce, '[role="menu"]').each((Be) => {
          Jo(Be, "position"), Jo(Be, "max-height");
        });
      };
      t.on("AutocompleterStart", ({ lookupData: Pe }) => {
        d.set(!0), i.set(!1), V(Pe);
      }), t.on("AutocompleterUpdate", ({ lookupData: Pe }) => V(Pe)), t.on("AutocompleterEnd", () => {
        S(), d.set(!1), i.set(!1);
      });
      const me = {
        cancelIfNecessary: D,
        isMenuOpen: p,
        isActive: C,
        isProcessingAction: i.get,
        getMenu: _
      };
      JA.setup(me, t);
    } }, pP = [
      "visible",
      "hidden",
      "clip"
    ], bP = (t) => wr(t).length > 0 && !io(pP, t), oO = (t) => {
      if (vc(t)) {
        const s = Us(t, "overflow-x"), a = Us(t, "overflow-y");
        return bP(s) || bP(a);
      } else
        return !1;
    }, m7 = (t) => {
      const s = OS(t, oO), a = s.length === 0 ? Ns(t).map(Is).map((i) => OS(i, oO)).getOr([]) : s;
      return Xn(a).map((i) => ({
        element: i,
        others: a.slice(1)
      }));
    }, Rp = (t, s) => Zg(t) ? m7(s) : A.none(), Av = (t) => {
      const s = [
        ...$e(t.others, Ar),
        La()
      ];
      return uh(Ar(t.element), s);
    }, $2 = (t, s, a) => ld(t, s, a).isSome(), vP = (t, s) => {
      let a = null;
      return {
        cancel: () => {
          a !== null && (clearTimeout(a), a = null);
        },
        schedule: (...g) => {
          a = setTimeout(() => {
            t.apply(null, g), a = null;
          }, s);
        }
      };
    }, yP = 5, f7 = 400, CP = (t) => {
      const s = t.raw;
      return s.touches === void 0 || s.touches.length !== 1 ? A.none() : A.some(s.touches[0]);
    }, g7 = (t, s) => {
      const a = Math.abs(t.clientX - s.x), i = Math.abs(t.clientY - s.y);
      return a > yP || i > yP;
    }, h7 = (t) => {
      const s = Go(), a = w(!1), i = vP((_) => {
        t.triggerEvent(wy(), _), a.set(!0);
      }, f7), d = (_) => (CP(_).each((D) => {
        i.cancel();
        const P = {
          x: D.clientX,
          y: D.clientY,
          target: _.target
        };
        i.schedule(_), a.set(!1), s.set(P);
      }), A.none()), g = (_) => (i.cancel(), CP(_).each((D) => {
        s.on((P) => {
          g7(D, P) && s.clear();
        });
      }), A.none()), p = (_) => {
        i.cancel();
        const D = (P) => Rs(P.target, _.target);
        return s.get().filter(D).map((P) => a.get() ? (_.prevent(), !1) : t.triggerEvent(ad(), _));
      }, C = Jn([
        {
          key: Mu(),
          value: d
        },
        {
          key: df(),
          value: g
        },
        {
          key: as(),
          value: p
        }
      ]);
      return { fireIfReady: (_, D) => Dt(C, D).bind((P) => P(_)) };
    }, p7 = (t) => t.raw.which === nA[0] && !io([
      "input",
      "textarea"
    ], Ds(t.target)) && !$2(t.target, '[contenteditable="true"]'), b7 = (t, s) => {
      const a = {
        stopBackspace: !0,
        ...s
      }, i = [
        "touchstart",
        "touchmove",
        "touchend",
        "touchcancel",
        "gesturestart",
        "mousedown",
        "mouseup",
        "mouseover",
        "mousemove",
        "mouseout",
        "click"
      ], d = h7(a), g = $e(i.concat([
        "selectstart",
        "input",
        "contextmenu",
        "change",
        "transitionend",
        "transitioncancel",
        "drag",
        "dragstart",
        "dragend",
        "dragenter",
        "dragleave",
        "dragover",
        "drop",
        "keyup"
      ]), (V) => hi(t, V, (Y) => {
        d.fireIfReady(Y, V).each((Pe) => {
          Pe && Y.kill();
        }), a.triggerEvent(V, Y) && Y.kill();
      })), p = Go(), C = hi(t, "paste", (V) => {
        d.fireIfReady(V, "paste").each((me) => {
          me && V.kill();
        }), a.triggerEvent("paste", V) && V.kill(), p.set(setTimeout(() => {
          a.triggerEvent(bg(), V);
        }, 0));
      }), S = hi(t, "keydown", (V) => {
        a.triggerEvent("keydown", V) ? V.kill() : a.stopBackspace && p7(V) && V.prevent();
      }), _ = hi(t, "focusin", (V) => {
        a.triggerEvent("focusin", V) && V.kill();
      }), D = Go(), P = hi(t, "focusout", (V) => {
        a.triggerEvent("focusout", V) && V.kill(), D.set(setTimeout(() => {
          a.triggerEvent(gf(), V);
        }, 0));
      });
      return { unbind: () => {
        ot(g, (V) => {
          V.unbind();
        }), S.unbind(), _.unbind(), P.unbind(), C.unbind(), p.on(clearTimeout), D.on(clearTimeout);
      } };
    }, wP = (t, s) => {
      const a = Dt(t, "target").getOr(s);
      return w(a);
    }, v7 = (t, s) => {
      const a = w(!1), i = w(!1);
      return {
        stop: () => {
          a.set(!0);
        },
        cut: () => {
          i.set(!0);
        },
        isStopped: a.get,
        isCut: i.get,
        event: t,
        setSource: s.set,
        getSource: s.get
      };
    }, SP = (t) => {
      const s = w(!1);
      return {
        stop: () => {
          s.set(!0);
        },
        cut: J,
        isStopped: s.get,
        isCut: Te,
        event: t,
        setSource: re("Cannot set source of a broadcasted event"),
        getSource: re("Cannot get source of a broadcasted event")
      };
    }, F2 = H.generate([
      { stopped: [] },
      { resume: ["element"] },
      { complete: [] }
    ]), xP = (t, s, a, i, d, g) => {
      const p = t(s, i), C = v7(a, d);
      return p.fold(() => (g.logEventNoHandlers(s, i), F2.complete()), (S) => {
        const _ = S.descHandler;
        return _h(_)(C), C.isStopped() ? (g.logEventStopped(s, S.element, _.purpose), F2.stopped()) : C.isCut() ? (g.logEventCut(s, S.element, _.purpose), F2.complete()) : Ta(S.element).fold(() => (g.logNoParent(s, S.element, _.purpose), F2.complete()), (P) => (g.logEventResponse(s, S.element, _.purpose), F2.resume(P)));
      });
    }, TP = (t, s, a, i, d, g) => xP(t, s, a, i, d, g).fold(Oe, (p) => TP(t, s, a, p, d, g), Te), y7 = (t, s, a, i, d) => {
      const g = wP(a, i);
      return xP(t, s, a, i, g, d);
    }, C7 = (t, s, a) => {
      const i = SP(s);
      return ot(t, (d) => {
        const g = d.descHandler;
        _h(g)(i);
      }), i.isStopped();
    }, sO = (t, s, a, i) => EP(t, s, a, a.target, i), EP = (t, s, a, i, d) => {
      const g = wP(a, i);
      return TP(t, s, a, i, g, d);
    }, w7 = (t, s) => ({
      element: t,
      descHandler: s
    }), S7 = (t, s) => ({
      id: t,
      descHandler: s
    }), kP = () => {
      const t = {}, s = (p, C, S) => {
        Ie(S, (_, D) => {
          const P = t[D] !== void 0 ? t[D] : {};
          P[C] = Py(_, p), t[D] = P;
        });
      }, a = (p, C) => C1(C).bind((S) => Dt(p, S)).map((S) => w7(C, S));
      return {
        registerId: s,
        unregisterId: (p) => {
          Ie(t, (C, S) => {
            Lo(C, p) && delete C[p];
          });
        },
        filterByType: (p) => Dt(t, p).map((C) => Yr(C, (S, _) => S7(_, S))).getOr([]),
        find: (p, C, S) => Dt(t, C).bind((_) => Vi(S, (D) => a(_, D), p))
      };
    }, _P = () => {
      const t = kP(), s = {}, a = (_) => {
        const D = _.element;
        return C1(D).getOrThunk(() => Sg("uid-", _.element));
      }, i = (_, D) => {
        const P = s[D];
        if (P === _)
          g(_);
        else
          throw new Error('The tagId "' + D + '" is already used by: ' + Cg(P.element) + `
Cannot use it for: ` + Cg(_.element) + `
The conflicting element is` + (qo(P.element) ? " " : " not ") + "already in the DOM");
      }, d = (_) => {
        const D = a(_);
        Or(s, D) && i(_, D);
        const P = [_];
        t.registerId(P, D, _.events), s[D] = _;
      }, g = (_) => {
        C1(_.element).each((D) => {
          delete s[D], t.unregisterId(D);
        });
      };
      return {
        find: (_, D, P) => t.find(_, D, P),
        filter: (_) => t.filterByType(_),
        register: d,
        unregister: g,
        getById: (_) => Dt(s, _)
      };
    }, Zm = gl({
      name: "Container",
      factory: (t) => {
        const { attributes: s, ...a } = t.dom;
        return {
          uid: t.uid,
          dom: {
            tag: "div",
            attributes: {
              role: "presentation",
              ...s
            },
            ...a
          },
          components: t.components,
          behaviours: Pm(t.containerBehaviours),
          events: t.events,
          domModification: t.domModification,
          eventOrder: t.eventOrder
        };
      },
      configFields: [
        Ne("components", []),
        za("containerBehaviours", []),
        Ne("events", {}),
        Ne("domModification", {}),
        Ne("eventOrder", {})
      ]
    }), TT = (t) => {
      const s = (xe) => Ta(t.element).fold(Oe, (Ce) => Rs(xe, Ce)), a = _P(), i = (xe, Ce) => a.find(s, xe, Ce), d = b7(t.element, {
        triggerEvent: (xe, Ce) => S0(xe, Ce.target, (Be) => sO(i, xe, Ce, Be))
      }), g = {
        debugInfo: U("real"),
        triggerEvent: (xe, Ce, Be) => {
          S0(xe, Ce, (St) => EP(i, xe, Be, Ce, St));
        },
        triggerFocus: (xe, Ce) => {
          C1(xe).fold(() => {
            Zi(xe);
          }, (Be) => {
            S0(ym(), xe, (St) => (y7(i, ym(), {
              originator: Ce,
              kill: J,
              prevent: J,
              target: xe
            }, xe, St), !1));
          });
        },
        triggerEscape: (xe, Ce) => {
          g.triggerEvent("keydown", xe.element, Ce.event);
        },
        getByUid: (xe) => me(xe),
        getByDom: (xe) => Pe(xe),
        build: Xc,
        buildOrPatch: y0,
        addToGui: (xe) => {
          S(xe);
        },
        removeFromGui: (xe) => {
          _(xe);
        },
        addToWorld: (xe) => {
          p(xe);
        },
        removeFromWorld: (xe) => {
          C(xe);
        },
        broadcast: (xe) => {
          L(xe);
        },
        broadcastOn: (xe, Ce) => {
          V(xe, Ce);
        },
        broadcastEvent: (xe, Ce) => {
          Y(xe, Ce);
        },
        isConnected: Oe
      }, p = (xe) => {
        xe.connect(g), Fo(xe.element) || (a.register(xe), ot(xe.components(), p), g.triggerEvent(hf(), xe.element, { target: xe.element }));
      }, C = (xe) => {
        Fo(xe.element) || (ot(xe.components(), C), a.unregister(xe)), xe.disconnect();
      }, S = (xe) => {
        Mf(t, xe);
      }, _ = (xe) => {
        jd(xe);
      }, D = () => {
        d.unbind(), rl(t.element);
      }, P = (xe) => {
        const Ce = a.filter(vg());
        ot(Ce, (Be) => {
          const St = Be.descHandler;
          _h(St)(xe);
        });
      }, L = (xe) => {
        P({
          universal: !0,
          data: xe
        });
      }, V = (xe, Ce) => {
        P({
          universal: !1,
          channels: xe,
          data: Ce
        });
      }, Y = (xe, Ce) => {
        const Be = a.filter(xe);
        return C7(Be, Ce);
      }, me = (xe) => a.getById(xe).fold(() => Mo.error(new Error('Could not find component with uid: "' + xe + '" in system.')), Mo.value), Pe = (xe) => {
        const Ce = C1(xe).getOr("not found");
        return me(Ce);
      };
      return p(t), {
        root: t,
        element: t.element,
        destroy: D,
        add: S,
        remove: _,
        getByUid: me,
        getByDom: Pe,
        addToWorld: p,
        removeFromWorld: C,
        broadcast: L,
        broadcastOn: V,
        broadcastEvent: Y
      };
    }, x7 = (t, s) => ({
      dom: {
        tag: "div",
        classes: [
          "tox-bar",
          "tox-form__controls-h-stack"
        ]
      },
      components: $e(t.items, s.interpreter)
    }), T7 = U([
      Ne("prefix", "form-field"),
      za("fieldBehaviours", [
        ts,
        ln
      ])
    ]), E7 = U([
      qi({
        schema: [gt("dom")],
        name: "label"
      }),
      qi({
        factory: {
          sketch: (t) => ({
            uid: t.uid,
            dom: {
              tag: "span",
              styles: { display: "none" },
              attributes: { "aria-hidden": "true" },
              innerHtml: t.text
            }
          })
        },
        schema: [gt("text")],
        name: "aria-descriptor"
      }),
      ei({
        factory: {
          sketch: (t) => {
            const s = pn(t, ["factory"]);
            return t.factory.sketch(s);
          }
        },
        schema: [gt("factory")],
        name: "field"
      })
    ]), k7 = (t, s, a, i) => {
      const d = Oa(t.fieldBehaviours, [
        ts.config({
          find: (C) => ir(C, t, "field")
        }),
        ln.config({
          store: {
            mode: "manual",
            getValue: (C) => ts.getCurrent(C).bind(ln.getValue),
            setValue: (C, S) => {
              ts.getCurrent(C).each((_) => {
                ln.setValue(_, S);
              });
            }
          }
        })
      ]), g = vr([cr((C, S) => {
        const _ = QS(C, t, [
          "label",
          "field",
          "aria-descriptor"
        ]);
        _.field().each((D) => {
          const P = An(t.prefix);
          _.label().each((L) => {
            sn(L.element, "for", P), sn(D.element, "id", P);
          }), _["aria-descriptor"]().each((L) => {
            const V = An(t.prefix);
            sn(L.element, "id", V), sn(D.element, "aria-describedby", V);
          });
        });
      })]), p = {
        getField: (C) => ir(C, t, "field"),
        getLabel: (C) => ir(C, t, "label")
      };
      return {
        uid: t.uid,
        dom: t.dom,
        components: s,
        behaviours: d,
        events: g,
        apis: p
      };
    }, qs = ti({
      name: "FormField",
      configFields: T7(),
      partFields: E7(),
      factory: k7,
      apis: {
        getField: (t, s) => t.getField(s),
        getLabel: (t, s) => t.getLabel(s)
      }
    });
    var ET = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      exhibit: (t, s) => ll({
        attributes: Jn([{
          key: s.tabAttr,
          value: "true"
        }])
      })
    }), _7 = [Ne("tabAttr", "data-alloy-tabstop")];
    const Lr = tc({
      fields: _7,
      name: "tabstopping",
      active: ET
    });
    var A7 = tinymce.util.Tools.resolve("tinymce.html.Entities");
    const I2 = (t, s, a, i) => {
      const d = D7(t, s, a, i);
      return qs.sketch(d);
    }, O7 = (t, s) => I2(t, s, [], []), D7 = (t, s, a, i) => ({
      dom: L2(a),
      components: t.toArray().concat([s]),
      fieldBehaviours: Ut(i)
    }), Ij = () => L2([]), L2 = (t) => ({
      tag: "div",
      classes: ["tox-form__group"].concat(t)
    }), Td = (t, s) => qs.parts.label({
      dom: {
        tag: "label",
        classes: ["tox-label"]
      },
      components: [da(s.translate(t))]
    }), Zl = An("form-component-change"), Ov = An("form-close"), Np = An("form-cancel"), Zf = An("form-action"), H2 = An("form-submit"), rO = An("form-block"), aO = An("form-unblock"), AP = An("form-tabchange"), OP = An("form-resize"), R7 = (t, s, a) => {
      const i = t.label.map((V) => Td(V, s)), d = s.icons(), g = (V) => {
        var Y;
        return (Y = d[V]) !== null && Y !== void 0 ? Y : V;
      }, p = (V) => (Y, me) => {
        ld(me.event.target, "[data-collection-item-value]").each((Pe) => {
          V(Y, me, Pe, rr(Pe, "data-collection-item-value"));
        });
      }, C = (V, Y) => {
        const me = $e(Y, (Ce) => {
          const Be = Vl.translate(Ce.text), St = t.columns === 1 ? `<div class="tox-collection__item-label">${Be}</div>` : "", ct = `<div class="tox-collection__item-icon">${g(Ce.icon)}</div>`, tt = {
            _: " ",
            " - ": " ",
            "-": " "
          }, Vt = Be.replace(/\_| \- |\-/g, ($o) => tt[$o]);
          return `<div class="tox-collection__item${s.isDisabled() ? " tox-collection__item--state-disabled" : ""}" tabindex="-1" data-collection-item-value="${A7.encodeAllRaw(Ce.value)}" title="${Vt}" aria-label="${Vt}">${ct}${St}</div>`;
        }), Pe = t.columns !== "auto" && t.columns > 1 ? kn(me, t.columns) : [me], xe = $e(Pe, (Ce) => `<div class="tox-collection__group">${Ce.join("")}</div>`);
        yg(V.element, xe.join(""));
      }, S = p((V, Y, me, Pe) => {
        Y.stop(), s.isDisabled() || to(V, Zf, {
          name: t.name,
          value: Pe
        });
      }), _ = [
        mt(Rl(), p((V, Y, me) => {
          Zi(me);
        })),
        mt(vm(), S),
        mt(ad(), S),
        mt($c(), p((V, Y, me) => {
          va(V.element, "." + Tp).each((Pe) => {
            Wr(Pe, Tp);
          }), ba(me, Tp);
        })),
        mt(Jb(), p((V) => {
          va(V.element, "." + Tp).each((Y) => {
            Wr(Y, Tp);
          });
        })),
        Bu(p((V, Y, me, Pe) => {
          to(V, Zf, {
            name: t.name,
            value: Pe
          });
        }))
      ], D = (V, Y) => $e(nc(V.element, ".tox-collection__item"), Y), P = qs.parts.field({
        dom: {
          tag: "div",
          classes: ["tox-collection"].concat(t.columns !== 1 ? ["tox-collection--grid"] : ["tox-collection--list"])
        },
        components: [],
        factory: { sketch: Tt },
        behaviours: Ut([
          mo.config({
            disabled: s.isDisabled,
            onDisabled: (V) => {
              D(V, (Y) => {
                ba(Y, "tox-collection__item--state-disabled"), sn(Y, "aria-disabled", !0);
              });
            },
            onEnabled: (V) => {
              D(V, (Y) => {
                Wr(Y, "tox-collection__item--state-disabled"), se(Y, "aria-disabled");
              });
            }
          }),
          fc(),
          Oo.config({}),
          ln.config({
            store: {
              mode: "memory",
              initialValue: a.getOr([])
            },
            onSetValue: (V, Y) => {
              C(V, Y), t.columns === "auto" && E2(V, 5, "tox-collection__item").each(({ numRows: me, numColumns: Pe }) => {
                no.setGridSize(V, me, Pe);
              }), cs(V, OP);
            }
          }),
          Lr.config({}),
          no.config(O8(t.columns, "normal")),
          Bo("collection-events", _)
        ]),
        eventOrder: {
          [cl()]: [
            "disabling",
            "alloy.base.behaviour",
            "collection-events"
          ]
        }
      });
      return I2(i, P, ["tox-form__group--collection"], []);
    }, N7 = [
      "input",
      "textarea"
    ], DP = (t) => {
      const s = Ds(t);
      return io(N7, s);
    }, RP = (t, s) => {
      const a = s.getRoot(t).getOr(t.element);
      Wr(a, s.invalidClass), s.notify.each((i) => {
        DP(t.element) && sn(t.element, "aria-invalid", !1), i.getContainer(t).each((d) => {
          yg(d, i.validHtml);
        }), i.onValid(t);
      });
    }, cO = (t, s, a, i) => {
      const d = s.getRoot(t).getOr(t.element);
      ba(d, s.invalidClass), s.notify.each((g) => {
        DP(t.element) && sn(t.element, "aria-invalid", !0), g.getContainer(t).each((p) => {
          yg(p, i);
        }), g.onInvalid(t, i);
      });
    }, _b = (t, s, a) => s.validator.fold(() => vi.pure(Mo.value(!0)), (i) => i.validate(t)), Xg = (t, s, a) => (s.notify.each((i) => {
      i.onValidate(t);
    }), _b(t, s).map((i) => t.getSystem().isConnected() ? i.fold((d) => (cO(t, s, a, d), Mo.error(d)), (d) => (RP(t, s), Mo.value(d))) : Mo.error("No longer in system")));
    var NP = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      markValid: RP,
      markInvalid: cO,
      query: _b,
      run: Xg,
      isInvalid: (t, s) => {
        const a = s.getRoot(t).getOr(t.element);
        return Ha(a, s.invalidClass);
      }
    }), kT = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      events: (t, s) => t.validator.map((a) => vr([mt(a.onEvent, (i) => {
        Xg(i, t, s).get(Tt);
      })].concat(a.validateOnLoad ? [cr((i) => {
        Xg(i, t, s).get(J);
      })] : []))).getOr({})
    }), P7 = [
      gt("invalidClass"),
      Ne("getRoot", A.none),
      ui("notify", [
        Ne("aria", "alert"),
        Ne("getContainer", A.none),
        Ne("validHtml", ""),
        gs("onValid"),
        gs("onInvalid"),
        gs("onValidate")
      ]),
      ui("validator", [
        gt("validate"),
        Ne("onEvent", "input"),
        Ne("validateOnLoad", !0)
      ])
    ];
    const ju = tc({
      fields: P7,
      name: "invalidating",
      active: kT,
      apis: NP,
      extra: {
        validation: (t) => (s) => {
          const a = ln.getValue(s);
          return vi.pure(t(a));
        }
      }
    });
    var B7 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      events: () => vr([xy(Mw(), Oe)]),
      exhibit: () => ll({
        styles: {
          "-webkit-user-select": "none",
          "user-select": "none",
          "-ms-user-select": "none",
          "-moz-user-select": "-moz-none"
        },
        attributes: { unselectable: "on" }
      })
    });
    const z2 = tc({
      fields: [],
      name: "unselecting",
      active: B7
    }), $7 = (t, s) => xd.sketch({
      dom: t.dom,
      components: t.components,
      toggleClass: "mce-active",
      dropdownBehaviours: Ut([
        Zu.button(s.providers.isDisabled),
        fc(),
        z2.config({}),
        Lr.config({})
      ]),
      layouts: t.layouts,
      sandboxClasses: ["tox-dialog__popups"],
      lazySink: s.getSink,
      fetch: (a) => vi.nu((i) => t.fetch(i)).map((i) => A.from(xT(Ms(j3(An("menu-value"), i, (d) => {
        t.onItemAction(a, d);
      }, t.columns, t.presets, Um.CLOSE_ON_EXECUTE, Te, s.providers), { movement: yT(t.columns, t.presets) })))),
      parts: { menu: Sv(!1, 1, t.presets) }
    }), MP = An("color-input-change"), PP = An("color-swatch-change"), V2 = An("color-picker-cancel"), F7 = (t, s, a, i) => {
      const d = qs.parts.field({
        factory: Cb,
        inputClasses: ["tox-textfield"],
        data: i,
        onSetValue: (_) => ju.run(_).get(J),
        inputBehaviours: Ut([
          mo.config({ disabled: s.providers.isDisabled }),
          fc(),
          Lr.config({}),
          ju.config({
            invalidClass: "tox-textbox-field-invalid",
            getRoot: (_) => Oc(_.element),
            notify: {
              onValid: (_) => {
                const D = ln.getValue(_);
                to(_, MP, { color: D });
              }
            },
            validator: {
              validateOnLoad: !1,
              validate: (_) => {
                const D = ln.getValue(_);
                if (D.length === 0)
                  return vi.pure(Mo.value(!0));
                {
                  const P = ve.fromTag("span");
                  _n(P, "background-color", D);
                  const L = Xs(P, "background-color").fold(() => Mo.error("blah"), (V) => Mo.value(D));
                  return vi.pure(L);
                }
              }
            }
          })
        ]),
        selectOnFocus: !1
      }), g = t.label.map((_) => Td(_, s.providers)), p = (_, D) => {
        to(_, PP, { value: D });
      }, C = (_, D) => {
        S.getOpt(_).each((P) => {
          D === "custom" ? a.colorPicker((L) => {
            L.fold(() => cs(P, V2), (V) => {
              p(P, V), F3(t.storageKey, V);
            });
          }, "#ffffff") : D === "remove" ? p(P, "") : p(P, D);
        });
      }, S = js($7({
        dom: {
          tag: "span",
          attributes: { "aria-label": s.providers.translate("Color swatch") }
        },
        layouts: {
          onRtl: () => [
            Lc,
            Qa,
            ec
          ],
          onLtr: () => [
            Qa,
            Lc,
            ec
          ]
        },
        components: [],
        fetch: QM(a.getColors(t.storageKey), t.storageKey, a.hasCustomColors()),
        columns: a.getColorCols(t.storageKey),
        presets: "color",
        onItemAction: C
      }, s));
      return qs.sketch({
        dom: {
          tag: "div",
          classes: ["tox-form__group"]
        },
        components: g.toArray().concat([{
          dom: {
            tag: "div",
            classes: ["tox-color-input"]
          },
          components: [
            d,
            S.asSpec()
          ]
        }]),
        fieldBehaviours: Ut([Bo("form-field-events", [
          mt(MP, (_, D) => {
            S.getOpt(_).each((P) => {
              _n(P.element, "background-color", D.event.color);
            }), to(_, Zl, { name: t.name });
          }),
          mt(PP, (_, D) => {
            qs.getField(_).each((P) => {
              ln.setValue(P, D.event.value), ts.getCurrent(_).each(po.focus);
            });
          }),
          mt(V2, (_, D) => {
            qs.getField(_).each((P) => {
              ts.getCurrent(_).each(po.focus);
            });
          })
        ])])
      });
    }, iO = qi({
      schema: [gt("dom")],
      name: "label"
    }), Mp = (t) => qi({
      name: "" + t + "-edge",
      overrides: (s) => s.model.manager.edgeActions[t].fold(() => ({}), (i) => ({
        events: vr([
          r0(Mu(), (d, g, p) => i(d, p), [s]),
          r0(Zs(), (d, g, p) => i(d, p), [s]),
          r0(Bc(), (d, g, p) => {
            p.mouseIsDown.get() && i(d, p);
          }, [s])
        ])
      }))
    }), I7 = Mp("top-left"), L7 = Mp("top"), BP = Mp("top-right"), H7 = Mp("right"), z7 = Mp("bottom-right"), V7 = Mp("bottom"), $P = Mp("bottom-left"), U7 = Mp("left"), W7 = ei({
      name: "thumb",
      defaults: U({ dom: { styles: { position: "absolute" } } }),
      overrides: (t) => ({
        events: vr([
          wh(Mu(), t, "spectrum"),
          wh(df(), t, "spectrum"),
          wh(as(), t, "spectrum"),
          wh(Zs(), t, "spectrum"),
          wh(Bc(), t, "spectrum"),
          wh(m1(), t, "spectrum")
        ])
      })
    }), AT = (t) => Hm(t.event), Z7 = ei({
      schema: [oa("mouseIsDown", () => w(!1))],
      name: "spectrum",
      overrides: (t) => {
        const a = t.model.manager, i = (d, g) => a.getValueFromEvent(g).map((p) => a.setValueFrom(d, t, p));
        return {
          behaviours: Ut([
            no.config({
              mode: "special",
              onLeft: (d, g) => a.onLeft(d, t, AT(g)),
              onRight: (d, g) => a.onRight(d, t, AT(g)),
              onUp: (d, g) => a.onUp(d, t, AT(g)),
              onDown: (d, g) => a.onDown(d, t, AT(g))
            }),
            Lr.config({}),
            po.config({})
          ]),
          events: vr([
            mt(Mu(), i),
            mt(df(), i),
            mt(Zs(), i),
            mt(Bc(), (d, g) => {
              t.mouseIsDown.get() && i(d, g);
            })
          ])
        };
      }
    });
    var j7 = [
      iO,
      U7,
      H7,
      L7,
      V7,
      I7,
      BP,
      $P,
      z7,
      W7,
      Z7
    ];
    const Dv = U("slider.change.value"), G7 = (t) => t.type.indexOf("touch") !== -1, lO = (t) => {
      const s = t.event.raw;
      if (G7(s)) {
        const a = s;
        return a.touches !== void 0 && a.touches.length === 1 ? A.some(a.touches[0]).map((i) => Es(i.clientX, i.clientY)) : A.none();
      } else {
        const a = s;
        return a.clientX !== void 0 ? A.some(a).map((i) => Es(i.clientX, i.clientY)) : A.none();
      }
    }, K7 = "top", Y7 = "right", X7 = "bottom", FP = "left", em = (t) => t.model.minX, Ab = (t) => t.model.minY, OT = (t) => t.model.minX - 1, DT = (t) => t.model.minY - 1, jf = (t) => t.model.maxX, Mi = (t) => t.model.maxY, Rv = (t) => t.model.maxX + 1, U2 = (t) => t.model.maxY + 1, IP = (t, s, a) => s(t) - a(t), uO = (t) => IP(t, jf, em), dO = (t) => IP(t, Mi, Ab), LP = (t) => uO(t) / 2, mO = (t) => dO(t) / 2, Ob = (t, s) => s ? t.stepSize * t.speedMultiplier : t.stepSize, HP = (t) => t.snapToGrid, zP = (t) => t.snapStart, fO = (t) => t.rounded, RT = (t, s) => t[s + "-edge"] !== void 0, gO = (t) => RT(t, FP), hO = (t) => RT(t, Y7), pO = (t) => RT(t, K7), VP = (t) => RT(t, X7), Jg = (t) => t.model.value.get(), Pp = (t, s) => ({
      x: t,
      y: s
    }), tm = (t, s) => {
      to(t, Dv(), { value: s });
    }, J7 = (t, s) => {
      tm(t, Pp(OT(s), DT(s)));
    }, Q7 = (t, s) => {
      tm(t, DT(s));
    }, bO = (t, s) => {
      tm(t, Pp(LP(s), DT(s)));
    }, eH = (t, s) => {
      tm(t, Pp(Rv(s), DT(s)));
    }, UP = (t, s) => {
      tm(t, Rv(s));
    }, tH = (t, s) => {
      tm(t, Pp(Rv(s), mO(s)));
    }, nH = (t, s) => {
      tm(t, Pp(Rv(s), U2(s)));
    }, oH = (t, s) => {
      tm(t, U2(s));
    }, sH = (t, s) => {
      tm(t, Pp(LP(s), U2(s)));
    }, rH = (t, s) => {
      tm(t, Pp(OT(s), U2(s)));
    }, aH = (t, s) => {
      tm(t, OT(s));
    }, cH = (t, s) => {
      tm(t, Pp(OT(s), mO(s)));
    }, NT = (t, s, a, i) => t < s ? t : t > a ? a : t === s ? s - 1 : Math.max(s, t - i), MT = (t, s, a, i) => t > a ? t : t < s ? s : t === a ? a + 1 : Math.min(a, t + i), WP = (t, s, a) => Math.max(s, Math.min(a, t)), iH = (t, s, a, i, d) => d.fold(() => {
      const g = t - s, p = Math.round(g / i) * i;
      return WP(s + p, s - 1, a + 1);
    }, (g) => {
      const p = (t - g) % i, C = Math.round(p / i), S = Math.floor((t - g) / i), _ = Math.floor((a - g) / i), D = Math.min(_, S + C), P = g + D * i;
      return Math.max(g, P);
    }), lH = (t, s, a) => Math.min(a, Math.max(t, s)) - s, ZP = (t) => {
      const { min: s, max: a, range: i, value: d, step: g, snap: p, snapStart: C, rounded: S, hasMinEdge: _, hasMaxEdge: D, minBound: P, maxBound: L, screenRange: V } = t, Y = _ ? s - 1 : s, me = D ? a + 1 : a;
      if (d < P)
        return Y;
      if (d > L)
        return me;
      {
        const Pe = lH(d, P, L), xe = WP(Pe / V * i + s, Y, me);
        return p && xe >= s && xe <= a ? iH(xe, s, a, g, C) : S ? Math.round(xe) : xe;
      }
    }, jP = (t) => {
      const { min: s, max: a, range: i, value: d, hasMinEdge: g, hasMaxEdge: p, maxBound: C, maxOffset: S, centerMinEdge: _, centerMaxEdge: D } = t;
      return d < s ? g ? 0 : _ : d > a ? p ? C : D : (d - s) / i * S;
    }, vO = "top", yO = "right", CO = "bottom", PT = "left", wO = "width", uH = "height", jm = (t) => t.element.dom.getBoundingClientRect(), nm = (t, s) => t[s], BT = (t) => {
      const s = jm(t);
      return nm(s, PT);
    }, qP = (t) => {
      const s = jm(t);
      return nm(s, yO);
    }, $T = (t) => {
      const s = jm(t);
      return nm(s, vO);
    }, FT = (t) => {
      const s = jm(t);
      return nm(s, CO);
    }, qf = (t) => {
      const s = jm(t);
      return nm(s, wO);
    }, GP = (t) => {
      const s = jm(t);
      return nm(s, uH);
    }, Nv = (t, s, a) => (t + s) / 2 - a, KP = (t, s) => {
      const a = jm(t), i = jm(s), d = nm(a, PT), g = nm(a, yO), p = nm(i, PT);
      return Nv(d, g, p);
    }, IT = (t, s) => {
      const a = jm(t), i = jm(s), d = nm(a, vO), g = nm(a, CO), p = nm(i, vO);
      return Nv(d, g, p);
    }, LT = (t, s) => {
      to(t, Dv(), { value: s });
    }, SO = (t, s, a) => {
      const i = {
        min: em(s),
        max: jf(s),
        range: uO(s),
        value: a,
        step: Ob(s),
        snap: HP(s),
        snapStart: zP(s),
        rounded: fO(s),
        hasMinEdge: gO(s),
        hasMaxEdge: hO(s),
        minBound: BT(t),
        maxBound: qP(t),
        screenRange: qf(t)
      };
      return ZP(i);
    }, dH = (t, s, a) => {
      const i = SO(t, s, a);
      return LT(t, i), i;
    }, YP = (t, s) => {
      const a = em(s);
      LT(t, a);
    }, mH = (t, s) => {
      const a = jf(s);
      LT(t, a);
    }, xO = (t, s, a, i) => {
      const g = (t > 0 ? MT : NT)(Jg(a), em(a), jf(a), Ob(a, i));
      return LT(s, g), A.some(g);
    }, HT = (t) => (s, a, i) => xO(t, s, a, i).map(Oe), TO = (t) => lO(t).map((a) => a.left), fH = (t, s, a, i, d) => {
      const p = qf(t), C = i.bind((D) => A.some(KP(D, t))).getOr(0), S = d.bind((D) => A.some(KP(D, t))).getOr(p), _ = {
        min: em(s),
        max: jf(s),
        range: uO(s),
        value: a,
        hasMinEdge: gO(s),
        hasMaxEdge: hO(s),
        minBound: BT(t),
        maxBound: qP(t),
        maxOffset: p,
        centerMinEdge: C,
        centerMaxEdge: S
      };
      return jP(_);
    }, jl = (t, s, a, i, d, g) => {
      const p = fH(s, g, a, i, d);
      return BT(s) - BT(t) + p;
    }, gH = (t, s, a, i) => {
      const d = Jg(a), g = jl(t, i.getSpectrum(t), d, i.getLeftEdge(t), i.getRightEdge(t), a), p = j(s.element) / 2;
      _n(s.element, "left", g - p + "px");
    }, hH = HT(-1), XP = HT(1), JP = A.none, pH = A.none, bH = {
      "top-left": A.none(),
      top: A.none(),
      "top-right": A.none(),
      right: A.some(UP),
      "bottom-right": A.none(),
      bottom: A.none(),
      "bottom-left": A.none(),
      left: A.some(aH)
    };
    var vH = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      setValueFrom: dH,
      setToMin: YP,
      setToMax: mH,
      findValueOfOffset: SO,
      getValueFromEvent: TO,
      findPositionOfValue: jl,
      setPositionFromValue: gH,
      onLeft: hH,
      onRight: XP,
      onUp: JP,
      onDown: pH,
      edgeActions: bH
    });
    const zT = (t, s) => {
      to(t, Dv(), { value: s });
    }, EO = (t, s, a) => {
      const i = {
        min: Ab(s),
        max: Mi(s),
        range: dO(s),
        value: a,
        step: Ob(s),
        snap: HP(s),
        snapStart: zP(s),
        rounded: fO(s),
        hasMinEdge: pO(s),
        hasMaxEdge: VP(s),
        minBound: $T(t),
        maxBound: FT(t),
        screenRange: GP(t)
      };
      return ZP(i);
    }, yH = (t, s, a) => {
      const i = EO(t, s, a);
      return zT(t, i), i;
    }, CH = (t, s) => {
      const a = Ab(s);
      zT(t, a);
    }, QP = (t, s) => {
      const a = Mi(s);
      zT(t, a);
    }, wH = (t, s, a, i) => {
      const g = (t > 0 ? MT : NT)(Jg(a), Ab(a), Mi(a), Ob(a, i));
      return zT(s, g), A.some(g);
    }, eB = (t) => (s, a, i) => wH(t, s, a, i).map(Oe), SH = (t) => lO(t).map((a) => a.top), tB = (t, s, a, i, d) => {
      const p = GP(t), C = i.bind((D) => A.some(IT(D, t))).getOr(0), S = d.bind((D) => A.some(IT(D, t))).getOr(p), _ = {
        min: Ab(s),
        max: Mi(s),
        range: dO(s),
        value: a,
        hasMinEdge: pO(s),
        hasMaxEdge: VP(s),
        minBound: $T(t),
        maxBound: FT(t),
        maxOffset: p,
        centerMinEdge: C,
        centerMaxEdge: S
      };
      return jP(_);
    }, W2 = (t, s, a, i, d, g) => {
      const p = tB(s, g, a, i, d);
      return $T(s) - $T(t) + p;
    }, xH = (t, s, a, i) => {
      const d = Jg(a), g = W2(t, i.getSpectrum(t), d, i.getTopEdge(t), i.getBottomEdge(t), a), p = hr(s.element) / 2;
      _n(s.element, "top", g - p + "px");
    }, kO = A.none, Mv = A.none, nB = eB(-1), oB = eB(1), sB = {
      "top-left": A.none(),
      top: A.some(Q7),
      "top-right": A.none(),
      right: A.none(),
      "bottom-right": A.none(),
      bottom: A.some(oH),
      "bottom-left": A.none(),
      left: A.none()
    };
    var TH = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      setValueFrom: yH,
      setToMin: CH,
      setToMax: QP,
      findValueOfOffset: EO,
      getValueFromEvent: SH,
      findPositionOfValue: W2,
      setPositionFromValue: xH,
      onLeft: kO,
      onRight: Mv,
      onUp: nB,
      onDown: oB,
      edgeActions: sB
    });
    const VT = (t, s) => {
      to(t, Dv(), { value: s });
    }, Db = (t, s) => ({
      x: t,
      y: s
    }), EH = (t, s, a) => {
      const i = SO(t, s, a.left), d = EO(t, s, a.top), g = Db(i, d);
      return VT(t, g), g;
    }, kH = (t, s, a, i, d) => {
      const g = t > 0 ? MT : NT, p = s ? Jg(i).x : g(Jg(i).x, em(i), jf(i), Ob(i, d)), C = s ? g(Jg(i).y, Ab(i), Mi(i), Ob(i, d)) : Jg(i).y;
      return VT(a, Db(p, C)), A.some(p);
    }, Z2 = (t, s) => (a, i, d) => kH(t, s, a, i, d).map(Oe), rB = (t, s) => {
      const a = em(s), i = Ab(s);
      VT(t, Db(a, i));
    }, _O = (t, s) => {
      const a = jf(s), i = Mi(s);
      VT(t, Db(a, i));
    }, aB = (t) => lO(t), pl = (t, s, a, i) => {
      const d = Jg(a), g = jl(t, i.getSpectrum(t), d.x, i.getLeftEdge(t), i.getRightEdge(t), a), p = W2(t, i.getSpectrum(t), d.y, i.getTopEdge(t), i.getBottomEdge(t), a), C = j(s.element) / 2, S = hr(s.element) / 2;
      _n(s.element, "left", g - C + "px"), _n(s.element, "top", p - S + "px");
    }, cB = Z2(-1, !1), _H = Z2(1, !1), AH = Z2(-1, !0), iB = Z2(1, !0), OH = {
      "top-left": A.some(J7),
      top: A.some(bO),
      "top-right": A.some(eH),
      right: A.some(tH),
      "bottom-right": A.some(nH),
      bottom: A.some(sH),
      "bottom-left": A.some(rH),
      left: A.some(cH)
    };
    var DH = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      setValueFrom: EH,
      setToMin: rB,
      setToMax: _O,
      getValueFromEvent: aB,
      setPositionFromValue: pl,
      onLeft: cB,
      onRight: _H,
      onUp: AH,
      onDown: iB,
      edgeActions: OH
    });
    const RH = [
      Ne("stepSize", 1),
      Ne("speedMultiplier", 10),
      Ne("onChange", J),
      Ne("onChoose", J),
      Ne("onInit", J),
      Ne("onDragStart", J),
      Ne("onDragEnd", J),
      Ne("snapToGrid", !1),
      Ne("rounded", !0),
      $s("snapStart"),
      _i("model", es("mode", {
        x: [
          Ne("minX", 0),
          Ne("maxX", 100),
          oa("value", (t) => w(t.mode.minX)),
          gt("getInitialValue"),
          Qs("manager", vH)
        ],
        y: [
          Ne("minY", 0),
          Ne("maxY", 100),
          oa("value", (t) => w(t.mode.minY)),
          gt("getInitialValue"),
          Qs("manager", TH)
        ],
        xy: [
          Ne("minX", 0),
          Ne("maxX", 100),
          Ne("minY", 0),
          Ne("maxY", 100),
          oa("value", (t) => w({
            x: t.mode.minX,
            y: t.mode.minY
          })),
          gt("getInitialValue"),
          Qs("manager", DH)
        ]
      })),
      za("sliderBehaviours", [
        no,
        ln
      ]),
      oa("mouseIsDown", () => w(!1))
    ], oi = ti({
      name: "Slider",
      configFields: RH,
      partFields: j7,
      factory: (t, s, a, i) => {
        const d = (ct) => $m(ct, t, "thumb"), g = (ct) => $m(ct, t, "spectrum"), p = (ct) => ir(ct, t, "left-edge"), C = (ct) => ir(ct, t, "right-edge"), S = (ct) => ir(ct, t, "top-edge"), _ = (ct) => ir(ct, t, "bottom-edge"), D = t.model, P = D.manager, L = (ct, tt) => {
          P.setPositionFromValue(ct, tt, t, {
            getLeftEdge: p,
            getRightEdge: C,
            getTopEdge: S,
            getBottomEdge: _,
            getSpectrum: g
          });
        }, V = (ct, tt) => {
          D.value.set(tt);
          const Vt = d(ct);
          L(ct, Vt);
        }, Y = (ct, tt) => {
          V(ct, tt);
          const Vt = d(ct);
          return t.onChange(ct, Vt, tt), A.some(!0);
        }, me = (ct) => {
          P.setToMin(ct, t);
        }, Pe = (ct) => {
          P.setToMax(ct, t);
        }, xe = (ct) => {
          const tt = () => {
            ir(ct, t, "thumb").each((Xt) => {
              const $o = D.value.get();
              t.onChoose(ct, Xt, $o);
            });
          }, Vt = t.mouseIsDown.get();
          t.mouseIsDown.set(!1), Vt && tt();
        }, Ce = (ct, tt) => {
          tt.stop(), t.mouseIsDown.set(!0), t.onDragStart(ct, d(ct));
        }, Be = (ct, tt) => {
          tt.stop(), t.onDragEnd(ct, d(ct)), xe(ct);
        }, St = (ct) => {
          ir(ct, t, "spectrum").map(no.focusIn);
        };
        return {
          uid: t.uid,
          dom: t.dom,
          components: s,
          behaviours: Oa(t.sliderBehaviours, [
            no.config({
              mode: "special",
              focusIn: St
            }),
            ln.config({
              store: {
                mode: "manual",
                getValue: (ct) => D.value.get(),
                setValue: V
              }
            }),
            Wi.config({ channels: { [PC()]: { onReceive: xe } } })
          ]),
          events: vr([
            mt(Dv(), (ct, tt) => {
              Y(ct, tt.event.value);
            }),
            cr((ct, tt) => {
              const Vt = D.getInitialValue();
              D.value.set(Vt);
              const Xt = d(ct);
              L(ct, Xt);
              const $o = g(ct);
              t.onInit(ct, Xt, $o, D.value.get());
            }),
            mt(Mu(), Ce),
            mt(as(), Be),
            mt(Zs(), (ct, tt) => {
              St(ct), Ce(ct, tt);
            }),
            mt(m1(), Be)
          ]),
          apis: {
            resetToMin: me,
            resetToMax: Pe,
            setValue: V,
            refresh: L
          },
          domModification: { styles: { position: "relative" } }
        };
      },
      apis: {
        setValue: (t, s, a) => {
          t.setValue(s, a);
        },
        resetToMin: (t, s) => {
          t.resetToMin(s);
        },
        resetToMax: (t, s) => {
          t.resetToMax(s);
        },
        refresh: (t, s) => {
          t.refresh(s);
        }
      }
    }), j2 = An("rgb-hex-update"), AO = An("slider-update"), q2 = An("palette-update"), OO = (t, s) => {
      const a = oi.parts.spectrum({
        dom: {
          tag: "div",
          classes: [s("hue-slider-spectrum")],
          attributes: { role: "presentation" }
        }
      }), i = oi.parts.thumb({
        dom: {
          tag: "div",
          classes: [s("hue-slider-thumb")],
          attributes: { role: "presentation" }
        }
      });
      return oi.sketch({
        dom: {
          tag: "div",
          classes: [s("hue-slider")],
          attributes: {
            role: "slider",
            "aria-valuemin": 0,
            "aria-valuemax": 360,
            "aria-valuenow": 120
          }
        },
        rounded: !1,
        model: {
          mode: "y",
          getInitialValue: U(0)
        },
        components: [
          a,
          i
        ],
        sliderBehaviours: Ut([po.config({})]),
        onChange: (d, g, p) => {
          sn(d.element, "aria-valuenow", Math.floor(360 - p * 3.6)), to(d, AO, { value: p });
        }
      });
    }, lB = "form", MH = [za("formBehaviours", [ln])], uB = (t) => "<alloy.field." + t + ">", PH = (t) => {
      const s = (() => {
        const g = [];
        return {
          field: (C, S) => (g.push(C), zC(lB, uB(C), S)),
          record: U(g)
        };
      })(), a = t(s), i = s.record(), d = $e(i, (g) => ei({
        name: g,
        pname: uB(g)
      }));
      return GC(lB, MH, d, $H, a);
    }, BH = (t, s) => t.fold(() => Mo.error(s), Mo.value), $H = (t, s) => ({
      uid: t.uid,
      dom: t.dom,
      components: s,
      behaviours: Oa(t.formBehaviours, [ln.config({
        store: {
          mode: "manual",
          getValue: (a) => {
            const i = UC(a, t);
            return et(i, (d, g) => d().bind((p) => {
              const C = ts.getCurrent(p);
              return BH(C, new Error(`Cannot find a current component to extract the value from for form part '${g}': ` + Cg(p.element)));
            }).map(ln.getValue));
          },
          setValue: (a, i) => {
            Ie(i, (d, g) => {
              ir(a, t, g).each((p) => {
                ts.getCurrent(p).each((C) => {
                  ln.setValue(C, d);
                });
              });
            });
          }
        }
      })]),
      apis: {
        getField: (a, i) => ir(a, t, i).bind(ts.getCurrent)
      }
    }), Pv = {
      getField: xg((t, s, a) => t.getField(s, a)),
      sketch: PH
    }, DO = An("valid-input"), dB = An("invalid-input"), qm = An("validating-input"), Bv = "colorcustom.rgb.", FH = (t, s, a, i) => {
      const d = (L, V) => ju.config({
        invalidClass: s("invalid"),
        notify: {
          onValidate: (Y) => {
            to(Y, qm, { type: L });
          },
          onValid: (Y) => {
            to(Y, DO, {
              type: L,
              value: ln.getValue(Y)
            });
          },
          onInvalid: (Y) => {
            to(Y, dB, {
              type: L,
              value: ln.getValue(Y)
            });
          }
        },
        validator: {
          validate: (Y) => {
            const me = ln.getValue(Y), Pe = V(me) ? Mo.value(!0) : Mo.error(t("aria.input.invalid"));
            return vi.pure(Pe);
          },
          validateOnLoad: !1
        }
      }), g = (L, V, Y, me, Pe) => {
        const xe = t(Bv + "range"), Ce = qs.parts.label({
          dom: {
            tag: "label",
            attributes: { "aria-label": me }
          },
          components: [da(Y)]
        }), Be = qs.parts.field({
          data: Pe,
          factory: Cb,
          inputAttributes: {
            type: "text",
            ...V === "hex" ? { "aria-live": "polite" } : {}
          },
          inputClasses: [s("textfield")],
          inputBehaviours: Ut([
            d(V, L),
            Lr.config({})
          ]),
          onSetValue: (Vt) => {
            ju.isInvalid(Vt) && ju.run(Vt).get(J);
          }
        }), St = [
          Ce,
          Be
        ], ct = V !== "hex" ? [qs.parts["aria-descriptor"]({ text: xe })] : [], tt = St.concat(ct);
        return {
          dom: {
            tag: "div",
            attributes: { role: "presentation" }
          },
          components: tt
        };
      }, p = (L, V) => {
        const Y = Kg(V);
        return Pv.getField(L, "hex").each((me) => {
          po.isFocused(me) || ln.setValue(L, { hex: Y.value });
        }), Y;
      }, C = (L, V) => {
        const Y = V.red, me = V.green, Pe = V.blue;
        ln.setValue(L, {
          red: Y,
          green: me,
          blue: Pe
        });
      }, S = js({
        dom: {
          tag: "div",
          classes: [s("rgba-preview")],
          styles: { "background-color": "white" },
          attributes: { role: "presentation" }
        }
      }), _ = (L, V) => {
        S.getOpt(L).each((Y) => {
          _n(Y.element, "background-color", "#" + V.value);
        });
      };
      return gl({
        factory: () => {
          const L = {
            red: w(A.some(255)),
            green: w(A.some(255)),
            blue: w(A.some(255)),
            hex: w(A.some("ffffff"))
          }, V = (bo, zs) => {
            const ro = R2(zs);
            C(bo, ro), xe(ro);
          }, Y = (bo) => L[bo].get(), me = (bo, zs) => {
            L[bo].set(zs);
          }, Pe = () => Y("red").bind((bo) => Y("green").bind((zs) => Y("blue").map((ro) => Ap(bo, zs, ro, 1)))), xe = (bo) => {
            const zs = bo.red, ro = bo.green, ys = bo.blue;
            me("red", A.some(zs)), me("green", A.some(ro)), me("blue", A.some(ys));
          }, Ce = (bo, zs) => {
            const ro = zs.event;
            ro.type !== "hex" ? me(ro.type, A.none()) : i(bo);
          }, Be = (bo, zs) => {
            a(bo);
            const ro = OM(zs);
            me("hex", A.some(ro.value));
            const ys = R2(ro);
            C(bo, ys), xe(ys), to(bo, j2, { hex: ro }), _(bo, ro);
          }, St = (bo, zs, ro) => {
            const ys = parseInt(ro, 10);
            me(zs, A.some(ys)), Pe().each((Jt) => {
              const Fn = p(bo, Jt);
              to(bo, j2, { hex: Fn }), _(bo, Fn);
            });
          }, ct = (bo) => bo.type === "hex", tt = (bo, zs) => {
            const ro = zs.event;
            ct(ro) ? Be(bo, ro.value) : St(bo, ro.type, ro.value);
          }, Vt = (bo) => ({
            label: t(Bv + bo + ".label"),
            description: t(Bv + bo + ".description")
          }), Xt = Vt("red"), $o = Vt("green"), Hn = Vt("blue"), co = Vt("hex");
          return Ms(Pv.sketch((bo) => ({
            dom: {
              tag: "form",
              classes: [s("rgb-form")],
              attributes: { "aria-label": t("aria.color.picker") }
            },
            components: [
              bo.field("red", qs.sketch(g(O3, "red", Xt.label, Xt.description, 255))),
              bo.field("green", qs.sketch(g(O3, "green", $o.label, $o.description, 255))),
              bo.field("blue", qs.sketch(g(O3, "blue", Hn.label, Hn.description, 255))),
              bo.field("hex", qs.sketch(g(A3, "hex", co.label, co.description, "ffffff"))),
              S.asSpec()
            ],
            formBehaviours: Ut([
              ju.config({ invalidClass: s("form-invalid") }),
              Bo("rgb-form-events", [
                mt(DO, tt),
                mt(dB, Ce),
                mt(qm, Ce)
              ])
            ])
          })), {
            apis: {
              updateHex: (bo, zs) => {
                ln.setValue(bo, { hex: zs.value }), V(bo, zs), _(bo, zs);
              }
            }
          });
        },
        name: "RgbForm",
        configFields: [],
        apis: {
          updateHex: (L, V, Y) => {
            L.updateHex(V, Y);
          }
        },
        extraApis: {}
      });
    }, IH = (t, s) => {
      const a = oi.parts.spectrum({
        dom: {
          tag: "canvas",
          attributes: { role: "presentation" },
          classes: [s("sv-palette-spectrum")]
        }
      }), i = oi.parts.thumb({
        dom: {
          tag: "div",
          attributes: { role: "presentation" },
          classes: [s("sv-palette-thumb")],
          innerHtml: `<div class=${s("sv-palette-inner-thumb")} role="presentation"></div>`
        }
      }), d = (_, D) => {
        const { width: P, height: L } = _, V = _.getContext("2d");
        if (V === null)
          return;
        V.fillStyle = D, V.fillRect(0, 0, P, L);
        const Y = V.createLinearGradient(0, 0, P, 0);
        Y.addColorStop(0, "rgba(255,255,255,1)"), Y.addColorStop(1, "rgba(255,255,255,0)"), V.fillStyle = Y, V.fillRect(0, 0, P, L);
        const me = V.createLinearGradient(0, 0, 0, L);
        me.addColorStop(0, "rgba(0,0,0,0)"), me.addColorStop(1, "rgba(0,0,0,1)"), V.fillStyle = me, V.fillRect(0, 0, P, L);
      }, g = (_, D) => {
        const P = _.components()[0].element.dom, L = M2(D, 100, 100), V = IM(L);
        d(P, R3(V));
      }, p = (_, D) => {
        const P = gT(R2(D));
        oi.setValue(_, {
          x: P.saturation,
          y: 100 - P.value
        }), sn(_.element, "aria-valuetext", t([
          "Saturation {0}%, Brightness {1}%",
          P.saturation,
          P.value
        ]));
      };
      return gl({
        factory: (_) => {
          const D = U({
            x: 0,
            y: 0
          }), P = (Y, me, Pe) => {
            Pn(Pe) || sn(Y.element, "aria-valuetext", t([
              "Saturation {0}%, Brightness {1}%",
              Math.floor(Pe.x),
              Math.floor(100 - Pe.y)
            ])), to(Y, q2, { value: Pe });
          }, L = (Y, me, Pe, xe) => {
            d(Pe.element.dom, R3(Sd));
          }, V = Ut([
            ts.config({ find: A.some }),
            po.config({})
          ]);
          return oi.sketch({
            dom: {
              tag: "div",
              attributes: {
                role: "slider",
                "aria-valuetext": t([
                  "Saturation {0}%, Brightness {1}%",
                  0,
                  0
                ])
              },
              classes: [s("sv-palette")]
            },
            model: {
              mode: "xy",
              getInitialValue: D
            },
            rounded: !1,
            components: [
              a,
              i
            ],
            onChange: P,
            onInit: L,
            sliderBehaviours: V
          });
        },
        name: "SaturationBrightnessPalette",
        configFields: [],
        apis: {
          setHue: (_, D, P) => {
            g(D, P);
          },
          setThumb: (_, D, P) => {
            p(D, P);
          }
        },
        extraApis: {}
      });
    }, mB = (t, s) => {
      const a = (d) => {
        const g = FH(t, s, d.onValidHex, d.onInvalidHex), p = IH(t, s), C = (tt) => (100 - tt) / 100 * 360, S = (tt) => 100 - tt / 360 * 100, _ = {
          paletteRgba: w(Sd),
          paletteHue: w(0)
        }, D = js(OO(t, s)), P = js(p.sketch({})), L = js(g.sketch({})), V = (tt, Vt, Xt) => {
          P.getOpt(tt).each(($o) => {
            p.setHue($o, Xt);
          });
        }, Y = (tt, Vt) => {
          L.getOpt(tt).each((Xt) => {
            g.updateHex(Xt, Vt);
          });
        }, me = (tt, Vt, Xt) => {
          D.getOpt(tt).each(($o) => {
            oi.setValue($o, S(Xt));
          });
        }, Pe = (tt, Vt) => {
          P.getOpt(tt).each((Xt) => {
            p.setThumb(Xt, Vt);
          });
        }, xe = (tt, Vt) => {
          const Xt = R2(tt);
          _.paletteRgba.set(Xt), _.paletteHue.set(Vt);
        }, Ce = (tt, Vt, Xt, $o) => {
          xe(Vt, Xt), ot($o, (Hn) => {
            Hn(tt, Vt, Xt);
          });
        }, Be = () => {
          const tt = [Y];
          return (Vt, Xt) => {
            const $o = Xt.event.value, Hn = _.paletteHue.get(), co = M2(Hn, $o.x, 100 - $o.y), bo = jM(co);
            Ce(Vt, bo, Hn, tt);
          };
        }, St = () => {
          const tt = [
            V,
            Y
          ];
          return (Vt, Xt) => {
            const $o = C(Xt.event.value), Hn = _.paletteRgba.get(), co = gT(Hn), bo = M2($o, co.saturation, co.value), zs = jM(bo);
            Ce(Vt, zs, $o, tt);
          };
        }, ct = () => {
          const tt = [
            V,
            me,
            Pe
          ];
          return (Vt, Xt) => {
            const $o = Xt.event.hex, Hn = v8($o);
            Ce(Vt, $o, Hn.hue, tt);
          };
        };
        return {
          uid: d.uid,
          dom: d.dom,
          components: [
            P.asSpec(),
            D.asSpec(),
            L.asSpec()
          ],
          behaviours: Ut([
            Bo("colour-picker-events", [
              mt(j2, ct()),
              mt(q2, Be()),
              mt(AO, St())
            ]),
            ts.config({ find: (tt) => L.getOpt(tt) }),
            no.config({ mode: "acyclic" })
          ])
        };
      };
      return gl({
        name: "ColourPicker",
        configFields: [
          gt("dom"),
          Ne("onValidHex", J),
          Ne("onInvalidHex", J)
        ],
        factory: a
      });
    }, ql = {
      self: () => ts.config({ find: A.some }),
      memento: (t) => ts.config({ find: t.getOpt }),
      childAt: (t) => ts.config({ find: (s) => wi(s.element, t).bind((a) => s.getSystem().getByDom(a).toOptional()) })
    }, G2 = jn([
      Ne("preprocess", Tt),
      Ne("postprocess", Tt)
    ]), gB = (t, s) => {
      const a = Gc("RepresentingConfigs.memento processors", G2, s);
      return ln.config({
        store: {
          mode: "manual",
          getValue: (i) => {
            const d = t.get(i), g = ln.getValue(d);
            return a.postprocess(g);
          },
          setValue: (i, d) => {
            const g = a.preprocess(d), p = t.get(i);
            ln.setValue(p, g);
          }
        }
      });
    }, Bp = (t, s, a) => ln.config({
      store: {
        mode: "manual",
        ...t.map((i) => ({ initialValue: i })).getOr({}),
        getValue: s,
        setValue: a
      }
    }), NO = (t, s, a) => Bp(t, (i) => s(i.element), (i, d) => a(i.element, d)), hB = (t) => NO(t, Ay, yg), UT = (t) => ln.config({
      store: {
        mode: "memory",
        initialValue: t
      }
    }), HH = {
      "colorcustom.rgb.red.label": "R",
      "colorcustom.rgb.red.description": "Red component",
      "colorcustom.rgb.green.label": "G",
      "colorcustom.rgb.green.description": "Green component",
      "colorcustom.rgb.blue.label": "B",
      "colorcustom.rgb.blue.description": "Blue component",
      "colorcustom.rgb.hex.label": "#",
      "colorcustom.rgb.hex.description": "Hex color code",
      "colorcustom.rgb.range": "Range 0 to 255",
      "aria.color.picker": "Color Picker",
      "aria.input.invalid": "Invalid input"
    }, zH = (t) => (s) => Ee(s) ? t.translate(HH[s]) : t.translate(s), VH = (t, s, a) => {
      const i = (S) => "tox-" + S, d = mB(zH(s), i), g = (S) => {
        to(S, Zf, {
          name: "hex-valid",
          value: !0
        });
      }, p = (S) => {
        to(S, Zf, {
          name: "hex-valid",
          value: !1
        });
      }, C = js(d.sketch({
        dom: {
          tag: "div",
          classes: [i("color-picker-container")],
          attributes: { role: "presentation" }
        },
        onValidHex: g,
        onInvalidHex: p
      }));
      return {
        dom: { tag: "div" },
        components: [C.asSpec()],
        behaviours: Ut([
          Bp(a, (S) => {
            const _ = C.get(S);
            return ts.getCurrent(_).bind((L) => ln.getValue(L).hex).map((L) => "#" + _c(L, "#")).getOr("");
          }, (S, _) => {
            const D = /^#([a-fA-F0-9]{3}(?:[a-fA-F0-9]{3})?)/, P = A.from(D.exec(_)).bind((Y) => hn(Y, 1)), L = C.get(S);
            ts.getCurrent(L).fold(() => {
            }, (Y) => {
              ln.setValue(Y, { hex: P.getOr("") }), Pv.getField(Y, "hex").each((me) => {
                cs(me, hg());
              });
            });
          }),
          ql.self()
        ])
      };
    };
    var UH = tinymce.util.Tools.resolve("tinymce.Resource");
    const pB = (t) => Lo(t, "init"), bB = (t) => {
      const s = Go(), a = js({ dom: { tag: t.tag } }), i = Go();
      return {
        dom: {
          tag: "div",
          classes: ["tox-custom-editor"]
        },
        behaviours: Ut([
          Bo("custom-editor-events", [cr((d) => {
            a.getOpt(d).each((g) => {
              (pB(t) ? t.init(g.element.dom) : UH.load(t.scriptId, t.scriptUrl).then((p) => p(g.element.dom, t.settings))).then((p) => {
                i.on((C) => {
                  p.setValue(C);
                }), i.clear(), s.set(p);
              });
            });
          })]),
          Bp(A.none(), () => s.get().fold(() => i.get().getOr(""), (d) => d.getValue()), (d, g) => {
            s.get().fold(() => i.set(g), (p) => p.setValue(g));
          }),
          ql.self()
        ]),
        components: [a.asSpec()]
      };
    };
    var Qg = tinymce.util.Tools.resolve("tinymce.util.Tools");
    const vB = (t, s) => {
      const a = Qg.explode(s.getOption("images_file_types")), i = (d) => jo(a, (g) => Sa(d.name.toLowerCase(), `.${g.toLowerCase()}`));
      return fo(ds(t), i);
    }, WH = (t, s, a) => {
      const i = (L, V) => {
        V.stop();
      }, d = (L) => (V, Y) => {
        ot(L, (me) => {
          me(V, Y);
        });
      }, g = (L, V) => {
        var Y;
        if (!mo.isDisabled(L)) {
          const me = V.event.raw;
          C(L, (Y = me.dataTransfer) === null || Y === void 0 ? void 0 : Y.files);
        }
      }, p = (L, V) => {
        const Y = V.event.raw.target;
        C(L, Y.files);
      }, C = (L, V) => {
        V && (ln.setValue(L, vB(V, s)), to(L, Zl, { name: t.name }));
      }, S = js({
        dom: {
          tag: "input",
          attributes: {
            type: "file",
            accept: "image/*"
          },
          styles: { display: "none" }
        },
        behaviours: Ut([Bo("input-file-events", [
          wm(vm()),
          wm(ad())
        ])])
      }), _ = (L) => ({
        uid: L.uid,
        dom: {
          tag: "div",
          classes: ["tox-dropzone-container"]
        },
        behaviours: Ut([
          UT(a.getOr([])),
          ql.self(),
          mo.config({}),
          Vo.config({
            toggleClass: "dragenter",
            toggleOnExecute: !1
          }),
          Bo("dropzone-events", [
            mt("dragenter", d([
              i,
              Vo.toggle
            ])),
            mt("dragleave", d([
              i,
              Vo.toggle
            ])),
            mt("dragover", i),
            mt("drop", d([
              i,
              g
            ])),
            mt(yh(), p)
          ])
        ]),
        components: [{
          dom: {
            tag: "div",
            classes: ["tox-dropzone"],
            styles: {}
          },
          components: [
            {
              dom: { tag: "p" },
              components: [da(s.translate("Drop an image here"))]
            },
            Ec.sketch({
              dom: {
                tag: "button",
                styles: { position: "relative" },
                classes: [
                  "tox-button",
                  "tox-button--secondary"
                ]
              },
              components: [
                da(s.translate("Browse for an image")),
                S.asSpec()
              ],
              action: (V) => {
                S.get(V).element.dom.click();
              },
              buttonBehaviours: Ut([
                Lr.config({}),
                Zu.button(s.isDisabled),
                fc()
              ])
            })
          ]
        }]
      }), D = t.label.map((L) => Td(L, s)), P = qs.parts.field({ factory: { sketch: _ } });
      return I2(D, P, ["tox-form__group--stretched"], []);
    }, yB = (t, s) => ({
      dom: {
        tag: "div",
        classes: [
          "tox-form__grid",
          `tox-form__grid--${t.columns}col`
        ]
      },
      components: $e(t.items, s.interpreter)
    }), K2 = (t, s) => {
      let a = null, i = null;
      return {
        cancel: () => {
          Sn(a) || (clearTimeout(a), a = null, i = null);
        },
        throttle: (...p) => {
          i = p, Sn(a) && (a = setTimeout(() => {
            const C = i;
            a = null, i = null, t.apply(null, C);
          }, s));
        }
      };
    }, ZH = (t, s) => {
      let a = null;
      return {
        cancel: () => {
          Sn(a) || (clearTimeout(a), a = null);
        },
        throttle: (...g) => {
          Sn(a) && (a = setTimeout(() => {
            a = null, t.apply(null, g);
          }, s));
        }
      };
    }, WT = (t, s) => {
      let a = null;
      const i = () => {
        Sn(a) || (clearTimeout(a), a = null);
      };
      return {
        cancel: i,
        throttle: (...g) => {
          i(), a = setTimeout(() => {
            a = null, t.apply(null, g);
          }, s);
        }
      };
    }, MO = An("alloy-fake-before-tabstop"), PO = An("alloy-fake-after-tabstop"), CB = (t) => ({
      dom: {
        tag: "div",
        styles: {
          width: "1px",
          height: "1px",
          outline: "none"
        },
        attributes: { tabindex: "0" },
        classes: t
      },
      behaviours: Ut([
        po.config({ ignore: !0 }),
        Lr.config({})
      ])
    }), wB = (t, s) => ({
      dom: {
        tag: "div",
        classes: [
          "tox-navobj",
          ...t.getOr([])
        ]
      },
      components: [
        CB([MO]),
        s,
        CB([PO])
      ],
      behaviours: Ut([ql.childAt(1)])
    }), BO = (t, s) => {
      to(t, Pu(), {
        raw: {
          which: 9,
          shiftKey: s
        }
      });
    }, jH = (t, s) => {
      const a = s.element;
      Ha(a, MO) ? BO(t, !0) : Ha(a, PO) && BO(t, !1);
    }, $v = (t) => $2(t, [
      "." + MO,
      "." + PO
    ].join(","), Te), Fv = An("update-dialog"), Gf = An("update-title"), ZT = An("update-body"), $O = An("update-footer"), FO = An("body-send-message"), Iv = An("dialog-focus-shifted"), jT = xl().browser, $p = jT.isSafari(), SB = jT.isFirefox(), IO = $p || SB, qH = jT.isChromium(), GH = ({ scrollTop: t, scrollHeight: s, clientHeight: a }) => Math.ceil(t) + a >= s, xB = (t, s) => t.scrollTo(0, s === "bottom" ? 99999999 : s), KH = (t, s) => {
      const a = t.body;
      return A.from(!/^<!DOCTYPE (html|HTML)/.test(s) && (!qH && !$p || En(a) && (a.scrollTop !== 0 || Math.abs(a.scrollHeight - a.clientHeight) > 1)) ? a : t.documentElement);
    }, TB = (t, s, a) => {
      const i = t.dom;
      A.from(i.contentDocument).fold(a, (d) => {
        let g = 0;
        const p = KH(d, s).map((S) => (g = S.scrollTop, S)).forall(GH), C = () => {
          const S = i.contentWindow;
          En(S) && (p ? xB(S, "bottom") : !p && IO && g !== 0 && xB(S, g));
        };
        $p && i.addEventListener("load", C, { once: !0 }), d.open(), d.write(s), d.close(), $p || C();
      });
    }, EB = Zn(IO, $p ? 500 : 200).map((t) => K2(TB, t)), XH = (t, s) => {
      const a = w(t.getOr(""));
      return {
        getValue: (i) => a.get(),
        setValue: (i, d) => {
          if (a.get() !== d) {
            const g = i.element, p = () => sn(g, "srcdoc", d);
            s ? EB.fold(U(TB), (C) => C.throttle)(g, d, p) : p();
          }
          a.set(d);
        }
      };
    }, JH = (t, s, a) => {
      const i = "tox-dialog__iframe", d = t.transparent ? [] : [`${i}--opaque`], g = t.border ? ["tox-navobj-bordered"] : [], p = {
        ...t.label.map((P) => ({ title: P })).getOr({}),
        ...a.map((P) => ({ srcdoc: P })).getOr({}),
        ...t.sandboxed ? { sandbox: "allow-scripts allow-same-origin" } : {}
      }, C = XH(a, t.streamContent), S = t.label.map((P) => Td(P, s)), _ = (P) => wB(A.from(g), {
        uid: P.uid,
        dom: {
          tag: "iframe",
          attributes: p,
          classes: [
            i,
            ...d
          ]
        },
        behaviours: Ut([
          Lr.config({}),
          po.config({}),
          Bp(a, C.getValue, C.setValue),
          Wi.config({
            channels: {
              [Iv]: {
                onReceive: (L, V) => {
                  V.newFocus.each((Y) => {
                    Oc(L.element).each((me) => {
                      (Rs(L.element, Y) ? ba : Wr)(me, "tox-navobj-bordered-focus");
                    });
                  });
                }
              }
            }
          })
        ])
      }), D = qs.parts.field({ factory: { sketch: _ } });
      return I2(S, D, ["tox-form__group--stretched"], []);
    }, QH = (t) => new Promise((s, a) => {
      const i = () => {
        g(), s(t);
      }, d = [
        hi(t, "load", i),
        hi(t, "error", () => {
          g(), a("Unable to load data from image: " + t.dom.src);
        })
      ], g = () => ot(d, (p) => p.unbind());
      t.dom.complete && i();
    }), qT = (t, s, a, i, d) => {
      const g = a * d, p = i * d, C = Math.max(0, t / 2 - g / 2), S = Math.max(0, s / 2 - p / 2);
      return {
        left: C.toString() + "px",
        top: S.toString() + "px",
        width: g.toString() + "px",
        height: p.toString() + "px"
      };
    }, e9 = (t, s, a) => {
      const i = j(t), d = hr(t);
      return Math.min(i / s, d / a, 1);
    }, t9 = (t, s) => {
      const a = w(s.getOr({ url: "" })), i = js({
        dom: {
          tag: "img",
          classes: ["tox-imagepreview__image"],
          attributes: s.map((S) => ({ src: S.url })).getOr({})
        }
      }), d = js({
        dom: {
          tag: "div",
          classes: ["tox-imagepreview__container"],
          attributes: { role: "presentation" }
        },
        components: [i.asSpec()]
      }), g = (S, _) => {
        const D = { url: _.url };
        _.zoom.each((L) => D.zoom = L), _.cachedWidth.each((L) => D.cachedWidth = L), _.cachedHeight.each((L) => D.cachedHeight = L), a.set(D);
        const P = () => {
          const { cachedWidth: L, cachedHeight: V, zoom: Y } = D;
          if (!Zt(L) && !Zt(V)) {
            if (Zt(Y)) {
              const Pe = e9(S.element, L, V);
              D.zoom = Pe;
            }
            const me = qT(j(S.element), hr(S.element), L, V, D.zoom);
            d.getOpt(S).each((Pe) => {
              gr(Pe.element, me);
            });
          }
        };
        i.getOpt(S).each((L) => {
          const V = L.element;
          _.url !== rr(V, "src") && (sn(V, "src", _.url), Wr(S.element, "tox-imagepreview__loaded")), P(), QH(V).then((Y) => {
            S.getSystem().isConnected() && (ba(S.element, "tox-imagepreview__loaded"), D.cachedWidth = Y.dom.naturalWidth, D.cachedHeight = Y.dom.naturalHeight, P());
          });
        });
      }, p = {};
      t.height.each((S) => p.height = S);
      const C = s.map((S) => ({
        url: S.url,
        zoom: A.from(S.zoom),
        cachedWidth: A.from(S.cachedWidth),
        cachedHeight: A.from(S.cachedHeight)
      }));
      return {
        dom: {
          tag: "div",
          classes: ["tox-imagepreview"],
          styles: p,
          attributes: { role: "presentation" }
        },
        components: [d.asSpec()],
        behaviours: Ut([
          ql.self(),
          Bp(C, () => a.get(), g)
        ])
      };
    }, kB = (t, s) => {
      const a = "tox-label", i = t.align === "center" ? [`${a}--center`] : [], d = t.align === "end" ? [`${a}--end`] : [], g = {
        dom: {
          tag: "label",
          classes: [
            a,
            ...i,
            ...d
          ]
        },
        components: [da(s.providers.translate(t.label))]
      }, p = $e(t.items, s.interpreter);
      return {
        dom: {
          tag: "div",
          classes: ["tox-form__group"]
        },
        components: [
          g,
          ...p
        ],
        behaviours: Ut([
          ql.self(),
          Oo.config({}),
          hB(A.none()),
          no.config({ mode: "acyclic" })
        ])
      };
    }, LO = An("toolbar.button.execute"), n9 = (t) => Bu((s, a) => {
      xb(t, s)((i) => {
        to(s, LO, { buttonApi: i }), t.onAction(i);
      });
    }), Rb = An("common-button-display-events"), GT = {
      [cl()]: [
        "disabling",
        "alloy.base.behaviour",
        "toggling",
        "toolbar-button-events"
      ],
      [Nl()]: [
        "toolbar-button-events",
        Rb
      ],
      [Zs()]: [
        "focusing",
        "alloy.base.behaviour",
        Rb
      ]
    }, HO = (t) => _n(t.element, "width", Us(t.element, "width")), zO = (t, s, a) => Xd(t, {
      tag: "span",
      classes: [
        "tox-icon",
        "tox-tbtn__icon-wrap"
      ],
      behaviours: a
    }, s), VO = (t, s) => zO(t, s, []), Fp = (t, s) => zO(t, s, [Oo.config({})]), _B = (t, s, a) => ({
      dom: {
        tag: "span",
        classes: [`${s}__select-label`]
      },
      components: [da(a.translate(t))],
      behaviours: Ut([Oo.config({})])
    }), qu = An("update-menu-text"), Ip = An("update-menu-icon"), UO = (t, s, a) => {
      const i = w(J), d = t.text.map((L) => js(_B(L, s, a.providers))), g = t.icon.map((L) => js(Fp(L, a.providers.icons))), p = (L, V) => {
        const Y = ln.getValue(L);
        return po.focus(Y), to(Y, "keydown", { raw: V.event.raw }), xd.close(Y), A.some(!0);
      }, C = t.role.fold(() => ({}), (L) => ({ role: L })), S = t.tooltip.fold(() => ({}), (L) => {
        const V = a.providers.translate(L);
        return {
          title: V,
          "aria-label": V
        };
      }), _ = Xd("chevron-down", {
        tag: "div",
        classes: [`${s}__select-chevron`]
      }, a.providers.icons), D = An("common-button-display-events");
      return js(xd.sketch({
        ...t.uid ? { uid: t.uid } : {},
        ...C,
        dom: {
          tag: "button",
          classes: [
            s,
            `${s}--select`
          ].concat($e(t.classes, (L) => `${s}--${L}`)),
          attributes: { ...S }
        },
        components: Tb([
          g.map((L) => L.asSpec()),
          d.map((L) => L.asSpec()),
          A.some(_)
        ]),
        matchWidth: !0,
        useMinWidth: !0,
        onOpen: (L, V, Y) => {
          t.searchable && r7(Y);
        },
        dropdownBehaviours: Ut([
          ...t.dropdownBehaviours,
          Zu.button(() => t.disabled || a.providers.isDisabled()),
          fc(),
          z2.config({}),
          Oo.config({}),
          Bo("dropdown-events", [
            Gg(t, i),
            Jd(t, i)
          ]),
          Bo(D, [cr((L, V) => HO(L))]),
          Bo("menubutton-update-display-text", [
            mt(qu, (L, V) => {
              d.bind((Y) => Y.getOpt(L)).each((Y) => {
                Oo.set(Y, [da(a.providers.translate(V.event.text))]);
              });
            }),
            mt(Ip, (L, V) => {
              g.bind((Y) => Y.getOpt(L)).each((Y) => {
                Oo.set(Y, [Fp(V.event.icon, a.providers.icons)]);
              });
            })
          ])
        ]),
        eventOrder: Ms(GT, {
          mousedown: [
            "focusing",
            "alloy.base.behaviour",
            "item-type-events",
            "normal-dropdown-events"
          ],
          [Nl()]: [
            "toolbar-button-events",
            "dropdown-events",
            D
          ]
        }),
        sandboxBehaviours: Ut([
          no.config({
            mode: "special",
            onLeft: p,
            onRight: p
          }),
          Bo("dropdown-sandbox-events", [
            mt(r3, (L, V) => {
              e7(L), V.stop();
            }),
            mt(Zx, (L, V) => {
              t7(L, V), V.stop();
            })
          ])
        ]),
        lazySink: a.getSink,
        toggleClass: `${s}--active`,
        parts: {
          menu: {
            ...Sv(!1, t.columns, t.presets),
            fakeFocus: t.searchable,
            onHighlightItem: nO,
            onCollapseMenu: (L, V, Y) => {
              Ps.getHighlighted(Y).each((me) => {
                nO(L, Y, me);
              });
            },
            onDehighlightItem: s7
          }
        },
        getAnchorOverrides: () => ({
          maxHeightFunction: (L, V) => {
            pS()(L, V - 10);
          }
        }),
        fetch: (L) => vi.nu(gn(t.fetch, L))
      })).asSpec();
    }, o9 = (t) => Ee(t), AB = (t) => t.type === "separator", s9 = (t) => Lo(t, "getSubmenuItems"), OB = { type: "separator" }, r9 = (t, s) => {
      const a = lt(t, (i, d) => o9(d) ? d === "" ? i : d === "|" ? i.length > 0 && !AB(i[i.length - 1]) ? i.concat([OB]) : i : Lo(s, d.toLowerCase()) ? i.concat([s[d.toLowerCase()]]) : i : i.concat([d]), []);
      return a.length > 0 && AB(a[a.length - 1]) && a.pop(), a;
    }, DB = (t, s) => {
      const a = t.getSubmenuItems(), i = RB(a, s), d = Ms(i.menus, { [t.value]: i.items }), g = Ms(i.expansions, { [t.value]: t.value });
      return {
        item: t,
        menus: d,
        expansions: g
      };
    }, a9 = (t) => {
      const s = Dt(t, "value").getOrThunk(() => An("generated-menu-item"));
      return Ms({ value: s }, t);
    }, RB = (t, s) => {
      const a = r9(Ee(t) ? t.split(" ") : t, s);
      return at(a, (i, d) => {
        if (s9(d)) {
          const g = a9(d), p = DB(g, s);
          return {
            menus: Ms(i.menus, p.menus),
            items: [
              p.item,
              ...i.items
            ],
            expansions: Ms(i.expansions, p.expansions)
          };
        } else
          return {
            ...i,
            items: [
              d,
              ...i.items
            ]
          };
      }, {
        menus: {},
        expansions: {},
        items: []
      });
    }, c9 = (t) => t.search.fold(() => ({ searchMode: "no-search" }), (s) => ({
      searchMode: "search-with-field",
      placeholder: s.placeholder
    })), i9 = (t) => t.search.fold(() => ({ searchMode: "no-search" }), (s) => ({ searchMode: "search-with-results" })), Lv = (t, s, a, i) => {
      const d = An("primary-menu"), g = RB(t, a.shared.providers.menuItems());
      if (g.items.length === 0)
        return A.none();
      const p = c9(i), C = hP(d, g.items, s, a, i.isHorizontalMenu, p), S = i9(i), _ = et(g.menus, (P, L) => hP(L, P, s, a, !1, S)), D = Ms(_, oo(d, C));
      return A.from(Cp.tieredData(d, D, g.expansions));
    }, WO = (t) => !Lo(t, "items"), NB = "data-value", MB = (t, s, a, i) => $e(a, (d) => WO(d) ? {
      type: "togglemenuitem",
      text: d.text,
      value: d.value,
      active: d.value === i,
      onAction: () => {
        ln.setValue(t, d.value), to(t, Zl, { name: s }), po.focus(t);
      }
    } : {
      type: "nestedmenuitem",
      text: d.text,
      getSubmenuItems: () => MB(t, s, d.items, i)
    }), ZO = (t, s) => No(t, (a) => WO(a) ? Zn(a.value === s, a) : ZO(a.items, s)), jO = (t, s, a) => {
      const i = s.shared.providers, d = a.bind((S) => ZO(t.items, S)).orThunk(() => Xn(t.items).filter(WO)), g = t.label.map((S) => Td(S, i)), p = qs.parts.field({
        dom: {},
        factory: {
          sketch: (S) => UO({
            uid: S.uid,
            text: d.map((_) => _.text),
            icon: A.none(),
            tooltip: t.label,
            role: A.none(),
            fetch: (_, D) => {
              const P = MB(_, t.name, t.items, ln.getValue(_));
              D(Lv(P, Um.CLOSE_ON_EXECUTE, s, {
                isHorizontalMenu: !1,
                search: A.none()
              }));
            },
            onSetup: U(J),
            getApi: U({}),
            columns: 1,
            presets: "normal",
            classes: [],
            dropdownBehaviours: [
              Lr.config({}),
              Bp(d.map((_) => _.value), (_) => rr(_.element, NB), (_, D) => {
                ZO(t.items, D).each((P) => {
                  sn(_.element, NB, P.value), to(_, qu, { text: P.text });
                });
              })
            ]
          }, "tox-listbox", s.shared)
        }
      }), C = {
        dom: {
          tag: "div",
          classes: ["tox-listboxfield"]
        },
        components: [p]
      };
      return qs.sketch({
        dom: {
          tag: "div",
          classes: ["tox-form__group"]
        },
        components: ye([
          g.toArray(),
          [C]
        ]),
        fieldBehaviours: Ut([mo.config({
          disabled: U(!t.enabled),
          onDisabled: (S) => {
            qs.getField(S).each(mo.disable);
          },
          onEnabled: (S) => {
            qs.getField(S).each(mo.enable);
          }
        })])
      });
    }, l9 = (t, s) => ({
      dom: {
        tag: "div",
        classes: t.classes
      },
      components: $e(t.items, s.shared.interpreter)
    }), u9 = (t, s) => {
      const a = $e(t.options, (d) => ({
        dom: {
          tag: "option",
          value: d.value,
          innerHtml: d.text
        }
      })), i = t.data.map((d) => oo("initialValue", d)).getOr({});
      return {
        uid: t.uid,
        dom: {
          tag: "select",
          classes: t.selectClasses,
          attributes: t.selectAttributes
        },
        components: a,
        behaviours: Oa(t.selectBehaviours, [
          po.config({}),
          ln.config({
            store: {
              mode: "manual",
              getValue: (d) => Ld(d.element),
              setValue: (d, g) => {
                const p = Xn(t.options);
                ee(t.options, (S) => S.value === g).isSome() ? Mh(d.element, g) : d.element.dom.selectedIndex === -1 && g === "" && p.each((S) => Mh(d.element, S.value));
              },
              ...i
            }
          })
        ])
      };
    }, d9 = gl({
      name: "HtmlSelect",
      configFields: [
        gt("options"),
        za("selectBehaviours", [
          po,
          ln
        ]),
        Ne("selectClasses", []),
        Ne("selectAttributes", {}),
        $s("data")
      ],
      factory: u9
    }), Y2 = (t, s, a) => {
      const i = $e(t.items, (S) => ({
        text: s.translate(S.text),
        value: S.value
      })), d = t.label.map((S) => Td(S, s)), g = qs.parts.field({
        dom: {},
        ...a.map((S) => ({ data: S })).getOr({}),
        selectAttributes: { size: t.size },
        options: i,
        factory: d9,
        selectBehaviours: Ut([
          mo.config({ disabled: () => !t.enabled || s.isDisabled() }),
          Lr.config({}),
          Bo("selectbox-change", [mt(yh(), (S, _) => {
            to(S, Zl, { name: t.name });
          })])
        ])
      }), p = t.size > 1 ? A.none() : A.some(Xd("chevron-down", {
        tag: "div",
        classes: ["tox-selectfield__icon-js"]
      }, s.icons)), C = {
        dom: {
          tag: "div",
          classes: ["tox-selectfield"]
        },
        components: ye([
          [g],
          p.toArray()
        ])
      };
      return qs.sketch({
        dom: {
          tag: "div",
          classes: ["tox-form__group"]
        },
        components: ye([
          d.toArray(),
          [C]
        ]),
        fieldBehaviours: Ut([
          mo.config({
            disabled: () => !t.enabled || s.isDisabled(),
            onDisabled: (S) => {
              qs.getField(S).each(mo.disable);
            },
            onEnabled: (S) => {
              qs.getField(S).each(mo.enable);
            }
          }),
          fc()
        ])
      });
    }, qO = U([
      Ne("field1Name", "field1"),
      Ne("field2Name", "field2"),
      ud("onLockedChange"),
      xf(["lockClass"]),
      Ne("locked", !1),
      lu.field("coupledFieldBehaviours", [
        ts,
        ln
      ])
    ]), m9 = (t, s, a) => ir(t, s, a).bind(ts.getCurrent), PB = (t, s) => ei({
      factory: qs,
      name: t,
      overrides: (a) => ({
        fieldBehaviours: Ut([Bo("coupled-input-behaviour", [mt(hg(), (i) => {
          m9(i, a, s).each((d) => {
            ir(i, a, "lock").each((g) => {
              Vo.isOn(g) && a.onLockedChange(i, d, g);
            });
          });
        })])])
      })
    }), GO = U([
      PB("field1", "field2"),
      PB("field2", "field1"),
      ei({
        factory: Ec,
        schema: [gt("dom")],
        name: "lock",
        overrides: (t) => ({
          buttonBehaviours: Ut([Vo.config({
            selected: t.locked,
            toggleClass: t.markers.lockClass,
            aria: { mode: "pressed" }
          })])
        })
      })
    ]), f9 = (t, s, a, i) => ({
      uid: t.uid,
      dom: t.dom,
      components: s,
      behaviours: lu.augment(t.coupledFieldBehaviours, [
        ts.config({ find: A.some }),
        ln.config({
          store: {
            mode: "manual",
            getValue: (d) => {
              const g = Fg(d, t, [
                "field1",
                "field2"
              ]);
              return {
                [t.field1Name]: ln.getValue(g.field1()),
                [t.field2Name]: ln.getValue(g.field2())
              };
            },
            setValue: (d, g) => {
              const p = Fg(d, t, [
                "field1",
                "field2"
              ]);
              Or(g, t.field1Name) && ln.setValue(p.field1(), g[t.field1Name]), Or(g, t.field2Name) && ln.setValue(p.field2(), g[t.field2Name]);
            }
          }
        })
      ]),
      apis: {
        getField1: (d) => ir(d, t, "field1"),
        getField2: (d) => ir(d, t, "field2"),
        getLock: (d) => ir(d, t, "lock")
      }
    }), Gl = ti({
      name: "FormCoupledInputs",
      configFields: qO(),
      partFields: GO(),
      factory: f9,
      apis: {
        getField1: (t, s) => t.getField1(s),
        getField2: (t, s) => t.getField2(s),
        getLock: (t, s) => t.getLock(s)
      }
    }), BB = (t) => {
      const s = {
        "": 0,
        px: 0,
        pt: 1,
        mm: 1,
        pc: 2,
        ex: 2,
        em: 2,
        ch: 2,
        rem: 2,
        cm: 3,
        in: 4,
        "%": 4
      }, a = (d) => d in s ? s[d] : 1;
      let i = t.value.toFixed(a(t.unit));
      return i.indexOf(".") !== -1 && (i = i.replace(/\.?0*$/, "")), i + t.unit;
    }, KO = (t) => {
      const a = /^\s*(\d+(?:\.\d+)?)\s*(|cm|mm|in|px|pt|pc|em|ex|ch|rem|vw|vh|vmin|vmax|%)\s*$/.exec(t);
      if (a !== null) {
        const i = parseFloat(a[1]), d = a[2];
        return Mo.value({
          value: i,
          unit: d
        });
      } else
        return Mo.error(t);
    }, $B = (t, s) => {
      const a = {
        "": 96,
        px: 96,
        pt: 72,
        cm: 2.54,
        pc: 12,
        mm: 25.4,
        in: 1
      }, i = (d) => Lo(a, d);
      return t.unit === s ? A.some(t.value) : i(t.unit) && i(s) ? a[t.unit] === a[s] ? A.some(t.value) : A.some(t.value / a[t.unit] * a[s]) : A.none();
    }, KT = (t) => A.none(), FB = (t, s) => (a) => $B(a, s).map((i) => ({
      value: i * t,
      unit: s
    })), g9 = (t, s) => {
      const a = KO(t).toOptional(), i = KO(s).toOptional();
      return fa(a, i, (d, g) => $B(d, g.unit).map((p) => g.value / p).map((p) => FB(p, g.unit)).getOr(KT)).getOr(KT);
    }, IB = (t, s) => {
      let a = KT;
      const i = An("ratio-event"), d = (P) => Xd(P, {
        tag: "span",
        classes: [
          "tox-icon",
          "tox-lock-icon__" + P
        ]
      }, s.icons), g = Gl.parts.lock({
        dom: {
          tag: "button",
          classes: [
            "tox-lock",
            "tox-button",
            "tox-button--naked",
            "tox-button--icon"
          ],
          attributes: { title: s.translate(t.label.getOr("Constrain proportions")) }
        },
        components: [
          d("lock"),
          d("unlock")
        ],
        buttonBehaviours: Ut([
          mo.config({ disabled: () => !t.enabled || s.isDisabled() }),
          fc(),
          Lr.config({})
        ])
      }), p = (P) => ({
        dom: {
          tag: "div",
          classes: ["tox-form__group"]
        },
        components: P
      }), C = (P) => qs.parts.field({
        factory: Cb,
        inputClasses: ["tox-textfield"],
        inputBehaviours: Ut([
          mo.config({ disabled: () => !t.enabled || s.isDisabled() }),
          fc(),
          Lr.config({}),
          Bo("size-input-events", [
            mt($c(), (L, V) => {
              to(L, i, { isField1: P });
            }),
            mt(yh(), (L, V) => {
              to(L, Zl, { name: t.name });
            })
          ])
        ]),
        selectOnFocus: !1
      }), S = (P) => ({
        dom: {
          tag: "label",
          classes: ["tox-label"]
        },
        components: [da(s.translate(P))]
      }), _ = Gl.parts.field1(p([
        qs.parts.label(S("Width")),
        C(!0)
      ])), D = Gl.parts.field2(p([
        qs.parts.label(S("Height")),
        C(!1)
      ]));
      return Gl.sketch({
        dom: {
          tag: "div",
          classes: ["tox-form__group"]
        },
        components: [{
          dom: {
            tag: "div",
            classes: ["tox-form__controls-h-stack"]
          },
          components: [
            _,
            D,
            p([
              S(bC),
              g
            ])
          ]
        }],
        field1Name: "width",
        field2Name: "height",
        locked: !0,
        markers: { lockClass: "tox-locked" },
        onLockedChange: (P, L, V) => {
          KO(ln.getValue(P)).each((Y) => {
            a(Y).each((me) => {
              ln.setValue(L, BB(me));
            });
          });
        },
        coupledFieldBehaviours: Ut([
          mo.config({
            disabled: () => !t.enabled || s.isDisabled(),
            onDisabled: (P) => {
              Gl.getField1(P).bind(qs.getField).each(mo.disable), Gl.getField2(P).bind(qs.getField).each(mo.disable), Gl.getLock(P).each(mo.disable);
            },
            onEnabled: (P) => {
              Gl.getField1(P).bind(qs.getField).each(mo.enable), Gl.getField2(P).bind(qs.getField).each(mo.enable), Gl.getLock(P).each(mo.enable);
            }
          }),
          fc(),
          Bo("size-input-events2", [mt(i, (P, L) => {
            const V = L.event.isField1, Y = V ? Gl.getField1(P) : Gl.getField2(P), me = V ? Gl.getField2(P) : Gl.getField1(P), Pe = Y.map(ln.getValue).getOr(""), xe = me.map(ln.getValue).getOr("");
            a = g9(Pe, xe);
          })])
        ])
      });
    }, LB = (t, s, a) => {
      const i = oi.parts.label({
        dom: {
          tag: "label",
          classes: ["tox-label"]
        },
        components: [da(s.translate(t.label))]
      }), d = oi.parts.spectrum({
        dom: {
          tag: "div",
          classes: ["tox-slider__rail"],
          attributes: { role: "presentation" }
        }
      }), g = oi.parts.thumb({
        dom: {
          tag: "div",
          classes: ["tox-slider__handle"],
          attributes: { role: "presentation" }
        }
      });
      return oi.sketch({
        dom: {
          tag: "div",
          classes: ["tox-slider"],
          attributes: { role: "presentation" }
        },
        model: {
          mode: "x",
          minX: t.min,
          maxX: t.max,
          getInitialValue: U(a.getOrThunk(() => (Math.abs(t.max) - Math.abs(t.min)) / 2))
        },
        components: [
          i,
          d,
          g
        ],
        sliderBehaviours: Ut([
          ql.self(),
          po.config({})
        ]),
        onChoose: (p, C, S) => {
          to(p, Zl, {
            name: t.name,
            value: S
          });
        }
      });
    }, h9 = (t, s) => {
      const a = (C) => ({
        dom: {
          tag: "th",
          innerHtml: s.translate(C)
        }
      }), i = (C) => ({
        dom: { tag: "thead" },
        components: [{
          dom: { tag: "tr" },
          components: $e(C, a)
        }]
      }), d = (C) => ({
        dom: {
          tag: "td",
          innerHtml: s.translate(C)
        }
      }), g = (C) => ({
        dom: { tag: "tr" },
        components: $e(C, d)
      }), p = (C) => ({
        dom: { tag: "tbody" },
        components: $e(C, g)
      });
      return {
        dom: {
          tag: "table",
          classes: ["tox-dialog__table"]
        },
        components: [
          i(t.header),
          p(t.cells)
        ],
        behaviours: Ut([
          Lr.config({}),
          po.config({})
        ])
      };
    }, YO = (t, s) => {
      const a = t.label.map((V) => Td(V, s)), i = [
        mo.config({ disabled: () => t.disabled || s.isDisabled() }),
        fc(),
        no.config({
          mode: "execution",
          useEnter: t.multiline !== !0,
          useControlEnter: t.multiline === !0,
          execute: (V) => (cs(V, H2), A.some(!0))
        }),
        Bo("textfield-change", [
          mt(hg(), (V, Y) => {
            to(V, Zl, { name: t.name });
          }),
          mt(bg(), (V, Y) => {
            to(V, Zl, { name: t.name });
          })
        ]),
        Lr.config({})
      ], d = t.validation.map((V) => ju.config({
        getRoot: (Y) => Oc(Y.element),
        invalidClass: "tox-invalid",
        validator: {
          validate: (Y) => {
            const me = ln.getValue(Y), Pe = V.validator(me);
            return vi.pure(Pe === !0 ? Mo.value(me) : Mo.error(Pe));
          },
          validateOnLoad: V.validateOnLoad
        }
      })).toArray(), g = t.placeholder.fold(U({}), (V) => ({ placeholder: s.translate(V) })), p = t.inputMode.fold(U({}), (V) => ({ inputmode: V })), C = {
        ...g,
        ...p
      }, S = qs.parts.field({
        tag: t.multiline === !0 ? "textarea" : "input",
        ...t.data.map((V) => ({ data: V })).getOr({}),
        inputAttributes: C,
        inputClasses: [t.classname],
        inputBehaviours: Ut(ye([
          i,
          d
        ])),
        selectOnFocus: !1,
        factory: Cb
      }), _ = t.multiline ? {
        dom: {
          tag: "div",
          classes: ["tox-textarea-wrap"]
        },
        components: [S]
      } : S, P = (t.flex ? ["tox-form__group--stretched"] : []).concat(t.maximized ? ["tox-form-group--maximize"] : []), L = [
        mo.config({
          disabled: () => t.disabled || s.isDisabled(),
          onDisabled: (V) => {
            qs.getField(V).each(mo.disable);
          },
          onEnabled: (V) => {
            qs.getField(V).each(mo.enable);
          }
        }),
        fc()
      ];
      return I2(a, _, P, L);
    }, HB = (t, s, a) => YO({
      name: t.name,
      multiline: !1,
      label: t.label,
      inputMode: t.inputMode,
      placeholder: t.placeholder,
      flex: !1,
      disabled: !t.enabled,
      classname: "tox-textfield",
      validation: A.none(),
      maximized: t.maximized,
      data: a
    }, s), zB = (t, s, a) => YO({
      name: t.name,
      multiline: !0,
      label: t.label,
      inputMode: A.none(),
      placeholder: t.placeholder,
      flex: !0,
      disabled: !t.enabled,
      classname: "tox-textarea",
      validation: A.none(),
      maximized: t.maximized,
      data: a
    }, s), X2 = (t, s) => s.getAnimationRoot.fold(() => t.element, (a) => a(t)), eh = (t) => t.dimension.property, Nb = (t, s) => t.dimension.getDimension(s), J2 = (t, s) => {
      const a = X2(t, s);
      Ml(a, [
        s.shrinkingClass,
        s.growingClass
      ]);
    }, XO = (t, s) => {
      Wr(t.element, s.openClass), ba(t.element, s.closedClass), _n(t.element, eh(s), "0px"), Ga(t.element);
    }, YT = (t, s) => {
      Wr(t.element, s.closedClass), ba(t.element, s.openClass), Jo(t.element, eh(s));
    }, VB = (t, s, a, i) => {
      a.setCollapsed(), _n(t.element, eh(s), Nb(s, t.element)), J2(t, s), XO(t, s), s.onStartShrink(t), s.onShrunk(t);
    }, p9 = (t, s, a, i) => {
      const d = i.getOrThunk(() => Nb(s, t.element));
      a.setCollapsed(), _n(t.element, eh(s), d), Ga(t.element);
      const g = X2(t, s);
      Wr(g, s.growingClass), ba(g, s.shrinkingClass), XO(t, s), s.onStartShrink(t);
    }, XT = (t, s, a) => {
      const i = Nb(s, t.element);
      (i === "0px" ? VB : p9)(t, s, a, A.some(i));
    }, UB = (t, s, a) => {
      const i = X2(t, s), d = Ha(i, s.shrinkingClass), g = Nb(s, t.element);
      YT(t, s);
      const p = Nb(s, t.element);
      (d ? () => {
        _n(t.element, eh(s), g), Ga(t.element);
      } : () => {
        XO(t, s);
      })(), Wr(i, s.shrinkingClass), ba(i, s.growingClass), YT(t, s), _n(t.element, eh(s), p), a.setExpanded(), s.onStartGrow(t);
    }, b9 = (t, s, a) => {
      if (a.isExpanded()) {
        Jo(t.element, eh(s));
        const i = Nb(s, t.element);
        _n(t.element, eh(s), i);
      }
    }, v9 = (t, s, a) => {
      a.isExpanded() || UB(t, s, a);
    }, WB = (t, s, a) => {
      a.isExpanded() && XT(t, s, a);
    }, y9 = (t, s, a) => {
      a.isExpanded() && VB(t, s, a);
    }, ZB = (t, s, a) => a.isExpanded(), C9 = (t, s, a) => a.isCollapsed(), JO = (t, s, a) => {
      const i = X2(t, s);
      return Ha(i, s.growingClass) === !0;
    }, jB = (t, s, a) => {
      const i = X2(t, s);
      return Ha(i, s.shrinkingClass) === !0;
    };
    var w9 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      refresh: b9,
      grow: v9,
      shrink: WB,
      immediateShrink: y9,
      hasGrown: ZB,
      hasShrunk: C9,
      isGrowing: JO,
      isShrinking: jB,
      isTransitioning: (t, s, a) => JO(t, s) || jB(t, s),
      toggleGrow: (t, s, a) => {
        (a.isExpanded() ? XT : UB)(t, s, a);
      },
      disableTransitions: J2,
      immediateGrow: (t, s, a) => {
        a.isExpanded() || (YT(t, s), _n(t.element, eh(s), Nb(s, t.element)), J2(t, s), a.setExpanded(), s.onStartGrow(t), s.onGrown(t));
      }
    }), x9 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      exhibit: (t, s, a) => {
        const i = s.expanded;
        return ll(i ? {
          classes: [s.openClass],
          styles: {}
        } : {
          classes: [s.closedClass],
          styles: oo(s.dimension.property, "0px")
        });
      },
      events: (t, s) => vr([$d(pg(), (a, i) => {
        i.event.raw.propertyName === t.dimension.property && (J2(a, t), s.isExpanded() && Jo(a.element, t.dimension.property), (s.isExpanded() ? t.onGrown : t.onShrunk)(a));
      })])
    }), qB = [
      gt("closedClass"),
      gt("openClass"),
      gt("shrinkingClass"),
      gt("growingClass"),
      $s("getAnimationRoot"),
      gs("onShrunk"),
      gs("onStartShrink"),
      gs("onGrown"),
      gs("onStartGrow"),
      Ne("expanded", !1),
      _i("dimension", es("property", {
        width: [
          Qs("property", "width"),
          Qs("getDimension", (t) => j(t) + "px")
        ],
        height: [
          Qs("property", "height"),
          Qs("getDimension", (t) => hr(t) + "px")
        ]
      }))
    ], T9 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      init: (t) => {
        const s = w(t.expanded), a = () => "expanded: " + s.get();
        return il({
          isExpanded: () => s.get() === !0,
          isCollapsed: () => s.get() === !1,
          setCollapsed: gn(s.set, !1),
          setExpanded: gn(s.set, !0),
          readState: a
        });
      }
    });
    const gu = tc({
      fields: qB,
      name: "sliding",
      active: x9,
      apis: w9,
      state: T9
    }), QO = (t) => ({
      isEnabled: () => !mo.isDisabled(t),
      setEnabled: (s) => mo.set(t, !s),
      setActive: (s) => {
        const a = t.element;
        s ? (ba(a, "tox-tbtn--enabled"), sn(a, "aria-pressed", !0)) : (Wr(a, "tox-tbtn--enabled"), se(a, "aria-pressed"));
      },
      isActive: () => Ha(t.element, "tox-tbtn--enabled"),
      setText: (s) => {
        to(t, qu, { text: s });
      },
      setIcon: (s) => to(t, Ip, { icon: s })
    }), Q2 = (t, s, a, i, d = !0) => UO({
      text: t.text,
      icon: t.icon,
      tooltip: t.tooltip,
      searchable: t.search.isSome(),
      role: i,
      fetch: (g, p) => {
        const C = { pattern: t.search.isSome() ? a7(g) : "" };
        t.fetch((S) => {
          p(Lv(S, Um.CLOSE_ON_EXECUTE, a, {
            isHorizontalMenu: !1,
            search: t.search
          }));
        }, C, QO(g));
      },
      onSetup: t.onSetup,
      getApi: QO,
      columns: 1,
      presets: "normal",
      classes: [],
      dropdownBehaviours: [...d ? [Lr.config({})] : []]
    }, s, a.shared), E9 = (t, s, a) => {
      const i = (g) => (p) => {
        const C = !p.isActive();
        p.setActive(C), g.storage.set(C), a.shared.getSink().each((S) => {
          s().getOpt(S).each((_) => {
            Zi(_.element), to(_, Zf, {
              name: g.name,
              value: g.storage.get()
            });
          });
        });
      }, d = (g) => (p) => {
        p.setActive(g.storage.get());
      };
      return (g) => {
        g($e(t, (p) => {
          const C = p.text.fold(() => ({}), (S) => ({ text: S }));
          return {
            type: p.type,
            active: !1,
            ...C,
            onAction: i(p),
            onSetup: d(p)
          };
        }));
      };
    }, GB = (t) => ({
      dom: {
        tag: "span",
        classes: ["tox-tree__label"],
        attributes: {
          title: t,
          "aria-label": t
        }
      },
      components: [da(t)]
    }), eD = An("leaf-label-event-id"), JT = ({ leaf: t, onLeafAction: s, visible: a, treeId: i, selectedId: d, backstage: g }) => {
      const p = t.menu.map((S) => Q2(S, "tox-mbtn", g, A.none(), a)), C = [GB(t.title)];
      return p.each((S) => C.push(S)), Ec.sketch({
        dom: {
          tag: "div",
          classes: [
            "tox-tree--leaf__label",
            "tox-trbtn"
          ].concat(a ? ["tox-tree--leaf__label--visible"] : [])
        },
        components: C,
        role: "treeitem",
        action: (S) => {
          s(t.id), S.getSystem().broadcastOn([`update-active-item-${i}`], { value: t.id });
        },
        eventOrder: {
          [Pu()]: [
            eD,
            "keying"
          ]
        },
        buttonBehaviours: Ut([
          ...a ? [Lr.config({})] : [],
          Vo.config({
            toggleClass: "tox-trbtn--enabled",
            toggleOnExecute: !1,
            aria: { mode: "selected" }
          }),
          Wi.config({
            channels: {
              [`update-active-item-${i}`]: {
                onReceive: (S, _) => {
                  (_.value === t.id ? Vo.on : Vo.off)(S);
                }
              }
            }
          }),
          Bo(eD, [
            cr((S, _) => {
              d.each((D) => {
                (D === t.id ? Vo.on : Vo.off)(S);
              });
            }),
            mt(Pu(), (S, _) => {
              const D = _.event.raw.code === "ArrowLeft", P = _.event.raw.code === "ArrowRight";
              D ? (dl(S.element, ".tox-tree--directory").each((L) => {
                S.getSystem().getByDom(L).each((V) => {
                  w0(L, ".tox-tree--directory__label").each((Y) => {
                    V.getSystem().getByDom(Y).each(po.focus);
                  });
                });
              }), _.stop()) : P && _.stop();
            })
          ])
        ])
      });
    }, KB = (t, s, a) => Xd(t, {
      tag: "span",
      classes: [
        "tox-tree__icon-wrap",
        "tox-icon"
      ],
      behaviours: a
    }, s), QT = (t, s) => KB(t, s, []), YB = An("directory-label-event-id"), k9 = ({ directory: t, visible: s, noChildren: a, backstage: i }) => {
      const d = t.menu.map((C) => Q2(C, "tox-mbtn", i, A.none())), g = [
        {
          dom: {
            tag: "div",
            classes: ["tox-chevron"]
          },
          components: [QT("chevron-right", i.shared.providers.icons)]
        },
        GB(t.title)
      ];
      d.each((C) => {
        g.push(C);
      });
      const p = (C) => {
        dl(C.element, ".tox-tree--directory").each((S) => {
          C.getSystem().getByDom(S).each((_) => {
            const D = !Vo.isOn(_);
            Vo.toggle(_), to(C, "expand-tree-node", {
              expanded: D,
              node: t.id
            });
          });
        });
      };
      return Ec.sketch({
        dom: {
          tag: "div",
          classes: [
            "tox-tree--directory__label",
            "tox-trbtn"
          ].concat(s ? ["tox-tree--directory__label--visible"] : [])
        },
        components: g,
        action: p,
        eventOrder: {
          [Pu()]: [
            YB,
            "keying"
          ]
        },
        buttonBehaviours: Ut([
          ...s ? [Lr.config({})] : [],
          Bo(YB, [mt(Pu(), (C, S) => {
            const _ = S.event.raw.code === "ArrowRight", D = S.event.raw.code === "ArrowLeft";
            _ && a && S.stop(), (_ || D) && dl(C.element, ".tox-tree--directory").each((P) => {
              C.getSystem().getByDom(P).each((L) => {
                !Vo.isOn(L) && _ || Vo.isOn(L) && D ? (p(C), S.stop()) : D && !Vo.isOn(L) && (dl(L.element, ".tox-tree--directory").each((V) => {
                  w0(V, ".tox-tree--directory__label").each((Y) => {
                    L.getSystem().getByDom(Y).each(po.focus);
                  });
                }), S.stop());
              });
            });
          })])
        ])
      });
    }, _9 = ({ children: t, onLeafAction: s, visible: a, treeId: i, expandedIds: d, selectedId: g, backstage: p }) => ({
      dom: {
        tag: "div",
        classes: ["tox-tree--directory__children"]
      },
      components: t.map((C) => C.type === "leaf" ? JT({
        leaf: C,
        selectedId: g,
        onLeafAction: s,
        visible: a,
        treeId: i,
        backstage: p
      }) : eE({
        directory: C,
        expandedIds: d,
        selectedId: g,
        onLeafAction: s,
        labelTabstopping: a,
        treeId: i,
        backstage: p
      })),
      behaviours: Ut([
        gu.config({
          dimension: { property: "height" },
          closedClass: "tox-tree--directory__children--closed",
          openClass: "tox-tree--directory__children--open",
          growingClass: "tox-tree--directory__children--growing",
          shrinkingClass: "tox-tree--directory__children--shrinking",
          expanded: a
        }),
        Oo.config({})
      ])
    }), A9 = An("directory-event-id"), eE = ({ directory: t, onLeafAction: s, labelTabstopping: a, treeId: i, backstage: d, expandedIds: g, selectedId: p }) => {
      const { children: C } = t, S = w(g), _ = (P) => C.map((L) => L.type === "leaf" ? JT({
        leaf: L,
        selectedId: p,
        onLeafAction: s,
        visible: P,
        treeId: i,
        backstage: d
      }) : eE({
        directory: L,
        expandedIds: S.get(),
        selectedId: p,
        onLeafAction: s,
        labelTabstopping: P,
        treeId: i,
        backstage: d
      })), D = g.includes(t.id);
      return {
        dom: {
          tag: "div",
          classes: ["tox-tree--directory"],
          attributes: { role: "treeitem" }
        },
        components: [
          k9({
            directory: t,
            visible: a,
            noChildren: t.children.length === 0,
            backstage: d
          }),
          _9({
            children: C,
            expandedIds: g,
            selectedId: p,
            onLeafAction: s,
            visible: D,
            treeId: i,
            backstage: d
          })
        ],
        behaviours: Ut([
          Bo(A9, [
            cr((P, L) => {
              Vo.set(P, D);
            }),
            mt("expand-tree-node", (P, L) => {
              const { expanded: V, node: Y } = L.event;
              S.set(V ? [
                ...S.get(),
                Y
              ] : S.get().filter((me) => me !== Y));
            })
          ]),
          Vo.config({
            ...t.children.length > 0 ? { aria: { mode: "expanded" } } : {},
            toggleClass: "tox-tree--directory--expanded",
            onToggled: (P, L) => {
              const V = P.components()[1], Y = _(L);
              L ? gu.grow(V) : gu.shrink(V), Oo.set(V, Y);
            }
          })
        ])
      };
    }, O9 = An("tree-event-id"), D9 = (t, s) => {
      const a = t.onLeafAction.getOr(J), i = t.onToggleExpand.getOr(J), d = t.defaultExpandedIds, g = w(d), p = w(t.defaultSelectedId), C = An("tree-id"), S = (_, D) => t.items.map((P) => P.type === "leaf" ? JT({
        leaf: P,
        selectedId: _,
        onLeafAction: a,
        visible: !0,
        treeId: C,
        backstage: s
      }) : eE({
        directory: P,
        selectedId: _,
        onLeafAction: a,
        expandedIds: D,
        labelTabstopping: !0,
        treeId: C,
        backstage: s
      }));
      return {
        dom: {
          tag: "div",
          classes: ["tox-tree"],
          attributes: { role: "tree" }
        },
        components: S(p.get(), g.get()),
        behaviours: Ut([
          no.config({
            mode: "flow",
            selector: ".tox-tree--leaf__label--visible, .tox-tree--directory__label--visible",
            cycles: !1
          }),
          Bo(O9, [mt("expand-tree-node", (_, D) => {
            const { expanded: P, node: L } = D.event;
            g.set(P ? [
              ...g.get(),
              L
            ] : g.get().filter((V) => V !== L)), i(g.get(), {
              expanded: P,
              node: L
            });
          })]),
          Wi.config({
            channels: {
              [`update-active-item-${C}`]: {
                onReceive: (_, D) => {
                  p.set(A.some(D.value)), Oo.set(_, S(A.some(D.value), g.get()));
                }
              }
            }
          }),
          Oo.config({})
        ])
      };
    };
    var XB = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      events: (t, s) => {
        const i = t.stream.streams.setup(t, s);
        return vr([
          mt(t.event, i),
          Fd(() => s.cancel())
        ].concat(t.cancelEvent.map((d) => [mt(d, () => s.cancel())]).getOr([])));
      }
    });
    const tD = (t) => {
      const s = w(null);
      return il({
        readState: () => ({ timer: s.get() !== null ? "set" : "unset" }),
        setTimer: (g) => {
          s.set(g);
        },
        cancel: () => {
          const g = s.get();
          g !== null && g.cancel();
        }
      });
    };
    var R9 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      throttle: tD,
      init: (t) => t.stream.streams.state(t)
    });
    const JB = (t, s) => {
      const a = t.stream, i = WT(t.onStream, a.delay);
      return s.setTimer(i), (d, g) => {
        i.throttle(d, g), a.stopEvent && g.stop();
      };
    };
    var N9 = [
      _i("stream", es("mode", {
        throttle: [
          gt("delay"),
          Ne("stopEvent", !0),
          Qs("streams", {
            setup: JB,
            state: tD
          })
        ]
      })),
      Ne("event", "input"),
      $s("cancelEvent"),
      ud("onStream")
    ];
    const nD = tc({
      fields: N9,
      name: "streaming",
      active: XB,
      state: R9
    }), yo = (t, s, a) => {
      const i = ln.getValue(a);
      ln.setValue(s, i), oD(s);
    }, Hv = (t, s) => {
      const a = t.element, i = Ld(a), d = a.dom;
      rr(a, "type") !== "number" && s(d, i);
    }, oD = (t) => {
      Hv(t, (s, a) => s.setSelectionRange(a.length, a.length));
    }, QB = (t, s) => {
      Hv(t, (a, i) => a.setSelectionRange(s, i.length));
    }, e$ = (t, s, a) => {
      if (t.selectsOver) {
        const i = ln.getValue(s), d = t.getDisplayText(i), g = ln.getValue(a);
        return t.getDisplayText(g).indexOf(d) === 0 ? A.some(() => {
          yo(t, s, a), QB(s, d.length);
        }) : A.none();
      } else
        return A.none();
    }, tE = U("alloy.typeahead.itemexecute"), t$ = (t, s, a, i) => {
      const d = (P, L, V) => {
        t.previewing.set(!1);
        const Y = Ca.getCoupled(P, "sandbox");
        if (is.isOpen(Y))
          ts.getCurrent(Y).each((me) => {
            Ps.getHighlighted(me).fold(() => {
              V(me);
            }, () => {
              Sy(Y, me.element, "keydown", L);
            });
          });
        else {
          const me = (Pe) => {
            ts.getCurrent(Pe).each(V);
          };
          ST(t, p(P), P, Y, i, me, Yi.HighlightMenuAndItem).get(J);
        }
      }, g = ZN(t), p = (P) => (L) => L.map((V) => {
        const Y = or(V.menus), me = ae(Y, (xe) => fo(xe.items, (Ce) => Ce.type === "item"));
        return ln.getState(P).update($e(me, (xe) => xe.data)), V;
      }), C = (P) => ts.getCurrent(P), S = "typeaheadevents", _ = [
        po.config({}),
        ln.config({
          onSetValue: t.onSetValue,
          store: {
            mode: "dataset",
            getDataKey: (P) => Ld(P.element),
            getFallbackEntry: (P) => ({
              value: P,
              meta: {}
            }),
            setValue: (P, L) => {
              Mh(P.element, t.model.getDisplayText(L));
            },
            ...t.initialData.map((P) => oo("initialValue", P)).getOr({})
          }
        }),
        nD.config({
          stream: {
            mode: "throttle",
            delay: t.responseTime,
            stopEvent: !1
          },
          onStream: (P, L) => {
            const V = Ca.getCoupled(P, "sandbox");
            if (po.isFocused(P) && Ld(P.element).length >= t.minChars) {
              const me = C(V).bind((xe) => Ps.getHighlighted(xe).map(ln.getValue));
              t.previewing.set(!0);
              const Pe = (xe) => {
                C(V).each((Ce) => {
                  me.fold(() => {
                    t.model.selectsOver && Ps.highlightFirst(Ce);
                  }, (Be) => {
                    Ps.highlightBy(Ce, (St) => ln.getValue(St).value === Be.value), Ps.getHighlighted(Ce).orThunk(() => (Ps.highlightFirst(Ce), A.none()));
                  });
                });
              };
              ST(t, p(P), P, V, i, Pe, Yi.HighlightJustMenu).get(J);
            }
          },
          cancelEvent: Qb()
        }),
        no.config({
          mode: "special",
          onDown: (P, L) => (d(P, L, Ps.highlightFirst), A.some(!0)),
          onEscape: (P) => {
            const L = Ca.getCoupled(P, "sandbox");
            return is.isOpen(L) ? (is.close(L), A.some(!0)) : A.none();
          },
          onUp: (P, L) => (d(P, L, Ps.highlightLast), A.some(!0)),
          onEnter: (P) => {
            const L = Ca.getCoupled(P, "sandbox"), V = is.isOpen(L);
            if (V && !t.previewing.get())
              return C(L).bind((Y) => Ps.getHighlighted(Y)).map((Y) => (to(P, tE(), { item: Y }), !0));
            {
              const Y = ln.getValue(P);
              return cs(P, Qb()), t.onExecute(L, P, Y), V && is.close(L), A.some(!0);
            }
          }
        }),
        Vo.config({
          toggleClass: t.markers.openClass,
          aria: { mode: "expanded" }
        }),
        Ca.config({
          others: {
            sandbox: (P) => eO(t, P, {
              onOpen: () => Vo.on(P),
              onClose: () => {
                t.lazyTypeaheadComp.get().each((L) => se(L.element, "aria-activedescendant")), Vo.off(P);
              }
            })
          }
        }),
        Bo(S, [
          cr((P) => {
            t.lazyTypeaheadComp.set(A.some(P));
          }),
          Fd((P) => {
            t.lazyTypeaheadComp.set(A.none());
          }),
          Bu((P) => {
            const L = J;
            Q3(t, p(P), P, i, L, Yi.HighlightMenuAndItem).get(J);
          }),
          mt(tE(), (P, L) => {
            const V = Ca.getCoupled(P, "sandbox");
            yo(t.model, P, L.event.item), cs(P, Qb()), t.onItemExecute(P, V, L.event.item, ln.getValue(P)), is.close(V), oD(P);
          })
        ].concat(t.dismissOnBlur ? [mt(gf(), (P) => {
          const L = Ca.getCoupled(P, "sandbox");
          Iu(L.element).isNone() && is.close(L);
        })] : []))
      ], D = {
        [pf()]: [
          ln.name(),
          nD.name(),
          S
        ],
        ...t.eventOrder
      };
      return {
        uid: t.uid,
        dom: jN(Ms(t, {
          inputAttributes: {
            role: "combobox",
            "aria-autocomplete": "list",
            "aria-haspopup": "true"
          }
        })),
        behaviours: {
          ...g,
          ...Oa(t.typeaheadBehaviours, _)
        },
        eventOrder: D
      };
    }, Gj = U([
      $s("lazySink"),
      gt("fetch"),
      Ne("minChars", 5),
      Ne("responseTime", 1e3),
      gs("onOpen"),
      Ne("getHotspot", A.some),
      Ne("getAnchorOverrides", U({})),
      Ne("layouts", A.none()),
      Ne("eventOrder", {}),
      Nu("model", {}, [
        Ne("getDisplayText", (t) => t.meta !== void 0 && t.meta.text !== void 0 ? t.meta.text : t.value),
        Ne("selectsOver", !0),
        Ne("populateFromBrowse", !0)
      ]),
      gs("onSetValue"),
      fl("onExecute"),
      gs("onItemExecute"),
      Ne("inputClasses", []),
      Ne("inputAttributes", {}),
      Ne("inputStyles", {}),
      Ne("matchWidth", !0),
      Ne("useMinWidth", !1),
      Ne("dismissOnBlur", !0),
      xf(["openClass"]),
      $s("initialData"),
      za("typeaheadBehaviours", [
        po,
        ln,
        nD,
        no,
        Vo,
        Ca
      ]),
      oa("lazyTypeaheadComp", () => w(A.none)),
      oa("previewing", () => w(!0))
    ].concat(WN()).concat(tO())), ew = U([zu({
      schema: [E1()],
      name: "menu",
      overrides: (t) => ({
        fakeFocus: !0,
        onHighlightItem: (s, a, i) => {
          t.previewing.get() ? t.lazyTypeaheadComp.get().each((d) => {
            e$(t.model, d, i).fold(() => {
              t.model.selectsOver ? (Ps.dehighlight(a, i), t.previewing.set(!0)) : t.previewing.set(!1);
            }, (g) => {
              g(), t.previewing.set(!1);
            });
          }) : t.lazyTypeaheadComp.get().each((d) => {
            t.model.populateFromBrowse && yo(t.model, d, i), B(i.element, "id").each((g) => sn(d.element, "aria-activedescendant", g));
          });
        },
        onExecute: (s, a) => t.lazyTypeaheadComp.get().map((i) => (to(i, tE(), { item: a }), !0)),
        onHover: (s, a) => {
          t.previewing.set(!1), t.lazyTypeaheadComp.get().each((i) => {
            t.model.populateFromBrowse && yo(t.model, i, a);
          });
        }
      })
    })]), M9 = ti({
      name: "Typeahead",
      configFields: Gj(),
      partFields: ew(),
      factory: t$
    }), Ed = (t) => ({
      ...t,
      toCached: () => Ed(t.toCached()),
      bindFuture: (S) => Ed(t.bind((_) => _.fold((D) => vi.pure(Mo.error(D)), (D) => S(D)))),
      bindResult: (S) => Ed(t.map((_) => _.bind(S))),
      mapResult: (S) => Ed(t.map((_) => _.map(S))),
      mapError: (S) => Ed(t.map((_) => _.mapError(S))),
      foldResult: (S, _) => t.map((D) => D.fold(S, _)),
      withTimeout: (S, _) => Ed(vi.nu((D) => {
        let P = !1;
        const L = setTimeout(() => {
          P = !0, D(Mo.error(_()));
        }, S);
        t.get((V) => {
          P || (clearTimeout(L), D(V));
        });
      }))
    }), n$ = (t) => Ed(vi.nu(t)), o$ = (t) => Ed(vi.pure(Mo.value(t))), $9 = {
      nu: n$,
      wrap: Ed,
      pure: o$,
      value: o$,
      error: (t) => Ed(vi.pure(Mo.error(t))),
      fromResult: (t) => Ed(vi.pure(t)),
      fromFuture: (t) => Ed(t.map(Mo.value)),
      fromPromise: (t) => n$((s) => {
        t.then((a) => {
          s(Mo.value(a));
        }, (a) => {
          s(Mo.error(a));
        });
      })
    }, nE = (t, s, a = [], i, d, g) => {
      const p = s.fold(() => ({}), (_) => ({ action: _ })), C = {
        buttonBehaviours: Ut([
          Zu.button(() => !t.enabled || g.isDisabled()),
          fc(),
          Lr.config({}),
          Bo("button press", [
            Ey("click"),
            Ey("mousedown")
          ])
        ].concat(a)),
        eventOrder: {
          click: [
            "button press",
            "alloy.base.behaviour"
          ],
          mousedown: [
            "button press",
            "alloy.base.behaviour"
          ]
        },
        ...p
      }, S = Ms(C, { dom: i });
      return Ms(S, { components: d });
    }, F9 = (t, s, a, i = []) => {
      const d = t.tooltip.map((S) => ({
        "aria-label": a.translate(S),
        title: a.translate(S)
      })).getOr({}), g = {
        tag: "button",
        classes: ["tox-tbtn"],
        attributes: d
      }, p = t.icon.map((S) => VO(S, a.icons)), C = Tb([p]);
      return nE(t, s, i, g, C, a);
    }, sD = (t) => {
      switch (t) {
        case "primary":
          return ["tox-button"];
        case "toolbar":
          return ["tox-tbtn"];
        case "secondary":
        default:
          return [
            "tox-button",
            "tox-button--secondary"
          ];
      }
    }, r$ = (t, s, a, i = [], d = []) => {
      const g = a.translate(t.text), p = t.icon.map((L) => VO(L, a.icons)), C = [p.getOrThunk(() => da(g))], S = t.buttonType.getOr(!t.primary && !t.borderless ? "secondary" : "primary"), P = {
        tag: "button",
        classes: [
          ...sD(S),
          ...p.isSome() ? ["tox-button--icon"] : [],
          ...t.borderless ? ["tox-button--naked"] : [],
          ...d
        ],
        attributes: { title: g }
      };
      return nE(t, s, i, P, C, a);
    }, rD = (t, s, a, i = [], d = []) => {
      const g = r$(t, A.some(s), a, i, d);
      return Ec.sketch(g);
    }, a$ = (t, s) => (a) => {
      s === "custom" ? to(a, Zf, {
        name: t,
        value: {}
      }) : s === "submit" ? cs(a, H2) : s === "cancel" && cs(a, Np);
    }, I9 = (t, s) => s === "menu", L9 = (t, s) => s === "custom" || s === "cancel" || s === "submit", H9 = (t, s) => s === "togglebutton", z9 = (t, s) => {
      var a, i;
      const d = t.icon.map((Ce) => Fp(Ce, s.icons)).map(js), g = (Ce) => {
        to(Ce, Zf, {
          name: t.name,
          value: {
            setIcon: (Be) => {
              d.map((St) => St.getOpt(Ce).each((ct) => {
                Oo.set(ct, [Fp(Be, s.icons)]);
              }));
            }
          }
        });
      }, p = t.buttonType.getOr(t.primary ? "primary" : "secondary"), C = {
        ...t,
        name: (a = t.name) !== null && a !== void 0 ? a : "",
        tooltip: A.from(t.tooltip),
        enabled: (i = t.enabled) !== null && i !== void 0 ? i : !1
      }, S = C.tooltip.map((Ce) => ({
        "aria-label": s.translate(Ce),
        title: s.translate(Ce)
      })).getOr({}), _ = sD(p ?? "secondary"), D = t.icon.isSome() && t.text.isSome(), P = {
        tag: "button",
        classes: [
          ..._.concat(t.icon.isSome() ? ["tox-button--icon"] : []),
          ...t.active ? ["tox-button--enabled"] : [],
          ...D ? ["tox-button--icon-and-text"] : []
        ],
        attributes: S
      }, L = [], V = s.translate(t.text.getOr("")), Y = da(V), Pe = [
        ...Tb([d.map((Ce) => Ce.asSpec())]),
        ...t.text.isSome() ? [Y] : []
      ], xe = nE(C, A.some(g), L, P, Pe, s);
      return Ec.sketch(xe);
    }, oE = (t, s, a) => {
      if (I9(t, s)) {
        const i = () => p, d = t, g = {
          ...t,
          type: "menubutton",
          search: A.none(),
          onSetup: (C) => (C.setEnabled(t.enabled), J),
          fetch: E9(d.items, i, a)
        }, p = js(Q2(g, "tox-tbtn", a, A.none()));
        return p.asSpec();
      } else if (L9(t, s)) {
        const i = a$(t.name, s), d = {
          ...t,
          borderless: !1
        };
        return rD(d, i, a.shared.providers, []);
      } else {
        if (H9(t, s))
          return z9(t, a.shared.providers);
        throw new Error("Unknown footer button type");
      }
    }, V9 = (t, s) => {
      const a = a$(t.name, "custom");
      return O7(A.none(), qs.parts.field({
        factory: Ec,
        ...r$(t, A.some(a), s, [
          UT(""),
          ql.self()
        ])
      }));
    }, U9 = { type: "separator" }, W9 = (t) => ({
      type: "menuitem",
      value: t.url,
      text: t.title,
      meta: { attach: t.attach },
      onAction: J
    }), aD = (t, s) => ({
      type: "menuitem",
      value: s,
      text: t,
      meta: { attach: void 0 },
      onAction: J
    }), Z9 = (t) => $e(t, W9), c$ = (t, s) => fo(s, (a) => a.type === t), i$ = (t, s) => Z9(c$(t, s)), j9 = (t) => i$("header", t.targets), q9 = (t) => i$("anchor", t.targets), G9 = (t) => A.from(t.anchorTop).map((s) => aD("<top>", s)).toArray(), K9 = (t) => A.from(t.anchorBottom).map((s) => aD("<bottom>", s)).toArray(), Y9 = (t) => $e(t, (s) => aD(s, s)), l$ = (t) => lt(t, (s, a) => s.length === 0 || a.length === 0 ? s.concat(a) : s.concat(U9, a), []), cD = (t, s) => {
      const a = t.toLowerCase();
      return fo(s, (i) => {
        var d;
        const g = i.meta !== void 0 && i.meta.text !== void 0 ? i.meta.text : i.text, p = (d = i.value) !== null && d !== void 0 ? d : "";
        return Ks(g.toLowerCase(), a) || Ks(p.toLowerCase(), a);
      });
    }, u$ = (t, s, a) => {
      var i, d;
      const g = ln.getValue(s), p = (d = (i = g?.meta) === null || i === void 0 ? void 0 : i.text) !== null && d !== void 0 ? d : g.value;
      return a.getLinkInformation().fold(() => [], (S) => {
        const _ = cD(p, Y9(a.getHistory(t)));
        return t === "file" ? l$([
          _,
          cD(p, j9(S)),
          cD(p, ye([
            G9(S),
            q9(S),
            K9(S)
          ]))
        ]) : _;
      });
    }, d$ = An("aria-invalid"), m$ = (t, s, a, i) => {
      const d = s.shared.providers, g = (Ce) => {
        const Be = ln.getValue(Ce);
        a.addToHistory(Be.value, t.filetype);
      }, p = {
        ...i.map((Ce) => ({ initialData: Ce })).getOr({}),
        dismissOnBlur: !0,
        inputClasses: ["tox-textfield"],
        sandboxClasses: ["tox-dialog__popups"],
        inputAttributes: {
          "aria-errormessage": d$,
          type: "url"
        },
        minChars: 0,
        responseTime: 0,
        fetch: (Ce) => {
          const Be = u$(t.filetype, Ce, a), St = Lv(Be, Um.BUBBLE_TO_SANDBOX, s, {
            isHorizontalMenu: !1,
            search: A.none()
          });
          return vi.pure(St);
        },
        getHotspot: (Ce) => Y.getOpt(Ce),
        onSetValue: (Ce, Be) => {
          Ce.hasConfigured(ju) && ju.run(Ce).get(J);
        },
        typeaheadBehaviours: Ut([
          ...a.getValidationHandler().map((Ce) => ju.config({
            getRoot: (Be) => Oc(Be.element),
            invalidClass: "tox-control-wrap--status-invalid",
            notify: {
              onInvalid: (Be, St) => {
                D.getOpt(Be).each((ct) => {
                  sn(ct.element, "title", d.translate(St));
                });
              }
            },
            validator: {
              validate: (Be) => {
                const St = ln.getValue(Be);
                return $9.nu((ct) => {
                  Ce({
                    type: t.filetype,
                    url: St.value
                  }, (tt) => {
                    if (tt.status === "invalid") {
                      const Vt = Mo.error(tt.message);
                      ct(Vt);
                    } else {
                      const Vt = Mo.value(tt.message);
                      ct(Vt);
                    }
                  });
                });
              },
              validateOnLoad: !1
            }
          })).toArray(),
          mo.config({ disabled: () => !t.enabled || d.isDisabled() }),
          Lr.config({}),
          Bo("urlinput-events", [
            mt(hg(), (Ce) => {
              const Be = Ld(Ce.element), St = Be.trim();
              St !== Be && Mh(Ce.element, St), t.filetype === "file" && to(Ce, Zl, { name: t.name });
            }),
            mt(yh(), (Ce) => {
              to(Ce, Zl, { name: t.name }), g(Ce);
            }),
            mt(bg(), (Ce) => {
              to(Ce, Zl, { name: t.name }), g(Ce);
            })
          ])
        ]),
        eventOrder: {
          [hg()]: [
            "streaming",
            "urlinput-events",
            "invalidating"
          ]
        },
        model: {
          getDisplayText: (Ce) => Ce.value,
          selectsOver: !1,
          populateFromBrowse: !1
        },
        markers: { openClass: "tox-textfield--popup-open" },
        lazySink: s.shared.getSink,
        parts: { menu: Sv(!1, 1, "normal") },
        onExecute: (Ce, Be, St) => {
          to(Be, H2, {});
        },
        onItemExecute: (Ce, Be, St, ct) => {
          g(Ce), to(Ce, Zl, { name: t.name });
        }
      }, C = qs.parts.field({
        ...p,
        factory: M9
      }), S = t.label.map((Ce) => Td(Ce, d)), D = js(((Ce, Be, St = Ce, ct = Ce) => Xd(St, {
        tag: "div",
        classes: [
          "tox-icon",
          "tox-control-wrap__status-icon-" + Ce
        ],
        attributes: {
          title: d.translate(ct),
          "aria-live": "polite",
          ...Be.fold(() => ({}), (tt) => ({ id: tt }))
        }
      }, d.icons))("invalid", A.some(d$), "warning")), P = js({
        dom: {
          tag: "div",
          classes: ["tox-control-wrap__status-icon-wrap"]
        },
        components: [D.asSpec()]
      }), L = a.getUrlPicker(t.filetype), V = An("browser.url.event"), Y = js({
        dom: {
          tag: "div",
          classes: ["tox-control-wrap"]
        },
        components: [
          C,
          P.asSpec()
        ],
        behaviours: Ut([mo.config({ disabled: () => !t.enabled || d.isDisabled() })])
      }), me = js(rD({
        name: t.name,
        icon: A.some("browse"),
        text: t.picker_text.or(t.label).getOr(""),
        enabled: t.enabled,
        primary: !1,
        buttonType: A.none(),
        borderless: !0
      }, (Ce) => cs(Ce, V), d, [], ["tox-browse-url"])), Pe = () => ({
        dom: {
          tag: "div",
          classes: ["tox-form__controls-h-stack"]
        },
        components: ye([
          [Y.asSpec()],
          L.map(() => me.asSpec()).toArray()
        ])
      }), xe = (Ce) => {
        ts.getCurrent(Ce).each((Be) => {
          const St = ln.getValue(Be), ct = {
            fieldname: t.name,
            ...St
          };
          L.each((tt) => {
            tt(ct).get((Vt) => {
              ln.setValue(Be, Vt), to(Ce, Zl, { name: t.name });
            });
          });
        });
      };
      return qs.sketch({
        dom: Ij(),
        components: S.toArray().concat([Pe()]),
        fieldBehaviours: Ut([
          mo.config({
            disabled: () => !t.enabled || d.isDisabled(),
            onDisabled: (Ce) => {
              qs.getField(Ce).each(mo.disable), me.getOpt(Ce).each(mo.disable);
            },
            onEnabled: (Ce) => {
              qs.getField(Ce).each(mo.enable), me.getOpt(Ce).each(mo.enable);
            }
          }),
          fc(),
          Bo("url-input-events", [mt(V, xe)])
        ])
      });
    }, f$ = (t, s) => {
      const a = fN(t.icon, s.icons);
      return Zm.sketch({
        dom: {
          tag: "div",
          attributes: { role: "alert" },
          classes: [
            "tox-notification",
            "tox-notification--in",
            `tox-notification--${t.level}`
          ]
        },
        components: [
          {
            dom: {
              tag: "div",
              classes: ["tox-notification__icon"],
              innerHtml: t.url ? void 0 : a
            },
            components: t.url ? [Ec.sketch({
              dom: {
                tag: "button",
                classes: [
                  "tox-button",
                  "tox-button--naked",
                  "tox-button--icon"
                ],
                innerHtml: a,
                attributes: { title: s.translate(t.iconTooltip) }
              },
              action: (i) => to(i, Zf, {
                name: "alert-banner",
                value: t.url
              }),
              buttonBehaviours: Ut([Rx()])
            })] : void 0
          },
          {
            dom: {
              tag: "div",
              classes: ["tox-notification__body"],
              innerHtml: s.translate(t.text)
            }
          }
        ]
      });
    }, iD = (t, s) => {
      t.dom.checked = s;
    }, X9 = (t) => t.dom.checked, g$ = (t, s, a) => {
      const i = (S) => (S.element.dom.click(), A.some(!0)), d = qs.parts.field({
        factory: { sketch: Tt },
        dom: {
          tag: "input",
          classes: ["tox-checkbox__input"],
          attributes: { type: "checkbox" }
        },
        behaviours: Ut([
          ql.self(),
          mo.config({
            disabled: () => !t.enabled || s.isDisabled(),
            onDisabled: (S) => {
              Oc(S.element).each((_) => ba(_, "tox-checkbox--disabled"));
            },
            onEnabled: (S) => {
              Oc(S.element).each((_) => Wr(_, "tox-checkbox--disabled"));
            }
          }),
          Lr.config({}),
          po.config({}),
          NO(a, X9, iD),
          no.config({
            mode: "special",
            onEnter: i,
            onSpace: i,
            stopSpaceKeyup: !0
          }),
          Bo("checkbox-events", [mt(yh(), (S, _) => {
            to(S, Zl, { name: t.name });
          })])
        ])
      }), g = qs.parts.label({
        dom: {
          tag: "span",
          classes: ["tox-checkbox__label"]
        },
        components: [da(s.translate(t.label))],
        behaviours: Ut([z2.config({})])
      }), p = (S) => Xd(S === "checked" ? "selected" : "unselected", {
        tag: "span",
        classes: [
          "tox-icon",
          "tox-checkbox-icon__" + S
        ]
      }, s.icons), C = js({
        dom: {
          tag: "div",
          classes: ["tox-checkbox__icons"]
        },
        components: [
          p("checked"),
          p("unchecked")
        ]
      });
      return qs.sketch({
        dom: {
          tag: "label",
          classes: ["tox-checkbox"]
        },
        components: [
          d,
          C.asSpec(),
          g
        ],
        fieldBehaviours: Ut([
          mo.config({ disabled: () => !t.enabled || s.isDisabled() }),
          fc()
        ])
      });
    }, h$ = (t) => t.presets === "presentation" ? Zm.sketch({
      dom: {
        tag: "div",
        classes: ["tox-form__group"],
        innerHtml: t.html
      }
    }) : Zm.sketch({
      dom: {
        tag: "div",
        classes: ["tox-form__group"],
        innerHtml: t.html,
        attributes: { role: "document" }
      },
      containerBehaviours: Ut([
        Lr.config({}),
        po.config({})
      ])
    }), hc = (t) => (s, a, i, d) => Dt(a, "name").fold(() => t(a, d, A.none()), (g) => s.field(g, t(a, d, Dt(i, g)))), p$ = (t) => (s, a, i, d) => {
      const g = Ms(a, { source: "dynamic" });
      return hc(t)(s, g, i, d);
    }, J9 = {
      bar: hc((t, s) => x7(t, s.shared)),
      collection: hc((t, s, a) => R7(t, s.shared.providers, a)),
      alertbanner: hc((t, s) => f$(t, s.shared.providers)),
      input: hc((t, s, a) => HB(t, s.shared.providers, a)),
      textarea: hc((t, s, a) => zB(t, s.shared.providers, a)),
      label: hc((t, s) => kB(t, s.shared)),
      iframe: p$((t, s, a) => JH(t, s.shared.providers, a)),
      button: hc((t, s) => V9(t, s.shared.providers)),
      checkbox: hc((t, s, a) => g$(t, s.shared.providers, a)),
      colorinput: hc((t, s, a) => F7(t, s.shared, s.colorinput, a)),
      colorpicker: hc((t, s, a) => VH(t, s.shared.providers, a)),
      dropzone: hc((t, s, a) => WH(t, s.shared.providers, a)),
      grid: hc((t, s) => yB(t, s.shared)),
      listbox: hc((t, s, a) => jO(t, s, a)),
      selectbox: hc((t, s, a) => Y2(t, s.shared.providers, a)),
      sizeinput: hc((t, s) => IB(t, s.shared.providers)),
      slider: hc((t, s, a) => LB(t, s.shared.providers, a)),
      urlinput: hc((t, s, a) => m$(t, s, s.urlinput, a)),
      customeditor: hc(bB),
      htmlpanel: hc(h$),
      imagepreview: hc((t, s, a) => t9(t, a)),
      table: hc((t, s) => h9(t, s.shared.providers)),
      tree: hc((t, s) => D9(t, s)),
      panel: hc((t, s) => l9(t, s))
    }, Q9 = {
      field: (t, s) => s,
      record: U([])
    }, om = (t, s, a, i) => {
      const d = Ms(i, { shared: { interpreter: (g) => zv(t, g, a, d) } });
      return zv(t, s, a, d);
    }, zv = (t, s, a, i) => Dt(J9, s.type).fold(() => s, (d) => d(t, s, a, i)), tw = (t, s, a) => zv(Q9, t, s, a), Lp = "layout-inset", nw = (t) => t.x, b$ = (t, s) => t.x + t.width / 2 - s.width / 2, ow = (t, s) => t.x + t.width - s.width, sE = (t) => t.y, sw = (t, s) => t.y + t.height - s.height, v$ = (t, s) => t.y + t.height / 2 - s.height / 2, rw = (t, s, a) => Ja(ow(t, s), sw(t, s), a.insetSouthwest(), Vd(), "southwest", Ir(t, {
      right: 0,
      bottom: 3
    }), Lp), aw = (t, s, a) => Ja(nw(t), sw(t, s), a.insetSoutheast(), E0(), "southeast", Ir(t, {
      left: 1,
      bottom: 3
    }), Lp), Mb = (t, s, a) => Ja(ow(t, s), sE(t), a.insetNorthwest(), Wy(), "northwest", Ir(t, {
      right: 0,
      top: 2
    }), Lp), cw = (t, s, a) => Ja(nw(t), sE(t), a.insetNortheast(), _1(), "northeast", Ir(t, {
      left: 1,
      top: 2
    }), Lp), sm = (t, s, a) => Ja(b$(t, s), sE(t), a.insetNorth(), _m(), "north", Ir(t, { top: 2 }), Lp), Vv = (t, s, a) => Ja(b$(t, s), sw(t, s), a.insetSouth(), Lk(), "south", Ir(t, { bottom: 3 }), Lp), y$ = (t, s, a) => Ja(ow(t, s), v$(t, s), a.insetEast(), A1(), "east", Ir(t, { right: 0 }), Lp), C$ = (t, s, a) => Ja(nw(t), v$(t, s), a.insetWest(), We(), "west", Ir(t, { left: 1 }), Lp), w$ = (t) => {
      switch (t) {
        case "north":
          return sm;
        case "northeast":
          return cw;
        case "northwest":
          return Mb;
        case "south":
          return Vv;
        case "southeast":
          return aw;
        case "southwest":
          return rw;
        case "east":
          return y$;
        case "west":
          return C$;
      }
    }, lD = (t, s, a, i, d) => lS(i).map(w$).getOr(sm)(t, s, a, i, d), ez = (t) => {
      switch (t) {
        case "north":
          return Vv;
        case "northeast":
          return aw;
        case "northwest":
          return rw;
        case "south":
          return sm;
        case "southeast":
          return cw;
        case "southwest":
          return Mb;
        case "east":
          return C$;
        case "west":
          return y$;
      }
    }, tz = (t, s, a, i, d) => lS(i).map(ez).getOr(sm)(t, s, a, i, d), iw = {
      valignCentre: [],
      alignCentre: [],
      alignLeft: [],
      alignRight: [],
      right: [],
      left: [],
      bottom: [],
      top: []
    }, nz = (t, s, a) => {
      const d = { maxHeightFunction: jh() }, g = () => ({
        type: "node",
        root: Rt(Ve(t())),
        node: A.from(t()),
        bubble: Wd(12, 12, iw),
        layouts: {
          onRtl: () => [cw],
          onLtr: () => [Mb]
        },
        overrides: d
      }), p = () => ({
        type: "hotspot",
        hotspot: s(),
        bubble: Wd(-12, 12, iw),
        layouts: {
          onRtl: () => [
            Qa,
            Lc,
            ec
          ],
          onLtr: () => [
            Lc,
            Qa,
            ec
          ]
        },
        overrides: d
      });
      return () => a() ? g() : p();
    }, S$ = (t, s, a, i) => {
      const g = { maxHeightFunction: jh() }, p = () => ({
        type: "node",
        root: Rt(Ve(s())),
        node: A.from(s()),
        bubble: Wd(12, 12, iw),
        layouts: {
          onRtl: () => [sm],
          onLtr: () => [sm]
        },
        overrides: g
      }), C = () => t ? {
        type: "node",
        root: Rt(Ve(s())),
        node: A.from(s()),
        bubble: Wd(0, -yu(s()), iw),
        layouts: {
          onRtl: () => [fi],
          onLtr: () => [fi]
        },
        overrides: g
      } : {
        type: "hotspot",
        hotspot: a(),
        bubble: Wd(0, 0, iw),
        layouts: {
          onRtl: () => [fi],
          onLtr: () => [fi]
        },
        overrides: g
      };
      return () => i() ? p() : C();
    }, Gm = (t, s, a) => {
      const i = () => ({
        type: "node",
        root: Rt(Ve(t())),
        node: A.from(t()),
        layouts: {
          onRtl: () => [sm],
          onLtr: () => [sm]
        }
      }), d = () => ({
        type: "hotspot",
        hotspot: s(),
        layouts: {
          onRtl: () => [ec],
          onLtr: () => [ec]
        }
      });
      return () => a() ? i() : d();
    }, uD = (t, s) => () => ({
      type: "selection",
      root: s(),
      getSelection: () => {
        const a = t.selection.getRng(), i = t.model.table.getSelectedCells();
        if (i.length > 1) {
          const d = i[0], g = i[i.length - 1], p = {
            firstCell: ve.fromDom(d),
            lastCell: ve.fromDom(g)
          };
          return A.some(p);
        }
        return A.some(xc.range(ve.fromDom(a.startContainer), a.startOffset, ve.fromDom(a.endContainer), a.endOffset));
      }
    }), oz = (t) => (s) => ({
      type: "node",
      root: t(),
      node: s
    }), sz = (t, s, a, i) => {
      const d = xp(t), g = () => ve.fromDom(t.getBody()), p = () => ve.fromDom(t.getContentAreaContainer()), C = () => d || !i();
      return {
        inlineDialog: nz(p, s, C),
        inlineBottomDialog: S$(t.inline, p, a, C),
        banner: Gm(p, s, C),
        cursor: uD(t, g),
        node: oz(g)
      };
    }, rz = (t) => (s, a) => {
      nP(t)(s, a);
    }, az = (t) => () => YM(t), cz = (t) => (s) => bT(t, s), x$ = (t) => (s) => KM(t, s), T$ = (t) => ({
      colorPicker: rz(t),
      hasCustomColors: az(t),
      getColors: cz(t),
      getColorCols: x$(t)
    }), Yj = (t) => () => kN(t), Xj = (t) => ({ isDraggableModal: Yj(t) }), yi = (t) => {
      const s = w(KA(t) ? "bottom" : "top");
      return {
        isPositionedAtTop: () => s.get() === "top",
        getDockingMode: s.get,
        setDockingMode: s.set
      };
    }, rE = (t) => Or(t, "items"), E$ = (t) => Or(t, "format"), lw = [
      {
        title: "Headings",
        items: [
          {
            title: "Heading 1",
            format: "h1"
          },
          {
            title: "Heading 2",
            format: "h2"
          },
          {
            title: "Heading 3",
            format: "h3"
          },
          {
            title: "Heading 4",
            format: "h4"
          },
          {
            title: "Heading 5",
            format: "h5"
          },
          {
            title: "Heading 6",
            format: "h6"
          }
        ]
      },
      {
        title: "Inline",
        items: [
          {
            title: "Bold",
            format: "bold"
          },
          {
            title: "Italic",
            format: "italic"
          },
          {
            title: "Underline",
            format: "underline"
          },
          {
            title: "Strikethrough",
            format: "strikethrough"
          },
          {
            title: "Superscript",
            format: "superscript"
          },
          {
            title: "Subscript",
            format: "subscript"
          },
          {
            title: "Code",
            format: "code"
          }
        ]
      },
      {
        title: "Blocks",
        items: [
          {
            title: "Paragraph",
            format: "p"
          },
          {
            title: "Blockquote",
            format: "blockquote"
          },
          {
            title: "Div",
            format: "div"
          },
          {
            title: "Pre",
            format: "pre"
          }
        ]
      },
      {
        title: "Align",
        items: [
          {
            title: "Left",
            format: "alignleft"
          },
          {
            title: "Center",
            format: "aligncenter"
          },
          {
            title: "Right",
            format: "alignright"
          },
          {
            title: "Justify",
            format: "alignjustify"
          }
        ]
      }
    ], iz = (t) => Lo(t, "items"), lz = (t) => Lo(t, "block"), uz = (t) => Lo(t, "inline"), dz = (t) => Lo(t, "selector"), k$ = (t) => lt(t, (s, a) => {
      if (iz(a)) {
        const i = k$(a.items);
        return {
          customFormats: s.customFormats.concat(i.customFormats),
          formats: s.formats.concat([{
            title: a.title,
            items: i.formats
          }])
        };
      } else if (uz(a) || lz(a) || dz(a)) {
        const d = `custom-${Ee(a.name) ? a.name : a.title.toLowerCase()}`;
        return {
          customFormats: s.customFormats.concat([{
            name: d,
            format: a
          }]),
          formats: s.formats.concat([{
            title: a.title,
            format: d,
            icon: a.icon
          }])
        };
      } else
        return {
          ...s,
          formats: s.formats.concat(a)
        };
    }, {
      customFormats: [],
      formats: []
    }), mz = (t, s) => {
      const a = k$(s), i = (d) => {
        ot(d, (g) => {
          t.formatter.has(g.name) || t.formatter.register(g.name, g.format);
        });
      };
      return t.formatter ? i(a.customFormats) : t.on("init", () => {
        i(a.customFormats);
      }), a.formats;
    }, _$ = (t) => VA(t).map((s) => {
      const a = mz(t, s);
      return bN(t) ? lw.concat(a) : a;
    }).getOr(lw), fz = (t) => {
      const s = Ao(t);
      return s.length === 1 && io(s, "title");
    }, dD = (t, s, a) => ({
      ...t,
      type: "formatter",
      isSelected: s(t.format),
      getStylePreview: a(t.format)
    }), uw = (t, s, a, i) => {
      const d = (S) => dD(S, a, i), g = (S) => {
        const _ = C(S.items);
        return {
          ...S,
          type: "submenu",
          getStyleItems: U(_)
        };
      }, p = (S) => {
        const _ = Ee(S.name) ? S.name : An(S.title), D = `custom-${_}`, P = {
          ...S,
          type: "formatter",
          format: D,
          isSelected: a(D),
          getStylePreview: i(D)
        };
        return t.formatter.register(_, P), P;
      }, C = (S) => $e(S, (_) => rE(_) ? g(_) : E$(_) ? d(_) : fz(_) ? {
        ..._,
        type: "separator"
      } : p(_));
      return C(s);
    }, gz = (t) => {
      const s = (C) => () => t.formatter.match(C), a = (C) => () => {
        const S = t.formatter.get(C);
        return S !== void 0 ? A.some({
          tag: S.length > 0 && (S[0].inline || S[0].block) || "div",
          styles: t.dom.parseStyle(t.formatter.getCssText(C))
        }) : A.none();
      }, i = w([]), d = w([]), g = w(!1);
      return t.on("PreInit", (C) => {
        const S = _$(t), _ = uw(t, S, s, a);
        i.set(_);
      }), t.on("addStyleModifications", (C) => {
        const S = uw(t, C.items, s, a);
        d.set(S), g.set(C.replace);
      }), { getData: () => {
        const C = g.get() ? [] : i.get(), S = d.get();
        return C.concat(S);
      } };
    }, A$ = (t) => En(t) && t.nodeType === 1, hz = Qg.trim, mD = (t) => (s) => !!(A$(s) && (s.contentEditable === t || s.getAttribute("data-mce-contenteditable") === t)), pz = mD("true"), bz = mD("false"), fD = (t, s, a, i, d) => ({
      type: t,
      title: s,
      url: a,
      level: i,
      attach: d
    }), Jj = (t) => {
      let s = t;
      for (; s = s.parentNode; ) {
        const a = s.contentEditable;
        if (a && a !== "inherit")
          return pz(s);
      }
      return !1;
    }, Qj = (t, s) => $e(nc(ve.fromDom(s), t), (a) => a.dom), O$ = (t) => t.innerText || t.textContent, vz = (t) => t.id ? t.id : An("h"), yz = (t) => t && t.nodeName === "A" && (t.id || t.name) !== void 0, D$ = (t) => yz(t) && R$(t), aE = (t) => t && /^(H[1-6])$/.test(t.nodeName), R$ = (t) => Jj(t) && !bz(t), Cz = (t) => aE(t) && R$(t), N$ = (t) => aE(t) ? parseInt(t.nodeName.substr(1), 10) : 0, wz = (t) => {
      var s;
      const a = vz(t), i = () => {
        t.id = a;
      };
      return fD("header", (s = O$(t)) !== null && s !== void 0 ? s : "", "#" + a, N$(t), i);
    }, Sz = (t) => {
      const s = t.id || t.name, a = O$(t);
      return fD("anchor", a || "#" + s, "#" + s, 0, J);
    }, xz = (t) => $e(fo(t, Cz), wz), Tz = (t) => $e(fo(t, D$), Sz), gD = (t) => Qj("h1,h2,h3,h4,h5,h6,a:not([href])", t), M$ = (t) => hz(t.title).length > 0, Ez = { find: (t) => {
      const s = gD(t);
      return fo(xz(s).concat(Tz(s)), M$);
    } }, P$ = "tinymce-url-history", B$ = 5, hD = (t) => Ee(t) && /^https?/.test(t), kz = (t) => dn(t) && t.length <= B$ && kt(t, hD), dw = (t) => Bt(t) && Ss(t, (s) => !kz(s)).isNone(), $$ = () => {
      const t = Op.getItem(P$);
      if (t === null)
        return {};
      let s;
      try {
        s = JSON.parse(t);
      } catch (a) {
        if (a instanceof SyntaxError)
          return {};
        throw a;
      }
      return dw(s) ? s : {};
    }, cE = (t) => {
      if (!dw(t))
        throw new Error(`Bad format for history:
` + JSON.stringify(t));
      Op.setItem(P$, JSON.stringify(t));
    }, _z = (t) => {
      const s = $$();
      return Dt(s, t).getOr([]);
    }, pD = (t, s) => {
      if (!hD(t))
        return;
      const a = $$(), i = Dt(a, s).getOr([]), d = fo(i, (g) => g !== t);
      a[s] = [t].concat(d).slice(0, B$), cE(a);
    }, Uv = (t) => !!t, F$ = (t) => et(Qg.makeMap(t, /[, ]/), Uv), bD = (t) => A.from(WA(t)), I$ = (t) => {
      const s = A.from(ZA(t)).filter(Uv).map(F$);
      return bD(t).fold(Te, (a) => s.fold(Oe, (i) => Ao(i).length > 0 ? i : !1));
    }, L$ = (t, s) => {
      const a = I$(t);
      return Ft(a) ? a ? bD(t) : A.none() : a[s] ? bD(t) : A.none();
    }, H$ = (t, s) => L$(t, s).map((a) => (i) => vi.nu((d) => {
      const g = (C, S) => {
        if (!Ee(C))
          throw new Error("Expected value to be string");
        if (S !== void 0 && !Bt(S))
          throw new Error("Expected meta to be a object");
        d({
          value: C,
          meta: S
        });
      }, p = {
        filetype: s,
        fieldname: i.fieldname,
        ...A.from(i.meta).getOr({})
      };
      a.call(t, g, i.value, p);
    })), z$ = (t) => A.from(t).filter(Ee).getOrUndefined(), vD = (t) => TN(t) ? A.some({
      targets: Ez.find(t.getBody()),
      anchorTop: z$(wv(t)),
      anchorBottom: z$(EN(t))
    }) : A.none(), iE = (t) => A.from(Px(t)), Az = (t) => ({
      getHistory: _z,
      addToHistory: pD,
      getLinkInformation: () => vD(t),
      getValidationHandler: () => iE(t),
      getUrlPicker: (s) => H$(t, s)
    }), Oz = (t, s, a, i) => {
      const d = w(!1), g = yi(s), p = {
        icons: () => s.ui.registry.getAll().icons,
        menuItems: () => s.ui.registry.getAll().menuItems,
        translate: Vl.translate,
        isDisabled: () => s.mode.isReadOnly() || !s.ui.isEnabled(),
        getOption: s.options.get
      }, C = Az(s), S = gz(s), _ = T$(s), D = Xj(s), P = () => d.get(), L = (Pe) => d.set(Pe), V = {
        shared: {
          providers: p,
          anchors: sz(s, a, i, g.isPositionedAtTop),
          header: g
        },
        urlinput: C,
        styles: S,
        colorinput: _,
        dialog: D,
        isContextMenuOpen: P,
        setContextMenuState: L
      }, Y = {
        ...V,
        shared: {
          ...V.shared,
          interpreter: (Pe) => tw(Pe, {}, Y),
          getSink: t.popup
        }
      }, me = {
        ...V,
        shared: {
          ...V.shared,
          interpreter: (Pe) => tw(Pe, {}, me),
          getSink: t.dialog
        }
      };
      return {
        popup: Y,
        dialog: me
      };
    }, Wv = (t, s, a) => {
      const i = (tt, Vt) => {
        ot([
          s,
          ...a
        ], (Xt) => {
          Xt.broadcastEvent(tt, Vt);
        });
      }, d = (tt, Vt) => {
        ot([
          s,
          ...a
        ], (Xt) => {
          Xt.broadcastOn([tt], Vt);
        });
      }, g = (tt) => d(gd(), { target: tt.target }), p = Dd(), C = hi(p, "touchstart", g), S = hi(p, "touchmove", (tt) => i(g1(), tt)), _ = hi(p, "touchend", (tt) => i(e0(), tt)), D = hi(p, "mousedown", g), P = hi(p, "mouseup", (tt) => {
        tt.raw.button === 0 && d(PC(), { target: tt.target });
      }), L = (tt) => d(gd(), { target: ve.fromDom(tt.target) }), V = (tt) => {
        tt.button === 0 && d(PC(), { target: ve.fromDom(tt.target) });
      }, Y = () => {
        ot(t.editorManager.get(), (tt) => {
          t !== tt && tt.dispatch("DismissPopups", { relatedTarget: t });
        });
      }, me = (tt) => i(Bd(), lC(tt)), Pe = (tt) => {
        d(Bg(), {}), i(cd(), lC(tt));
      }, xe = Ve(ve.fromDom(t.getElement())), Ce = R0(xe, "scroll", (tt) => {
        requestAnimationFrame(() => {
          const Vt = t.getContainer();
          if (Vt != null) {
            const $o = Rp(t, s.element).map((Hn) => [
              Hn.element,
              ...Hn.others
            ]).getOr([]);
            jo($o, (Hn) => Rs(Hn, tt.target)) && (t.dispatch("ElementScroll", { target: tt.target.dom }), i(n0(), tt));
          }
        });
      }), Be = () => d(Bg(), {}), St = (tt) => {
        tt.state && d(gd(), { target: ve.fromDom(t.getContainer()) });
      }, ct = (tt) => {
        d(gd(), { target: ve.fromDom(tt.relatedTarget.getContainer()) });
      };
      t.on("PostRender", () => {
        t.on("click", L), t.on("tap", L), t.on("mouseup", V), t.on("mousedown", Y), t.on("ScrollWindow", me), t.on("ResizeWindow", Pe), t.on("ResizeEditor", Be), t.on("AfterProgressState", St), t.on("DismissPopups", ct);
      }), t.on("remove", () => {
        t.off("click", L), t.off("tap", L), t.off("mouseup", V), t.off("mousedown", Y), t.off("ScrollWindow", me), t.off("ResizeWindow", Pe), t.off("ResizeEditor", Be), t.off("AfterProgressState", St), t.off("DismissPopups", ct), D.unbind(), C.unbind(), S.unbind(), _.unbind(), P.unbind(), Ce.unbind();
      }), t.on("detach", () => {
        ot([
          s,
          ...a
        ], rp), ot([
          s,
          ...a
        ], (tt) => tt.destroy());
      });
    }, pc = z_, Kf = YS, V$ = U([
      Ne("shell", !1),
      gt("makeItem"),
      Ne("setupItem", J),
      lu.field("listBehaviours", [Oo])
    ]), yD = qi({
      name: "items",
      overrides: () => ({ behaviours: Ut([Oo.config({})]) })
    }), Dz = U([yD]), Rz = U("CustomList"), Nz = (t, s, a, i) => {
      const d = (C, S) => {
        p(C).fold(() => {
          throw new Error("Custom List was defined to not be a shell, but no item container was specified in components");
        }, (_) => {
          const D = Oo.contents(_), P = S.length, L = P - D.length, V = L > 0 ? bt(L, () => t.makeItem()) : [], Y = D.slice(P);
          ot(Y, (Pe) => Oo.remove(_, Pe)), ot(V, (Pe) => Oo.append(_, Pe));
          const me = Oo.contents(_);
          ot(me, (Pe, xe) => {
            t.setupItem(C, Pe, S[xe], xe);
          });
        });
      }, g = t.shell ? {
        behaviours: [Oo.config({})],
        components: []
      } : {
        behaviours: [],
        components: s
      }, p = (C) => t.shell ? A.some(C) : ir(C, t, "items");
      return {
        uid: t.uid,
        dom: t.dom,
        components: g.components,
        behaviours: Oa(t.listBehaviours, g.behaviours),
        apis: { setItems: d }
      };
    }, lE = ti({
      name: Rz(),
      configFields: V$(),
      partFields: Dz(),
      factory: Nz,
      apis: {
        setItems: (t, s, a) => {
          t.setItems(s, a);
        }
      }
    }), Zv = U([
      gt("dom"),
      Ne("shell", !0),
      za("toolbarBehaviours", [Oo])
    ]), Mz = U([qi({
      name: "groups",
      overrides: () => ({ behaviours: Ut([Oo.config({})]) })
    })]), Pz = (t, s, a, i) => {
      const d = (C, S) => {
        g(C).fold(() => {
          throw new Error("Toolbar was defined to not be a shell, but no groups container was specified in components");
        }, (_) => {
          Oo.set(_, S);
        });
      }, g = (C) => t.shell ? A.some(C) : ir(C, t, "groups"), p = t.shell ? {
        behaviours: [Oo.config({})],
        components: []
      } : {
        behaviours: [],
        components: s
      };
      return {
        uid: t.uid,
        dom: t.dom,
        components: p.components,
        behaviours: Oa(t.toolbarBehaviours, p.behaviours),
        apis: {
          setGroups: d,
          refresh: J
        },
        domModification: { attributes: { role: "group" } }
      };
    }, Km = ti({
      name: "Toolbar",
      configFields: Zv(),
      partFields: Mz(),
      factory: Pz,
      apis: {
        setGroups: (t, s, a) => {
          t.setGroups(s, a);
        }
      }
    }), Bz = J, $z = Te, CD = U([]);
    var Fz = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      setup: Bz,
      isDocked: $z,
      getBehaviours: CD
    });
    const Pb = (t) => (aa(Xs(t, "position"), "fixed") ? A.none() : Dc(t)).orThunk(() => {
      const i = ve.fromTag("span");
      return Ta(t).bind((d) => {
        Sc(d, i);
        const g = Dc(i);
        return rl(i), g;
      });
    }), W$ = (t) => Pb(t).map(Cc).getOrThunk(() => Es(0, 0)), Iz = (t, s) => {
      const a = t.element;
      ba(a, s.transitionClass), Wr(a, s.fadeOutClass), ba(a, s.fadeInClass), s.onShow(t);
    }, wD = (t, s) => {
      const a = t.element;
      ba(a, s.transitionClass), Wr(a, s.fadeInClass), ba(a, s.fadeOutClass), s.onHide(t);
    }, Z$ = (t, s) => t.y < s.bottom && t.bottom > s.y, j$ = (t, s) => t.y >= s.y, q$ = (t, s) => t.bottom <= s.bottom, SD = (t, s, a) => ({
      location: "top",
      leftX: s,
      topY: a.bounds.y - t.y
    }), xD = (t, s, a) => ({
      location: "bottom",
      leftX: s,
      bottomY: t.bottom - a.bounds.bottom
    }), TD = (t) => t.box.x - t.win.x, Lz = (t, s, a) => {
      const i = s.win, d = s.box, g = TD(s);
      return No(t, (p) => {
        switch (p) {
          case "bottom":
            return q$(d, a.bounds) ? A.none() : A.some(xD(i, g, a));
          case "top":
            return j$(d, a.bounds) ? A.none() : A.some(SD(i, g, a));
          default:
            return A.none();
        }
      }).getOr({ location: "no-dock" });
    }, Hz = (t, s, a) => kt(t, (i) => {
      switch (i) {
        case "bottom":
          return q$(s, a.bounds);
        case "top":
          return j$(s, a.bounds);
      }
    }), zz = (t, s) => {
      const a = s.optScrollEnv.fold(U(t.bounds.y), (i) => i.scrollElmTop + (t.bounds.y - i.currentScrollTop));
      return Es(t.bounds.x, a);
    }, Vz = (t, s) => {
      const a = s.optScrollEnv.fold(U(t.y), (i) => t.y + i.currentScrollTop - i.scrollElmTop);
      return Es(t.x, a);
    }, G$ = (t, s, a) => a.getInitialPos().map((i) => {
      const d = zz(i, s);
      return {
        box: Rr(d.left, d.top, j(t), hr(t)),
        location: i.location
      };
    }), K$ = (t, s, a, i, d) => {
      const g = Vz(s, a), p = Rr(g.left, g.top, s.width, s.height);
      i.setInitialPos({
        style: Zr(t),
        position: Us(t, "position") || "static",
        bounds: p,
        location: d.location
      });
    }, Y$ = (t, s, a, i, d) => {
      i.getInitialPos().fold(() => K$(t, s, a, i, d), () => J);
    }, ED = (t, s, a) => a.getInitialPos().bind((i) => {
      var d;
      switch (a.clearInitialPos(), i.position) {
        case "static":
          return A.some({ morph: "static" });
        case "absolute":
          const g = Pb(t).getOr(fr()), p = Ar(g), C = (d = g.dom.scrollTop) !== null && d !== void 0 ? d : 0;
          return A.some({
            morph: "absolute",
            positionCss: $l("absolute", Dt(i.style, "left").map((S) => s.x - p.x), Dt(i.style, "top").map((S) => s.y - p.y + C), Dt(i.style, "right").map((S) => p.right - s.right), Dt(i.style, "bottom").map((S) => p.bottom - s.bottom))
          });
        default:
          return A.none();
      }
    }), uE = (t, s, a) => G$(t, s, a).filter(({ box: i }) => Hz(a.getModes(), i, s)).bind(({ box: i }) => ED(t, i, a)), dE = (t) => {
      switch (t.location) {
        case "top":
          return A.some({
            morph: "fixed",
            positionCss: $l("fixed", A.some(t.leftX), A.some(t.topY), A.none(), A.none())
          });
        case "bottom":
          return A.some({
            morph: "fixed",
            positionCss: $l("fixed", A.some(t.leftX), A.none(), A.none(), A.some(t.bottomY))
          });
        default:
          return A.none();
      }
    }, Uz = (t, s, a) => {
      const i = Ar(t), d = La(), g = Lz(a.getModes(), {
        win: d,
        box: i
      }, s);
      return g.location === "top" || g.location === "bottom" ? (K$(t, i, s, a, g), dE(g)) : A.none();
    }, Wz = (t, s, a) => uE(t, s, a).orThunk(() => s.optScrollEnv.bind((i) => G$(t, s, a)).bind(({ box: i, location: d }) => {
      const g = La(), p = TD({
        win: g,
        box: i
      }), C = d === "top" ? SD(g, p, s) : xD(g, p, s);
      return dE(C);
    })), Zz = (t, s, a) => {
      const i = t.element;
      return aa(Xs(i, "position"), "fixed") ? Wz(i, s, a) : Uz(i, s, a);
    }, jz = (t, s, a) => {
      const i = t.element;
      return G$(i, s, a).bind(({ box: d }) => ED(i, d, a));
    }, qz = (t, s, a, i) => {
      const d = Ar(t), g = La(), p = TD({
        win: g,
        box: d
      }), C = i(g, p, s);
      return C.location === "bottom" || C.location === "top" ? (Y$(t, d, s, a, C), dE(C)) : A.none();
    }, X$ = (t, s, a) => {
      a.setDocked(!1), ot([
        "left",
        "right",
        "top",
        "bottom",
        "position"
      ], (i) => Jo(t.element, i)), s.onUndocked(t);
    }, kD = (t, s, a, i) => {
      const d = i.position === "fixed";
      a.setDocked(d), cS(t.element, i), (d ? s.onDocked : s.onUndocked)(t);
    }, _D = (t, s, a, i, d = !1) => {
      s.contextual.each((g) => {
        g.lazyContext(t).each((p) => {
          const C = Z$(p, i.bounds);
          C !== a.isVisible() && (a.setVisible(C), d && !C ? (jr(t.element, [g.fadeOutClass]), g.onHide(t)) : (C ? Iz : wD)(t, g));
        });
      });
    }, AD = (t, s, a, i, d) => {
      _D(t, s, a, i, !0), kD(t, s, a, d.positionCss);
    }, Gz = (t, s, a, i, d) => {
      switch (d.morph) {
        case "static":
          return X$(t, s, a);
        case "absolute":
          return kD(t, s, a, d.positionCss);
        case "fixed":
          return AD(t, s, a, i, d);
      }
    }, J$ = (t, s, a) => {
      const i = s.lazyViewport(t);
      _D(t, s, a, i), Zz(t, i, a).each((d) => {
        Gz(t, s, a, i, d);
      });
    }, Kz = (t, s, a) => {
      const i = t.element;
      a.setDocked(!1);
      const d = s.lazyViewport(t);
      jz(t, d, a).each((g) => {
        switch (g.morph) {
          case "static": {
            X$(t, s, a);
            break;
          }
          case "absolute": {
            kD(t, s, a, g.positionCss);
            break;
          }
        }
      }), a.setVisible(!0), s.contextual.each((g) => {
        Ml(i, [
          g.fadeInClass,
          g.fadeOutClass,
          g.transitionClass
        ]), g.onShow(t);
      }), mE(t, s, a);
    }, mE = (t, s, a) => {
      t.getSystem().isConnected() && J$(t, s, a);
    }, Q$ = (t, s, a) => {
      a.isDocked() && Kz(t, s, a);
    }, Hp = (t) => (s, a, i) => {
      const d = a.lazyViewport(s);
      qz(s.element, d, i, t).each((p) => {
        AD(s, a, i, d, p);
      });
    }, e5 = Hp(SD), mw = Hp(xD);
    var t5 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      refresh: mE,
      reset: Q$,
      isDocked: (t, s, a) => a.isDocked(),
      getModes: (t, s, a) => a.getModes(),
      setModes: (t, s, a, i) => a.setModes(i),
      forceDockToTop: e5,
      forceDockToBottom: mw
    }), Jz = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      events: (t, s) => vr([
        $d(pg(), (a, i) => {
          t.contextual.each((d) => {
            Ha(a.element, d.transitionClass) && (Ml(a.element, [
              d.transitionClass,
              d.fadeInClass
            ]), (s.isVisible() ? d.onShown : d.onHidden)(a)), i.stop();
          });
        }),
        mt(Bd(), (a, i) => {
          mE(a, t, s);
        }),
        mt(n0(), (a, i) => {
          mE(a, t, s);
        }),
        mt(cd(), (a, i) => {
          Q$(a, t, s);
        })
      ])
    }), Qz = [
      ui("contextual", [
        _s("fadeInClass"),
        _s("fadeOutClass"),
        _s("transitionClass"),
        ou("lazyContext"),
        gs("onShow"),
        gs("onShown"),
        gs("onHide"),
        gs("onHidden")
      ]),
      _a("lazyViewport", () => ({
        bounds: La(),
        optScrollEnv: A.none()
      })),
      di("modes", [
        "top",
        "bottom"
      ], Xa),
      gs("onDocked"),
      gs("onUndocked")
    ], eV = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      init: (t) => {
        const s = w(!1), a = w(!0), i = Go(), d = w(t.modes), g = () => `docked:  ${s.get()}, visible: ${a.get()}, modes: ${d.get().join(",")}`;
        return il({
          isDocked: s.get,
          setDocked: s.set,
          getInitialPos: i.get,
          setInitialPos: i.set,
          clearInitialPos: i.clear,
          isVisible: a.get,
          setVisible: a.set,
          getModes: d.get,
          setModes: d.set,
          readState: g
        });
      }
    });
    const Da = tc({
      fields: Qz,
      name: "docking",
      active: Jz,
      apis: t5,
      state: eV
    }), zp = U(An("toolbar-height-change")), Gu = {
      fadeInClass: "tox-editor-dock-fadein",
      fadeOutClass: "tox-editor-dock-fadeout",
      transitionClass: "tox-editor-dock-transition"
    }, fE = "tox-tinymce--toolbar-sticky-on", n5 = "tox-tinymce--toolbar-sticky-off", tV = (t, s) => {
      const a = Ia(s), d = Uc(s).dom.innerHeight, g = Mc(a), p = ve.fromDom(t.elm), C = ci(p), S = hr(p), _ = C.y, D = _ + S, P = Cc(s), L = hr(s), V = P.top, Y = V + L, me = Math.abs(V - g.top) < 2, Pe = Math.abs(Y - (g.top + d)) < 2;
      if (me && _ < Y)
        ih(g.left, _ - L, a);
      else if (Pe && D > V) {
        const xe = _ - d + S + L;
        ih(g.left, xe, a);
      }
    }, jv = (t, s) => io(Da.getModes(t), s), DD = (t) => {
      const s = (i) => yu(i) + (parseInt(Us(i, "margin-top"), 10) || 0) + (parseInt(Us(i, "margin-bottom"), 10) || 0), a = t.element;
      Oc(a).each((i) => {
        const d = "padding-" + Da.getModes(t)[0];
        if (Da.isDocked(t)) {
          const g = j(i);
          _n(a, "width", g + "px"), _n(i, d, s(a) + "px");
        } else
          Jo(a, "width"), Jo(i, d);
      });
    }, qv = (t, s) => {
      s ? (Wr(t, Gu.fadeOutClass), jr(t, [
        Gu.transitionClass,
        Gu.fadeInClass
      ])) : (Wr(t, Gu.fadeInClass), jr(t, [
        Gu.fadeOutClass,
        Gu.transitionClass
      ]));
    }, RD = (t, s) => {
      const a = ve.fromDom(t.getContainer());
      s ? (ba(a, fE), Wr(a, n5)) : (ba(a, n5), Wr(a, fE));
    }, nV = (t, s) => {
      const a = Ia(s);
      Ud(a).filter((i) => !Rs(s, i)).filter((i) => Rs(i, ve.fromDom(a.dom.body)) || ca(t, i)).each(() => Zi(s));
    }, oV = (t, s) => Iu(t).orThunk(() => s().toOptional().bind((a) => Iu(a.element))), sV = (t, s, a) => {
      t.inline || (s.header.isPositionedAtTop() || t.on("ResizeEditor", () => {
        a().each(Da.reset);
      }), t.on("ResizeWindow ResizeEditor", () => {
        a().each(DD);
      }), t.on("SkinLoaded", () => {
        a().each((i) => {
          Da.isDocked(i) ? Da.reset(i) : Da.refresh(i);
        });
      }), t.on("FullscreenStateChanged", () => {
        a().each(Da.reset);
      })), t.on("AfterScrollIntoView", (i) => {
        a().each((d) => {
          Da.refresh(d);
          const g = d.element;
          uv(g) && tV(i, g);
        });
      }), t.on("PostRender", () => {
        RD(t, !1);
      });
    }, rV = (t) => t().map(Da.isDocked).getOr(!1), aV = () => [Wi.config({ channels: { [zp()]: { onReceive: DD } } })], o5 = (t, s) => {
      const a = Go(), i = s.getSink, d = (C) => {
        i().each((S) => C(S.element));
      }, g = (C) => {
        t.inline || DD(C), RD(t, Da.isDocked(C)), C.getSystem().broadcastOn([Bg()], {}), i().each((S) => S.getSystem().broadcastOn([Bg()], {}));
      }, p = t.inline ? [] : aV();
      return [
        po.config({}),
        Da.config({
          contextual: {
            lazyContext: (C) => {
              const S = yu(C.element), _ = t.inline ? t.getContentAreaContainer() : t.getContainer();
              return A.from(_).map((D) => {
                const P = Ar(ve.fromDom(D));
                return Rp(t, C.element).fold(() => {
                  const V = P.height - S, Y = P.y + (jv(C, "top") ? 0 : S);
                  return Rr(P.x, Y, P.width, V);
                }, (V) => {
                  const Y = sf(P, Av(V)), me = jv(C, "top") ? Y.y : Y.y + S;
                  return Rr(Y.x, me, Y.width, Y.height - S);
                });
              });
            },
            onShow: () => {
              d((C) => qv(C, !0));
            },
            onShown: (C) => {
              d((S) => Ml(S, [
                Gu.transitionClass,
                Gu.fadeInClass
              ])), a.get().each((S) => {
                nV(C.element, S), a.clear();
              });
            },
            onHide: (C) => {
              oV(C.element, i).fold(a.clear, a.set), d((S) => qv(S, !1));
            },
            onHidden: () => {
              d((C) => Ml(C, [Gu.transitionClass]));
            },
            ...Gu
          },
          lazyViewport: (C) => Rp(t, C.element).fold(() => {
            const _ = La(), D = UA(t), P = _.y + (jv(C, "top") ? D : 0), L = _.height - (jv(C, "bottom") ? D : 0);
            return {
              bounds: Rr(_.x, P, _.width, L),
              optScrollEnv: A.none()
            };
          }, (_) => ({
            bounds: Av(_),
            optScrollEnv: A.some({
              currentScrollTop: _.element.dom.scrollTop,
              scrollElmTop: Cc(_.element).top
            })
          })),
          modes: [s.header.getDockingMode()],
          onDocked: g,
          onUndocked: g
        }),
        ...p
      ];
    };
    var s5 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      setup: sV,
      isDocked: rV,
      getBehaviours: o5
    });
    const r5 = (t) => {
      const s = t.editor, a = t.sticky ? o5 : CD;
      return {
        uid: t.uid,
        dom: t.dom,
        components: t.components,
        behaviours: Ut(a(s, t.sharedBackstage))
      };
    }, ND = jn([
      $a,
      _i("items", xn([
        Ou([
          Yx,
          zi("items", Xa)
        ]),
        Xa
      ]))
    ].concat(Tv)), cV = (t) => $r("GroupToolbarButton", ND, t), gE = [
      mc("text"),
      mc("tooltip"),
      mc("icon"),
      Pc("search", !1, xn([
        nu,
        jn([mc("placeholder")])
      ], (t) => Ft(t) ? t ? A.some({ placeholder: A.none() }) : A.none() : A.some(t))),
      ou("fetch"),
      _a("onSetup", () => J)
    ], fw = jn([
      $a,
      ...gE
    ]), MD = (t) => $r("menubutton", fw, t), iV = jn([
      $a,
      Jx,
      mu,
      _p,
      wb,
      tM,
      kp,
      Ai("presets", "normal", [
        "normal",
        "color",
        "listpreview"
      ]),
      f3(1),
      Ep,
      nM
    ]), lV = (t) => $r("SplitButton", iV, t);
    var PD = gl({
      factory: (t, s) => {
        const a = (d, g) => {
          const p = $e(g, (C) => {
            const S = {
              type: "menubutton",
              text: C.text,
              fetch: (D) => {
                D(C.getItems());
              }
            }, _ = MD(S).mapError((D) => Kc(D)).getOrDie();
            return Q2(_, "tox-mbtn", s.backstage, A.some("menuitem"));
          });
          Oo.set(d, p);
        }, i = {
          focus: no.focusIn,
          setMenus: a
        };
        return {
          uid: t.uid,
          dom: t.dom,
          components: [],
          behaviours: Ut([
            Oo.config({}),
            Bo("menubar-events", [
              cr((d) => {
                t.onSetup(d);
              }),
              mt(Rl(), (d, g) => {
                va(d.element, ".tox-mbtn--active").each((p) => {
                  ld(g.event.target, ".tox-mbtn").each((C) => {
                    Rs(p, C) || d.getSystem().getByDom(p).each((S) => {
                      d.getSystem().getByDom(C).each((_) => {
                        xd.expand(_), xd.close(S), po.focus(_);
                      });
                    });
                  });
                });
              }),
              mt(t0(), (d, g) => {
                g.event.prevFocus.bind((p) => d.getSystem().getByDom(p).toOptional()).each((p) => {
                  g.event.newFocus.bind((C) => d.getSystem().getByDom(C).toOptional()).each((C) => {
                    xd.isOpen(p) && (xd.expand(C), xd.close(p));
                  });
                });
              })
            ]),
            no.config({
              mode: "flow",
              selector: ".tox-mbtn",
              onEscape: (d) => (t.onEscape(d), A.some(!0))
            }),
            Lr.config({})
          ]),
          apis: i,
          domModification: { attributes: { role: "menubar" } }
        };
      },
      name: "silver.Menubar",
      configFields: [
        gt("dom"),
        gt("uid"),
        gt("onEscape"),
        gt("backstage"),
        Ne("onSetup", J)
      ],
      apis: {
        focus: (t, s) => {
          t.focus(s);
        },
        setMenus: (t, s, a) => {
          t.setMenus(s, a);
        }
      }
    });
    const BD = "⚡️Upgrade", $D = "https://www.tiny.cloud/tinymce-self-hosted-premium-features/?utm_campaign=self_hosted_upgrade_promo&utm_source=tiny&utm_medium=referral", uV = (t) => ({
      uid: t.uid,
      dom: t.dom,
      components: [{
        dom: {
          tag: "a",
          attributes: {
            href: $D,
            rel: "noopener",
            target: "_blank",
            "aria-hidden": "true"
          },
          classes: ["tox-promotion-link"],
          innerHtml: BD
        }
      }]
    }), hE = "container", dV = [za("slotBehaviours", [])], a5 = (t) => "<alloy.field." + t + ">", mV = (t) => {
      const s = (() => {
        const g = [];
        return {
          slot: (C, S) => (g.push(C), zC(hE, a5(C), S)),
          record: U(g)
        };
      })(), a = t(s), i = s.record(), d = $e(i, (g) => ei({
        name: g,
        pname: a5(g)
      }));
      return GC(hE, dV, d, fV, a);
    }, fV = (t, s) => {
      const a = (me) => WC(t), i = (me, Pe) => ir(me, t, Pe), d = (me, Pe) => (xe, Ce) => ir(xe, t, Ce).map((Be) => me(Be, Ce)).getOr(Pe), g = (me) => (Pe, xe) => {
        ot(xe, (Ce) => me(Pe, Ce));
      }, p = (me, Pe) => rr(me.element, "aria-hidden") !== "true", C = (me, Pe) => {
        if (!p(me)) {
          const xe = me.element;
          Jo(xe, "display"), se(xe, "aria-hidden"), to(me, h1(), {
            name: Pe,
            visible: !0
          });
        }
      }, S = (me, Pe) => {
        if (p(me)) {
          const xe = me.element;
          _n(xe, "display", "none"), sn(xe, "aria-hidden", "true"), to(me, h1(), {
            name: Pe,
            visible: !1
          });
        }
      }, _ = d(p, !1), D = d(S), P = g(D), L = (me) => P(me, a()), V = d(C), Y = {
        getSlotNames: a,
        getSlot: i,
        isShowing: _,
        hideSlot: D,
        hideAllSlots: L,
        showSlot: V
      };
      return {
        uid: t.uid,
        dom: t.dom,
        components: s,
        behaviours: Pm(t.slotBehaviours),
        apis: Y
      };
    }, Ji = {
      ...et({
        getSlotNames: (t, s) => t.getSlotNames(s),
        getSlot: (t, s, a) => t.getSlot(s, a),
        isShowing: (t, s, a) => t.isShowing(s, a),
        hideSlot: (t, s, a) => t.hideSlot(s, a),
        hideAllSlots: (t, s) => t.hideAllSlots(s),
        showSlot: (t, s, a) => t.showSlot(s, a)
      }, (t) => xg(t)),
      sketch: mV
    }, rq = jn([
      mu,
      Jx,
      _a("onShow", J),
      _a("onHide", J),
      kp
    ]), c5 = (t) => $r("sidebar", rq, t), gV = (t) => {
      const { sidebars: s } = t.ui.registry.getAll();
      ot(Ao(s), (a) => {
        const i = s[a], d = () => aa(A.from(t.queryCommandValue("ToggleSidebar")), a);
        t.ui.registry.addToggleButton(a, {
          icon: i.icon,
          tooltip: i.tooltip,
          onAction: (g) => {
            t.execCommand("ToggleSidebar", !1, a), g.setActive(d());
          },
          onSetup: (g) => {
            g.setActive(d());
            const p = () => g.setActive(d());
            return t.on("ToggleSidebar", p), () => {
              t.off("ToggleSidebar", p);
            };
          }
        });
      });
    }, i5 = (t) => ({ element: () => t.element.dom }), hV = (t, s) => {
      const a = $e(Ao(s), (i) => {
        const d = s[i], g = Js(c5(d));
        return {
          name: i,
          getApi: i5,
          onSetup: g.onSetup,
          onShow: g.onShow,
          onHide: g.onHide
        };
      });
      return $e(a, (i) => {
        const d = w(J);
        return t.slot(i.name, {
          dom: {
            tag: "div",
            classes: ["tox-sidebar__pane"]
          },
          behaviours: k2.unnamedEvents([
            Gg(i, d),
            Jd(i, d),
            mt(h1(), (g, p) => {
              const C = p.event;
              ee(a, (_) => _.name === C.name).each((_) => {
                (C.visible ? _.onShow : _.onHide)(_.getApi(g));
              });
            })
          ])
        });
      });
    }, pV = (t) => Ji.sketch((s) => ({
      dom: {
        tag: "div",
        classes: ["tox-sidebar__pane-container"]
      },
      components: hV(s, t),
      slotBehaviours: k2.unnamedEvents([cr((a) => Ji.hideAllSlots(a))])
    })), bV = (t, s, a) => {
      ts.getCurrent(t).each((d) => {
        Oo.set(d, [pV(s)]);
        const g = a?.toLowerCase();
        Ee(g) && Lo(s, g) && ts.getCurrent(d).each((p) => {
          Ji.showSlot(p, g), gu.immediateGrow(d), Jo(d.element, "width"), pE(t.element, "region");
        });
      });
    }, pE = (t, s) => {
      sn(t, "role", s);
    }, vV = (t, s) => {
      ts.getCurrent(t).each((i) => {
        ts.getCurrent(i).each((g) => {
          gu.hasGrown(i) ? Ji.isShowing(g, s) ? (gu.shrink(i), pE(t.element, "presentation")) : (Ji.hideAllSlots(g), Ji.showSlot(g, s), pE(t.element, "region")) : (Ji.hideAllSlots(g), Ji.showSlot(g, s), gu.grow(i), pE(t.element, "region"));
        });
      });
    }, l5 = (t) => ts.getCurrent(t).bind((a) => gu.isGrowing(a) || gu.hasGrown(a) ? ts.getCurrent(a).bind((g) => ee(Ji.getSlotNames(g), (p) => Ji.isShowing(g, p))) : A.none()), FD = An("FixSizeEvent"), ID = An("AutoSizeEvent"), yV = (t) => ({
      uid: t.uid,
      dom: {
        tag: "div",
        classes: ["tox-sidebar"],
        attributes: { role: "presentation" }
      },
      components: [{
        dom: {
          tag: "div",
          classes: ["tox-sidebar__slider"]
        },
        components: [],
        behaviours: Ut([
          Lr.config({}),
          po.config({}),
          gu.config({
            dimension: { property: "width" },
            closedClass: "tox-sidebar--sliding-closed",
            openClass: "tox-sidebar--sliding-open",
            shrinkingClass: "tox-sidebar--sliding-shrinking",
            growingClass: "tox-sidebar--sliding-growing",
            onShrunk: (s) => {
              ts.getCurrent(s).each(Ji.hideAllSlots), cs(s, ID);
            },
            onGrown: (s) => {
              cs(s, ID);
            },
            onStartGrow: (s) => {
              to(s, FD, { width: Xs(s.element, "width").getOr("") });
            },
            onStartShrink: (s) => {
              to(s, FD, { width: j(s.element) + "px" });
            }
          }),
          Oo.config({}),
          ts.config({
            find: (s) => {
              const a = Oo.contents(s);
              return Xn(a);
            }
          })
        ])
      }],
      behaviours: Ut([
        ql.childAt(0),
        Bo("sidebar-sliding-events", [
          mt(FD, (s, a) => {
            _n(s.element, "width", a.event.width);
          }),
          mt(ID, (s, a) => {
            Jo(s.element, "width");
          })
        ])
      ])
    });
    var u5 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      block: (t, s, a, i) => {
        sn(t.element, "aria-busy", !0);
        const d = s.getRoot(t).getOr(t), g = Ut([
          no.config({
            mode: "special",
            onTab: () => A.some(!0),
            onShiftTab: () => A.some(!0)
          }),
          po.config({})
        ]), p = i(d, g), C = d.getSystem().build(p);
        Oo.append(d, Pl(C)), C.hasConfigured(no) && s.focus && no.focusIn(C), a.isBlocked() || s.onBlock(t), a.blockWith(() => Oo.remove(d, C));
      },
      unblock: (t, s, a) => {
        se(t.element, "aria-busy"), a.isBlocked() && s.onUnblock(t), a.clear();
      },
      isBlocked: (t, s, a) => a.isBlocked()
    }), wV = [
      _a("getRoot", A.none),
      Pa("focus", !0),
      gs("onBlock"),
      gs("onUnblock")
    ], Ku = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      init: () => {
        const t = Jk(), s = (a) => {
          t.set({ destroy: a });
        };
        return il({
          readState: t.isSet,
          blockWith: s,
          clear: t.clear,
          isBlocked: t.isSet
        });
      }
    });
    const Ym = tc({
      fields: wV,
      name: "blocking",
      apis: u5,
      state: Ku
    }), d5 = (t) => (s, a) => ({
      dom: {
        tag: "div",
        attributes: {
          "aria-label": t.translate("Loading..."),
          tabindex: "0"
        },
        classes: ["tox-throbber__busy-spinner"]
      },
      components: [{ dom: Ug('<div class="tox-spinner"><div></div><div></div><div></div></div>') }]
    }), LD = (t) => ts.getCurrent(t).each((s) => Zi(s.element, !0)), SV = (t, s) => {
      const a = "tabindex", i = `data-mce-${a}`;
      A.from(t.iframeElement).map(ve.fromDom).each((d) => {
        s ? (B(d, a).each((g) => sn(d, i, g)), sn(d, a, -1)) : (se(d, a), B(d, i).each((g) => {
          sn(d, a, g), se(d, i);
        }));
      });
    }, gw = (t, s, a, i) => {
      const d = s.element;
      if (SV(t, a), a)
        Ym.block(s, d5(i)), Jo(d, "display"), se(d, "aria-hidden"), t.hasFocus() && LD(s);
      else {
        const g = ts.getCurrent(s).exists((p) => N1(p.element));
        Ym.unblock(s), _n(d, "display", "none"), sn(d, "aria-hidden", "true"), g && t.focus();
      }
    }, xV = (t) => ({
      uid: t.uid,
      dom: {
        tag: "div",
        attributes: { "aria-hidden": "true" },
        classes: ["tox-throbber"],
        styles: { display: "none" }
      },
      behaviours: Ut([
        Oo.config({}),
        Ym.config({ focus: !1 }),
        ts.config({ find: (s) => Xn(s.components()) })
      ]),
      components: []
    }), bE = (t) => t.type === "focusin", TV = (t) => bE(t) ? (t.composed ? Xn(t.composedPath()) : A.from(t.target)).map(ve.fromDom).filter(lo).exists((a) => Ha(a, "mce-pastebin")) : !1, vE = (t, s, a) => {
      const i = w(!1), d = Go(), g = (C) => {
        i.get() && !TV(C) && (C.preventDefault(), LD(s()), t.editorManager.setActive(t));
      };
      t.inline || t.on("PreInit", () => {
        t.dom.bind(t.getWin(), "focusin", g), t.on("BeforeExecCommand", (C) => {
          C.command.toLowerCase() === "mcefocus" && C.value !== !0 && g(C);
        });
      });
      const p = (C) => {
        C !== i.get() && (i.set(C), gw(t, s(), C, a.providers), zM(t, C));
      };
      t.on("ProgressState", (C) => {
        if (d.on(clearTimeout), Pn(C.time)) {
          const S = bb.setEditorTimeout(t, () => p(C.state), C.time);
          d.set(S);
        } else
          p(C.state), d.clear();
      });
    }, EV = (t, s) => lt(t, (d, g) => s(g, d.len).fold(U(d), (C) => ({
      len: C.finish,
      list: d.list.concat([C])
    })), {
      len: 0,
      list: []
    }).list, HD = (t, s, a) => ({
      within: t,
      extra: s,
      withinWidth: a
    }), Yu = (t, s, a) => {
      const i = EV(t, (C, S) => {
        const _ = a(C);
        return A.some({
          element: C,
          start: S,
          finish: S + _,
          width: _
        });
      }), d = fo(i, (C) => C.finish <= s), g = at(d, (C, S) => C + S.width, 0), p = i.slice(d.length);
      return {
        within: d,
        extra: p,
        withinWidth: g
      };
    }, yE = (t) => $e(t, (s) => s.element), CE = (t, s, a) => {
      const i = yE(t.concat(s));
      return HD(i, [], a);
    }, m5 = (t, s, a, i) => {
      const d = yE(t).concat([a]);
      return HD(d, yE(s), i);
    }, f5 = (t, s, a) => HD(yE(t), [], a), kV = (t, s, a) => {
      const i = Yu(s, t, a);
      return i.extra.length === 0 ? A.some(i) : A.none();
    }, g5 = (t, s, a, i) => {
      const d = kV(t, s, a).getOrThunk(() => Yu(s, t - a(i), a)), g = d.within, p = d.extra, C = d.withinWidth;
      return p.length === 1 && p[0].width <= a(i) ? CE(g, p, C) : p.length >= 1 ? m5(g, p, i, C) : f5(g, p, C);
    }, h5 = (t, s) => {
      const a = $e(s, (i) => Pl(i));
      Km.setGroups(t, a);
    }, _V = (t) => No(t, (s) => Iu(s.element).bind((a) => s.getSystem().getByDom(a).toOptional())), p5 = (t, s, a) => {
      const i = s.builtGroups.get();
      if (i.length === 0)
        return;
      const d = $m(t, s, "primary"), g = Ca.getCoupled(t, "overflowGroup");
      _n(d.element, "visibility", "hidden");
      const p = i.concat([g]), C = _V(p);
      a([]), h5(d, p);
      const S = j(d.element), _ = g5(S, s.builtGroups.get(), (D) => j(D.element), g);
      _.extra.length === 0 ? (Oo.remove(d, g), a([])) : (h5(d, _.within), a(_.extra)), Jo(d.element, "visibility"), Ga(d.element), C.each(po.focus);
    }, b5 = U([
      za("splitToolbarBehaviours", [Ca]),
      oa("builtGroups", () => w([]))
    ]), AV = U([
      xf(["overflowToggledClass"]),
      bm("getOverflowBounds"),
      gt("lazySink"),
      oa("overflowGroups", () => w([])),
      gs("onOpened"),
      gs("onClosed")
    ].concat(b5())), OV = U([
      ei({
        factory: Km,
        schema: Zv(),
        name: "primary"
      }),
      zu({
        schema: Zv(),
        name: "overflow"
      }),
      zu({ name: "overflow-button" }),
      zu({ name: "overflow-group" })
    ]), zD = U((t, s) => {
      Le(t, Math.floor(s));
    }), v5 = U([
      xf(["toggledClass"]),
      gt("lazySink"),
      ou("fetch"),
      bm("getBounds"),
      ui("fireDismissalEventInstead", [Ne("event", bf())]),
      kf(),
      gs("onToggled")
    ]), y5 = U([
      zu({
        name: "button",
        overrides: (t) => ({
          dom: { attributes: { "aria-haspopup": "true" } },
          buttonBehaviours: Ut([Vo.config({
            toggleClass: t.markers.toggledClass,
            aria: { mode: "expanded" },
            toggleOnExecute: !1,
            onToggled: t.onToggled
          })])
        })
      }),
      zu({
        factory: Km,
        schema: Zv(),
        name: "toolbar",
        overrides: (t) => ({
          toolbarBehaviours: Ut([no.config({
            mode: "cyclic",
            onEscape: (s) => (ir(s, t, "button").each(po.focus), A.none())
          })])
        })
      })
    ]), hw = Go(), DV = (t, s) => {
      hw.set(!0), VD(t, s), hw.clear();
    }, VD = (t, s) => {
      const a = Ca.getCoupled(t, "toolbarSandbox");
      is.isOpen(a) ? is.close(a) : is.open(a, s.toolbar());
    }, wE = (t, s, a, i) => {
      const d = a.getBounds.map((p) => p()), g = a.lazySink(t).getOrDie();
      Qc.positionWithinBounds(g, s, {
        anchor: {
          type: "hotspot",
          hotspot: t,
          layouts: i,
          overrides: { maxWidthFunction: zD() }
        }
      }, d);
    }, UD = (t, s, a, i, d) => {
      Km.setGroups(s, d), wE(t, s, a, i), Vo.on(t);
    }, C5 = (t, s, a) => {
      const i = kg(), d = (p, C) => {
        const S = hw.get().getOr(!1);
        a.fetch().get((_) => {
          UD(t, C, a, s.layouts, _), i.link(t.element), S || no.focusIn(C);
        });
      }, g = () => {
        Vo.off(t), hw.get().getOr(!1) || po.focus(t), i.unlink(t.element);
      };
      return {
        dom: {
          tag: "div",
          attributes: { id: i.id }
        },
        behaviours: Ut([
          no.config({
            mode: "special",
            onEscape: (p) => (is.close(p), A.some(!0))
          }),
          is.config({
            onOpen: d,
            onClose: g,
            isPartOf: (p, C, S) => km(C, S) || km(t, S),
            getAttachPoint: () => a.lazySink(t).getOrDie()
          }),
          Wi.config({
            channels: {
              ...K1({
                isExtraPart: Te,
                ...a.fireDismissalEventInstead.map((p) => ({ fireEventInstead: { event: p.event } })).getOr({})
              }),
              ...ap({
                doReposition: () => {
                  is.getState(Ca.getCoupled(t, "toolbarSandbox")).each((p) => {
                    wE(t, p, a, s.layouts);
                  });
                }
              })
            }
          })
        ])
      };
    }, Vp = ti({
      name: "FloatingToolbarButton",
      factory: (t, s, a, i) => ({
        ...Ec.sketch({
          ...i.button(),
          action: (d) => {
            VD(d, i);
          },
          buttonBehaviours: lu.augment({ dump: i.button().buttonBehaviours }, [Ca.config({
            others: {
              toolbarSandbox: (d) => C5(d, a, t)
            }
          })])
        }),
        apis: {
          setGroups: (d, g) => {
            is.getState(Ca.getCoupled(d, "toolbarSandbox")).each((p) => {
              UD(d, p, t, a.layouts, g);
            });
          },
          reposition: (d) => {
            is.getState(Ca.getCoupled(d, "toolbarSandbox")).each((g) => {
              wE(d, g, t, a.layouts);
            });
          },
          toggle: (d) => {
            VD(d, i);
          },
          toggleWithoutFocusing: (d) => {
            DV(d, i);
          },
          getToolbar: (d) => is.getState(Ca.getCoupled(d, "toolbarSandbox")),
          isOpen: (d) => is.isOpen(Ca.getCoupled(d, "toolbarSandbox"))
        }
      }),
      configFields: v5(),
      partFields: y5(),
      apis: {
        setGroups: (t, s, a) => {
          t.setGroups(s, a);
        },
        reposition: (t, s) => {
          t.reposition(s);
        },
        toggle: (t, s) => {
          t.toggle(s);
        },
        toggleWithoutFocusing: (t, s) => {
          t.toggleWithoutFocusing(s);
        },
        getToolbar: (t, s) => t.getToolbar(s),
        isOpen: (t, s) => t.isOpen(s)
      }
    }), RV = U([
      gt("items"),
      xf(["itemSelector"]),
      za("tgroupBehaviours", [no])
    ]), w5 = U([sb({
      name: "items",
      unit: "item"
    })]), NV = (t, s, a, i) => ({
      uid: t.uid,
      dom: t.dom,
      components: s,
      behaviours: Oa(t.tgroupBehaviours, [no.config({
        mode: "flow",
        selector: t.markers.itemSelector
      })]),
      domModification: { attributes: { role: "toolbar" } }
    }), SE = ti({
      name: "ToolbarGroup",
      configFields: RV(),
      partFields: w5(),
      factory: NV
    }), S5 = (t) => $e(t, (s) => Pl(s)), x5 = (t, s, a) => {
      p5(t, a, (i) => {
        a.overflowGroups.set(i), s.getOpt(t).each((d) => {
          Vp.setGroups(d, S5(i));
        });
      });
    }, MV = (t, s, a, i) => {
      const d = js(Vp.sketch({
        fetch: () => vi.nu((g) => {
          g(S5(t.overflowGroups.get()));
        }),
        layouts: {
          onLtr: () => [
            Lc,
            Qa
          ],
          onRtl: () => [
            Qa,
            Lc
          ],
          onBottomLtr: () => [
            Jc,
            Di
          ],
          onBottomRtl: () => [
            Di,
            Jc
          ]
        },
        getBounds: a.getOverflowBounds,
        lazySink: t.lazySink,
        fireDismissalEventInstead: {},
        markers: { toggledClass: t.markers.overflowToggledClass },
        parts: {
          button: i["overflow-button"](),
          toolbar: i.overflow()
        },
        onToggled: (g, p) => t[p ? "onOpened" : "onClosed"](g)
      }));
      return {
        uid: t.uid,
        dom: t.dom,
        components: s,
        behaviours: Oa(t.splitToolbarBehaviours, [Ca.config({
          others: {
            overflowGroup: () => SE.sketch({
              ...i["overflow-group"](),
              items: [d.asSpec()]
            })
          }
        })]),
        apis: {
          setGroups: (g, p) => {
            t.builtGroups.set($e(p, g.getSystem().build)), x5(g, d, t);
          },
          refresh: (g) => x5(g, d, t),
          toggle: (g) => {
            d.getOpt(g).each((p) => {
              Vp.toggle(p);
            });
          },
          toggleWithoutFocusing: (g) => {
            d.getOpt(g).each(Vp.toggleWithoutFocusing);
          },
          isOpen: (g) => d.getOpt(g).map(Vp.isOpen).getOr(!1),
          reposition: (g) => {
            d.getOpt(g).each((p) => {
              Vp.reposition(p);
            });
          },
          getOverflow: (g) => d.getOpt(g).bind(Vp.getToolbar)
        },
        domModification: { attributes: { role: "group" } }
      };
    }, T5 = ti({
      name: "SplitFloatingToolbar",
      configFields: AV(),
      partFields: OV(),
      factory: MV,
      apis: {
        setGroups: (t, s, a) => {
          t.setGroups(s, a);
        },
        refresh: (t, s) => {
          t.refresh(s);
        },
        reposition: (t, s) => {
          t.reposition(s);
        },
        toggle: (t, s) => {
          t.toggle(s);
        },
        toggleWithoutFocusing: (t, s) => {
          t.toggle(s);
        },
        isOpen: (t, s) => t.isOpen(s),
        getOverflow: (t, s) => t.getOverflow(s)
      }
    }), PV = U([
      xf([
        "closedClass",
        "openClass",
        "shrinkingClass",
        "growingClass",
        "overflowToggledClass"
      ]),
      gs("onOpened"),
      gs("onClosed")
    ].concat(b5())), BV = U([
      ei({
        factory: Km,
        schema: Zv(),
        name: "primary"
      }),
      ei({
        factory: Km,
        schema: Zv(),
        name: "overflow",
        overrides: (t) => ({
          toolbarBehaviours: Ut([
            gu.config({
              dimension: { property: "height" },
              closedClass: t.markers.closedClass,
              openClass: t.markers.openClass,
              shrinkingClass: t.markers.shrinkingClass,
              growingClass: t.markers.growingClass,
              onShrunk: (s) => {
                ir(s, t, "overflow-button").each((a) => {
                  Vo.off(a), po.focus(a);
                }), t.onClosed(s);
              },
              onGrown: (s) => {
                no.focusIn(s), t.onOpened(s);
              },
              onStartGrow: (s) => {
                ir(s, t, "overflow-button").each(Vo.on);
              }
            }),
            no.config({
              mode: "acyclic",
              onEscape: (s) => (ir(s, t, "overflow-button").each(po.focus), A.some(!0))
            })
          ])
        })
      }),
      zu({
        name: "overflow-button",
        overrides: (t) => ({
          buttonBehaviours: Ut([Vo.config({
            toggleClass: t.markers.overflowToggledClass,
            aria: { mode: "pressed" },
            toggleOnExecute: !1
          })])
        })
      }),
      zu({ name: "overflow-group" })
    ]), $V = (t, s) => ir(t, s, "overflow").map(gu.hasGrown).getOr(!1), E5 = (t, s) => {
      ir(t, s, "overflow-button").bind(() => ir(t, s, "overflow")).each((a) => {
        xE(t, s), gu.toggleGrow(a);
      });
    }, xE = (t, s) => {
      ir(t, s, "overflow").each((a) => {
        p5(t, s, (i) => {
          const d = $e(i, (g) => Pl(g));
          Km.setGroups(a, d);
        }), ir(t, s, "overflow-button").each((i) => {
          gu.hasGrown(a) && Vo.on(i);
        }), gu.refresh(a);
      });
    }, FV = (t, s, a, i) => {
      const d = "alloy.toolbar.toggle", g = (p, C) => {
        const S = $e(C, p.getSystem().build);
        t.builtGroups.set(S);
      };
      return {
        uid: t.uid,
        dom: t.dom,
        components: s,
        behaviours: Oa(t.splitToolbarBehaviours, [
          Ca.config({
            others: {
              overflowGroup: (p) => SE.sketch({
                ...i["overflow-group"](),
                items: [Ec.sketch({
                  ...i["overflow-button"](),
                  action: (C) => {
                    cs(p, d);
                  }
                })]
              })
            }
          }),
          Bo("toolbar-toggle-events", [mt(d, (p) => {
            E5(p, t);
          })])
        ]),
        apis: {
          setGroups: (p, C) => {
            g(p, C), xE(p, t);
          },
          refresh: (p) => xE(p, t),
          toggle: (p) => E5(p, t),
          isOpen: (p) => $V(p, t)
        },
        domModification: { attributes: { role: "group" } }
      };
    }, WD = ti({
      name: "SplitSlidingToolbar",
      configFields: PV(),
      partFields: BV(),
      factory: FV,
      apis: {
        setGroups: (t, s, a) => {
          t.setGroups(s, a);
        },
        refresh: (t, s) => {
          t.refresh(s);
        },
        toggle: (t, s) => {
          t.toggle(s);
        },
        isOpen: (t, s) => t.isOpen(s)
      }
    }), TE = (t) => {
      const s = t.title.fold(() => ({}), (a) => ({ attributes: { title: a } }));
      return {
        dom: {
          tag: "div",
          classes: ["tox-toolbar__group"],
          ...s
        },
        components: [SE.parts.items({})],
        items: t.items,
        markers: { itemSelector: "*:not(.tox-split-button) > .tox-tbtn:not([disabled]), .tox-split-button:not([disabled]), .tox-toolbar-nav-js:not([disabled]), .tox-number-input:not([disabled])" },
        tgroupBehaviours: Ut([
          Lr.config({}),
          po.config({})
        ])
      };
    }, EE = (t) => SE.sketch(TE(t)), pw = (t, s) => {
      const a = cr((i) => {
        const d = $e(t.initGroups, EE);
        Km.setGroups(i, d);
      });
      return Ut([
        Zu.toolbarButton(t.providers.isDisabled),
        fc(),
        no.config({
          mode: s,
          onEscape: t.onEscape,
          selector: ".tox-toolbar__group"
        }),
        Bo("toolbar-events", [a])
      ]);
    }, k5 = (t) => {
      const s = t.cyclicKeying ? "cyclic" : "acyclic";
      return {
        uid: t.uid,
        dom: {
          tag: "div",
          classes: ["tox-toolbar-overlord"]
        },
        parts: {
          "overflow-group": TE({
            title: A.none(),
            items: []
          }),
          "overflow-button": F9({
            icon: A.some("more-drawer"),
            enabled: !0,
            tooltip: A.some("Reveal or hide additional toolbar items")
          }, A.none(), t.providers)
        },
        splitToolbarBehaviours: pw(t, s)
      };
    }, _5 = (t) => {
      const s = k5(t), a = 4, i = T5.parts.primary({
        dom: {
          tag: "div",
          classes: ["tox-toolbar__primary"]
        }
      });
      return T5.sketch({
        ...s,
        lazySink: t.getSink,
        getOverflowBounds: () => {
          const d = t.moreDrawerData.lazyHeader().element, g = ci(d), p = yc(d), C = ci(p), S = Math.max(p.dom.scrollHeight, C.height);
          return Rr(g.x + a, C.y, g.width - a * 2, S);
        },
        parts: {
          ...s.parts,
          overflow: {
            dom: {
              tag: "div",
              classes: ["tox-toolbar__overflow"],
              attributes: t.attributes
            }
          }
        },
        components: [i],
        markers: { overflowToggledClass: "tox-tbtn--enabled" },
        onOpened: (d) => t.onToggled(d, !0),
        onClosed: (d) => t.onToggled(d, !1)
      });
    }, IV = (t) => {
      const s = WD.parts.primary({
        dom: {
          tag: "div",
          classes: ["tox-toolbar__primary"]
        }
      }), a = WD.parts.overflow({
        dom: {
          tag: "div",
          classes: ["tox-toolbar__overflow"]
        }
      }), i = k5(t);
      return WD.sketch({
        ...i,
        components: [
          s,
          a
        ],
        markers: {
          openClass: "tox-toolbar__overflow--open",
          closedClass: "tox-toolbar__overflow--closed",
          growingClass: "tox-toolbar__overflow--growing",
          shrinkingClass: "tox-toolbar__overflow--shrinking",
          overflowToggledClass: "tox-tbtn--enabled"
        },
        onOpened: (d) => {
          d.getSystem().broadcastOn([zp()], { type: "opened" }), t.onToggled(d, !0);
        },
        onClosed: (d) => {
          d.getSystem().broadcastOn([zp()], { type: "closed" }), t.onToggled(d, !1);
        }
      });
    }, kE = (t) => {
      const s = t.cyclicKeying ? "cyclic" : "acyclic";
      return Km.sketch({
        uid: t.uid,
        dom: {
          tag: "div",
          classes: ["tox-toolbar"].concat(t.type === yd.scrolling ? ["tox-toolbar--scrolling"] : [])
        },
        components: [Km.parts.groups({})],
        toolbarBehaviours: pw(t, s)
      });
    }, LV = [
      _p,
      mu,
      mc("tooltip"),
      Ai("buttonType", "secondary", [
        "primary",
        "secondary"
      ]),
      Pa("borderless", !1),
      ou("onAction")
    ], HV = [
      ...LV,
      Vf,
      Al("type", ["button"])
    ], zV = [
      ...LV,
      Pa("active", !1),
      Al("type", ["togglebutton"])
    ], _E = {
      button: HV,
      togglebutton: zV
    }, VV = [
      Al("type", ["group"]),
      di("buttons", [], es("type", _E))
    ], AE = es("type", {
      ..._E,
      group: VV
    }), A5 = jn([
      di("buttons", [], AE),
      ou("onShow"),
      ou("onHide")
    ]), O5 = (t) => $r("view", A5, t), ZD = (t, s) => {
      var a, i;
      const d = t.type === "togglebutton", g = t.icon.map((Be) => Fp(Be, s.icons)).map(js), C = (Be) => {
        const St = (Vt) => {
          g.map((Xt) => Xt.getOpt(Be).each(($o) => {
            Oo.set($o, [Fp(Vt, s.icons)]);
          }));
        }, ct = (Vt) => {
          const Xt = Be.element;
          Vt ? (ba(Xt, "tox-button--enabled"), sn(Xt, "aria-pressed", !0)) : (Wr(Xt, "tox-button--enabled"), se(Xt, "aria-pressed"));
        }, tt = () => Ha(Be.element, "tox-button--enabled");
        if (d)
          return t.onAction({
            setIcon: St,
            setActive: ct,
            isActive: tt
          });
        if (t.type === "button")
          return t.onAction({ setIcon: St });
      }, S = {
        ...t,
        name: d ? t.text.getOr(t.icon.getOr("")) : (a = t.text) !== null && a !== void 0 ? a : t.icon.getOr(""),
        primary: t.buttonType === "primary",
        buttonType: A.from(t.buttonType),
        tooltip: t.tooltip,
        icon: t.icon,
        enabled: !0,
        borderless: t.borderless
      }, _ = sD((i = t.buttonType) !== null && i !== void 0 ? i : "secondary"), D = d ? t.text.map(s.translate) : A.some(s.translate(t.text)), P = D.map(da), L = S.tooltip.or(D).map((Be) => ({
        "aria-label": s.translate(Be),
        title: s.translate(Be)
      })).getOr({}), V = g.map((Be) => Be.asSpec()), Y = Tb([
        V,
        P
      ]), me = t.icon.isSome() && P.isSome(), Pe = {
        tag: "button",
        classes: _.concat(...t.icon.isSome() && !me ? ["tox-button--icon"] : []).concat(...me ? ["tox-button--icon-and-text"] : []).concat(...t.borderless ? ["tox-button--naked"] : []).concat(...t.type === "togglebutton" && t.active ? ["tox-button--enabled"] : []),
        attributes: L
      }, xe = [], Ce = nE(S, A.some(C), xe, Pe, Y, s);
      return Ec.sketch(Ce);
    }, D5 = (t, s) => ZD(t, s), R5 = (t, s) => ({
      dom: {
        tag: "div",
        classes: ["tox-view__toolbar__group"]
      },
      components: $e(t.buttons, (a) => D5(a, s))
    }), Bb = xl().deviceType, N5 = Bb.isPhone(), UV = Bb.isTablet(), WV = (t) => {
      let s = !1;
      const a = $e(t.buttons, (i) => i.type === "group" ? (s = !0, R5(i, t.providers)) : D5(i, t.providers));
      return {
        uid: t.uid,
        dom: {
          tag: "div",
          classes: [
            s ? "tox-view__toolbar" : "tox-view__header",
            ...N5 || UV ? [
              "tox-view--mobile",
              "tox-view--scrolling"
            ] : []
          ]
        },
        behaviours: Ut([
          po.config({}),
          no.config({
            mode: "flow",
            selector: "button, .tox-button",
            focusInside: h.OnEnterOrSpaceMode
          })
        ]),
        components: s ? a : [
          Zm.sketch({
            dom: {
              tag: "div",
              classes: ["tox-view__header-start"]
            },
            components: []
          }),
          Zm.sketch({
            dom: {
              tag: "div",
              classes: ["tox-view__header-end"]
            },
            components: a
          })
        ]
      };
    }, ZV = (t) => ({
      uid: t.uid,
      dom: {
        tag: "div",
        classes: ["tox-view__pane"]
      }
    }), jD = (t, s, a, i) => {
      const d = {
        getPane: (g) => pc.getPart(g, t, "pane"),
        getOnShow: (g) => t.viewConfig.onShow,
        getOnHide: (g) => t.viewConfig.onHide
      };
      return {
        uid: t.uid,
        dom: t.dom,
        components: s,
        apis: d
      };
    };
    var Gv = ti({
      name: "silver.View",
      configFields: [gt("viewConfig")],
      partFields: [
        qi({
          factory: { sketch: WV },
          schema: [
            gt("buttons"),
            gt("providers")
          ],
          name: "header"
        }),
        qi({
          factory: { sketch: ZV },
          schema: [],
          name: "pane"
        })
      ],
      factory: jD,
      apis: {
        getPane: (t, s) => t.getPane(s),
        getOnShow: (t, s) => t.getOnShow(s),
        getOnHide: (t, s) => t.getOnHide(s)
      }
    });
    const jV = (t, s, a) => Yr(s, (i, d) => {
      const g = Js(O5(i));
      return t.slot(d, Gv.sketch({
        dom: {
          tag: "div",
          classes: ["tox-view"]
        },
        viewConfig: g,
        components: [
          ...g.buttons.length > 0 ? [Gv.parts.header({
            buttons: g.buttons,
            providers: a
          })] : [],
          Gv.parts.pane({})
        ]
      }));
    }), M5 = (t, s) => Ji.sketch((a) => ({
      dom: {
        tag: "div",
        classes: ["tox-view-wrap__slot-container"]
      },
      components: jV(a, t, s),
      slotBehaviours: k2.unnamedEvents([cr((i) => Ji.hideAllSlots(i))])
    })), qD = (t) => ee(Ji.getSlotNames(t), (s) => Ji.isShowing(t, s)), OE = (t) => {
      const s = t.element;
      _n(s, "display", "none"), sn(s, "aria-hidden", "true");
    }, GD = (t) => {
      const s = t.element;
      Jo(s, "display"), se(s, "aria-hidden");
    }, qV = (t) => ({ getContainer: U(t) }), P5 = (t, s, a) => {
      Ji.getSlot(t, s).each((i) => {
        Gv.getPane(i).each((d) => {
          a(i)(qV(d.element.dom));
        });
      });
    }, B5 = (t, s) => P5(t, s, Gv.getOnShow), GV = (t, s) => P5(t, s, Gv.getOnHide);
    var DE = gl({
      factory: (t, s) => {
        const g = {
          setViews: (p, C) => {
            Oo.set(p, [M5(C, s.backstage.shared.providers)]);
          },
          whichView: (p) => ts.getCurrent(p).bind(qD),
          toggleView: (p, C, S, _) => ts.getCurrent(p).exists((D) => {
            const P = qD(D), L = P.exists((Y) => _ === Y), V = Ji.getSlot(D, _).isSome();
            return V && (Ji.hideAllSlots(D), L ? (OE(p), C()) : (S(), GD(p), Ji.showSlot(D, _), B5(D, _)), P.each((Y) => GV(D, Y))), V;
          })
        };
        return {
          uid: t.uid,
          dom: {
            tag: "div",
            classes: ["tox-view-wrap"],
            attributes: { "aria-hidden": "true" },
            styles: { display: "none" }
          },
          components: [],
          behaviours: Ut([
            Oo.config({}),
            ts.config({
              find: (p) => {
                const C = Oo.contents(p);
                return Xn(C);
              }
            })
          ]),
          apis: g
        };
      },
      name: "silver.ViewWrapper",
      configFields: [gt("backstage")],
      apis: {
        setViews: (t, s, a) => t.setViews(s, a),
        toggleView: (t, s, a, i, d) => t.toggleView(s, a, i, d),
        whichView: (t, s) => t.whichView(s)
      }
    });
    const $5 = (t, s, a) => {
      let i = !1;
      const d = {
        getSocket: (g) => pc.getPart(g, t, "socket"),
        setSidebar: (g, p, C) => {
          pc.getPart(g, t, "sidebar").each((S) => bV(S, p, C));
        },
        toggleSidebar: (g, p) => {
          pc.getPart(g, t, "sidebar").each((C) => vV(C, p));
        },
        whichSidebar: (g) => pc.getPart(g, t, "sidebar").bind(l5).getOrNull(),
        getHeader: (g) => pc.getPart(g, t, "header"),
        getToolbar: (g) => pc.getPart(g, t, "toolbar"),
        setToolbar: (g, p) => {
          pc.getPart(g, t, "toolbar").each((C) => {
            const S = $e(p, EE);
            C.getApis().setGroups(C, S);
          });
        },
        setToolbars: (g, p) => {
          pc.getPart(g, t, "multiple-toolbar").each((C) => {
            const S = $e(p, (_) => $e(_, EE));
            lE.setItems(C, S);
          });
        },
        refreshToolbar: (g) => {
          pc.getPart(g, t, "toolbar").each((C) => C.getApis().refresh(C));
        },
        toggleToolbarDrawer: (g) => {
          pc.getPart(g, t, "toolbar").each((p) => {
            Ts(p.getApis().toggle, (C) => C(p));
          });
        },
        toggleToolbarDrawerWithoutFocusing: (g) => {
          pc.getPart(g, t, "toolbar").each((p) => {
            Ts(p.getApis().toggleWithoutFocusing, (C) => C(p));
          });
        },
        isToolbarDrawerToggled: (g) => pc.getPart(g, t, "toolbar").bind((p) => A.from(p.getApis().isOpen).map((C) => C(p))).getOr(!1),
        getThrobber: (g) => pc.getPart(g, t, "throbber"),
        focusToolbar: (g) => {
          pc.getPart(g, t, "toolbar").orThunk(() => pc.getPart(g, t, "multiple-toolbar")).each((C) => {
            no.focusIn(C);
          });
        },
        setMenubar: (g, p) => {
          pc.getPart(g, t, "menubar").each((C) => {
            PD.setMenus(C, p);
          });
        },
        focusMenubar: (g) => {
          pc.getPart(g, t, "menubar").each((p) => {
            PD.focus(p);
          });
        },
        setViews: (g, p) => {
          pc.getPart(g, t, "viewWrapper").each((C) => {
            DE.setViews(C, p);
          });
        },
        toggleView: (g, p) => pc.getPart(g, t, "viewWrapper").exists((C) => DE.toggleView(C, () => d.showMainView(g), () => d.hideMainView(g), p)),
        whichView: (g) => pc.getPart(g, t, "viewWrapper").bind(DE.whichView).getOrNull(),
        hideMainView: (g) => {
          i = d.isToolbarDrawerToggled(g), i && d.toggleToolbarDrawer(g), pc.getPart(g, t, "editorContainer").each((p) => {
            const C = p.element;
            _n(C, "display", "none"), sn(C, "aria-hidden", "true");
          });
        },
        showMainView: (g) => {
          i && d.toggleToolbarDrawer(g), pc.getPart(g, t, "editorContainer").each((p) => {
            const C = p.element;
            Jo(C, "display"), se(C, "aria-hidden");
          });
        }
      };
      return {
        uid: t.uid,
        dom: t.dom,
        components: s,
        apis: d,
        behaviours: t.behaviours
      };
    }, KV = Kf.optional({
      factory: PD,
      name: "menubar",
      schema: [gt("backstage")]
    }), YV = (t) => t.type === yd.sliding ? IV : t.type === yd.floating ? _5 : kE, KD = Kf.optional({
      factory: {
        sketch: (t) => lE.sketch({
          uid: t.uid,
          dom: t.dom,
          listBehaviours: Ut([no.config({
            mode: "acyclic",
            selector: ".tox-toolbar"
          })]),
          makeItem: () => kE({
            type: t.type,
            uid: An("multiple-toolbar-item"),
            cyclicKeying: !1,
            initGroups: [],
            providers: t.providers,
            onEscape: () => (t.onEscape(), A.some(!0))
          }),
          setupItem: (s, a, i, d) => {
            Km.setGroups(a, i);
          },
          shell: !0
        })
      },
      name: "multiple-toolbar",
      schema: [
        gt("dom"),
        gt("onEscape")
      ]
    }), XV = Kf.optional({
      factory: {
        sketch: (t) => {
          const s = YV(t), a = {
            type: t.type,
            uid: t.uid,
            onEscape: () => (t.onEscape(), A.some(!0)),
            onToggled: (i, d) => t.onToolbarToggled(d),
            cyclicKeying: !1,
            initGroups: [],
            getSink: t.getSink,
            providers: t.providers,
            moreDrawerData: {
              lazyToolbar: t.lazyToolbar,
              lazyMoreButton: t.lazyMoreButton,
              lazyHeader: t.lazyHeader
            },
            attributes: t.attributes
          };
          return s(a);
        }
      },
      name: "toolbar",
      schema: [
        gt("dom"),
        gt("onEscape"),
        gt("getSink")
      ]
    }), JV = Kf.optional({
      factory: { sketch: r5 },
      name: "header",
      schema: [gt("dom")]
    }), F5 = Kf.optional({
      factory: { sketch: uV },
      name: "promotion",
      schema: [gt("dom")]
    }), QV = Kf.optional({
      name: "socket",
      schema: [gt("dom")]
    }), I5 = Kf.optional({
      factory: { sketch: yV },
      name: "sidebar",
      schema: [gt("dom")]
    }), eU = Kf.optional({
      factory: { sketch: xV },
      name: "throbber",
      schema: [gt("dom")]
    }), L5 = Kf.optional({
      factory: DE,
      name: "viewWrapper",
      schema: [gt("backstage")]
    }), tU = (t) => ({
      uid: t.uid,
      dom: {
        tag: "div",
        classes: ["tox-editor-container"]
      },
      components: t.components
    }), nU = Kf.optional({
      factory: { sketch: tU },
      name: "editorContainer",
      schema: []
    });
    var Tr = ti({
      name: "OuterContainer",
      factory: $5,
      configFields: [
        gt("dom"),
        gt("behaviours")
      ],
      partFields: [
        JV,
        KV,
        XV,
        KD,
        QV,
        I5,
        F5,
        eU,
        L5,
        nU
      ],
      apis: {
        getSocket: (t, s) => t.getSocket(s),
        setSidebar: (t, s, a, i) => {
          t.setSidebar(s, a, i);
        },
        toggleSidebar: (t, s, a) => {
          t.toggleSidebar(s, a);
        },
        whichSidebar: (t, s) => t.whichSidebar(s),
        getHeader: (t, s) => t.getHeader(s),
        getToolbar: (t, s) => t.getToolbar(s),
        setToolbar: (t, s, a) => {
          t.setToolbar(s, a);
        },
        setToolbars: (t, s, a) => {
          t.setToolbars(s, a);
        },
        refreshToolbar: (t, s) => t.refreshToolbar(s),
        toggleToolbarDrawer: (t, s) => {
          t.toggleToolbarDrawer(s);
        },
        toggleToolbarDrawerWithoutFocusing: (t, s) => {
          t.toggleToolbarDrawerWithoutFocusing(s);
        },
        isToolbarDrawerToggled: (t, s) => t.isToolbarDrawerToggled(s),
        getThrobber: (t, s) => t.getThrobber(s),
        setMenubar: (t, s, a) => {
          t.setMenubar(s, a);
        },
        focusMenubar: (t, s) => {
          t.focusMenubar(s);
        },
        focusToolbar: (t, s) => {
          t.focusToolbar(s);
        },
        setViews: (t, s, a) => {
          t.setViews(s, a);
        },
        toggleView: (t, s, a) => t.toggleView(s, a),
        whichView: (t, s) => t.whichView(s)
      }
    });
    const H5 = "file edit view insert format tools table help", z5 = {
      file: {
        title: "File",
        items: "newdocument restoredraft | preview | export print | deleteallconversations"
      },
      edit: {
        title: "Edit",
        items: "undo redo | cut copy paste pastetext | selectall | searchreplace"
      },
      view: {
        title: "View",
        items: "code | visualaid visualchars visualblocks | spellchecker | preview fullscreen | showcomments"
      },
      insert: {
        title: "Insert",
        items: "image link media addcomment pageembed template inserttemplate codesample inserttable accordion | charmap emoticons hr | pagebreak nonbreaking anchor tableofcontents footnotes | mergetags | insertdatetime"
      },
      format: {
        title: "Format",
        items: "bold italic underline strikethrough superscript subscript codeformat | styles blocks fontfamily fontsize align lineheight | forecolor backcolor | language | removeformat"
      },
      tools: {
        title: "Tools",
        items: "aidialog aishortcuts | spellchecker spellcheckerlanguage | autocorrect capitalization | a11ycheck code typography wordcount addtemplate"
      },
      table: {
        title: "Table",
        items: "inserttable | cell row column | advtablesort | tableprops deletetable"
      },
      help: {
        title: "Help",
        items: "help"
      }
    }, oU = (t, s, a) => {
      const i = Sp(a).split(/[ ,]/);
      return {
        text: t.title,
        getItems: () => ae(t.items, (d) => {
          const g = d.toLowerCase();
          return g.trim().length === 0 ? [] : jo(i, (p) => p === g) ? [] : g === "separator" || g === "|" ? [{ type: "separator" }] : s.menuItems[g] ? [s.menuItems[g]] : [];
        })
      };
    }, YD = (t) => t.split(" "), RE = (t, s) => {
      const a = {
        ...z5,
        ...s.menus
      }, i = Ao(s.menus).length > 0, d = s.menubar === void 0 || s.menubar === !0 ? YD(H5) : YD(s.menubar === !1 ? "" : s.menubar), g = fo(d, (C) => {
        const S = Lo(z5, C);
        return i ? S || Dt(s.menus, C).exists((_) => Lo(_, "items")) : S;
      }), p = $e(g, (C) => {
        const S = a[C];
        return oU({
          title: S.title,
          items: YD(S.items)
        }, s, t);
      });
      return fo(p, (C) => {
        const S = (_) => Ee(_) || _.type !== "separator";
        return C.getItems().length > 0 && jo(C.getItems(), S);
      });
    }, XD = (t) => {
      const s = () => {
        t._skinLoaded = !0, u8(t);
      };
      return () => {
        t.initialized ? s() : t.on("init", s);
      };
    }, sU = (t, s) => () => N3(t, { message: s }), V5 = (t, s, a) => (t.on("remove", () => a.unload(s)), a.load(s)), JD = (t, s, a, i) => (t.on("remove", () => i.unloadRawCss(s)), i.loadRawCss(s, a)), rU = async (t, s) => {
      const i = "ui/" + zx(t).getOr("default") + "/skin.css", d = tinymce.Resource.get(i);
      if (Ee(d))
        return Promise.resolve(JD(t, i, d, t.ui.styleSheetLoader));
      {
        const g = s + "/skin.min.css";
        return V5(t, g, t.ui.styleSheetLoader);
      }
    }, aU = async (t, s) => {
      if (eo(ve.fromDom(t.getElement()))) {
        const d = "ui/" + zx(t).getOr("default") + "/skin.shadowdom.css", g = tinymce.Resource.get(d);
        if (Ee(g))
          return JD(t, d, g, vv.DOM.styleSheetLoader), Promise.resolve();
        {
          const p = s + "/skin.shadowdom.min.css";
          return V5(t, p, vv.DOM.styleSheetLoader);
        }
      }
    }, cU = async (t, s) => {
      zx(s).fold(() => {
        const i = Hx(s);
        i && s.contentCSS.push(i + (t ? "/content.inline" : "/content") + ".min.css");
      }, (i) => {
        const d = "ui/" + i + (t ? "/content.inline" : "/content") + ".css", g = tinymce.Resource.get(d);
        if (Ee(g))
          JD(s, d, g, s.ui.styleSheetLoader);
        else {
          const p = Hx(s);
          p && s.contentCSS.push(p + (t ? "/content.inline" : "/content") + ".min.css");
        }
      });
      const a = Hx(s);
      if (!qA(s) && Ee(a))
        return Promise.all([
          rU(s, a),
          aU(s, a)
        ]).then();
    }, U5 = (t, s) => cU(t, s).then(XD(s), sU(s, "Skin could not be loaded")), iU = gn(U5, !1), lU = gn(U5, !0), $b = (t, s, a) => t.translate([
      s,
      t.translate(a)
    ]), NE = (t, s) => {
      const a = (p, C, S, _) => {
        const D = t.shared.providers.translate(p.title);
        if (p.type === "separator")
          return A.some({
            type: "separator",
            text: D
          });
        if (p.type === "submenu") {
          const P = ae(p.getStyleItems(), (L) => i(L, C, _));
          return C === 0 && P.length <= 0 ? A.none() : A.some({
            type: "nestedmenuitem",
            text: D,
            enabled: P.length > 0,
            getSubmenuItems: () => ae(p.getStyleItems(), (L) => i(L, C, _))
          });
        } else
          return A.some({
            type: "togglemenuitem",
            text: D,
            icon: p.icon,
            active: p.isSelected(_),
            enabled: !S,
            onAction: s.onAction(p),
            ...p.getStylePreview().fold(() => ({}), (P) => ({ meta: { style: P } }))
          });
      }, i = (p, C, S) => {
        const _ = p.type === "formatter" && s.isInvalid(p);
        return C === 0 ? _ ? [] : a(p, C, !1, S).toArray() : a(p, C, _, S).toArray();
      }, d = (p) => {
        const C = s.getCurrentValue(), S = s.shouldHide ? 0 : 1;
        return ae(p, (_) => i(_, S, C));
      };
      return {
        validateItems: d,
        getFetch: (p, C) => (S, _) => {
          const D = C(), P = d(D), L = Lv(P, Um.CLOSE_ON_EXECUTE, p, {
            isHorizontalMenu: !1,
            search: A.none()
          });
          _(L);
        }
      };
    }, Up = (t, s, a) => {
      const i = a.dataset, d = i.type === "basic" ? () => $e(i.data, (g) => dD(g, a.isSelectedFor, a.getPreviewFor)) : i.getData;
      return {
        items: NE(s, a),
        getStyleItems: d
      };
    }, Kv = (t, s, a, i, d) => {
      const { items: g, getStyleItems: p } = Up(t, s, a), C = (_) => ({
        getComponent: U(_),
        setTooltip: (D) => {
          const P = s.shared.providers.translate(D);
          Ql(_.element, {
            "aria-label": P,
            title: P
          });
        }
      }), S = (_) => {
        const D = (P) => _.setTooltip($b(t, i, P.value));
        return t.on(d, D), N2(Qd(t, "NodeChange", (P) => {
          const L = P.getComponent();
          a.updateText(L), mo.set(P.getComponent(), !t.selection.isEditable());
        })(_), () => t.off(d, D));
      };
      return UO({
        text: a.icon.isSome() ? A.none() : a.text,
        icon: a.icon,
        tooltip: A.from(a.tooltip),
        role: A.none(),
        fetch: g.getFetch(s, p),
        onSetup: S,
        getApi: C,
        columns: 1,
        presets: "normal",
        classes: a.icon.isSome() ? [] : ["bespoke"],
        dropdownBehaviours: []
      }, "tox-tbtn", s.shared);
    }, Wp = (t) => $e(t, (s) => {
      let a = s, i = s;
      const d = s.split("=");
      return d.length > 1 && (a = d[0], i = d[1]), {
        title: a,
        format: i
      };
    }), W5 = (t) => ({
      type: "basic",
      data: t
    });
    var Yv;
    (function(t) {
      t[t.SemiColon = 0] = "SemiColon", t[t.Space = 1] = "Space";
    })(Yv || (Yv = {}));
    const uU = (t, s) => s === Yv.SemiColon ? t.replace(/;$/, "").split(";") : t.split(" "), QD = (t, s, a) => {
      const i = t.options.get(s);
      return {
        type: "basic",
        data: Wp(uU(i, a))
      };
    }, dU = "Align", Z5 = "Alignment {0}", j5 = "left", e4 = [
      {
        title: "Left",
        icon: "align-left",
        format: "alignleft",
        command: "JustifyLeft"
      },
      {
        title: "Center",
        icon: "align-center",
        format: "aligncenter",
        command: "JustifyCenter"
      },
      {
        title: "Right",
        icon: "align-right",
        format: "alignright",
        command: "JustifyRight"
      },
      {
        title: "Justify",
        icon: "align-justify",
        format: "alignjustify",
        command: "JustifyFull"
      }
    ], t4 = (t) => {
      const s = () => ee(e4, (C) => t.formatter.match(C.format)), a = (C) => () => t.formatter.match(C), i = (C) => A.none, d = (C) => {
        const _ = s().fold(U(j5), (D) => D.title.toLowerCase());
        to(C, Ip, { icon: `align-${_}` }), g8(t, { value: _ });
      }, g = W5(e4), p = (C) => () => ee(e4, (S) => S.format === C.format).each((S) => t.execCommand(S.command));
      return {
        tooltip: $b(t, Z5, j5),
        text: A.none(),
        icon: A.some("align-left"),
        isSelectedFor: a,
        getCurrentValue: A.none,
        getPreviewFor: i,
        onAction: p,
        updateText: d,
        dataset: g,
        shouldHide: !1,
        isInvalid: (C) => !t.formatter.canApply(C.format)
      };
    }, mU = (t, s) => Kv(t, s, t4(t), Z5, "AlignTextUpdate"), fU = (t, s) => {
      const a = Up(t, s, t4(t));
      t.ui.registry.addNestedMenuItem("align", {
        text: s.shared.providers.translate(dU),
        onSetup: Xi(t),
        getSubmenuItems: () => a.items.validateItems(a.getStyleItems())
      });
    }, ME = (t, s) => {
      const a = s(), i = $e(a, (d) => d.format);
      return A.from(t.formatter.closest(i)).bind((d) => ee(a, (g) => g.format === d)).orThunk(() => Zn(t.formatter.match("p"), {
        title: "Paragraph",
        format: "p"
      }));
    }, gU = "Blocks", q5 = "Block {0}", n4 = "Paragraph", G5 = (t) => {
      const s = (g) => () => t.formatter.match(g), a = (g) => () => {
        const p = t.formatter.get(g);
        return p ? A.some({
          tag: p.length > 0 && (p[0].inline || p[0].block) || "div",
          styles: t.dom.parseStyle(t.formatter.getCssText(g))
        }) : A.none();
      }, i = (g) => {
        const C = ME(t, () => d.data).fold(U(n4), (S) => S.title);
        to(g, qu, { text: C }), UM(t, { value: C });
      }, d = QD(t, "block_formats", Yv.SemiColon);
      return {
        tooltip: $b(t, q5, n4),
        text: A.some(n4),
        icon: A.none(),
        isSelectedFor: s,
        getCurrentValue: A.none,
        getPreviewFor: a,
        onAction: ZM(t),
        updateText: i,
        dataset: d,
        shouldHide: !1,
        isInvalid: (g) => !t.formatter.canApply(g.format)
      };
    }, hU = (t, s) => Kv(t, s, G5(t), q5, "BlocksTextUpdate"), pU = (t, s) => {
      const a = Up(t, s, G5(t));
      t.ui.registry.addNestedMenuItem("blocks", {
        text: gU,
        onSetup: Xi(t),
        getSubmenuItems: () => a.items.validateItems(a.getStyleItems())
      });
    }, K5 = "Fonts", o4 = "Font {0}", PE = "System Font", bU = [
      "-apple-system",
      "Segoe UI",
      "Roboto",
      "Helvetica Neue",
      "sans-serif"
    ], s4 = (t) => {
      const s = t.split(/\s*,\s*/);
      return $e(s, (a) => a.replace(/^['"]+|['"]+$/g, ""));
    }, Y5 = (t, s) => s.length > 0 && kt(s, (a) => t.indexOf(a.toLowerCase()) > -1), vU = (t, s) => {
      if (t.indexOf("-apple-system") === 0 || s.length > 0) {
        const a = s4(t.toLowerCase());
        return Y5(a, bU) || Y5(a, s);
      } else
        return !1;
    }, X5 = (t) => {
      const s = () => {
        const S = (Y) => Y ? s4(Y)[0] : "", _ = t.queryCommandValue("FontName"), D = C.data, P = _ ? _.toLowerCase() : "", L = DN(t);
        return {
          matchOpt: ee(D, (Y) => {
            const me = Y.format;
            return me.toLowerCase() === P || S(me).toLowerCase() === S(P).toLowerCase();
          }).orThunk(() => Zn(vU(P, L), {
            title: PE,
            format: P
          })),
          font: _
        };
      }, a = (S) => (_) => _.exists((D) => D.format === S), i = () => {
        const { matchOpt: S } = s();
        return S;
      }, d = (S) => () => A.some({
        tag: "div",
        styles: S.indexOf("dings") === -1 ? { "font-family": S } : {}
      }), g = (S) => () => {
        t.undoManager.transact(() => {
          t.focus(), t.execCommand("FontName", !1, S.format);
        });
      }, p = (S) => {
        const { matchOpt: _, font: D } = s(), P = _.fold(U(D), (L) => L.title);
        to(S, qu, { text: P }), WM(t, { value: P });
      }, C = QD(t, "font_family_formats", Yv.SemiColon);
      return {
        tooltip: $b(t, o4, PE),
        text: A.some(PE),
        icon: A.none(),
        isSelectedFor: a,
        getCurrentValue: i,
        getPreviewFor: d,
        onAction: g,
        updateText: p,
        dataset: C,
        shouldHide: !1,
        isInvalid: Te
      };
    }, J5 = (t, s) => Kv(t, s, X5(t), o4, "FontFamilyTextUpdate"), yU = (t, s) => {
      const a = Up(t, s, X5(t));
      t.ui.registry.addNestedMenuItem("fontfamily", {
        text: s.shared.providers.translate(K5),
        onSetup: Xi(t),
        getSubmenuItems: () => a.items.validateItems(a.getStyleItems())
      });
    }, Q5 = {
      unsupportedLength: [
        "em",
        "ex",
        "cap",
        "ch",
        "ic",
        "rem",
        "lh",
        "rlh",
        "vw",
        "vh",
        "vi",
        "vb",
        "vmin",
        "vmax",
        "cm",
        "mm",
        "Q",
        "in",
        "pc",
        "pt",
        "px"
      ],
      fixed: [
        "px",
        "pt"
      ],
      relative: ["%"],
      empty: [""]
    }, CU = (() => {
      const t = "[0-9]+", a = "[eE]" + ("[+-]?" + t), i = "\\.", d = (C) => `(?:${C})?`, p = `[+-]?(?:${[
        "Infinity",
        t + i + d(t) + d(a),
        i + t + d(a),
        t + d(a)
      ].join("|")})`;
      return new RegExp(`^(${p})(.*)$`);
    })(), wU = (t, s) => jo(s, (a) => jo(Q5[a], (i) => t === i)), BE = (t, s) => A.from(CU.exec(t)).bind((i) => {
      const d = Number(i[1]), g = i[2];
      return wU(g, s) ? A.some({
        value: d,
        unit: g
      }) : A.none();
    }), SU = (t, s) => BE(t, s).map(({ value: a, unit: i }) => a + i), eF = {
      tab: U(9),
      escape: U(27),
      enter: U(13),
      backspace: U(8),
      delete: U(46),
      left: U(37),
      up: U(38),
      right: U(39),
      down: U(40),
      space: U(32),
      home: U(36),
      end: U(35),
      pageUp: U(33),
      pageDown: U(34)
    }, xU = (t, s, a) => {
      let i = A.none();
      const d = (Ce) => Ce.map((Be) => ln.getValue(Be)).getOr(""), g = Qd(t, "NodeChange SwitchMode", (Ce) => {
        const Be = Ce.getComponent();
        i = A.some(Be), a.updateInputValue(Be), mo.set(Be, !t.selection.isEditable());
      }), p = (Ce) => ({ getComponent: U(Ce) }), C = w(J), S = An("custom-number-input-events"), _ = (Ce, Be, St) => {
        const ct = d(i), tt = a.getNewValue(ct, Ce), Vt = ct.length - `${tt}`.length, Xt = i.map((Hn) => Hn.element.dom.selectionStart - Vt), $o = i.map((Hn) => Hn.element.dom.selectionEnd - Vt);
        a.onAction(tt, St), i.each((Hn) => {
          ln.setValue(Hn, tt), Be && (Xt.each((co) => Hn.element.dom.selectionStart = co), $o.each((co) => Hn.element.dom.selectionEnd = co));
        });
      }, D = (Ce, Be) => _((St, ct) => St - ct, Ce, Be), P = (Ce, Be) => _((St, ct) => St + ct, Ce, Be), L = (Ce) => Oc(Ce.element).fold(A.none, (Be) => (Zi(Be), A.some(!0))), V = (Ce) => N1(Ce.element) ? (Bi(Ce.element).each((Be) => Zi(Be)), A.some(!0)) : A.none(), Y = (Ce, Be, St, ct) => {
        const tt = w(J), Vt = s.shared.providers.translate(St), Xt = An("altExecuting"), $o = Qd(t, "NodeChange SwitchMode", (co) => {
          mo.set(co.getComponent(), !t.selection.isEditable());
        }), Hn = (co) => {
          mo.isDisabled(co) || Ce(!0);
        };
        return Ec.sketch({
          dom: {
            tag: "button",
            attributes: {
              title: Vt,
              "aria-label": Vt
            },
            classes: ct.concat(Be)
          },
          components: [VO(Be, s.shared.providers.icons)],
          buttonBehaviours: Ut([
            mo.config({}),
            Bo(Xt, [
              Gg({
                onSetup: $o,
                getApi: p
              }, tt),
              Jd({ getApi: p }, tt),
              mt(Pu(), (co, bo) => {
                (bo.event.raw.keyCode === eF.space() || bo.event.raw.keyCode === eF.enter()) && (mo.isDisabled(co) || Ce(!1));
              }),
              mt(vm(), Hn),
              mt(as(), Hn)
            ])
          ]),
          eventOrder: {
            [Pu()]: [
              Xt,
              "keying"
            ],
            [vm()]: [
              Xt,
              "alloy.base.behaviour"
            ],
            [as()]: [
              Xt,
              "alloy.base.behaviour"
            ]
          }
        });
      }, me = js(Y((Ce) => D(!1, Ce), "minus", "Decrease font size", [])), Pe = js(Y((Ce) => P(!1, Ce), "plus", "Increase font size", [])), xe = js({
        dom: {
          tag: "div",
          classes: ["tox-input-wrapper"]
        },
        components: [Cb.sketch({
          inputBehaviours: Ut([
            mo.config({}),
            Bo(S, [
              Gg({
                onSetup: g,
                getApi: p
              }, C),
              Jd({ getApi: p }, C)
            ]),
            Bo("input-update-display-text", [
              mt(qu, (Ce, Be) => {
                ln.setValue(Ce, Be.event.text);
              }),
              mt(Jb(), (Ce) => {
                a.onAction(ln.getValue(Ce));
              }),
              mt(yh(), (Ce) => {
                a.onAction(ln.getValue(Ce));
              })
            ]),
            no.config({
              mode: "special",
              onEnter: (Ce) => (_(Tt, !0, !0), A.some(!0)),
              onEscape: L,
              onUp: (Ce) => (P(!0, !1), A.some(!0)),
              onDown: (Ce) => (D(!0, !1), A.some(!0)),
              onLeft: (Ce, Be) => (Be.cut(), A.none()),
              onRight: (Ce, Be) => (Be.cut(), A.none())
            })
          ])
        })],
        behaviours: Ut([
          po.config({}),
          no.config({
            mode: "special",
            onEnter: V,
            onSpace: V,
            onEscape: L
          }),
          Bo("input-wrapper-events", [mt(Rl(), (Ce) => {
            ot([
              me,
              Pe
            ], (Be) => {
              const St = ve.fromDom(Be.get(Ce).element.dom);
              N1(St) && Uh(St);
            });
          })])
        ])
      });
      return {
        dom: {
          tag: "div",
          classes: ["tox-number-input"]
        },
        components: [
          me.asSpec(),
          xe.asSpec(),
          Pe.asSpec()
        ],
        behaviours: Ut([
          po.config({}),
          no.config({
            mode: "flow",
            focusInside: h.OnEnterOrSpaceMode,
            cycles: !1,
            selector: "button, .tox-input-wrapper",
            onEscape: (Ce) => N1(Ce.element) ? A.none() : (Zi(Ce.element), A.some(!0))
          })
        ])
      };
    }, TU = "Font sizes", r4 = "Font size {0}", tF = "12pt", EU = {
      "8pt": "1",
      "10pt": "2",
      "12pt": "3",
      "14pt": "4",
      "18pt": "5",
      "24pt": "6",
      "36pt": "7"
    }, kU = {
      "xx-small": "7pt",
      "x-small": "8pt",
      small: "10pt",
      medium: "12pt",
      large: "14pt",
      "x-large": "18pt",
      "xx-large": "24pt"
    }, _U = (t, s) => {
      const a = Math.pow(10, s);
      return Math.round(t * a) / a;
    }, AU = (t, s) => /[0-9.]+px$/.test(t) ? _U(parseInt(t, 10) * 72 / 96, s || 0) + "pt" : Dt(kU, t).getOr(t), OU = (t) => Dt(EU, t).getOr(""), nF = (t) => {
      const s = () => {
        let S = A.none();
        const _ = C.data, D = t.queryCommandValue("FontSize");
        if (D)
          for (let P = 3; S.isNone() && P >= 0; P--) {
            const L = AU(D, P), V = OU(L);
            S = ee(_, (Y) => Y.format === D || Y.format === L || Y.format === V);
          }
        return {
          matchOpt: S,
          size: D
        };
      }, a = (S) => (_) => _.exists((D) => D.format === S), i = () => {
        const { matchOpt: S } = s();
        return S;
      }, d = U(A.none), g = (S) => () => {
        t.undoManager.transact(() => {
          t.focus(), t.execCommand("FontSize", !1, S.format);
        });
      }, p = (S) => {
        const { matchOpt: _, size: D } = s(), P = _.fold(U(D), (L) => L.title);
        to(S, qu, { text: P }), h8(t, { value: P });
      }, C = QD(t, "font_size_formats", Yv.Space);
      return {
        tooltip: $b(t, r4, tF),
        text: A.some(tF),
        icon: A.none(),
        isSelectedFor: a,
        getPreviewFor: d,
        getCurrentValue: i,
        onAction: g,
        updateText: p,
        dataset: C,
        shouldHide: !1,
        isInvalid: Te
      };
    }, oF = (t, s) => Kv(t, s, nF(t), r4, "FontSizeTextUpdate"), DU = (t) => {
      var s;
      const a = { step: 1 };
      return (s = {
        em: { step: 0.1 },
        cm: { step: 0.1 },
        in: { step: 0.1 },
        pc: { step: 0.1 },
        ch: { step: 0.1 },
        rem: { step: 0.1 }
      }[t]) !== null && s !== void 0 ? s : a;
    }, RU = 16, sF = (t) => t >= 0, NU = (t) => {
      const s = () => t.queryCommandValue("FontSize");
      return {
        updateInputValue: (i) => to(i, qu, { text: s() }),
        onAction: (i, d) => t.execCommand("FontSize", !1, i, { skip_focus: !d }),
        getNewValue: (i, d) => {
          BE(i, [
            "unsupportedLength",
            "empty"
          ]);
          const g = s(), p = BE(i, [
            "unsupportedLength",
            "empty"
          ]).or(BE(g, [
            "unsupportedLength",
            "empty"
          ])), C = p.map((L) => L.value).getOr(RU), S = xN(t), _ = p.map((L) => L.unit).filter((L) => L !== "").getOr(S), D = d(C, DU(_).step), P = `${sF(D) ? D : C}${_}`;
          return P !== g && p8(t, { value: P }), P;
        }
      };
    }, rF = (t, s) => xU(t, s, NU(t)), aF = (t, s) => {
      const a = Up(t, s, nF(t));
      t.ui.registry.addNestedMenuItem("fontsize", {
        text: TU,
        onSetup: Xi(t),
        getSubmenuItems: () => a.items.validateItems(a.getStyleItems())
      });
    }, MU = "Formats", cF = "Format {0}", iF = (t, s) => {
      const a = "Paragraph", i = (p) => () => t.formatter.match(p), d = (p) => () => {
        const C = t.formatter.get(p);
        return C !== void 0 ? A.some({
          tag: C.length > 0 && (C[0].inline || C[0].block) || "div",
          styles: t.dom.parseStyle(t.formatter.getCssText(p))
        }) : A.none();
      }, g = (p) => {
        const C = (P) => rE(P) ? ae(P.items, C) : E$(P) ? [{
          title: P.title,
          format: P.format
        }] : [], S = ae(_$(t), C), D = ME(t, U(S)).fold(U(a), (P) => P.title);
        to(p, qu, { text: D }), f8(t, { value: D });
      };
      return {
        tooltip: $b(t, cF, a),
        text: A.some(a),
        icon: A.none(),
        isSelectedFor: i,
        getCurrentValue: A.none,
        getPreviewFor: d,
        onAction: ZM(t),
        updateText: g,
        shouldHide: vN(t),
        isInvalid: (p) => !t.formatter.canApply(p.format),
        dataset: s
      };
    }, Xv = (t, s) => {
      const a = {
        type: "advanced",
        ...s.styles
      };
      return Kv(t, s, iF(t, a), cF, "StylesTextUpdate");
    }, PU = (t, s) => {
      const a = {
        type: "advanced",
        ...s.styles
      }, i = Up(t, s, iF(t, a));
      t.ui.registry.addNestedMenuItem("styles", {
        text: MU,
        onSetup: Xi(t),
        getSubmenuItems: () => i.items.validateItems(i.getStyleItems())
      });
    }, BU = U([
      gt("toggleClass"),
      gt("fetch"),
      ud("onExecute"),
      Ne("getHotspot", A.some),
      Ne("getAnchorOverrides", U({})),
      kf(),
      ud("onItemExecute"),
      $s("lazySink"),
      gt("dom"),
      gs("onOpen"),
      za("splitDropdownBehaviours", [
        Ca,
        no,
        po
      ]),
      Ne("matchWidth", !1),
      Ne("useMinWidth", !1),
      Ne("eventOrder", {}),
      $s("role")
    ].concat(tO())), $U = ei({
      factory: Ec,
      schema: [gt("dom")],
      name: "arrow",
      defaults: () => ({ buttonBehaviours: Ut([po.revoke()]) }),
      overrides: (t) => ({
        dom: {
          tag: "span",
          attributes: { role: "presentation" }
        },
        action: (s) => {
          s.getSystem().getByUid(t.uid).each(Cm);
        },
        buttonBehaviours: Ut([Vo.config({
          toggleOnExecute: !1,
          toggleClass: t.toggleClass
        })])
      })
    }), FU = ei({
      factory: Ec,
      schema: [gt("dom")],
      name: "button",
      defaults: () => ({ buttonBehaviours: Ut([po.revoke()]) }),
      overrides: (t) => ({
        dom: {
          tag: "span",
          attributes: { role: "presentation" }
        },
        action: (s) => {
          s.getSystem().getByUid(t.uid).each((a) => {
            t.onExecute(a, s);
          });
        }
      })
    }), IU = U([
      $U,
      FU,
      qi({
        factory: {
          sketch: (t) => ({
            uid: t.uid,
            dom: {
              tag: "span",
              styles: { display: "none" },
              attributes: { "aria-hidden": "true" },
              innerHtml: t.text
            }
          })
        },
        schema: [gt("text")],
        name: "aria-descriptor"
      }),
      zu({
        schema: [E1()],
        name: "menu",
        defaults: (t) => ({
          onExecute: (s, a) => {
            s.getSystem().getByUid(t.uid).each((i) => {
              t.onItemExecute(i, s, a);
            });
          }
        })
      }),
      uP()
    ]), LU = (t, s, a, i) => {
      const d = (D) => {
        ts.getCurrent(D).each((P) => {
          Ps.highlightFirst(P), no.focusIn(P);
        });
      }, g = (D) => {
        Q3(t, Tt, D, i, d, Yi.HighlightMenuAndItem).get(J);
      }, p = (D) => (g(D), A.some(!0)), C = (D) => {
        const P = $m(D, t, "button");
        return Cm(P), A.some(!0);
      }, S = {
        ...vr([cr((D, P) => {
          ir(D, t, "aria-descriptor").each((V) => {
            const Y = An("aria");
            sn(V.element, "id", Y), sn(D.element, "aria-describedby", Y);
          });
        })]),
        ...zm(A.some(g))
      }, _ = {
        repositionMenus: (D) => {
          Vo.isOn(D) && gP(D);
        }
      };
      return {
        uid: t.uid,
        dom: t.dom,
        components: s,
        apis: _,
        eventOrder: {
          ...t.eventOrder,
          [cl()]: [
            "disabling",
            "toggling",
            "alloy.base.behaviour"
          ]
        },
        events: S,
        behaviours: Oa(t.splitDropdownBehaviours, [
          Ca.config({
            others: {
              sandbox: (D) => {
                const P = $m(D, t, "arrow");
                return eO(t, D, {
                  onOpen: () => {
                    Vo.on(P), Vo.on(D);
                  },
                  onClose: () => {
                    Vo.off(P), Vo.off(D);
                  }
                });
              }
            }
          }),
          no.config({
            mode: "special",
            onSpace: C,
            onEnter: C,
            onDown: p
          }),
          po.config({}),
          Vo.config({
            toggleOnExecute: !1,
            aria: { mode: "expanded" }
          })
        ]),
        domModification: {
          attributes: {
            role: t.role.getOr("button"),
            "aria-haspopup": !0
          }
        }
      };
    }, $E = ti({
      name: "SplitDropdown",
      configFields: BU(),
      partFields: IU(),
      factory: LU,
      apis: { repositionMenus: (t, s) => t.repositionMenus(s) }
    }), lF = (t) => ({
      isEnabled: () => !mo.isDisabled(t),
      setEnabled: (s) => mo.set(t, !s),
      setText: (s) => to(t, qu, { text: s }),
      setIcon: (s) => to(t, Ip, { icon: s })
    }), a4 = (t) => ({
      setActive: (s) => {
        Vo.set(t, s);
      },
      isActive: () => Vo.isOn(t),
      isEnabled: () => !mo.isDisabled(t),
      setEnabled: (s) => mo.set(t, !s),
      setText: (s) => to(t, qu, { text: s }),
      setIcon: (s) => to(t, Ip, { icon: s })
    }), uF = (t, s) => t.map((a) => ({
      "aria-label": s.translate(a),
      title: s.translate(a)
    })).getOr({}), dF = An("focus-button"), FE = (t, s, a, i, d) => {
      const g = s.map((C) => js(_B(C, "tox-tbtn", d))), p = t.map((C) => js(Fp(C, d.icons)));
      return {
        dom: {
          tag: "button",
          classes: ["tox-tbtn"].concat(s.isSome() ? ["tox-tbtn--select"] : []),
          attributes: uF(a, d)
        },
        components: Tb([
          p.map((C) => C.asSpec()),
          g.map((C) => C.asSpec())
        ]),
        eventOrder: {
          [Zs()]: [
            "focusing",
            "alloy.base.behaviour",
            Rb
          ],
          [Nl()]: [
            Rb,
            "toolbar-group-button-events"
          ]
        },
        buttonBehaviours: Ut([
          Zu.toolbarButton(d.isDisabled),
          fc(),
          Bo(Rb, [
            cr((C, S) => HO(C)),
            mt(qu, (C, S) => {
              g.bind((_) => _.getOpt(C)).each((_) => {
                Oo.set(_, [da(d.translate(S.event.text))]);
              });
            }),
            mt(Ip, (C, S) => {
              p.bind((_) => _.getOpt(C)).each((_) => {
                Oo.set(_, [Fp(S.event.icon, d.icons)]);
              });
            }),
            mt(Zs(), (C, S) => {
              S.event.prevent(), cs(C, dF);
            })
          ])
        ].concat(i.getOr([])))
      };
    }, mF = (t, s, a, i) => {
      const d = s.shared, g = w(J), p = {
        toolbarButtonBehaviours: [],
        getApi: lF,
        onSetup: t.onSetup
      }, C = [Bo("toolbar-group-button-events", [
        Gg(p, g),
        Jd(p, g)
      ])];
      return Vp.sketch({
        lazySink: d.getSink,
        fetch: () => vi.nu((S) => {
          S($e(a(t.items), EE));
        }),
        markers: { toggledClass: "tox-tbtn--enabled" },
        parts: {
          button: FE(t.icon, t.text, t.tooltip, A.some(C), d.providers),
          toolbar: {
            dom: {
              tag: "div",
              classes: ["tox-toolbar__overflow"],
              attributes: i
            }
          }
        }
      });
    }, fF = (t, s, a) => {
      var i;
      const d = w(J), g = FE(t.icon, t.text, t.tooltip, A.none(), a);
      return Ec.sketch({
        dom: g.dom,
        components: g.components,
        eventOrder: GT,
        buttonBehaviours: {
          ...Ut([
            Bo("toolbar-button-events", [
              n9({
                onAction: t.onAction,
                getApi: s.getApi
              }),
              Gg(s, d),
              Jd(s, d)
            ]),
            Zu.toolbarButton(() => !t.enabled || a.isDisabled()),
            fc()
          ].concat(s.toolbarButtonBehaviours)),
          [Rb]: (i = g.buttonBehaviours) === null || i === void 0 ? void 0 : i[Rb]
        }
      });
    }, HU = (t, s) => gF(t, s, []), gF = (t, s, a) => fF(t, {
      toolbarButtonBehaviours: a.length > 0 ? [Bo("toolbarButtonWith", a)] : [],
      getApi: lF,
      onSetup: t.onSetup
    }, s), zU = (t, s) => hF(t, s, []), hF = (t, s, a) => fF(t, {
      toolbarButtonBehaviours: [
        Oo.config({}),
        Vo.config({
          toggleClass: "tox-tbtn--enabled",
          aria: { mode: "pressed" },
          toggleOnExecute: !1
        })
      ].concat(a.length > 0 ? [Bo("toolbarToggleButtonWith", a)] : []),
      getApi: a4,
      onSetup: t.onSetup
    }, s), VU = (t, s, a) => (i) => vi.nu((d) => s.fetch(d)).map((d) => A.from(xT(Ms(j3(An("menu-value"), d, (g) => {
      s.onItemAction(t(i), g);
    }, s.columns, s.presets, Um.CLOSE_ON_EXECUTE, s.select.getOr(Te), a), {
      movement: yT(s.columns, s.presets),
      menuBehaviours: k2.unnamedEvents(s.columns !== "auto" ? [] : [cr((g, p) => {
        E2(g, 4, Wx(s.presets)).each(({ numRows: C, numColumns: S }) => {
          no.setGridSize(g, C, S);
        });
      })])
    })))), pF = (t, s) => {
      const a = (g) => ({
        isEnabled: () => !mo.isDisabled(g),
        setEnabled: (p) => mo.set(g, !p),
        setIconFill: (p, C) => {
          va(g.element, `svg path[class="${p}"], rect[class="${p}"]`).each((S) => {
            sn(S, "fill", C);
          });
        },
        setActive: (p) => {
          sn(g.element, "aria-pressed", p), va(g.element, "span").each((C) => {
            g.getSystem().getByDom(C).each((S) => Vo.set(S, p));
          });
        },
        isActive: () => va(g.element, "span").exists((p) => g.getSystem().getByDom(p).exists(Vo.isOn)),
        setText: (p) => va(g.element, "span").each((C) => g.getSystem().getByDom(C).each((S) => to(S, qu, { text: p }))),
        setIcon: (p) => va(g.element, "span").each((C) => g.getSystem().getByDom(C).each((S) => to(S, Ip, { icon: p }))),
        setTooltip: (p) => {
          const C = s.providers.translate(p);
          Ql(g.element, {
            "aria-label": C,
            title: C
          });
        }
      }), i = w(J), d = {
        getApi: a,
        onSetup: t.onSetup
      };
      return $E.sketch({
        dom: {
          tag: "div",
          classes: ["tox-split-button"],
          attributes: {
            "aria-pressed": !1,
            ...uF(t.tooltip, s.providers)
          }
        },
        onExecute: (g) => {
          const p = a(g);
          p.isEnabled() && t.onAction(p);
        },
        onItemExecute: (g, p, C) => {
        },
        splitDropdownBehaviours: Ut([
          Zu.splitButton(s.providers.isDisabled),
          fc(),
          Bo("split-dropdown-events", [
            cr((g, p) => HO(g)),
            mt(dF, po.focus),
            Gg(d, i),
            Jd(d, i)
          ]),
          z2.config({})
        ]),
        eventOrder: {
          [Nl()]: [
            "alloy.base.behaviour",
            "split-dropdown-events"
          ]
        },
        toggleClass: "tox-tbtn--enabled",
        lazySink: s.getSink,
        fetch: VU(a, t, s.providers),
        parts: { menu: Sv(!1, t.columns, t.presets) },
        components: [
          $E.parts.button(FE(t.icon, t.text, A.none(), A.some([Vo.config({
            toggleClass: "tox-tbtn--enabled",
            toggleOnExecute: !1
          })]), s.providers)),
          $E.parts.arrow({
            dom: {
              tag: "button",
              classes: [
                "tox-tbtn",
                "tox-split-button__chevron"
              ],
              innerHtml: fN("chevron-down", s.providers.icons)
            },
            buttonBehaviours: Ut([
              Zu.splitButton(s.providers.isDisabled),
              fc(),
              Rx()
            ])
          }),
          $E.parts["aria-descriptor"]({ text: s.providers.translate("To open the popup, press Shift+Enter") })
        ]
      });
    }, UU = [
      {
        name: "history",
        items: [
          "undo",
          "redo"
        ]
      },
      {
        name: "ai",
        items: [
          "aidialog",
          "aishortcuts"
        ]
      },
      {
        name: "styles",
        items: ["styles"]
      },
      {
        name: "formatting",
        items: [
          "bold",
          "italic"
        ]
      },
      {
        name: "alignment",
        items: [
          "alignleft",
          "aligncenter",
          "alignright",
          "alignjustify"
        ]
      },
      {
        name: "indentation",
        items: [
          "outdent",
          "indent"
        ]
      },
      {
        name: "permanent pen",
        items: ["permanentpen"]
      },
      {
        name: "comments",
        items: ["addcomment"]
      }
    ], bw = (t, s) => (a, i, d) => {
      const g = t(a).mapError((p) => Kc(p)).getOrDie();
      return s(g, i, d);
    }, WU = {
      button: bw(iM, (t, s) => HU(t, s.shared.providers)),
      togglebutton: bw(p3, (t, s) => zU(t, s.shared.providers)),
      menubutton: bw(MD, (t, s) => Q2(t, "tox-tbtn", s, A.none(), !1)),
      splitbutton: bw(lV, (t, s) => pF(t, s.shared)),
      grouptoolbarbutton: bw(cV, (t, s, a) => {
        const i = a.ui.registry.getAll().buttons, d = (p) => HE(a, {
          buttons: i,
          toolbar: p,
          allowToolbarGroups: !1
        }, s, A.none()), g = { [qh]: s.shared.header.isPositionedAtTop() ? iu.TopToBottom : iu.BottomToTop };
        switch (Cv(a)) {
          case yd.floating:
            return mF(t, s, d, g);
          default:
            throw new Error("Toolbar groups are only supported when using floating toolbar mode");
        }
      })
    }, ZU = (t, s, a) => Dt(WU, t.type).fold(() => A.none(), (i) => A.some(i(t, s, a))), vw = {
      styles: Xv,
      fontsize: oF,
      fontsizeinput: rF,
      fontfamily: J5,
      blocks: hU,
      align: mU
    }, jU = (t) => {
      const s = $e(UU, (a) => {
        const i = fo(a.items, (d) => Lo(t, d) || Lo(vw, d));
        return {
          name: a.name,
          items: i
        };
      });
      return fo(s, (a) => a.items.length > 0);
    }, IE = (t) => {
      const s = t.split("|");
      return $e(s, (a) => ({ items: a.trim().split(" ") }));
    }, LE = (t) => Kt(t, (s) => Lo(s, "name") && Lo(s, "items")), bF = (t) => {
      const s = t.toolbar, a = t.buttons;
      return s === !1 ? [] : s === void 0 || s === !0 ? jU(a) : Ee(s) ? IE(s) : LE(s) ? s : [];
    }, qU = (t, s, a, i, d, g) => Dt(s, a.toLowerCase()).orThunk(() => g.bind((p) => No(p, (C) => Dt(s, C + a.toLowerCase())))).fold(() => Dt(vw, a.toLowerCase()).map((p) => p(t, d)), (p) => p.type === "grouptoolbarbutton" && !i ? A.none() : ZU(p, d, t)), HE = (t, s, a, i) => {
      const d = bF(s), g = $e(d, (p) => {
        const C = ae(p.items, (S) => S.trim().length === 0 ? [] : qU(t, s.buttons, S, s.allowToolbarGroups, a, i).toArray());
        return {
          title: A.from(t.translate(p.name)),
          items: C
        };
      });
      return fo(g, (p) => p.items.length > 0);
    }, vF = (t, s, a, i) => {
      const d = s.mainUi.outerContainer, g = a.toolbar, p = a.buttons;
      if (Kt(g, Ee)) {
        const C = g.map((S) => {
          const _ = {
            toolbar: S,
            buttons: p,
            allowToolbarGroups: a.allowToolbarGroups
          };
          return HE(t, _, i, A.none());
        });
        Tr.setToolbars(d, C);
      } else
        Tr.setToolbar(d, HE(t, a, i, A.none()));
    }, yF = xl(), GU = yF.os.isiOS() && yF.os.version.major <= 12, zE = (t, s) => {
      const { uiMotherships: a } = s, i = t.dom;
      let d = t.getWin();
      const g = t.getDoc().documentElement, p = w(Es(d.innerWidth, d.innerHeight)), C = w(Es(g.offsetWidth, g.offsetHeight)), S = () => {
        const L = p.get();
        (L.left !== d.innerWidth || L.top !== d.innerHeight) && (p.set(Es(d.innerWidth, d.innerHeight)), dT(t));
      }, _ = () => {
        const L = t.getDoc().documentElement, V = C.get();
        (V.left !== L.offsetWidth || V.top !== L.offsetHeight) && (C.set(Es(L.offsetWidth, L.offsetHeight)), dT(t));
      }, D = (L) => {
        d8(t, L);
      };
      i.bind(d, "resize", S), i.bind(d, "scroll", D);
      const P = R0(ve.fromDom(t.getBody()), "load", _);
      t.on("hide", () => {
        ot(a, (L) => {
          _n(L.element, "display", "none");
        });
      }), t.on("show", () => {
        ot(a, (L) => {
          Jo(L.element, "display");
        });
      }), t.on("NodeChange", _), t.on("remove", () => {
        P.unbind(), i.unbind(d, "resize", S), i.unbind(d, "scroll", D), d = null;
      });
    }, CF = (t, s, a) => {
      Zg(t) && Nm(a.mainUi.mothership.element, a.popupUi.mothership), Tc(s, a.dialogUi.mothership);
    };
    var wF = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      render: (t, s, a, i, d) => {
        const { mainUi: g, uiMotherships: p } = s, C = w(0), S = g.outerContainer;
        iU(t);
        const _ = ve.fromDom(d.targetNode), D = Rt(Ve(_));
        Nm(_, g.mothership), CF(t, D, s), t.on("SkinLoaded", () => {
          Tr.setSidebar(S, a.sidebar, AN(t)), vF(t, s, a, i), C.set(t.getWin().innerWidth), Tr.setMenubar(S, RE(t, a)), Tr.setViews(S, a.views), zE(t, s);
        });
        const P = Tr.getSocket(S).getOrDie("Could not find expected socket element");
        if (GU) {
          gr(P.element, {
            overflow: "scroll",
            "-webkit-overflow-scrolling": "touch"
          });
          const me = ZH(() => {
            t.dispatch("ScrollContent");
          }, 20), Pe = hi(P.element, "scroll", me.throttle);
          t.on("remove", Pe.unbind);
        }
        SM(t, s), t.addCommand("ToggleSidebar", (me, Pe) => {
          Tr.toggleSidebar(S, Pe), t.dispatch("ToggleSidebar");
        }), t.addQueryValueHandler("ToggleSidebar", () => {
          var me;
          return (me = Tr.whichSidebar(S)) !== null && me !== void 0 ? me : "";
        }), t.addCommand("ToggleView", (me, Pe) => {
          if (Tr.toggleView(S, Pe)) {
            const xe = S.element;
            g.mothership.broadcastOn([gd()], { target: xe }), ot(p, (Ce) => {
              Ce.broadcastOn([gd()], { target: xe });
            }), Sn(Tr.whichView(S)) && (t.focus(), t.nodeChanged(), Tr.refreshToolbar(S));
          }
        }), t.addQueryValueHandler("ToggleView", () => {
          var me;
          return (me = Tr.whichView(S)) !== null && me !== void 0 ? me : "";
        });
        const L = Cv(t), V = () => {
          Tr.refreshToolbar(s.mainUi.outerContainer);
        };
        (L === yd.sliding || L === yd.floating) && t.on("ResizeWindow ResizeEditor ResizeContent", () => {
          const me = t.getWin().innerWidth;
          me !== C.get() && (V(), C.set(me));
        });
        const Y = {
          setEnabled: (me) => {
            aT(s, !me);
          },
          isEnabled: () => !mo.isDisabled(S)
        };
        return {
          iframeContainer: P.element.dom,
          editorContainer: S.element.dom,
          api: Y
        };
      }
    });
    const VE = (t) => /^[0-9\.]+(|px)$/i.test("" + t) ? A.some(parseInt("" + t, 10)) : A.none(), c4 = (t) => Pn(t) ? t + "px" : t, yw = (t, s, a) => {
      const i = s.filter((g) => t < g), d = a.filter((g) => t > g);
      return i.or(d).getOr(t);
    }, YU = (t) => {
      const s = FA(t), a = HA(t), i = zA(t);
      return VE(s).map((d) => yw(d, a, i));
    }, XU = (t) => YU(t).getOr(FA(t)), SF = (t) => {
      const s = IA(t), a = LA(t), i = Nx(t);
      return VE(s).map((d) => yw(d, a, i));
    }, JU = (t) => SF(t).getOr(IA(t)), { ToolbarLocation: i4, ToolbarMode: Jv } = b6, QU = 40, eW = (t, s, a, i, d) => {
      const { mainUi: g, uiMotherships: p } = a, C = vv.DOM, S = xp(t), _ = C2(t), D = Nx(t).or(SF(t)), P = i.shared.header, L = P.isPositionedAtTop, V = Cv(t), Y = V === Jv.sliding || V === Jv.floating, me = w(!1), Pe = () => me.get() && !t.removed, xe = (ro) => Y ? ro.fold(U(0), (ys) => ys.components().length > 1 ? hr(ys.components()[1].element) : 0) : 0, Ce = (ro) => {
        switch (b2(t)) {
          case i4.auto:
            const ys = Tr.getToolbar(g.outerContainer), Jt = xe(ys), Fn = hr(ro.element) - Jt, So = Ar(s);
            if (So.y > Fn)
              return "top";
            {
              const uo = yc(s), Ro = Math.max(uo.dom.scrollHeight, hr(uo));
              return So.bottom < Ro - Fn || La().bottom < So.bottom - Fn ? "bottom" : "top";
            }
          case i4.bottom:
            return "bottom";
          case i4.top:
          default:
            return "top";
        }
      }, Be = (ro) => {
        d.on((ys) => {
          Da.setModes(ys, [ro]), P.setDockingMode(ro);
          const Jt = L() ? iu.TopToBottom : iu.BottomToTop;
          sn(ys.element, qh, Jt);
        });
      }, St = () => {
        d.on((ro) => {
          const ys = D.getOrThunk(() => {
            const Jt = VE(Us(fr(), "margin-left")).getOr(0);
            return j(fr()) - Cc(s).left + Jt;
          });
          _n(ro.element, "max-width", ys + "px");
        });
      }, ct = (ro) => {
        d.on((ys) => {
          const Jt = Tr.getToolbar(g.outerContainer), Fn = xe(Jt), So = Ar(s), { top: ns, left: uo } = tt(t, g.outerContainer.element).fold(() => ({
            top: L() ? Math.max(So.y - hr(ys.element) + Fn, 0) : So.bottom,
            left: So.x
          }), (Bs) => {
            var Pi;
            const Hr = Ar(Bs), Yl = (Pi = Bs.dom.scrollTop) !== null && Pi !== void 0 ? Pi : 0, im = Rs(Bs, fr()), Jp = im ? Math.max(So.y - hr(ys.element) + Fn, 0) : So.y - Hr.y + Yl - hr(ys.element) + Fn;
            return {
              top: L() ? Jp : So.bottom,
              left: im ? So.x : So.x - Hr.x
            };
          }), Ro = {
            position: "absolute",
            left: Math.round(uo) + "px",
            top: Math.round(ns) + "px"
          }, ur = ro.map((Bs) => {
            const Pi = Mc(), Hr = 150, Yl = window.innerWidth - (uo - Pi.left);
            return { width: Math.max(Math.min(Bs, Yl), Hr) + "px" };
          }).getOr({});
          gr(g.outerContainer.element, {
            ...Ro,
            ...ur
          });
        });
      }, tt = (ro, ys) => Zg(ro) ? Pb(ys) : A.none(), Vt = () => {
        ot(p, (ro) => {
          ro.broadcastOn([Bg()], {});
        });
      }, Xt = () => {
        if (S)
          return A.none();
        if (Cc(g.outerContainer.element).left + oe(g.outerContainer.element) >= window.innerWidth - QU || Xs(g.outerContainer.element, "width").isSome()) {
          _n(g.outerContainer.element, "position", "absolute"), _n(g.outerContainer.element, "left", "0px"), Jo(g.outerContainer.element, "width");
          const ys = oe(g.outerContainer.element);
          return A.some(ys);
        } else
          return A.none();
      }, $o = (ro) => {
        if (!Pe())
          return;
        S || St();
        const ys = S ? A.none() : Xt();
        Y && Tr.refreshToolbar(g.outerContainer), S || ct(ys), _ && d.on(ro), Vt();
      }, Hn = () => S || !_ || !Pe() ? !1 : d.get().exists((ro) => {
        const ys = P.getDockingMode(), Jt = Ce(ro);
        return Jt !== ys ? (Be(Jt), !0) : !1;
      });
      return {
        isVisible: Pe,
        isPositionedAtTop: L,
        show: () => {
          me.set(!0), _n(g.outerContainer.element, "display", "flex"), C.addClass(t.getBody(), "mce-edit-focus"), ot(p, (ro) => {
            Jo(ro.element, "display");
          }), Hn(), Zg(t) ? $o((ro) => Da.isDocked(ro) ? Da.reset(ro) : Da.refresh(ro)) : $o(Da.refresh);
        },
        hide: () => {
          me.set(!1), _n(g.outerContainer.element, "display", "none"), C.removeClass(t.getBody(), "mce-edit-focus"), ot(p, (ro) => {
            _n(ro.element, "display", "none");
          });
        },
        update: $o,
        updateMode: () => {
          Hn() && $o(Da.reset);
        },
        repositionPopups: Vt
      };
    }, xF = (t, s) => {
      const a = Ar(t);
      return {
        pos: s ? a.y : a.bottom,
        bounds: a
      };
    }, TF = (t, s, a, i) => {
      const d = w(xF(s, a.isPositionedAtTop())), g = (_) => {
        const { pos: D, bounds: P } = xF(s, a.isPositionedAtTop()), {
          pos: L,
          bounds: V
        } = d.get(), Y = P.height !== V.height || P.width !== V.width;
        d.set({
          pos: D,
          bounds: P
        }), Y && dT(t, _), a.isVisible() && (L !== D ? a.update(Da.reset) : Y && (a.updateMode(), a.repositionPopups()));
      };
      i || (t.on("activate", a.show), t.on("deactivate", a.hide)), t.on("SkinLoaded ResizeWindow", () => a.update(Da.reset)), t.on("NodeChange keydown", (_) => {
        requestAnimationFrame(() => g(_));
      });
      let p = 0;
      const C = WT(() => a.update(Da.refresh), 33);
      t.on("ScrollWindow", () => {
        const _ = Mc().left;
        _ !== p && (p = _, C.throttle()), a.updateMode();
      }), Zg(t) && t.on("ElementScroll", (_) => {
        a.update(Da.refresh);
      });
      const S = Om();
      S.set(R0(ve.fromDom(t.getBody()), "load", (_) => g(_.raw))), t.on("remove", () => {
        S.clear();
      });
    };
    var EF = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      render: (t, s, a, i, d) => {
        const { mainUi: g } = s, p = Go(), C = ve.fromDom(d.targetNode), S = eW(t, C, s, i, p), _ = wN(t);
        lU(t);
        const D = () => {
          if (p.isSet()) {
            S.show();
            return;
          }
          p.set(Tr.getHeader(g.outerContainer).getOrDie());
          const L = YA(t);
          Zg(t) ? (Nm(C, g.mothership), Nm(C, s.popupUi.mothership)) : Tc(L, g.mothership), Tc(L, s.dialogUi.mothership), vF(t, s, a, i), Tr.setMenubar(g.outerContainer, RE(t, a)), S.show(), TF(t, C, S, _), t.nodeChanged();
        };
        t.on("show", D), t.on("hide", S.hide), _ || (t.on("focus", D), t.on("blur", S.hide)), t.on("init", () => {
          (t.hasFocus() || _) && D();
        }), SM(t, s);
        const P = {
          show: D,
          hide: S.hide,
          setEnabled: (L) => {
            aT(s, !L);
          },
          isEnabled: () => !mo.isDisabled(g.outerContainer)
        };
        return {
          editorContainer: g.outerContainer.element.dom,
          api: P
        };
      }
    });
    const tW = () => {
      const t = Go(), s = Go(), a = Go();
      return {
        dialogUi: t,
        popupUi: s,
        mainUi: a,
        getUiMotherships: () => {
          const g = t.get().map((C) => C.mothership), p = s.get().map((C) => C.mothership);
          return g.fold(() => p.toArray(), (C) => p.fold(() => [C], (S) => Rs(C.element, S.element) ? [C] : [
            C,
            S
          ]));
        },
        lazyGetInOuterOrDie: (g, p) => () => a.get().bind((C) => p(C.outerContainer)).getOrDie(`Could not find ${g} element in OuterContainer`)
      };
    }, nW = "contexttoolbar-show", kF = "contexttoolbar-hide", oW = (t) => ({
      hide: () => cs(t, f1()),
      getValue: () => ln.getValue(t)
    }), _F = (t, s) => mt(LO, (a, i) => {
      const d = t.get(a), g = oW(d);
      s.onAction(g, i.event.buttonApi);
    }), Cw = (t, s, a) => {
      const { primary: i, ...d } = s.original, g = Js(iM({
        ...d,
        type: "button",
        onAction: J
      }));
      return gF(g, a, [_F(t, s)]);
    }, AF = (t, s, a) => {
      const { primary: i, ...d } = s.original, g = Js(p3({
        ...d,
        type: "togglebutton",
        onAction: J
      }));
      return hF(g, a, [_F(t, s)]);
    }, sW = (t) => t.type === "contextformtogglebutton", rW = (t, s, a) => sW(s) ? AF(t, s, a) : Cw(t, s, a), OF = (t, s, a) => {
      const i = $e(s, (p) => js(rW(t, p, a)));
      return {
        asSpecs: () => $e(i, (p) => p.asSpec()),
        findPrimary: (p) => No(s, (C, S) => C.primary ? A.from(i[S]).bind((_) => _.getOpt(p)).filter(De(mo.isDisabled)) : A.none())
      };
    }, UE = (t, s) => {
      const a = t.label.fold(() => ({}), (g) => ({ "aria-label": g })), i = js(Cb.sketch({
        inputClasses: [
          "tox-toolbar-textfield",
          "tox-toolbar-nav-js"
        ],
        data: t.initValue(),
        inputAttributes: a,
        selectOnFocus: !0,
        inputBehaviours: Ut([no.config({
          mode: "special",
          onEnter: (g) => d.findPrimary(g).map((p) => (Cm(p), !0)),
          onLeft: (g, p) => (p.cut(), A.none()),
          onRight: (g, p) => (p.cut(), A.none())
        })])
      })), d = OF(i, t.commands, s);
      return [
        {
          title: A.none(),
          items: [i.asSpec()]
        },
        {
          title: A.none(),
          items: d.asSpecs()
        }
      ];
    }, DF = {
      renderContextForm: (t, s, a) => kE({
        type: t,
        uid: An("context-toolbar"),
        initGroups: UE(s, a),
        onEscape: A.none,
        cyclicKeying: !0,
        providers: a
      }),
      buildInitGroups: UE
    }, RF = (t, s, a) => s.bottom - t.y >= a && t.bottom - s.y >= a, Qv = (t) => {
      const s = t.getBoundingClientRect();
      if (s.height <= 0 && s.width <= 0) {
        const a = Ju(ve.fromDom(t.startContainer), t.startOffset).element;
        return (Fo(a) ? Ta(a) : A.some(a)).filter(lo).map((d) => d.dom.getBoundingClientRect()).getOr(s);
      } else
        return s;
    }, ey = (t) => {
      const s = t.selection.getRng(), a = Qv(s);
      if (t.inline) {
        const i = Mc();
        return Rr(i.left + a.left, i.top + a.top, a.width, a.height);
      } else {
        const i = ci(ve.fromDom(t.getBody()));
        return Rr(i.x + a.left, i.y + a.top, a.width, a.height);
      }
    }, l4 = (t, s) => s.filter((a) => qo(a) && vc(a)).map(ci).getOrThunk(() => ey(t)), NF = (t, s, a) => {
      const i = Math.max(t.x + a, s.x), d = Math.min(t.right - a, s.right);
      return {
        x: i,
        width: d - i
      };
    }, MF = (t, s, a, i, d, g) => {
      const p = ve.fromDom(t.getContainer()), C = va(p, ".tox-editor-header").getOr(p), S = Ar(C), _ = S.y >= s.bottom, D = i && !_;
      if (t.inline && D)
        return {
          y: Math.max(S.bottom + g, a.y),
          bottom: a.bottom
        };
      if (t.inline && !D)
        return {
          y: a.y,
          bottom: Math.min(S.y - g, a.bottom)
        };
      const P = d === "line" ? Ar(p) : s;
      return D ? {
        y: Math.max(S.bottom + g, a.y),
        bottom: Math.min(P.bottom - g, a.bottom)
      } : {
        y: Math.max(P.y + g, a.y),
        bottom: Math.min(S.y - g, a.bottom)
      };
    }, PF = (t, s, a, i = 0) => {
      const d = of(window), g = Ar(ve.fromDom(t.getContentAreaContainer())), p = Lx(t) || Vx(t) || y2(t), { x: C, width: S } = NF(g, d, i);
      if (t.inline && !p)
        return Rr(C, d.y, S, d.height);
      {
        const _ = s.header.isPositionedAtTop(), { y: D, bottom: P } = MF(t, g, d, _, a, i);
        return Rr(C, D, S, P - D);
      }
    }, ww = 12, BF = {
      valignCentre: [],
      alignCentre: [],
      alignLeft: ["tox-pop--align-left"],
      alignRight: ["tox-pop--align-right"],
      right: ["tox-pop--right"],
      left: ["tox-pop--left"],
      bottom: ["tox-pop--bottom"],
      top: ["tox-pop--top"],
      inset: ["tox-pop--inset"]
    }, $F = {
      maxHeightFunction: jh(),
      maxWidthFunction: zD()
    }, cW = (t, s) => {
      const a = t.selection.getRng(), i = Ju(ve.fromDom(a.startContainer), a.startOffset);
      return a.startContainer === a.endContainer && a.startOffset === a.endOffset - 1 && Rs(i.element, s);
    }, iW = (t, s, a) => {
      const i = Xs(t, "position");
      _n(t, "position", s);
      const d = a(t);
      return i.each((g) => _n(t, "position", g)), d;
    }, FF = (t) => t === "node", IF = (t, s, a, i, d) => {
      const g = ey(t), p = i.lastElement().exists((C) => Rs(a, C));
      if (cW(t, a))
        return p ? lD : sm;
      if (p)
        return iW(s, i.getMode(), () => RF(g, Ar(s), -20) && !i.isReposition() ? tz : lD);
      {
        const C = i.getMode() === "fixed" ? d.y + Mc().top : d.y, S = hr(s) + ww;
        return C + S <= g.y ? sm : Vv;
      }
    }, WE = (t, s, a, i) => {
      const d = (S) => (_, D, P, L, V) => {
        const Y = IF(t, L, S, a, V), me = {
          ..._,
          y: V.y,
          height: V.height
        };
        return {
          ...Y(me, D, P, L, V),
          alwaysFit: !0
        };
      }, g = (S) => FF(i) ? [d(S)] : [];
      return s ? {
        onLtr: (S) => [
          ec,
          Qa,
          Lc,
          Di,
          Jc,
          fi
        ].concat(g(S)),
        onRtl: (S) => [
          ec,
          Lc,
          Qa,
          Jc,
          Di,
          fi
        ].concat(g(S))
      } : {
        onLtr: (S) => [
          fi,
          ec,
          Di,
          Qa,
          Jc,
          Lc
        ].concat(g(S)),
        onRtl: (S) => [
          fi,
          ec,
          Jc,
          Lc,
          Di,
          Qa
        ].concat(g(S))
      };
    }, LF = (t, s, a, i) => s === "line" ? {
      bubble: Wd(ww, 0, BF),
      layouts: {
        onLtr: () => [Ky],
        onRtl: () => [D1]
      },
      overrides: $F
    } : {
      bubble: Wd(0, ww, BF, 1 / ww),
      layouts: WE(t, a, i, s),
      overrides: $F
    }, ZE = (t, s) => {
      const a = fo(s, (g) => g.predicate(t.dom)), { pass: i, fail: d } = ss(a, (g) => g.type === "contexttoolbar");
      return {
        contextToolbars: i,
        contextForms: d
      };
    }, u4 = (t) => {
      if (t.length <= 1)
        return t;
      {
        const s = (g) => jo(t, (p) => p.position === g), a = (g) => fo(t, (p) => p.position === g), i = s("selection"), d = s("node");
        if (i || d)
          if (d && i) {
            const g = a("node"), p = $e(a("selection"), (C) => ({
              ...C,
              position: "node"
            }));
            return g.concat(p);
          } else
            return a(i ? "selection" : "node");
        else
          return a("line");
      }
    }, lW = (t) => {
      if (t.length <= 1)
        return t;
      {
        const s = (i) => ee(t, (d) => d.position === i);
        return s("selection").orThunk(() => s("node")).orThunk(() => s("line")).map((i) => i.position).fold(() => [], (i) => fo(t, (d) => d.position === i));
      }
    }, HF = (t, s, a) => {
      const i = ZE(t, s);
      if (i.contextForms.length > 0)
        return A.some({
          elem: t,
          toolbars: [i.contextForms[0]]
        });
      {
        const d = ZE(t, a);
        if (d.contextForms.length > 0)
          return A.some({
            elem: t,
            toolbars: [d.contextForms[0]]
          });
        if (i.contextToolbars.length > 0 || d.contextToolbars.length > 0) {
          const g = u4(i.contextToolbars.concat(d.contextToolbars));
          return A.some({
            elem: t,
            toolbars: g
          });
        } else
          return A.none();
      }
    }, uW = (t, s, a) => t(s) ? A.none() : au(s, (i) => {
      if (lo(i)) {
        const { contextToolbars: d, contextForms: g } = ZE(i, a.inNodeScope), p = g.length > 0 ? g : lW(d);
        return p.length > 0 ? A.some({
          elem: i,
          toolbars: p
        }) : A.none();
      } else
        return A.none();
    }, t), dW = (t, s) => {
      const a = ve.fromDom(s.getBody()), i = (p) => Rs(p, a), d = (p) => !i(p) && !ca(a, p), g = ve.fromDom(s.selection.getNode());
      return d(g) ? A.none() : HF(g, t.inNodeScope, t.inEditorScope).orThunk(() => uW(i, g, t));
    }, jE = (t, s) => {
      const a = {}, i = [], d = [], g = {}, p = {}, C = (D, P) => {
        const L = Js(rT(P));
        a[D] = L, L.launch.map((V) => {
          g["form:" + D] = {
            ...P.launch,
            type: V.type === "contextformtogglebutton" ? "togglebutton" : "button",
            onAction: () => {
              s(L);
            }
          };
        }), L.scope === "editor" ? d.push(L) : i.push(L), p[D] = L;
      }, S = (D, P) => {
        uM(P).each((L) => {
          P.scope === "editor" ? d.push(L) : i.push(L), p[D] = L;
        });
      }, _ = Ao(t);
      return ot(_, (D) => {
        const P = t[D];
        P.type === "contextform" ? C(D, P) : P.type === "contexttoolbar" && S(D, P);
      }), {
        forms: a,
        inNodeScope: i,
        inEditorScope: d,
        lookupTable: p,
        formNavigators: g
      };
    }, d4 = An("forward-slide"), zF = An("backward-slide"), m4 = An("change-slide-event"), f4 = "tox-pop--resizing", mW = (t) => {
      const s = w([]);
      return qr.sketch({
        dom: {
          tag: "div",
          classes: ["tox-pop"]
        },
        fireDismissalEventInstead: { event: "doNotDismissYet" },
        onShow: (a) => {
          s.set([]), qr.getContent(a).each((i) => {
            Jo(i.element, "visibility");
          }), Wr(a.element, f4), Jo(a.element, "width");
        },
        inlineBehaviours: Ut([
          Bo("context-toolbar-events", [
            $d(pg(), (a, i) => {
              i.event.raw.propertyName === "width" && (Wr(a.element, f4), Jo(a.element, "width"));
            }),
            mt(m4, (a, i) => {
              const d = a.element;
              Jo(d, "width");
              const g = j(d);
              qr.setContent(a, i.event.contents), ba(d, f4);
              const p = j(d);
              _n(d, "width", g + "px"), qr.getContent(a).each((C) => {
                i.event.focus.bind((S) => (Zi(S), Iu(d))).orThunk(() => (no.focusIn(C), Ud(Ve(d))));
              }), setTimeout(() => {
                _n(a.element, "width", p + "px");
              }, 0);
            }),
            mt(d4, (a, i) => {
              qr.getContent(a).each((d) => {
                s.set(s.get().concat([{
                  bar: d,
                  focus: Ud(Ve(a.element))
                }]));
              }), to(a, m4, {
                contents: i.event.forwardContents,
                focus: A.none()
              });
            }),
            mt(zF, (a, i) => {
              Xo(s.get()).each((d) => {
                s.set(s.get().slice(0, s.get().length - 1)), to(a, m4, {
                  contents: Pl(d.bar),
                  focus: d.focus
                });
              });
            })
          ]),
          no.config({
            mode: "special",
            onEscape: (a) => Xo(s.get()).fold(() => t.onEscape(), (i) => (cs(a, zF), A.some(!0)))
          })
        ]),
        lazySink: () => Mo.value(t.sink)
      });
    }, g4 = "tox-pop--transition", VF = (t, s, a, i) => {
      const d = i.backstage, g = d.shared, p = xl().deviceType.isTouch, C = Go(), S = Go(), _ = Go(), D = Xc(mW({
        sink: a,
        onEscape: () => (t.focus(), A.some(!0))
      })), P = () => {
        const Hn = _.get().getOr("node"), co = FF(Hn) ? 1 : 0;
        return PF(t, g, Hn, co);
      }, L = () => !t.removed && !(p() && d.isContextMenuOpen()), V = (Hn) => aa(fa(Hn, C.get(), Rs), !0), Y = () => {
        if (L()) {
          const Hn = P(), co = aa(_.get(), "node") ? l4(t, C.get()) : ey(t);
          return Hn.height <= 0 || !RF(co, Hn, 0.01);
        } else
          return !0;
      }, me = () => {
        C.clear(), S.clear(), _.clear(), qr.hide(D);
      }, Pe = () => {
        if (qr.isOpen(D)) {
          const Hn = D.element;
          Jo(Hn, "display"), Y() ? _n(Hn, "display", "none") : (S.set(0), qr.reposition(D));
        }
      }, xe = (Hn) => ({
        dom: {
          tag: "div",
          classes: ["tox-pop__dialog"]
        },
        components: [Hn],
        behaviours: Ut([
          no.config({ mode: "acyclic" }),
          Bo("pop-dialog-wrap-events", [
            cr((co) => {
              t.shortcuts.add("ctrl+F9", "focus statusbar", () => no.focusIn(co));
            }),
            Fd((co) => {
              t.shortcuts.remove("ctrl+F9");
            })
          ])
        ])
      }), Ce = je(() => jE(s, (Hn) => {
        const co = ct([Hn]);
        to(D, d4, { forwardContents: xe(co) });
      })), Be = (Hn, co) => HE(t, {
        buttons: Hn,
        toolbar: co.items,
        allowToolbarGroups: !1
      }, i.backstage, A.some(["form:"])), St = (Hn, co) => DF.buildInitGroups(Hn, co), ct = (Hn) => {
        const { buttons: co } = t.ui.registry.getAll(), bo = Ce(), zs = {
          ...co,
          ...bo.formNavigators
        }, ro = Cv(t) === yd.scrolling ? yd.scrolling : yd.default, ys = ye($e(Hn, (Jt) => Jt.type === "contexttoolbar" ? Be(zs, Jt) : St(Jt, g.providers)));
        return kE({
          type: ro,
          uid: An("context-toolbar"),
          initGroups: ys,
          onEscape: A.none,
          cyclicKeying: !0,
          providers: g.providers
        });
      }, tt = (Hn, co) => {
        const bo = Hn === "node" ? g.anchors.node(co) : g.anchors.cursor(), zs = LF(t, Hn, p(), {
          lastElement: C.get,
          isReposition: () => aa(S.get(), 0),
          getMode: () => Qc.getMode(a)
        });
        return Ms(bo, zs);
      }, Vt = (Hn, co) => {
        if ($o.cancel(), !L())
          return;
        const bo = ct(Hn), zs = Hn[0].position, ro = tt(zs, co);
        _.set(zs), S.set(1);
        const ys = D.element;
        Jo(ys, "display"), V(co) || (Wr(ys, g4), Qc.reset(a, D)), qr.showWithinBounds(D, xe(bo), {
          anchor: ro,
          transition: {
            classes: [g4],
            mode: "placement"
          }
        }, () => A.some(P())), co.fold(C.clear, C.set), Y() && _n(ys, "display", "none");
      };
      let Xt = !1;
      const $o = WT(() => {
        if (!(!t.hasFocus() || t.removed || Xt))
          if (Ha(D.element, g4))
            $o.throttle();
          else {
            const Hn = Ce();
            dW(Hn, t).fold(me, (co) => {
              Vt(co.toolbars, A.some(co.elem));
            });
          }
      }, 17);
      t.on("init", () => {
        t.on("remove", me), t.on("ScrollContent ScrollWindow ObjectResized ResizeEditor longpress", Pe), t.on("click keyup focus SetContent", $o.throttle), t.on(kF, me), t.on(nW, (Hn) => {
          const co = Ce();
          Dt(co.lookupTable, Hn.toolbarKey).each((bo) => {
            Vt([bo], Zn(Hn.target !== t, Hn.target)), qr.getContent(D).each(no.focusIn);
          });
        }), t.on("focusout", (Hn) => {
          bb.setEditorTimeout(t, () => {
            Iu(a.element).isNone() && Iu(D.element).isNone() && me();
          }, 0);
        }), t.on("SwitchMode", () => {
          t.mode.isReadOnly() && me();
        }), t.on("AfterProgressState", (Hn) => {
          Hn.state ? me() : t.hasFocus() && $o.throttle();
        }), t.on("dragstart", () => {
          Xt = !0;
        }), t.on("dragend drop", () => {
          Xt = !1;
        }), t.on("NodeChange", (Hn) => {
          Iu(D.element).fold($o.throttle, J);
        });
      });
    }, UF = (t) => {
      ot([
        {
          name: "alignleft",
          text: "Align left",
          cmd: "JustifyLeft",
          icon: "align-left"
        },
        {
          name: "aligncenter",
          text: "Align center",
          cmd: "JustifyCenter",
          icon: "align-center"
        },
        {
          name: "alignright",
          text: "Align right",
          cmd: "JustifyRight",
          icon: "align-right"
        },
        {
          name: "alignjustify",
          text: "Justify",
          cmd: "JustifyFull",
          icon: "align-justify"
        }
      ], (a) => {
        t.ui.registry.addToggleButton(a.name, {
          tooltip: a.text,
          icon: a.icon,
          onAction: Wl(t, a.cmd),
          onSetup: mT(t, a.name)
        });
      }), t.ui.registry.addButton("alignnone", {
        tooltip: "No alignment",
        icon: "align-none",
        onSetup: Xi(t),
        onAction: Wl(t, "JustifyNone")
      });
    }, WF = (t, s) => {
      const a = () => {
        const i = s.getOptions(t), d = s.getCurrent(t).map(s.hash), g = Go();
        return $e(i, (p) => ({
          type: "togglemenuitem",
          text: s.display(p),
          onSetup: (C) => {
            const S = (D) => {
              D && (g.on((P) => P.setActive(!1)), g.set(C)), C.setActive(D);
            };
            S(aa(d, s.hash(p)));
            const _ = s.watcher(t, p, S);
            return () => {
              g.clear(), _();
            };
          },
          onAction: () => s.setCurrent(t, p)
        }));
      };
      t.ui.registry.addMenuButton(s.name, {
        tooltip: s.text,
        icon: s.icon,
        fetch: (i) => i(a()),
        onSetup: s.onToolbarSetup
      }), t.ui.registry.addNestedMenuItem(s.name, {
        type: "nestedmenuitem",
        text: s.text,
        getSubmenuItems: a,
        onSetup: s.onMenuSetup
      });
    }, fW = (t) => ({
      name: "lineheight",
      text: "Line height",
      icon: "line-height",
      getOptions: RN,
      hash: (s) => SU(s, [
        "fixed",
        "relative",
        "empty"
      ]).getOr(s),
      display: Tt,
      watcher: (s, a, i) => s.formatter.formatChanged("lineheight", i, !1, { value: a }).unbind,
      getCurrent: (s) => A.from(s.queryCommandValue("LineHeight")),
      setCurrent: (s, a) => s.execCommand("LineHeight", !1, a),
      onToolbarSetup: Xi(t),
      onMenuSetup: Xi(t)
    }), ZF = (t) => A.from(Mx(t)).map((a) => ({
      name: "language",
      text: "Language",
      icon: "language",
      getOptions: U(a),
      hash: (i) => Zt(i.customCode) ? i.code : `${i.code}/${i.customCode}`,
      display: (i) => i.title,
      watcher: (i, d, g) => {
        var p;
        return i.formatter.formatChanged("lang", g, !1, {
          value: d.code,
          customValue: (p = d.customCode) !== null && p !== void 0 ? p : null
        }).unbind;
      },
      getCurrent: (i) => {
        const d = ve.fromDom(i.selection.getNode());
        return Vi(d, (g) => A.some(g).filter(lo).bind((p) => B(p, "lang").map((S) => {
          const _ = B(p, "data-mce-lang").getOrUndefined();
          return {
            code: S,
            customCode: _,
            title: ""
          };
        })));
      },
      setCurrent: (i, d) => i.execCommand("Lang", !1, d),
      onToolbarSetup: (i) => {
        const d = Om();
        return i.setActive(t.formatter.match("lang", {}, void 0, !0)), d.set(t.formatter.formatChanged("lang", i.setActive, !0)), N2(d.clear, Xi(t)(i));
      },
      onMenuSetup: Xi(t)
    })), gW = (t) => {
      WF(t, fW(t)), ZF(t).each((s) => WF(t, s));
    }, hW = (t, s) => {
      fU(t, s), yU(t, s), PU(t, s), pU(t, s), aF(t, s);
    }, pW = (t) => Qd(t, "NodeChange", (s) => {
      s.setEnabled(t.queryCommandState("outdent") && t.selection.isEditable());
    }), bW = (t) => {
      t.ui.registry.addButton("outdent", {
        tooltip: "Decrease indent",
        icon: "outdent",
        onSetup: pW(t),
        onAction: Wl(t, "outdent")
      }), t.ui.registry.addButton("indent", {
        tooltip: "Increase indent",
        icon: "indent",
        onSetup: Xi(t),
        onAction: Wl(t, "indent")
      });
    }, vW = (t) => {
      bW(t);
    }, qE = (t, s) => (a) => {
      a.setActive(s.get());
      const i = (d) => {
        s.set(d.state), a.setActive(d.state);
      };
      return t.on("PastePlainTextToggle", i), N2(() => t.off("PastePlainTextToggle", i), Xi(t)(a));
    }, yW = (t) => {
      const s = w(_N(t)), a = () => t.execCommand("mceTogglePlainTextPaste");
      t.ui.registry.addToggleButton("pastetext", {
        active: !1,
        icon: "paste-text",
        tooltip: "Paste as text",
        onAction: a,
        onSetup: qE(t, s)
      }), t.ui.registry.addToggleMenuItem("pastetext", {
        text: "Paste as text",
        icon: "paste-text",
        onAction: a,
        onSetup: qE(t, s)
      });
    }, h4 = (t, s) => () => {
      t.execCommand("mceToggleFormat", !1, s);
    }, p4 = (t) => {
      Qg.each([
        {
          name: "bold",
          text: "Bold",
          icon: "bold"
        },
        {
          name: "italic",
          text: "Italic",
          icon: "italic"
        },
        {
          name: "underline",
          text: "Underline",
          icon: "underline"
        },
        {
          name: "strikethrough",
          text: "Strikethrough",
          icon: "strike-through"
        },
        {
          name: "subscript",
          text: "Subscript",
          icon: "subscript"
        },
        {
          name: "superscript",
          text: "Superscript",
          icon: "superscript"
        }
      ], (s, a) => {
        t.ui.registry.addToggleButton(s.name, {
          tooltip: s.text,
          icon: s.icon,
          onSetup: mT(t, s.name),
          onAction: h4(t, s.name)
        });
      });
      for (let s = 1; s <= 6; s++) {
        const a = "h" + s;
        t.ui.registry.addToggleButton(a, {
          text: a.toUpperCase(),
          tooltip: "Heading " + s,
          onSetup: mT(t, a),
          onAction: h4(t, a)
        });
      }
    }, jF = (t) => {
      Qg.each([
        {
          name: "copy",
          text: "Copy",
          action: "Copy",
          icon: "copy"
        },
        {
          name: "help",
          text: "Help",
          action: "mceHelp",
          icon: "help"
        },
        {
          name: "selectall",
          text: "Select all",
          action: "SelectAll",
          icon: "select-all"
        },
        {
          name: "newdocument",
          text: "New document",
          action: "mceNewDocument",
          icon: "new-document"
        },
        {
          name: "print",
          text: "Print",
          action: "mcePrint",
          icon: "print"
        }
      ], (s) => {
        t.ui.registry.addButton(s.name, {
          tooltip: s.text,
          icon: s.icon,
          onAction: Wl(t, s.action)
        });
      }), Qg.each([
        {
          name: "cut",
          text: "Cut",
          action: "Cut",
          icon: "cut"
        },
        {
          name: "paste",
          text: "Paste",
          action: "Paste",
          icon: "paste"
        },
        {
          name: "removeformat",
          text: "Clear formatting",
          action: "RemoveFormat",
          icon: "remove-formatting"
        },
        {
          name: "remove",
          text: "Remove",
          action: "Delete",
          icon: "remove"
        },
        {
          name: "hr",
          text: "Horizontal line",
          action: "InsertHorizontalRule",
          icon: "horizontal-rule"
        }
      ], (s) => {
        t.ui.registry.addButton(s.name, {
          tooltip: s.text,
          icon: s.icon,
          onSetup: Xi(t),
          onAction: Wl(t, s.action)
        });
      });
    }, qF = (t) => {
      Qg.each([{
        name: "blockquote",
        text: "Blockquote",
        action: "mceBlockQuote",
        icon: "quote"
      }], (s) => {
        t.ui.registry.addToggleButton(s.name, {
          tooltip: s.text,
          icon: s.icon,
          onAction: Wl(t, s.action),
          onSetup: mT(t, s.name)
        });
      });
    }, CW = (t) => {
      p4(t), jF(t), qF(t);
    }, wW = (t) => {
      Qg.each([
        {
          name: "newdocument",
          text: "New document",
          action: "mceNewDocument",
          icon: "new-document"
        },
        {
          name: "copy",
          text: "Copy",
          action: "Copy",
          icon: "copy",
          shortcut: "Meta+C"
        },
        {
          name: "selectall",
          text: "Select all",
          action: "SelectAll",
          icon: "select-all",
          shortcut: "Meta+A"
        },
        {
          name: "print",
          text: "Print...",
          action: "mcePrint",
          icon: "print",
          shortcut: "Meta+P"
        }
      ], (s) => {
        t.ui.registry.addMenuItem(s.name, {
          text: s.text,
          icon: s.icon,
          shortcut: s.shortcut,
          onAction: Wl(t, s.action)
        });
      }), Qg.each([
        {
          name: "bold",
          text: "Bold",
          action: "Bold",
          icon: "bold",
          shortcut: "Meta+B"
        },
        {
          name: "italic",
          text: "Italic",
          action: "Italic",
          icon: "italic",
          shortcut: "Meta+I"
        },
        {
          name: "underline",
          text: "Underline",
          action: "Underline",
          icon: "underline",
          shortcut: "Meta+U"
        },
        {
          name: "strikethrough",
          text: "Strikethrough",
          action: "Strikethrough",
          icon: "strike-through"
        },
        {
          name: "subscript",
          text: "Subscript",
          action: "Subscript",
          icon: "subscript"
        },
        {
          name: "superscript",
          text: "Superscript",
          action: "Superscript",
          icon: "superscript"
        },
        {
          name: "removeformat",
          text: "Clear formatting",
          action: "RemoveFormat",
          icon: "remove-formatting"
        },
        {
          name: "cut",
          text: "Cut",
          action: "Cut",
          icon: "cut",
          shortcut: "Meta+X"
        },
        {
          name: "paste",
          text: "Paste",
          action: "Paste",
          icon: "paste",
          shortcut: "Meta+V"
        },
        {
          name: "hr",
          text: "Horizontal line",
          action: "InsertHorizontalRule",
          icon: "horizontal-rule"
        }
      ], (s) => {
        t.ui.registry.addMenuItem(s.name, {
          text: s.text,
          icon: s.icon,
          shortcut: s.shortcut,
          onSetup: Xi(t),
          onAction: Wl(t, s.action)
        });
      }), t.ui.registry.addMenuItem("codeformat", {
        text: "Code",
        icon: "sourcecode",
        onSetup: Xi(t),
        onAction: h4(t, "code")
      });
    }, SW = (t) => {
      CW(t), wW(t);
    }, GE = (t, s) => Qd(t, "Undo Redo AddUndo TypingUndo ClearUndos SwitchMode", (a) => {
      a.setEnabled(!t.mode.isReadOnly() && t.undoManager[s]());
    }), xW = (t) => {
      t.ui.registry.addMenuItem("undo", {
        text: "Undo",
        icon: "undo",
        shortcut: "Meta+Z",
        onSetup: GE(t, "hasUndo"),
        onAction: Wl(t, "undo")
      }), t.ui.registry.addMenuItem("redo", {
        text: "Redo",
        icon: "redo",
        shortcut: "Meta+Y",
        onSetup: GE(t, "hasRedo"),
        onAction: Wl(t, "redo")
      });
    }, b4 = (t) => {
      t.ui.registry.addButton("undo", {
        tooltip: "Undo",
        icon: "undo",
        enabled: !1,
        onSetup: GE(t, "hasUndo"),
        onAction: Wl(t, "undo")
      }), t.ui.registry.addButton("redo", {
        tooltip: "Redo",
        icon: "redo",
        enabled: !1,
        onSetup: GE(t, "hasRedo"),
        onAction: Wl(t, "redo")
      });
    }, TW = (t) => {
      xW(t), b4(t);
    }, GF = (t) => Qd(t, "VisualAid", (s) => {
      s.setActive(t.hasVisual);
    }), EW = (t) => {
      t.ui.registry.addToggleMenuItem("visualaid", {
        text: "Visual aids",
        onSetup: GF(t),
        onAction: Wl(t, "mceToggleVisualAid")
      });
    }, kW = (t) => {
      t.ui.registry.addButton("visualaid", {
        tooltip: "Visual aids",
        text: "Visual aids",
        onAction: Wl(t, "mceToggleVisualAid")
      });
    }, v4 = (t) => {
      kW(t), EW(t);
    }, _W = (t, s) => {
      UF(t), SW(t), hW(t, s), TW(t), oP(t), v4(t), vW(t), gW(t), yW(t);
    }, KF = (t) => Ee(t) ? t.split(/[ ,]/) : t, YF = (t) => (s) => s.options.get(t), AW = (t) => {
      const s = t.options.register;
      s("contextmenu_avoid_overlap", {
        processor: "string",
        default: ""
      }), s("contextmenu_never_use_native", {
        processor: "boolean",
        default: !1
      }), s("contextmenu", {
        processor: (a) => a === !1 ? {
          value: [],
          valid: !0
        } : Ee(a) || Kt(a, Ee) ? {
          value: KF(a),
          valid: !0
        } : {
          valid: !1,
          message: "Must be false or a string."
        },
        default: "link linkchecker image editimage table spellchecker configurepermanentpen"
      });
    }, KE = YF("contextmenu_never_use_native"), OW = YF("contextmenu_avoid_overlap"), DW = (t) => XF(t).length === 0, XF = (t) => {
      const s = t.ui.registry.getAll().contextMenus, a = t.options.get("contextmenu");
      return t.options.isSet("contextmenu") ? a : fo(a, (i) => Lo(s, i));
    }, Sw = (t, s) => ({
      type: "makeshift",
      x: t,
      y: s
    }), RW = (t, s, a) => Sw(t.x + s, t.y + a), y4 = (t) => t.type === "longpress" || t.type.indexOf("touch") === 0, NW = (t) => {
      if (y4(t)) {
        const s = t.touches[0];
        return Sw(s.pageX, s.pageY);
      } else
        return Sw(t.pageX, t.pageY);
    }, MW = (t) => {
      if (y4(t)) {
        const s = t.touches[0];
        return Sw(s.clientX, s.clientY);
      } else
        return Sw(t.clientX, t.clientY);
    }, PW = (t, s) => {
      const a = vv.DOM.getPos(t);
      return RW(s, a.x, a.y);
    }, BW = (t, s) => s.type === "contextmenu" || s.type === "longpress" ? t.inline ? NW(s) : PW(t.getContentAreaContainer(), MW(s)) : JF(t), JF = (t) => ({
      type: "selection",
      root: ve.fromDom(t.selection.getNode())
    }), $W = (t) => ({
      type: "node",
      node: A.some(ve.fromDom(t.selection.getNode())),
      root: ve.fromDom(t.getBody())
    }), QF = (t, s, a) => {
      switch (a) {
        case "node":
          return $W(t);
        case "point":
          return BW(t, s);
        case "selection":
          return JF(t);
      }
    }, FW = (t, s, a, i, d, g) => {
      const p = a(), C = QF(t, s, g);
      Lv(p, Um.CLOSE_ON_EXECUTE, i, {
        isHorizontalMenu: !1,
        search: A.none()
      }).map((S) => {
        s.preventDefault(), qr.showMenuAt(d, { anchor: C }, {
          menu: { markers: Hf("normal") },
          data: S
        });
      });
    }, eI = {
      onLtr: () => [
        ec,
        Qa,
        Lc,
        Di,
        Jc,
        fi,
        sm,
        Vv,
        cw,
        aw,
        Mb,
        rw
      ],
      onRtl: () => [
        ec,
        Lc,
        Qa,
        Jc,
        Di,
        fi,
        sm,
        Vv,
        Mb,
        rw,
        cw,
        aw
      ]
    }, IW = 12, tI = {
      valignCentre: [],
      alignCentre: [],
      alignLeft: ["tox-pop--align-left"],
      alignRight: ["tox-pop--align-right"],
      right: ["tox-pop--right"],
      left: ["tox-pop--left"],
      bottom: ["tox-pop--bottom"],
      top: ["tox-pop--top"]
    }, LW = (t, s) => {
      const a = t.selection;
      if (a.isCollapsed() || s.touches.length < 1)
        return !1;
      {
        const i = s.touches[0], d = a.getRng();
        return TC(t.getWin(), xc.domRange(d)).exists((p) => p.left <= i.clientX && p.right >= i.clientX && p.top <= i.clientY && p.bottom >= i.clientY);
      }
    }, HW = (t) => {
      const s = t.selection.getRng(), a = () => {
        bb.setEditorTimeout(t, () => {
          t.selection.setRng(s);
        }, 10), g();
      };
      t.once("touchend", a);
      const i = (p) => {
        p.preventDefault(), p.stopImmediatePropagation();
      };
      t.on("mousedown", i, !0);
      const d = () => g();
      t.once("longpresscancel", d);
      const g = () => {
        t.off("touchend", a), t.off("longpresscancel", d), t.off("mousedown", i);
      };
    }, zW = (t, s, a) => {
      const i = QF(t, s, a);
      return {
        bubble: Wd(0, a === "point" ? IW : 0, tI),
        layouts: eI,
        overrides: {
          maxWidthFunction: zD(),
          maxHeightFunction: jh()
        },
        ...i
      };
    }, Fb = (t, s, a, i, d, g, p) => {
      const C = zW(t, s, g);
      Lv(a, Um.CLOSE_ON_EXECUTE, i, {
        isHorizontalMenu: !0,
        search: A.none()
      }).map((S) => {
        s.preventDefault();
        const _ = p ? Yi.HighlightMenuAndItem : Yi.HighlightNone;
        qr.showMenuWithinBounds(d, { anchor: C }, {
          menu: {
            markers: Hf("normal"),
            highlightOnOpen: _
          },
          data: S,
          type: "horizontal"
        }, () => A.some(PF(t, i.shared, g === "node" ? "node" : "selection"))), t.dispatch(kF);
      });
    }, nI = (t, s, a, i, d, g) => {
      const p = xl(), C = p.os.isiOS(), S = p.os.isMacOS(), _ = p.os.isAndroid(), D = p.deviceType.isTouch(), P = () => !(_ || C || S && D), L = () => {
        const V = a();
        Fb(t, s, V, i, d, g, P());
      };
      if ((S || C) && g !== "node") {
        const V = () => {
          HW(t), L();
        };
        LW(t, s) ? V() : (t.once("selectionchange", V), t.once("touchend", () => t.off("selectionchange", V)));
      } else
        L();
    }, oI = (t) => Ee(t) ? t === "|" : t.type === "separator", C4 = { type: "separator" }, sI = (t) => {
      const s = (a) => ({
        text: a.text,
        icon: a.icon,
        enabled: a.enabled,
        shortcut: a.shortcut
      });
      if (Ee(t))
        return t;
      switch (t.type) {
        case "separator":
          return C4;
        case "submenu":
          return {
            type: "nestedmenuitem",
            ...s(t),
            getSubmenuItems: () => {
              const i = t.getSubmenuItems();
              return Ee(i) ? i : $e(i, sI);
            }
          };
        default:
          const a = t;
          return {
            type: "menuitem",
            ...s(a),
            onAction: Qe(a.onAction)
          };
      }
    }, rI = (t, s) => {
      if (s.length === 0)
        return t;
      const i = Xo(t).filter((d) => !oI(d)).fold(() => [], (d) => [C4]);
      return t.concat(i).concat(s).concat([C4]);
    }, aI = (t, s, a) => {
      const i = lt(s, (d, g) => Dt(t, g.toLowerCase()).map((p) => {
        const C = p.update(a);
        if (Ee(C) && de(wr(C)))
          return rI(d, C.split(" "));
        if (dn(C) && C.length > 0) {
          const S = $e(C, sI);
          return rI(d, S);
        } else
          return d;
      }).getOrThunk(() => d.concat([g])), []);
      return i.length > 0 && oI(i[i.length - 1]) && i.pop(), i;
    }, VW = (t, s) => s.ctrlKey && !KE(t), UW = (t) => t.type === "longpress" || Lo(t, "touches"), cI = (t, s) => !UW(s) && (s.button !== 2 || s.target === t.getBody() && s.pointerType === ""), iI = (t, s) => cI(t, s) ? t.selection.getStart(!0) : s.target, WW = (t, s) => {
      const a = OW(t), i = cI(t, s) ? "selection" : "point";
      if (de(a)) {
        const d = iI(t, s);
        return $2(ve.fromDom(d), a) ? "node" : i;
      } else
        return i;
    }, ZW = (t, s, a) => {
      const d = xl().deviceType.isTouch, g = Xc(qr.sketch({
        dom: { tag: "div" },
        lazySink: s,
        onEscape: () => t.focus(),
        onShow: () => a.setContextMenuState(!0),
        onHide: () => a.setContextMenuState(!1),
        fireDismissalEventInstead: {},
        inlineBehaviours: Ut([Bo("dismissContextMenu", [mt(bf(), (S, _) => {
          is.close(S), t.focus();
        })])])
      })), p = () => qr.hide(g), C = (S) => {
        if (KE(t) && S.preventDefault(), VW(t, S) || DW(t))
          return;
        const _ = WW(t, S), D = () => {
          const L = iI(t, S), V = t.ui.registry.getAll(), Y = XF(t);
          return aI(V.contextMenus, Y, L);
        };
        (d() ? nI : FW)(t, S, D, a, g, _);
      };
      t.on("init", () => {
        const S = "ResizeEditor ScrollContent ScrollWindow longpresscancel" + (d() ? "" : " ResizeWindow");
        t.on(S, p), t.on("longpress contextmenu", C);
      });
    }, w4 = H.generate([
      {
        offset: [
          "x",
          "y"
        ]
      },
      {
        absolute: [
          "x",
          "y"
        ]
      },
      {
        fixed: [
          "x",
          "y"
        ]
      }
    ]), YE = (t) => (s) => s.translate(-t.left, -t.top), XE = (t) => (s) => s.translate(t.left, t.top), th = (t) => (s, a) => lt(t, (i, d) => d(i), Es(s, a)), xw = (t, s, a) => t.fold(th([
      XE(a),
      YE(s)
    ]), th([YE(s)]), th([])), Ib = (t, s, a) => t.fold(th([XE(a)]), th([]), th([XE(s)])), lI = (t, s, a) => t.fold(th([]), th([YE(a)]), th([
      XE(s),
      YE(a)
    ])), Tw = (t, s, a, i, d, g) => {
      const p = Ib(t, d, g), C = Ib(s, d, g);
      return Math.abs(p.left - C.left) <= a && Math.abs(p.top - C.top) <= i;
    }, jW = (t, s, a, i, d, g) => {
      const p = Ib(t, d, g), C = Ib(s, d, g), S = Math.abs(p.left - C.left), _ = Math.abs(p.top - C.top);
      return Es(S, _);
    }, uI = (t, s, a) => {
      const i = t.fold((d, g) => ({
        position: A.some("absolute"),
        left: A.some(d + "px"),
        top: A.some(g + "px")
      }), (d, g) => ({
        position: A.some("absolute"),
        left: A.some(d - a.left + "px"),
        top: A.some(g - a.top + "px")
      }), (d, g) => ({
        position: A.some("fixed"),
        left: A.some(d + "px"),
        top: A.some(g + "px")
      }));
      return {
        right: A.none(),
        bottom: A.none(),
        ...i
      };
    }, S4 = (t, s, a) => t.fold((i, d) => JE(i + s, d + a), (i, d) => Zp(i + s, d + a), (i, d) => Lb(i + s, d + a)), x4 = (t, s, a, i) => {
      const d = (g, p) => (C, S) => {
        const _ = g(s, a, i);
        return p(C.getOr(_.left), S.getOr(_.top));
      };
      return t.fold(d(lI, JE), d(Ib, Zp), d(xw, Lb));
    }, JE = w4.offset, Zp = w4.absolute, Lb = w4.fixed, dI = (t, s) => {
      const a = rr(t, s);
      return Zt(a) ? NaN : parseInt(a, 10);
    }, qW = (t, s) => {
      const a = t.element, i = dI(a, s.leftAttr), d = dI(a, s.topAttr);
      return isNaN(i) || isNaN(d) ? A.none() : A.some(Es(i, d));
    }, GW = (t, s, a) => {
      const i = t.element;
      sn(i, s.leftAttr, a.left + "px"), sn(i, s.topAttr, a.top + "px");
    }, KW = (t, s) => {
      const a = t.element;
      se(a, s.leftAttr), se(a, s.topAttr);
    }, YW = (t, s, a, i) => qW(t, s).fold(() => a, (d) => Lb(d.left + i.left, d.top + i.top)), XW = (t, s, a, i, d, g) => {
      const p = YW(t, s, a, i), C = s.mustSnap ? QW(t, s, p, d, g) : eZ(t, s, p, d, g), S = xw(p, d, g);
      return GW(t, s, S), C.fold(() => ({
        coord: Lb(S.left, S.top),
        extra: A.none()
      }), (_) => ({
        coord: _.output,
        extra: _.extra
      }));
    }, JW = (t, s) => {
      KW(t, s);
    }, mI = (t, s, a, i) => No(t, (d) => {
      const g = d.sensor;
      return Tw(s, g, d.range.left, d.range.top, a, i) ? A.some({
        output: x4(d.output, s, a, i),
        extra: d.extra
      }) : A.none();
    }), QW = (t, s, a, i, d) => {
      const g = s.getSnapPoints(t);
      return mI(g, a, i, d).orThunk(() => lt(g, (S, _) => {
        const D = _.sensor, P = jW(a, D, _.range.left, _.range.top, i, d);
        return S.deltas.fold(() => ({
          deltas: A.some(P),
          snap: A.some(_)
        }), (L) => {
          const V = (P.left + P.top) / 2, Y = (L.left + L.top) / 2;
          return V <= Y ? {
            deltas: A.some(P),
            snap: A.some(_)
          } : S;
        });
      }, {
        deltas: A.none(),
        snap: A.none()
      }).snap.map((S) => ({
        output: x4(S.output, a, i, d),
        extra: S.extra
      })));
    }, eZ = (t, s, a, i, d) => {
      const g = s.getSnapPoints(t);
      return mI(g, a, i, d);
    }, tZ = (t, s, a) => ({
      coord: x4(t.output, t.output, s, a),
      extra: t.extra
    });
    var nZ = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      snapTo: (t, s, a, i) => {
        const d = s.getTarget(t.element);
        if (s.repositionTarget) {
          const g = Ia(t.element), p = Mc(g), C = W$(d), S = tZ(i, p, C), _ = uI(S.coord, p, C);
          _t(d, _);
        }
      }
    });
    const ty = "data-initial-z-index", oZ = (t) => {
      Ta(t.element).filter(lo).each((s) => {
        B(s, ty).fold(() => Jo(s, "z-index"), (a) => _n(s, "z-index", a)), se(s, ty);
      });
    }, sZ = (t) => {
      Ta(t.element).filter(lo).each((s) => {
        Xs(s, "z-index").each((a) => {
          sn(s, ty, a);
        }), _n(s, "z-index", Us(t.element, "z-index"));
      });
    }, fI = (t, s) => {
      t.getSystem().addToGui(s), sZ(s);
    }, rZ = (t) => {
      oZ(t), t.getSystem().removeFromGui(t);
    }, gI = (t, s, a) => t.getSystem().build(Zm.sketch({
      dom: {
        styles: {
          left: "0px",
          top: "0px",
          width: "100%",
          height: "100%",
          position: "fixed",
          "z-index": "1000000000000000"
        },
        classes: [s]
      },
      events: a
    }));
    var aZ = ui("snaps", [
      gt("getSnapPoints"),
      gs("onSensor"),
      gt("leftAttr"),
      gt("topAttr"),
      Ne("lazyViewport", La),
      Ne("mustSnap", !1)
    ]);
    const QE = [
      Ne("useFixed", Te),
      gt("blockerClass"),
      Ne("getTarget", Tt),
      Ne("onDrag", J),
      Ne("repositionTarget", !0),
      Ne("onDrop", J),
      _a("getBounds", La),
      aZ
    ], cZ = (t) => Qr(Xs(t, "left"), Xs(t, "top"), Xs(t, "position"), (s, a, i) => (i === "fixed" ? Lb : JE)(parseInt(s, 10), parseInt(a, 10))).getOrThunk(() => {
      const s = Cc(t);
      return Zp(s.left, s.top);
    }), iZ = (t, s, a, i, d) => {
      const g = d.bounds, p = Ib(s, a, i), C = Bl(p.left, g.x, g.x + g.width - d.width), S = Bl(p.top, g.y, g.y + g.height - d.height), _ = Zp(C, S);
      return s.fold(() => {
        const D = lI(_, a, i);
        return JE(D.left, D.top);
      }, U(_), () => {
        const D = xw(_, a, i);
        return Lb(D.left, D.top);
      });
    }, lZ = (t, s, a, i, d, g, p) => {
      const C = s.fold(() => {
        const S = S4(a, g.left, g.top), _ = xw(S, i, d);
        return Lb(_.left, _.top);
      }, (S) => {
        const _ = XW(t, S, a, g, i, d);
        return _.extra.each((D) => {
          S.onSensor(t, D);
        }), _.coord;
      });
      return iZ(t, C, i, d, p);
    }, uZ = (t, s, a, i) => {
      const d = s.getTarget(t.element);
      if (s.repositionTarget) {
        const g = Ia(t.element), p = Mc(g), C = W$(d), S = cZ(d), _ = lZ(t, s.snaps, S, p, C, i, a), D = uI(_, p, C);
        _t(d, D);
      }
      s.onDrag(t, d, i);
    }, hI = (t, s) => ({
      bounds: t.getBounds(),
      height: yu(s.element),
      width: oe(s.element)
    }), Ew = (t, s, a, i, d) => {
      const g = a.update(i, d), p = a.getStartData().getOrThunk(() => hI(s, t));
      g.each((C) => {
        uZ(t, s, p, C);
      });
    }, T4 = (t, s, a, i) => {
      s.each(rZ), a.snaps.each((g) => {
        JW(t, g);
      });
      const d = a.getTarget(t.element);
      i.reset(), a.onDrop(t, d);
    }, E4 = (t) => (s, a) => {
      const i = (d) => {
        a.setStartData(hI(s, d));
      };
      return vr([
        mt(Bd(), (d) => {
          a.getStartData().each(() => i(d));
        }),
        ...t(s, a, i)
      ]);
    }, dZ = (t) => vr([
      mt(Zs(), t.forceDrop),
      mt(m1(), t.drop),
      mt(Bc(), (s, a) => {
        t.move(a.event);
      }),
      mt(mf(), t.delayDrop)
    ]);
    var mZ = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      getData: (t) => A.from(Es(t.x, t.y)),
      getDelta: (t, s) => Es(s.left - t.left, s.top - t.top)
    });
    const pI = (t, s, a) => [mt(Zs(), (i, d) => {
      if (d.event.raw.button !== 0)
        return;
      d.stop();
      const p = () => T4(i, A.some(_), t, s), C = vP(p, 200), S = {
        drop: p,
        delayDrop: C.schedule,
        forceDrop: p,
        move: (P) => {
          C.cancel(), Ew(i, t, s, mZ, P);
        }
      }, _ = gI(i, t.blockerClass, dZ(S));
      (() => {
        a(i), fI(i, _);
      })();
    })], fZ = [
      ...QE,
      Qs("dragger", { handlers: E4(pI) })
    ], gZ = (t) => vr([
      mt(Mu(), t.forceDrop),
      mt(as(), t.drop),
      mt(Ur(), t.drop),
      mt(df(), (s, a) => {
        t.move(a.event);
      })
    ]), hZ = (t) => {
      const s = t[0];
      return A.some(Es(s.clientX, s.clientY));
    };
    var bI = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      getData: (t) => {
        const a = t.raw.touches;
        return a.length === 1 ? hZ(a) : A.none();
      },
      getDelta: (t, s) => Es(s.left - t.left, s.top - t.top)
    });
    const vI = (t, s, a) => {
      const i = Go(), d = (g) => {
        T4(g, i.get(), t, s), i.clear();
      };
      return [
        mt(Mu(), (g, p) => {
          p.stop();
          const C = () => d(g), S = {
            drop: C,
            delayDrop: J,
            forceDrop: C,
            move: (P) => {
              Ew(g, t, s, bI, P);
            }
          }, _ = gI(g, t.blockerClass, gZ(S));
          i.set(_), (() => {
            a(g), fI(g, _);
          })();
        }),
        mt(df(), (g, p) => {
          p.stop(), Ew(g, t, s, bI, p.event);
        }),
        mt(as(), (g, p) => {
          p.stop(), d(g);
        }),
        mt(Ur(), d)
      ];
    }, pZ = [
      ...QE,
      Qs("dragger", { handlers: E4(vI) })
    ], bZ = (t, s, a) => [
      ...pI(t, s, a),
      ...vI(t, s, a)
    ], vZ = [
      ...QE,
      Qs("dragger", { handlers: E4(bZ) })
    ];
    var CZ = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      mouse: fZ,
      touch: pZ,
      mouseOrTouch: vZ
    }), wZ = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      init: () => {
        let t = A.none(), s = A.none();
        const a = () => {
          t = A.none(), s = A.none();
        }, i = (S, _) => {
          const D = t.map((P) => S.getDelta(P, _));
          return t = A.some(_), D;
        }, d = (S, _) => S.getData(_).bind((D) => i(S, D)), g = (S) => {
          s = A.some(S);
        }, p = () => s, C = U({});
        return il({
          readState: C,
          reset: a,
          update: d,
          getStartData: p,
          setStartData: g
        });
      }
    });
    const Hb = D0({
      branchKey: "mode",
      branches: CZ,
      name: "dragging",
      active: {
        events: (t, s) => t.dragger.handlers(t, s)
      },
      extra: {
        snap: (t) => ({
          sensor: t.sensor,
          range: t.range,
          output: t.output,
          extra: A.from(t.extra)
        })
      },
      state: wZ,
      apis: nZ
    }), k4 = 40, ek = k4 / 2, yI = (t, s, a, i, d, g) => t.fold(() => Hb.snap({
      sensor: Zp(a - ek, i - ek),
      range: Es(d, g),
      output: Zp(A.some(a), A.some(i)),
      extra: { td: s }
    }), (p) => {
      const C = a - ek, S = i - ek, _ = k4, D = k4, P = p.element.dom.getBoundingClientRect();
      return Hb.snap({
        sensor: Zp(C, S),
        range: Es(_, D),
        output: Zp(A.some(a - P.width / 2), A.some(i - P.height / 2)),
        extra: { td: s }
      });
    }), _4 = (t, s, a) => {
      const i = (d, g) => d.exists((p) => Rs(p, g));
      return {
        getSnapPoints: t,
        leftAttr: "data-drag-left",
        topAttr: "data-drag-top",
        onSensor: (d, g) => {
          const p = g.td;
          i(s.get(), p) || (s.set(p), a(p));
        },
        mustSnap: !0
      };
    }, A4 = (t) => js(Ec.sketch({
      dom: {
        tag: "div",
        classes: ["tox-selector"]
      },
      buttonBehaviours: Ut([
        Hb.config({
          mode: "mouseOrTouch",
          blockerClass: "blocker",
          snaps: t
        }),
        z2.config({})
      ]),
      eventOrder: {
        mousedown: [
          "dragging",
          "alloy.base.behaviour"
        ],
        touchstart: [
          "dragging",
          "alloy.base.behaviour"
        ]
      }
    })), zb = (t, s) => {
      const a = w([]), i = w([]), d = w(!1), g = Go(), p = Go(), C = (Vt) => {
        const Xt = ci(Vt);
        return yI(V.getOpt(s), Vt, Xt.x, Xt.y, Xt.width, Xt.height);
      }, S = () => $e(a.get(), (Vt) => C(Vt)), _ = (Vt) => {
        const Xt = ci(Vt);
        return yI(Y.getOpt(s), Vt, Xt.right, Xt.bottom, Xt.width, Xt.height);
      }, D = () => $e(i.get(), (Vt) => _(Vt)), P = _4(S, g, (Vt) => {
        p.get().each((Xt) => {
          t.dispatch("TableSelectorChange", {
            start: Vt,
            finish: Xt
          });
        });
      }), L = _4(D, p, (Vt) => {
        g.get().each((Xt) => {
          t.dispatch("TableSelectorChange", {
            start: Xt,
            finish: Vt
          });
        });
      }), V = A4(P), Y = A4(L), me = Xc(V.asSpec()), Pe = Xc(Y.asSpec()), xe = (Vt, Xt, $o, Hn) => {
        const co = Xt.dom.getBoundingClientRect();
        Jo(Vt.element, "display");
        const bo = Uc(ve.fromDom(t.getBody())).dom.innerHeight, zs = $o(co), ro = Hn(co, bo);
        (zs || ro) && _n(Vt.element, "display", "none");
      }, Ce = (Vt, Xt, $o, Hn) => {
        const co = $o(Xt);
        Hb.snapTo(Vt, co), xe(Vt, Xt, (ro) => ro[Hn] < 0, (ro, ys) => ro[Hn] > ys);
      }, Be = (Vt) => Ce(me, Vt, C, "top"), St = () => g.get().each(Be), ct = (Vt) => Ce(Pe, Vt, _, "bottom"), tt = () => p.get().each(ct);
      xl().deviceType.isTouch() && (t.on("TableSelectionChange", (Vt) => {
        d.get() || (Mf(s, me), Mf(s, Pe), d.set(!0)), g.set(Vt.start), p.set(Vt.finish), Vt.otherCells.each((Xt) => {
          a.set(Xt.upOrLeftCells), i.set(Xt.downOrRightCells), Be(Vt.start), ct(Vt.finish);
        });
      }), t.on("ResizeEditor ResizeWindow ScrollContent", () => {
        St(), tt();
      }), t.on("TableSelectionClear", () => {
        d.get() && (jd(me), jd(Pe), d.set(!1)), g.clear(), p.clear();
      }));
    };
    var SZ = `<svg width="50px" height="16px" viewBox="0 0 50 16" xmlns="http://www.w3.org/2000/svg">
  <path fill-rule="evenodd" clip-rule="evenodd" d="M10.143 0c2.608.015 5.186 2.178 5.186 5.331 0 0 .077 3.812-.084 4.87-.361 2.41-2.164 4.074-4.65 4.496-1.453.284-2.523.49-3.212.623-.373.071-.634.122-.785.152-.184.038-.997.145-1.35.145-2.732 0-5.21-2.04-5.248-5.33 0 0 0-3.514.03-4.442.093-2.4 1.758-4.342 4.926-4.963 0 0 3.875-.752 4.036-.782.368-.07.775-.1 1.15-.1Zm1.826 2.8L5.83 3.989v2.393l-2.455.475v5.968l6.137-1.189V9.243l2.456-.476V2.8ZM5.83 6.382l3.682-.713v3.574l-3.682.713V6.382Zm27.173-1.64-.084-1.066h-2.226v9.132h2.456V7.743c-.008-1.151.998-2.064 2.149-2.072 1.15-.008 1.987.92 1.995 2.072v5.065h2.455V7.359c-.015-2.18-1.657-3.929-3.837-3.913a3.993 3.993 0 0 0-2.908 1.296Zm-6.3-4.266L29.16 0v2.387l-2.456.475V.476Zm0 3.2v9.132h2.456V3.676h-2.456Zm18.179 11.787L49.11 3.676H46.58l-1.612 4.527-.46 1.382-.384-1.382-1.611-4.527H39.98l3.3 9.132L42.15 16l2.732-.537ZM22.867 9.738c0 .752.568 1.075.921 1.075.353 0 .668-.047.998-.154l.537 1.765c-.23.154-.92.537-2.225.537-1.305 0-2.655-.997-2.686-2.686a136.877 136.877 0 0 1 0-4.374H18.8V3.676h1.612v-1.98l2.455-.476v2.456h2.302V5.9h-2.302v3.837Z"/>
</svg>
`;
    const O4 = (t) => t.nodeName === "BR" || !!t.getAttribute("data-mce-bogus") || t.getAttribute("data-mce-type") === "bookmark", tk = (t, s, a) => {
      var i;
      const d = (i = s.delimiter) !== null && i !== void 0 ? i : "›", g = (_, D, P) => Ec.sketch({
        dom: {
          tag: "div",
          classes: ["tox-statusbar__path-item"],
          attributes: {
            "data-index": P,
            "aria-level": P + 1
          }
        },
        components: [da(_)],
        action: (L) => {
          t.focus(), t.selection.select(D), t.nodeChanged();
        },
        buttonBehaviours: Ut([
          Zu.button(a.isDisabled),
          fc()
        ])
      }), p = () => ({
        dom: {
          tag: "div",
          classes: ["tox-statusbar__path-divider"],
          attributes: { "aria-hidden": !0 }
        },
        components: [da(` ${d} `)]
      }), C = (_) => lt(_, (D, P, L) => {
        const V = g(P.name, P.element, L);
        return L === 0 ? D.concat([V]) : D.concat([
          p(),
          V
        ]);
      }, []), S = (_) => {
        const D = [];
        let P = _.length;
        for (; P-- > 0; ) {
          const L = _[P];
          if (L.nodeType === 1 && !O4(L)) {
            const V = VM(t, L);
            if (V.isDefaultPrevented() || D.push({
              name: V.name,
              element: L
            }), V.isPropagationStopped())
              break;
          }
        }
        return D;
      };
      return {
        dom: {
          tag: "div",
          classes: ["tox-statusbar__path"],
          attributes: { role: "navigation" }
        },
        behaviours: Ut([
          no.config({
            mode: "flow",
            selector: "div[role=button]"
          }),
          mo.config({ disabled: a.isDisabled }),
          fc(),
          Lr.config({}),
          Oo.config({}),
          Bo("elementPathEvents", [cr((_, D) => {
            t.shortcuts.add("alt+F11", "focus statusbar elementpath", () => no.focusIn(_)), t.on("NodeChange", (P) => {
              const L = S(P.parents), V = L.length > 0 ? C(L) : [];
              Oo.set(_, V);
            });
          })])
        ]),
        components: []
      };
    };
    var jp;
    (function(t) {
      t[t.None = 0] = "None", t[t.Both = 1] = "Both", t[t.Vertical = 2] = "Vertical";
    })(jp || (jp = {}));
    const xZ = (t, s, a, i, d) => {
      const g = { height: yw(i + s.top, HA(t), zA(t)) };
      return a === jp.Both && (g.width = yw(d + s.left, LA(t), Nx(t))), g;
    }, CI = (t, s, a) => {
      const i = ve.fromDom(t.getContainer()), d = xZ(t, s, a, hr(i), j(i));
      Ie(d, (g, p) => {
        Pn(g) && _n(i, p, c4(g));
      }), HM(t);
    }, TZ = (t) => {
      const s = Fx(t);
      return s === !1 ? jp.None : s === "both" ? jp.Both : jp.Vertical;
    }, nk = (t, s, a, i) => {
      const g = Es(a * 20, i * 20);
      return CI(t, g, s), A.some(!0);
    }, Vb = (t, s) => {
      const a = TZ(t);
      if (a === jp.None)
        return A.none();
      const i = a === jp.Both ? "Press the arrow keys to resize the editor." : "Press the Up and Down arrow keys to resize the editor.";
      return A.some(Xd("resize-handle", {
        tag: "div",
        classes: ["tox-statusbar__resize-handle"],
        attributes: {
          title: s.translate("Resize"),
          "aria-label": s.translate(i)
        },
        behaviours: [
          Hb.config({
            mode: "mouse",
            repositionTarget: !1,
            onDrag: (d, g, p) => CI(t, p, a),
            blockerClass: "tox-blocker"
          }),
          no.config({
            mode: "special",
            onLeft: () => nk(t, a, -1, 0),
            onRight: () => nk(t, a, 1, 0),
            onUp: () => nk(t, a, 0, -1),
            onDown: () => nk(t, a, 0, 1)
          }),
          Lr.config({}),
          po.config({})
        ]
      }, s.icons));
    }, wI = (t, s) => {
      const a = (i, d, g) => Oo.set(i, [da(s.translate([
        "{0} " + g,
        d[g]
      ]))]);
      return Ec.sketch({
        dom: {
          tag: "button",
          classes: ["tox-statusbar__wordcount"]
        },
        components: [],
        buttonBehaviours: Ut([
          Zu.button(s.isDisabled),
          fc(),
          Lr.config({}),
          Oo.config({}),
          ln.config({
            store: {
              mode: "memory",
              initialValue: {
                mode: "words",
                count: {
                  words: 0,
                  characters: 0
                }
              }
            }
          }),
          Bo("wordcount-events", [
            Bu((i) => {
              const d = ln.getValue(i), g = d.mode === "words" ? "characters" : "words";
              ln.setValue(i, {
                mode: g,
                count: d.count
              }), a(i, d.count, g);
            }),
            cr((i) => {
              t.on("wordCountUpdate", (d) => {
                const { mode: g } = ln.getValue(i);
                ln.setValue(i, {
                  mode: g,
                  count: d.wordCount
                }), a(i, d.wordCount, g);
              });
            })
          ])
        ]),
        eventOrder: {
          [cl()]: [
            "disabling",
            "alloy.base.behaviour",
            "wordcount-events"
          ]
        }
      });
    }, EZ = (t, s) => {
      const a = () => ({
        dom: {
          tag: "span",
          classes: ["tox-statusbar__branding"]
        },
        components: [{
          dom: {
            tag: "a",
            attributes: {
              href: "https://www.tiny.cloud/powered-by-tiny?utm_campaign=poweredby&utm_source=tiny&utm_medium=referral&utm_content=v6",
              rel: "noopener",
              target: "_blank",
              "aria-label": Vl.translate([
                "Powered by {0}",
                "Tiny"
              ])
            },
            innerHtml: SZ.trim()
          },
          behaviours: Ut([po.config({})])
        }]
      }), i = () => {
        const C = TM("Alt+0");
        return {
          dom: {
            tag: "div",
            classes: ["tox-statusbar__help-text"]
          },
          components: [da(Vl.translate([
            "Press {0} for help",
            C
          ]))]
        };
      }, d = () => {
        const C = [];
        return t.hasPlugin("wordcount") && C.push(wI(t, s)), jA(t) && C.push(a()), {
          dom: {
            tag: "div",
            classes: ["tox-statusbar__right-container"]
          },
          components: C
        };
      }, g = () => {
        const C = [], S = ON(t), _ = $x(t), D = jA(t) || t.hasPlugin("wordcount"), P = () => {
          const L = "tox-statusbar__text-container--flex-start", V = "tox-statusbar__text-container--flex-end", Y = "tox-statusbar__text-container--space-around";
          if (S) {
            const me = "tox-statusbar__text-container-3-cols";
            return !D && !_ ? [
              me,
              Y
            ] : D && !_ ? [
              me,
              V
            ] : [
              me,
              L
            ];
          }
          return [D && !_ ? V : L];
        };
        return _ && C.push(tk(t, {}, s)), S && C.push(i()), D && C.push(d()), C.length > 0 ? [{
          dom: {
            tag: "div",
            classes: [
              "tox-statusbar__text-container",
              ...P()
            ]
          },
          components: C
        }] : [];
      };
      return {
        dom: {
          tag: "div",
          classes: ["tox-statusbar"]
        },
        components: (() => {
          const C = g(), S = Vb(t, s);
          return C.concat(S.toArray());
        })()
      };
    }, SI = (t, s) => s.get().getOrDie(`UI for ${t} has not been rendered`), kZ = (t, s) => {
      const a = t.inline, i = a ? EF : wF, d = C2(t) ? s5 : Fz, g = tW(), p = Go(), C = Go(), S = Go(), L = xl().deviceType.isTouch() ? ["tox-platform-touch"] : [], V = KA(t), Y = Cv(t), me = js({
        dom: {
          tag: "div",
          classes: ["tox-anchorbar"]
        }
      }), Pe = js({
        dom: {
          tag: "div",
          classes: ["tox-bottom-anchorbar"]
        }
      }), xe = () => g.mainUi.get().map((uo) => uo.outerContainer).bind(Tr.getHeader), Ce = () => Mo.fromOption(g.dialogUi.get().map((uo) => uo.sink), "UI has not been rendered"), Be = () => Mo.fromOption(g.popupUi.get().map((uo) => uo.sink), "(popup) UI has not been rendered"), St = g.lazyGetInOuterOrDie("anchor bar", me.getOpt), ct = g.lazyGetInOuterOrDie("bottom anchor bar", Pe.getOpt), tt = g.lazyGetInOuterOrDie("toolbar", Tr.getToolbar), Vt = g.lazyGetInOuterOrDie("throbber", Tr.getThrobber), Xt = Oz({
        popup: Be,
        dialog: Ce
      }, t, St, ct), $o = () => {
        const uo = { attributes: { [qh]: V ? iu.BottomToTop : iu.TopToBottom } }, Ro = Tr.parts.menubar({
          dom: {
            tag: "div",
            classes: ["tox-menubar"]
          },
          backstage: Xt.popup,
          onEscape: () => {
            t.focus();
          }
        }), ur = Tr.parts.toolbar({
          dom: {
            tag: "div",
            classes: ["tox-toolbar"]
          },
          getSink: Xt.popup.shared.getSink,
          providers: Xt.popup.shared.providers,
          onEscape: () => {
            t.focus();
          },
          onToolbarToggled: (e1) => {
            m8(t, e1);
          },
          type: Y,
          lazyToolbar: tt,
          lazyHeader: () => xe().getOrDie("Could not find header element"),
          ...uo
        }), Bs = Tr.parts["multiple-toolbar"]({
          dom: {
            tag: "div",
            classes: ["tox-toolbar-overlord"]
          },
          providers: Xt.popup.shared.providers,
          onEscape: () => {
            t.focus();
          },
          type: Y
        }), Pi = y2(t), Hr = Vx(t), Yl = Lx(t), im = Ix(t), Jp = Hn(), Qp = Pi || Hr || Yl, jb = () => Pi ? [Bs] : Hr ? [ur] : [], mk = im ? [
          Jp,
          Ro
        ] : [Ro];
        return Tr.parts.header({
          dom: {
            tag: "div",
            classes: ["tox-editor-header"].concat(Qp ? [] : ["tox-editor-header--empty"]),
            ...uo
          },
          components: ye([
            Yl ? mk : [],
            jb(),
            xp(t) ? [] : [me.asSpec()]
          ]),
          sticky: C2(t),
          editor: t,
          sharedBackstage: Xt.popup.shared
        });
      }, Hn = () => Tr.parts.promotion({
        dom: {
          tag: "div",
          classes: ["tox-promotion"]
        }
      }), co = () => {
        const uo = Tr.parts.socket({
          dom: {
            tag: "div",
            classes: ["tox-edit-area"]
          }
        }), Ro = Tr.parts.sidebar({
          dom: {
            tag: "div",
            classes: ["tox-sidebar"]
          }
        });
        return {
          dom: {
            tag: "div",
            classes: ["tox-sidebar-wrap"]
          },
          components: [
            uo,
            Ro
          ]
        };
      }, bo = () => {
        const uo = YA(t), Ro = Rs(fr(), uo) && Us(uo, "display") === "grid", ur = {
          dom: {
            tag: "div",
            classes: [
              "tox",
              "tox-silver-sink",
              "tox-tinymce-aux"
            ].concat(L),
            attributes: { ...Vl.isRtl() ? { dir: "rtl" } : {} }
          },
          behaviours: Ut([Qc.config({ useFixed: () => d.isDocked(xe) })])
        }, Bs = {
          dom: { styles: { width: document.body.clientWidth + "px" } },
          events: vr([mt(cd(), (Yl) => {
            _n(Yl.element, "width", document.body.clientWidth + "px");
          })])
        }, Pi = Xc(Ms(ur, Ro ? Bs : {})), Hr = TT(Pi);
        return C.set(Hr), {
          sink: Pi,
          mothership: Hr
        };
      }, zs = () => {
        const uo = {
          dom: {
            tag: "div",
            classes: [
              "tox",
              "tox-silver-sink",
              "tox-silver-popup-sink",
              "tox-tinymce-aux"
            ].concat(L),
            attributes: { ...Vl.isRtl() ? { dir: "rtl" } : {} }
          },
          behaviours: Ut([Qc.config({
            useFixed: () => d.isDocked(xe),
            getBounds: () => s.getPopupSinkBounds()
          })])
        }, Ro = Xc(uo), ur = TT(Ro);
        return S.set(ur), {
          sink: Ro,
          mothership: ur
        };
      }, ro = () => {
        const uo = $o(), Ro = co(), ur = Tr.parts.throbber({
          dom: {
            tag: "div",
            classes: ["tox-throbber"]
          },
          backstage: Xt.popup
        }), Bs = Tr.parts.viewWrapper({ backstage: Xt.popup }), Pi = Bx(t) && !a ? A.some(EZ(t, Xt.popup.shared.providers)) : A.none(), Hr = ye([
          V ? [] : [uo],
          a ? [] : [Ro],
          V ? [uo] : []
        ]), Yl = Tr.parts.editorContainer({
          components: ye([
            Hr,
            a ? [] : [
              Pe.asSpec(),
              ...Pi.toArray()
            ]
          ])
        }), im = XA(t), Jp = {
          role: "application",
          ...Vl.isRtl() ? { dir: "rtl" } : {},
          ...im ? { "aria-hidden": "true" } : {}
        }, Qp = Xc(Tr.sketch({
          dom: {
            tag: "div",
            classes: [
              "tox",
              "tox-tinymce"
            ].concat(a ? ["tox-tinymce-inline"] : []).concat(V ? ["tox-tinymce--toolbar-bottom"] : []).concat(L),
            styles: {
              visibility: "hidden",
              ...im ? {
                opacity: "0",
                border: "0"
              } : {}
            },
            attributes: Jp
          },
          components: [
            Yl,
            ...a ? [] : [Bs],
            ur
          ],
          behaviours: Ut([
            fc(),
            mo.config({ disableClass: "tox-tinymce--disabled" }),
            no.config({
              mode: "cyclic",
              selector: ".tox-menubar, .tox-toolbar, .tox-toolbar__primary, .tox-toolbar__overflow--open, .tox-sidebar__overflow--open, .tox-statusbar__path, .tox-statusbar__wordcount, .tox-statusbar__branding a, .tox-statusbar__resize-handle"
            })
          ])
        })), jb = TT(Qp);
        return p.set(jb), {
          mothership: jb,
          outerContainer: Qp
        };
      }, ys = (uo) => {
        const Ro = c4(XU(t)), ur = c4(JU(t));
        return t.inline || (ri("div", "width", ur) && _n(uo.element, "width", ur), ri("div", "height", Ro) ? _n(uo.element, "height", Ro) : _n(uo.element, "height", "400px")), Ro;
      }, Jt = (uo) => {
        t.addShortcut("alt+F9", "focus menubar", () => {
          Tr.focusMenubar(uo);
        }), t.addShortcut("alt+F10", "focus toolbar", () => {
          Tr.focusToolbar(uo);
        }), t.addCommand("ToggleToolbarDrawer", (Ro, ur) => {
          ur?.skipFocus ? Tr.toggleToolbarDrawerWithoutFocusing(uo) : Tr.toggleToolbarDrawer(uo);
        }), t.addQueryStateHandler("ToggleToolbarDrawer", () => Tr.isToolbarDrawerToggled(uo));
      }, Fn = (uo) => {
        const { mainUi: Ro, popupUi: ur, uiMotherships: Bs } = uo;
        et(yN(t), (qb, H4) => {
          t.ui.registry.addGroupToolbarButton(H4, qb);
        });
        const { buttons: Pi, menuItems: Hr, contextToolbars: Yl, sidebars: im, views: Jp } = t.ui.registry.getAll(), Qp = GA(t), jb = {
          menuItems: Hr,
          menus: MN(t),
          menubar: SN(t),
          toolbar: Qp.getOrThunk(() => v2(t)),
          allowToolbarGroups: Y === yd.floating,
          buttons: Pi,
          sidebar: im,
          views: Jp
        };
        Jt(Ro.outerContainer), Wv(t, Ro.mothership, Bs), d.setup(t, Xt.popup.shared, xe), _W(t, Xt.popup), ZW(t, Xt.popup.shared.getSink, Xt.popup), gV(t), vE(t, Vt, Xt.popup.shared), VF(t, Yl, ur.sink, { backstage: Xt.popup }), zb(t, ur.sink);
        const mk = t.getElement(), e1 = ys(Ro.outerContainer), L4 = {
          targetNode: mk,
          height: e1
        };
        return i.render(t, uo, jb, Xt.popup, L4);
      }, So = (uo) => (S.set(uo.mothership), uo), ns = () => {
        const uo = ro(), Ro = bo(), ur = Zg(t) ? zs() : So(Ro);
        g.dialogUi.set(Ro), g.popupUi.set(ur), g.mainUi.set(uo);
        const Bs = {
          popupUi: ur,
          dialogUi: Ro,
          mainUi: uo,
          uiMotherships: g.getUiMotherships()
        };
        return Fn(Bs);
      };
      return {
        popups: {
          backstage: Xt.popup,
          getMothership: () => SI("popups", S)
        },
        dialogs: {
          backstage: Xt.dialog,
          getMothership: () => SI("dialogs", C)
        },
        renderUI: ns
      };
    }, _Z = (t, s) => {
      const a = B(t, "id").fold(() => {
        const i = An("dialog-label");
        return sn(s, "id", i), i;
      }, Tt);
      sn(t, "aria-labelledby", a);
    }, AZ = U([
      gt("lazySink"),
      $s("dragBlockClass"),
      _a("getBounds", La),
      Ne("useTabstopAt", Oe),
      Ne("firstTabstop", 0),
      Ne("eventOrder", {}),
      za("modalBehaviours", [no]),
      fl("onExecute"),
      zy("onEscape")
    ]), D4 = { sketch: Tt }, OZ = U([
      qi({
        name: "draghandle",
        overrides: (t, s) => ({
          behaviours: Ut([Hb.config({
            mode: "mouse",
            getTarget: (a) => dl(a, '[role="dialog"]').getOr(a),
            blockerClass: t.dragBlockClass.getOrDie(new Error(`The drag blocker class was not specified for a dialog with a drag handle: 
` + JSON.stringify(s, null, 2)).message),
            getBounds: t.getDragBounds
          })])
        })
      }),
      ei({
        schema: [gt("dom")],
        name: "title"
      }),
      ei({
        factory: D4,
        schema: [gt("dom")],
        name: "close"
      }),
      ei({
        factory: D4,
        schema: [gt("dom")],
        name: "body"
      }),
      qi({
        factory: D4,
        schema: [gt("dom")],
        name: "footer"
      }),
      zu({
        factory: {
          sketch: (t, s) => ({
            ...t,
            dom: s.dom,
            components: s.components
          })
        },
        schema: [
          Ne("dom", {
            tag: "div",
            styles: {
              position: "fixed",
              left: "0px",
              top: "0px",
              right: "0px",
              bottom: "0px"
            }
          }),
          Ne("components", [])
        ],
        name: "blocker"
      })
    ]), DZ = (t, s, a, i) => {
      const d = Go(), g = (V) => {
        d.set(V);
        const Y = t.lazySink(V).getOrDie(), me = i.blocker(), Pe = Y.getSystem().build({
          ...me,
          components: me.components.concat([Pl(V)]),
          behaviours: Ut([
            po.config({}),
            Bo("dialog-blocker-events", [$d($c(), () => {
              Ym.isBlocked(V) ? J() : no.focusIn(V);
            })])
          ])
        });
        Mf(Y, Pe), no.focusIn(V);
      }, p = (V) => {
        d.clear(), Ta(V.element).each((Y) => {
          V.getSystem().getByDom(Y).each((me) => {
            jd(me);
          });
        });
      }, C = (V) => $m(V, t, "body"), S = (V) => ir(V, t, "footer"), _ = (V, Y) => {
        Ym.block(V, Y);
      }, D = (V) => {
        Ym.unblock(V);
      }, P = An("modal-events"), L = {
        ...t.eventOrder,
        [Nl()]: [P].concat(t.eventOrder["alloy.system.attached"] || [])
      };
      return {
        uid: t.uid,
        dom: t.dom,
        components: s,
        apis: {
          show: g,
          hide: p,
          getBody: C,
          getFooter: S,
          setIdle: D,
          setBusy: _
        },
        eventOrder: L,
        domModification: {
          attributes: {
            role: "dialog",
            "aria-modal": "true"
          }
        },
        behaviours: Oa(t.modalBehaviours, [
          Oo.config({}),
          no.config({
            mode: "cyclic",
            onEnter: t.onExecute,
            onEscape: t.onEscape,
            useTabstopAt: t.useTabstopAt,
            firstTabstop: t.firstTabstop
          }),
          Ym.config({ getRoot: d.get }),
          Bo(P, [cr((V) => {
            _Z(V.element, $m(V, t, "title").element);
          })])
        ])
      };
    }, Va = ti({
      name: "ModalDialog",
      configFields: AZ(),
      partFields: OZ(),
      factory: DZ,
      apis: {
        show: (t, s) => {
          t.show(s);
        },
        hide: (t, s) => {
          t.hide(s);
        },
        getBody: (t, s) => t.getBody(s),
        getFooter: (t, s) => t.getFooter(s),
        setBusy: (t, s, a) => {
          t.setBusy(s, a);
        },
        setIdle: (t, s) => {
          t.setIdle(s);
        }
      }
    }), kw = jn([
      $a,
      Yx
    ].concat(Sb)), R4 = nu, ny = [
      sT("button"),
      mu,
      Ai("align", "end", [
        "start",
        "end"
      ]),
      tT,
      fu,
      d1("buttonType", [
        "primary",
        "secondary"
      ])
    ], qp = [
      ...ny,
      Vf
    ], oy = [
      Al("type", [
        "submit",
        "cancel",
        "custom"
      ]),
      ...qp
    ], RZ = [
      Al("type", ["menu"]),
      _p,
      Jx,
      mu,
      zi("items", kw),
      ...ny
    ], xI = [
      ...ny,
      Al("type", ["togglebutton"]),
      _s("tooltip"),
      mu,
      _p,
      Pa("active", !1)
    ], TI = es("type", {
      submit: oy,
      cancel: oy,
      custom: oy,
      menu: RZ,
      togglebutton: xI
    }), EI = [
      $a,
      Vf,
      Al("level", [
        "info",
        "warn",
        "error",
        "success"
      ]),
      eM,
      Ne("url", "")
    ], NZ = jn(EI), MZ = (t) => [
      $a,
      t
    ], PZ = [
      $a,
      Vf,
      fu,
      sT("button"),
      mu,
      m3,
      d1("buttonType", [
        "primary",
        "secondary",
        "toolbar"
      ]),
      tT
    ], vq = jn(PZ), Ub = [
      $a,
      Yx
    ], kd = Ub.concat([Qx]), BZ = Ub.concat([
      Xx,
      fu
    ]), $Z = jn(BZ), FZ = nu, kI = kd.concat([f3("auto")]), IZ = jn(kI), LZ = Ou([
      T2,
      Vf,
      eM
    ]), HZ = kd.concat([ru("storageKey", "default")]), N4 = jn(HZ), M4 = Xa, _I = jn(kd), zZ = Xa, VZ = Ub.concat([
      ru("tag", "textarea"),
      _s("scriptId"),
      _s("scriptUrl"),
      Nw("settings", void 0)
    ]), AI = Ub.concat([
      ru("tag", "textarea"),
      ou("init")
    ]), UZ = Nd((t) => $r("customeditor.old", br(AI), t).orThunk(() => $r("customeditor.new", br(VZ), t))), WZ = Xa, OI = jn(kd), ZZ = Xb(), ok = (t) => [
      $a,
      fg("columns"),
      t
    ], ry = [
      $a,
      _s("html"),
      Ai("presets", "presentation", [
        "presentation",
        "document"
      ])
    ], sk = jn(ry), DI = kd.concat([
      Pa("border", !1),
      Pa("sandboxed", !0),
      Pa("streamContent", !1),
      Pa("transparent", !0)
    ]), rk = jn(DI), Kl = Xa, ak = jn(Ub.concat([mc("height")])), RI = jn([
      _s("url"),
      pm("zoom"),
      pm("cachedWidth"),
      pm("cachedHeight")
    ]), NI = kd.concat([
      mc("inputMode"),
      mc("placeholder"),
      Pa("maximized", !1),
      fu
    ]), jZ = jn(NI), qZ = Xa, Gp = (t) => [
      $a,
      Xx,
      t,
      Ai("align", "start", [
        "start",
        "center",
        "end"
      ])
    ], Cq = [
      Vf,
      T2
    ], GZ = [
      Vf,
      zi("items", mg("items", () => P4))
    ], P4 = xn([
      jn(Cq),
      jn(GZ)
    ]), ay = kd.concat([
      zi("items", P4),
      fu
    ]), ck = jn(ay), MI = Xa, KZ = kd.concat([
      u1("items", [
        Vf,
        T2
      ]),
      al("size", 1),
      fu
    ]), YZ = jn(KZ), XZ = Xa, JZ = kd.concat([
      Pa("constrain", !0),
      fu
    ]), cy = jn(JZ), QZ = jn([
      _s("width"),
      _s("height")
    ]), ej = Ub.concat([
      Xx,
      al("min", 0),
      al("max", 0)
    ]), tj = jn(ej), wq = ug, nj = [
      $a,
      zi("header", Xa),
      zi("cells", tu(Xa))
    ], oj = jn(nj), _w = kd.concat([
      mc("placeholder"),
      Pa("maximized", !1),
      fu
    ]), sj = jn(_w), rj = Xa, B4 = [
      Al("type", [
        "directory",
        "leaf"
      ]),
      u3,
      _s("id"),
      Ru("menu", fw)
    ], aj = jn(B4), e = B4.concat([zi("children", mg("children", () => Mt("type", {
      directory: n,
      leaf: aj
    })))]), n = jn(e), o = Mt("type", {
      directory: n,
      leaf: aj
    }), r = [
      $a,
      zi("items", o),
      bm("onLeafAction"),
      bm("onToggleExpand"),
      di("defaultExpandedIds", [], Xa),
      mc("defaultSelectedId")
    ], c = jn(r), u = kd.concat([
      Ai("filetype", "file", [
        "image",
        "media",
        "file"
      ]),
      fu,
      mc("picker_text")
    ]), f = jn(u), b = jn([
      T2,
      nT
    ]), y = (t) => dc("items", "items", bs(), tu(Nd((s) => $r(`Checking item of ${t}`, E, s).fold((a) => Mo.error(Kc(a)), (a) => Mo.value(a))))), E = uc(() => Mt("type", {
      alertbanner: NZ,
      bar: jn(MZ(y("bar"))),
      button: vq,
      checkbox: $Z,
      colorinput: N4,
      colorpicker: _I,
      dropzone: OI,
      grid: jn(ok(y("grid"))),
      iframe: rk,
      input: jZ,
      listbox: ck,
      selectbox: YZ,
      sizeinput: cy,
      slider: tj,
      textarea: sj,
      urlinput: f,
      customeditor: UZ,
      htmlpanel: sk,
      imagepreview: ak,
      collection: IZ,
      label: jn(Gp(y("label"))),
      table: oj,
      tree: c,
      panel: M
    })), N = [
      $a,
      Ne("classes", []),
      zi("items", E)
    ], M = jn(N), I = [
      sT("tab"),
      u3,
      zi("items", E)
    ], X = [
      $a,
      u1("tabs", I)
    ], te = jn(X), G = qp, ne = TI, Se = jn([
      _s("title"),
      _i("body", Mt("type", {
        panel: M,
        tabpanel: te
      })),
      ru("size", "normal"),
      di("buttons", [], ne),
      Ne("initialData", {}),
      _a("onAction", J),
      _a("onChange", J),
      _a("onSubmit", J),
      _a("onClose", J),
      _a("onCancel", J),
      _a("onTabChange", J)
    ]), ke = (t) => $r("dialog", Se, t), Ae = jn([
      Al("type", [
        "cancel",
        "custom"
      ]),
      ...G
    ]), Me = jn([
      _s("title"),
      _s("url"),
      pm("height"),
      pm("width"),
      Md("buttons", Ae),
      _a("onAction", J),
      _a("onCancel", J),
      _a("onClose", J),
      _a("onMessage", J)
    ]), pt = (t) => $r("dialog", Me, t), It = (t) => Bt(t) ? [t].concat(ae(or(t), It)) : dn(t) ? ae(t, It) : [], un = (t) => Ee(t.type) && Ee(t.name), nt = {
      checkbox: FZ,
      colorinput: M4,
      colorpicker: zZ,
      dropzone: ZZ,
      input: qZ,
      iframe: Kl,
      imagepreview: RI,
      selectbox: XZ,
      sizeinput: QZ,
      slider: wq,
      listbox: MI,
      size: QZ,
      textarea: rj,
      urlinput: b,
      customeditor: WZ,
      collection: LZ,
      togglemenuitem: R4
    }, qe = (t) => A.from(nt[t.type]), xt = (t) => fo(It(t), un), bn = (t) => {
      const s = xt(t), a = ae(s, (i) => qe(i).fold(() => [], (d) => [_i(i.name, d)]));
      return jn(a);
    }, Yn = (t) => {
      var s;
      const a = Js(ke(t)), i = bn(t), d = (s = t.initialData) !== null && s !== void 0 ? s : {};
      return {
        internalDialog: a,
        dataValidator: i,
        initialData: d
      };
    }, Po = {
      open: (t, s) => {
        const a = Yn(s);
        return t(a.internalDialog, a.initialData, a.dataValidator);
      },
      openUrl: (t, s) => {
        const a = Js(pt(s));
        return t(a);
      },
      redial: (t) => Yn(t)
    };
    var er = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      events: (t, s) => {
        const a = (i, d) => {
          t.updateState.each((g) => {
            const p = g(i, d);
            s.set(p);
          }), t.renderComponents.each((g) => {
            const p = g(d, s.get());
            (t.reuseDom ? TR : Ki)(i, p);
          });
        };
        return vr([
          mt(vg(), (i, d) => {
            const g = d;
            if (!g.universal) {
              const p = t.channel;
              io(g.channels, p) && a(i, g.data);
            }
          }),
          cr((i, d) => {
            t.initialData.each((g) => {
              a(i, g);
            });
          })
        ]);
      }
    }), wa = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      getState: (t, s, a) => a
    }), si = [
      gt("channel"),
      $s("renderComponents"),
      $s("updateState"),
      $s("initialData"),
      Pa("reuseDom", !0)
    ], Gt = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      init: () => {
        const t = w(A.none()), s = () => t.set(A.none());
        return {
          readState: () => t.get().getOr("none"),
          get: t.get,
          set: t.set,
          clear: s
        };
      }
    });
    const vn = tc({
      fields: si,
      name: "reflecting",
      active: er,
      apis: wa,
      state: Gt
    }), As = (t) => {
      const s = [], a = {};
      return Ie(t, (i, d) => {
        i.fold(() => {
          s.push(d);
        }, (g) => {
          a[d] = g;
        });
      }), s.length > 0 ? Mo.error(s) : Mo.value(a);
    }, vs = (t, s, a) => {
      const i = js(Pv.sketch((d) => ({
        dom: {
          tag: "div",
          classes: ["tox-form"].concat(t.classes)
        },
        components: $e(t.items, (g) => om(d, g, s, a))
      })));
      return {
        dom: {
          tag: "div",
          classes: ["tox-dialog__body"]
        },
        components: [{
          dom: {
            tag: "div",
            classes: ["tox-dialog__body-content"]
          },
          components: [i.asSpec()]
        }],
        behaviours: Ut([
          no.config({
            mode: "acyclic",
            useTabstopAt: De($v)
          }),
          ql.memento(i),
          gB(i, {
            postprocess: (d) => As(d).fold((g) => ({}), Tt)
          }),
          Bo("dialog-body-panel", [mt($c(), (d, g) => {
            d.getSystem().broadcastOn([Iv], { newFocus: A.some(g.event.target) });
          })])
        ])
      };
    }, zn = (t, s) => ({
      uid: t.uid,
      dom: t.dom,
      components: t.components,
      events: zm(t.action),
      behaviours: Oa(t.tabButtonBehaviours, [
        po.config({}),
        no.config({
          mode: "execution",
          useSpace: !0,
          useEnter: !0
        }),
        ln.config({
          store: {
            mode: "memory",
            initialValue: t.value
          }
        })
      ]),
      domModification: t.domModification
    }), Un = gl({
      name: "TabButton",
      configFields: [
        Ne("uid", void 0),
        gt("value"),
        dc("dom", "dom", Wo(() => ({
          attributes: {
            role: "tab",
            id: An("aria"),
            "aria-selected": "false"
          }
        })), ua()),
        $s("action"),
        Ne("domModification", {}),
        za("tabButtonBehaviours", [
          po,
          no,
          ln
        ]),
        gt("view")
      ],
      factory: zn
    }), zt = U([
      gt("tabs"),
      gt("dom"),
      Ne("clickToDismiss", !1),
      za("tabbarBehaviours", [
        Ps,
        no
      ]),
      xf([
        "tabClass",
        "selectedClass"
      ])
    ]), Eo = sb({
      factory: Un,
      name: "tabs",
      unit: "tab",
      overrides: (t) => {
        const s = (i, d) => {
          Ps.dehighlight(i, d), to(i, o0(), {
            tabbar: i,
            button: d
          });
        }, a = (i, d) => {
          Ps.highlight(i, d), to(i, Bw(), {
            tabbar: i,
            button: d
          });
        };
        return {
          action: (i) => {
            const d = i.getSystem().getByUid(t.uid).getOrDie(), g = Ps.isHighlighted(d, i);
            (g && t.clickToDismiss ? s : g ? J : a)(d, i);
          },
          domModification: { classes: [t.markers.tabClass] }
        };
      }
    }), hs = U([Eo]), nr = (t, s, a, i) => ({
      uid: t.uid,
      dom: t.dom,
      components: s,
      "debug.sketcher": "Tabbar",
      domModification: { attributes: { role: "tablist" } },
      behaviours: Oa(t.tabbarBehaviours, [
        Ps.config({
          highlightClass: t.markers.selectedClass,
          itemClass: t.markers.tabClass,
          onHighlight: (d, g) => {
            sn(g.element, "aria-selected", "true");
          },
          onDehighlight: (d, g) => {
            sn(g.element, "aria-selected", "false");
          }
        }),
        no.config({
          mode: "flow",
          getInitial: (d) => Ps.getHighlighted(d).map((g) => g.element),
          selector: "." + t.markers.tabClass,
          executeOnMove: !0
        })
      ])
    }), kr = ti({
      name: "Tabbar",
      configFields: zt(),
      partFields: hs(),
      factory: nr
    }), Qi = (t, s) => ({
      uid: t.uid,
      dom: t.dom,
      behaviours: Oa(t.tabviewBehaviours, [Oo.config({})]),
      domModification: { attributes: { role: "tabpanel" } }
    }), hu = gl({
      name: "Tabview",
      configFields: [za("tabviewBehaviours", [Oo])],
      factory: Qi
    }), Yf = U([
      Ne("selectFirst", !0),
      gs("onChangeTab"),
      gs("onDismissTab"),
      Ne("tabs", []),
      za("tabSectionBehaviours", [])
    ]), el = ei({
      factory: kr,
      schema: [
        gt("dom"),
        su("markers", [
          gt("tabClass"),
          gt("selectedClass")
        ])
      ],
      name: "tabbar",
      defaults: (t) => ({ tabs: t.tabs })
    }), rm = ei({
      factory: hu,
      name: "tabview"
    }), Do = U([
      el,
      rm
    ]), ps = (t, s, a, i) => {
      const d = (p) => {
        const C = ln.getValue(p);
        ir(p, t, "tabview").each((S) => {
          ee(t.tabs, (D) => D.value === C).each((D) => {
            const P = D.view();
            B(p.element, "id").each((L) => {
              sn(S.element, "aria-labelledby", L);
            }), Oo.set(S, P), t.onChangeTab(S, p, P);
          });
        });
      }, g = (p, C) => {
        ir(p, t, "tabbar").each((S) => {
          C(S).each(Cm);
        });
      };
      return {
        uid: t.uid,
        dom: t.dom,
        components: s,
        behaviours: Pm(t.tabSectionBehaviours),
        events: vr(ye([
          t.selectFirst ? [cr((p, C) => {
            g(p, Ps.getFirst);
          })] : [],
          [
            mt(Bw(), (p, C) => {
              const S = C.event.button;
              d(S);
            }),
            mt(o0(), (p, C) => {
              const S = C.event.button;
              t.onDismissTab(p, S);
            })
          ]
        ])),
        apis: {
          getViewItems: (p) => ir(p, t, "tabview").map((C) => Oo.contents(C)).getOr([]),
          showTab: (p, C) => {
            g(p, (_) => {
              const D = Ps.getCandidates(_);
              return ee(D, (L) => ln.getValue(L) === C).filter((L) => !Ps.isHighlighted(_, L));
            });
          }
        }
      };
    }, Ls = ti({
      name: "TabSection",
      configFields: Yf(),
      partFields: Do(),
      factory: ps,
      apis: {
        getViewItems: (t, s) => t.getViewItems(s),
        showTab: (t, s, a) => {
          t.showTab(s, a);
        }
      }
    }), Gr = (t, s, a) => $e(t, (i, d) => {
      Oo.set(a, t[d].view());
      const g = s.dom.getBoundingClientRect();
      return Oo.set(a, []), g.height;
    }), ra = (t) => Xn(In(t, (s, a) => s > a ? -1 : s < a ? 1 : 0)), _d = (t, s, a) => {
      const i = yc(t).dom, d = dl(t, ".tox-dialog-wrap").getOr(t), g = Us(d, "position") === "fixed";
      let p;
      g ? p = Math.max(i.clientHeight, window.innerHeight) : p = Math.max(i.offsetHeight, i.scrollHeight);
      const C = hr(s), _ = s.dom.offsetLeft >= a.dom.offsetLeft + j(a) ? Math.max(hr(a), C) : C, D = parseInt(Us(t, "margin-top"), 10) || 0, P = parseInt(Us(t, "margin-bottom"), 10) || 0, V = hr(t) + D + P - _;
      return p - V;
    }, iy = (t, s) => {
      Xn(t).each((a) => Ls.showTab(s, a.value));
    }, ly = (t, s) => {
      _n(t, "height", s + "px"), _n(t, "flex-basis", s + "px");
    }, Xf = (t, s, a) => {
      dl(t, '[role="dialog"]').each((i) => {
        va(i, '[role="tablist"]').each((d) => {
          a.get().map((g) => (_n(s, "height", "0"), _n(s, "flex-basis", "0"), Math.min(g, _d(i, s, d)))).each((g) => {
            ly(s, g);
          });
        });
      });
    }, Jf = (t) => va(t, '[role="tabpanel"]'), Kp = (t) => {
      const s = Go();
      return {
        extraEvents: [
          cr((d) => {
            const g = d.element;
            Jf(g).each((p) => {
              _n(p, "visibility", "hidden"), d.getSystem().getByDom(p).toOptional().each((C) => {
                const S = Gr(t, p, C);
                ra(S).fold(s.clear, s.set);
              }), Xf(g, p, s), Jo(p, "visibility"), iy(t, d), requestAnimationFrame(() => {
                Xf(g, p, s);
              });
            });
          }),
          mt(cd(), (d) => {
            const g = d.element;
            Jf(g).each((p) => {
              Xf(g, p, s);
            });
          }),
          mt(OP, (d, g) => {
            const p = d.element;
            Jf(p).each((C) => {
              const S = Ud(Ve(C));
              _n(C, "visibility", "hidden");
              const _ = Xs(C, "height").map((L) => parseInt(L, 10));
              Jo(C, "height"), Jo(C, "flex-basis");
              const D = C.dom.getBoundingClientRect().height;
              _.forall((L) => D > L) ? (s.set(D), Xf(p, C, s)) : _.each((L) => {
                ly(C, L);
              }), Jo(C, "visibility"), S.each(Zi);
            });
          })
        ],
        selectFirst: !1
      };
    }, uy = "send-data-to-section", Aw = "send-data-to-view", ik = (t, s, a) => {
      const i = w({}), d = (_) => {
        const D = ln.getValue(_), P = As(D).getOr({}), L = i.get(), V = Ms(L, P);
        i.set(V);
      }, g = (_) => {
        const D = i.get();
        ln.setValue(_, D);
      }, p = w(null), C = $e(t.tabs, (_) => ({
        value: _.name,
        dom: {
          tag: "div",
          classes: ["tox-dialog__body-nav-item"]
        },
        components: [da(a.shared.providers.translate(_.title))],
        view: () => [Pv.sketch((D) => ({
          dom: {
            tag: "div",
            classes: ["tox-form"]
          },
          components: $e(_.items, (P) => om(D, P, s, a)),
          formBehaviours: Ut([
            no.config({
              mode: "acyclic",
              useTabstopAt: De($v)
            }),
            Bo("TabView.form.events", [
              cr(g),
              Fd(d)
            ]),
            Wi.config({
              channels: Jn([
                {
                  key: uy,
                  value: { onReceive: d }
                },
                {
                  key: Aw,
                  value: { onReceive: g }
                }
              ])
            })
          ])
        }))]
      })), S = Kp(C);
      return Ls.sketch({
        dom: {
          tag: "div",
          classes: ["tox-dialog__body"]
        },
        onChangeTab: (_, D, P) => {
          const L = ln.getValue(D);
          to(_, AP, {
            name: L,
            oldName: p.get()
          }), p.set(L);
        },
        tabs: C,
        components: [
          Ls.parts.tabbar({
            dom: {
              tag: "div",
              classes: ["tox-dialog__body-nav"]
            },
            components: [kr.parts.tabs({})],
            markers: {
              tabClass: "tox-tab",
              selectedClass: "tox-dialog__body-nav-item--active"
            },
            tabbarBehaviours: Ut([Lr.config({})])
          }),
          Ls.parts.tabview({
            dom: {
              tag: "div",
              classes: ["tox-dialog__body-content"]
            }
          })
        ],
        selectFirst: S.selectFirst,
        tabSectionBehaviours: Ut([
          Bo("tabpanel", S.extraEvents),
          no.config({ mode: "acyclic" }),
          ts.config({ find: (_) => Xn(Ls.getViewItems(_)) }),
          Bp(A.none(), (_) => (_.getSystem().broadcastOn([uy], {}), i.get()), (_, D) => {
            i.set(D), _.getSystem().broadcastOn([Aw], {});
          })
        ])
      });
    }, Wb = (t, s, a, i, d) => {
      const g = (S) => {
        const _ = S.body;
        switch (_.type) {
          case "tabpanel":
            return [ik(_, S.initialData, i)];
          default:
            return [vs(_, S.initialData, i)];
        }
      }, p = (S, _) => A.some({ isTabPanel: () => _.body.type === "tabpanel" }), C = { "aria-live": "polite" };
      return {
        dom: {
          tag: "div",
          classes: ["tox-dialog__content-js"],
          attributes: {
            ...a.map((S) => ({ id: S })).getOr({}),
            ...d ? C : {}
          }
        },
        components: [],
        behaviours: Ut([
          ql.childAt(0),
          vn.config({
            channel: `${ZT}-${s}`,
            updateState: p,
            renderComponents: g,
            initialData: t
          })
        ])
      };
    }, lk = (t, s, a, i, d) => Wb(t, s, A.some(a), i, d), Yp = (t, s, a) => {
      const i = Wb(t, s, A.none(), a, !1);
      return Va.parts.body(i);
    }, dy = (t) => {
      const s = {
        dom: {
          tag: "div",
          classes: ["tox-dialog__content-js"]
        },
        components: [{
          dom: {
            tag: "div",
            classes: ["tox-dialog__body-iframe"]
          },
          components: [wB(A.none(), {
            dom: {
              tag: "iframe",
              attributes: { src: t.url }
            },
            behaviours: Ut([
              Lr.config({}),
              po.config({})
            ])
          })]
        }],
        behaviours: Ut([no.config({
          mode: "acyclic",
          useTabstopAt: De($v)
        })])
      };
      return Va.parts.body(s);
    }, am = yv.deviceType.isTouch(), Qf = (t, s) => ({
      dom: {
        tag: "div",
        styles: { display: "none" },
        classes: ["tox-dialog__header"]
      },
      components: [
        t,
        s
      ]
    }), my = (t, s) => Va.parts.close(Ec.sketch({
      dom: {
        tag: "button",
        classes: [
          "tox-button",
          "tox-button--icon",
          "tox-button--naked"
        ],
        attributes: {
          type: "button",
          "aria-label": s.translate("Close")
        }
      },
      action: t,
      buttonBehaviours: Ut([Lr.config({})])
    })), fy = () => Va.parts.title({
      dom: {
        tag: "div",
        classes: ["tox-dialog__title"],
        innerHtml: "",
        styles: { display: "none" }
      }
    }), Ow = (t, s) => Va.parts.body({
      dom: {
        tag: "div",
        classes: ["tox-dialog__body"]
      },
      components: [{
        dom: {
          tag: "div",
          classes: ["tox-dialog__body-content"]
        },
        components: [{ dom: Ug(`<p>${dN(s.translate(t))}</p>`) }]
      }]
    }), Zb = (t) => Va.parts.footer({
      dom: {
        tag: "div",
        classes: ["tox-dialog__footer"]
      },
      components: t
    }), $4 = (t, s) => [
      Zm.sketch({
        dom: {
          tag: "div",
          classes: ["tox-dialog__footer-start"]
        },
        components: t
      }),
      Zm.sketch({
        dom: {
          tag: "div",
          classes: ["tox-dialog__footer-end"]
        },
        components: s
      })
    ], uk = (t) => {
      const s = "tox-dialog", a = s + "-wrap", i = a + "__backdrop", d = s + "__disable-scroll";
      return Va.sketch({
        lazySink: t.lazySink,
        onEscape: (g) => (t.onEscape(g), A.some(!0)),
        useTabstopAt: (g) => !$v(g),
        firstTabstop: t.firstTabstop,
        dom: {
          tag: "div",
          classes: [s].concat(t.extraClasses),
          styles: {
            position: "relative",
            ...t.extraStyles
          }
        },
        components: [
          t.header,
          t.body,
          ...t.footer.toArray()
        ],
        parts: {
          blocker: {
            dom: Ug(`<div class="${a}"></div>`),
            components: [{
              dom: {
                tag: "div",
                classes: am ? [
                  i,
                  i + "--opaque"
                ] : [i]
              }
            }]
          }
        },
        dragBlockClass: a,
        modalBehaviours: Ut([
          po.config({}),
          Bo("dialog-events", t.dialogEvents.concat([
            $d($c(), (g, p) => {
              Ym.isBlocked(g) ? J() : no.focusIn(g);
            }),
            mt(t0(), (g, p) => {
              g.getSystem().broadcastOn([Iv], { newFocus: p.event.newFocus });
            })
          ])),
          Bo("scroll-lock", [
            cr(() => {
              ba(fr(), d);
            }),
            Fd(() => {
              Wr(fr(), d);
            })
          ]),
          ...t.extraBehaviours
        ]),
        eventOrder: {
          [cl()]: ["dialog-events"],
          [Nl()]: [
            "scroll-lock",
            "dialog-events",
            "alloy.base.behaviour"
          ],
          [pf()]: [
            "alloy.base.behaviour",
            "dialog-events",
            "scroll-lock"
          ],
          ...t.eventOrder
        }
      });
    }, Ci = (t) => Ec.sketch({
      dom: {
        tag: "button",
        classes: [
          "tox-button",
          "tox-button--icon",
          "tox-button--naked"
        ],
        attributes: {
          type: "button",
          "aria-label": t.translate("Close"),
          title: t.translate("Close")
        }
      },
      buttonBehaviours: Ut([Lr.config({})]),
      components: [Xd("close", {
        tag: "span",
        classes: ["tox-icon"]
      }, t.icons)],
      action: (s) => {
        cs(s, Np);
      }
    }), Xp = (t, s, a, i) => {
      const d = (g) => [da(i.translate(g.title))];
      return {
        dom: {
          tag: "div",
          classes: ["tox-dialog__title"],
          attributes: { ...a.map((g) => ({ id: g })).getOr({}) }
        },
        components: [],
        behaviours: Ut([vn.config({
          channel: `${Gf}-${s}`,
          initialData: t,
          renderComponents: d
        })])
      };
    }, nh = () => ({ dom: Ug('<div class="tox-dialog__draghandle"></div>') }), Dw = (t, s, a, i) => Zm.sketch({
      dom: Ug('<div class="tox-dialog__header"></div>'),
      components: [
        Xp(t, s, A.some(a), i),
        nh(),
        Ci(i)
      ],
      containerBehaviours: Ut([Hb.config({
        mode: "mouse",
        blockerClass: "blocker",
        getTarget: (d) => ld(d, '[role="dialog"]').getOrDie(),
        snaps: {
          getSnapPoints: () => [],
          leftAttr: "data-drag-left",
          topAttr: "data-drag-top"
        }
      })])
    }), He = (t, s, a) => {
      const i = Va.parts.title(Xp(t, s, A.none(), a)), d = Va.parts.draghandle(nh()), g = Va.parts.close(Ci(a)), p = [i].concat(t.draggable ? [d] : []).concat([g]);
      return Zm.sketch({
        dom: Ug('<div class="tox-dialog__header"></div>'),
        components: p
      });
    }, Ze = (t, s, a) => He({
      title: a.shared.providers.translate(t),
      draggable: a.dialog.isDraggableModal()
    }, s, a.shared.providers), jt = (t, s, a, i) => ({
      dom: {
        tag: "div",
        classes: ["tox-dialog__busy-spinner"],
        attributes: { "aria-label": a.translate(t) },
        styles: {
          left: "0px",
          right: "0px",
          bottom: "0px",
          top: `${i.getOr(0)}px`,
          position: "absolute"
        }
      },
      behaviours: s,
      components: [{ dom: Ug('<div class="tox-spinner"><div></div><div></div><div></div></div>') }]
    }), Lt = (t, s, a) => ({
      onClose: () => a.closeWindow(),
      onBlock: (i) => {
        const d = va(t().element, ".tox-dialog__header").map((g) => hr(g));
        Va.setBusy(t(), (g, p) => jt(i.message, p, s, d));
      },
      onUnblock: () => {
        Va.setIdle(t());
      }
    }), so = "tox-dialog--fullscreen", us = "tox-dialog--width-lg", Kr = "tox-dialog--width-md", Ua = (t) => {
      switch (t) {
        case "large":
          return A.some(us);
        case "medium":
          return A.some(Kr);
        default:
          return A.none();
      }
    }, sc = (t, s) => {
      const a = ve.fromDom(s.element.dom);
      Ha(a, so) || (Ml(a, [
        us,
        Kr
      ]), Ua(t).each((i) => ba(a, i)));
    }, gy = (t, s) => {
      const a = ve.fromDom(t.element.dom), i = Nh(a), d = ee(i, (g) => g === us || g === Kr).or(Ua(s));
      Fy(a, [
        so,
        ...d.toArray()
      ]);
    }, hy = (t, s, a) => Xc(uk({
      ...t,
      firstTabstop: 1,
      lazySink: a.shared.getSink,
      extraBehaviours: [
        UT({}),
        ...t.extraBehaviours
      ],
      onEscape: (i) => {
        cs(i, Np);
      },
      dialogEvents: s,
      eventOrder: {
        [vg()]: [
          vn.name(),
          Wi.name()
        ],
        [Nl()]: [
          "scroll-lock",
          vn.name(),
          "messages",
          "dialog-events",
          "alloy.base.behaviour"
        ],
        [pf()]: [
          "alloy.base.behaviour",
          "dialog-events",
          "messages",
          vn.name(),
          "scroll-lock"
        ]
      }
    })), dk = (t, s = {}) => {
      const a = (i) => {
        const d = $e(i.items, (g) => {
          const p = Dt(s, g.name).getOr(w(!1));
          return {
            ...g,
            storage: p
          };
        });
        return {
          ...i,
          items: d
        };
      };
      return $e(t, (i) => i.type === "menu" ? a(i) : i);
    }, F4 = (t) => lt(t, (s, a) => a.type === "menu" ? lt(a.items, (d, g) => (d[g.name] = g.storage, d), s) : s, {}), eg = (t, s) => [
      ky($c(), jH),
      t(Ov, (a, i, d, g) => {
        Ud(Ve(g.element)).fold(J, Uh), s.onClose(), i.onClose();
      }),
      t(Np, (a, i, d, g) => {
        i.onCancel(a), cs(g, Ov);
      }),
      mt(aO, (a, i) => s.onUnblock()),
      mt(rO, (a, i) => s.onBlock(i.event))
    ], PI = (t, s) => {
      const a = (d, g) => mt(d, (p, C) => {
        i(p, (S, _) => {
          g(t(), S, C.event, p);
        });
      }), i = (d, g) => {
        vn.getState(d).get().each((p) => {
          g(p, d);
        });
      };
      return [
        ...eg(a, s),
        a(Zf, (d, g, p) => {
          g.onAction(d, { name: p.name });
        })
      ];
    }, I4 = (t, s, a) => {
      const i = (g, p) => mt(g, (C, S) => {
        d(C, (_, D) => {
          p(t(), _, S.event, C);
        });
      }), d = (g, p) => {
        vn.getState(g).get().each((C) => {
          p(C.internalDialog, g);
        });
      };
      return [
        ...eg(i, s),
        i(H2, (g, p) => p.onSubmit(g)),
        i(Zl, (g, p, C) => {
          p.onChange(g, { name: C.name });
        }),
        i(Zf, (g, p, C, S) => {
          const _ = () => S.getSystem().isConnected() ? no.focusIn(S) : void 0, D = (V) => K(V, "disabled") || B(V, "aria-disabled").exists((Y) => Y === "true"), P = Ve(S.element), L = Ud(P);
          p.onAction(g, {
            name: C.name,
            value: C.value
          }), Ud(P).fold(_, (V) => {
            D(V) || L.exists((Y) => ca(V, Y) && D(Y)) ? _() : a().toOptional().filter((Y) => !ca(Y.element, V)).each(_);
          });
        }),
        i(AP, (g, p, C) => {
          p.onTabChange(g, {
            newTabName: C.name,
            oldTabName: C.oldName
          });
        }),
        Fd((g) => {
          const p = t();
          ln.setValue(g, p.getData());
        })
      ];
    }, BI = (t, s) => oE(t, t.type, s), $I = (t, s, a) => ee(s, (i) => i.name === a).bind((i) => i.memento.getOpt(t)), cj = (t, s) => {
      const a = s.map((C) => C.footerButtons).getOr([]), i = ss(a, (C) => C.align === "start"), d = (C, S) => Zm.sketch({
        dom: {
          tag: "div",
          classes: [`tox-dialog__footer-${C}`]
        },
        components: $e(S, (_) => _.memento.asSpec())
      }), g = d("start", i.pass), p = d("end", i.fail);
      return [
        g,
        p
      ];
    }, Yo = (t, s, a) => {
      const i = (d, g) => {
        const p = $e(g.buttons, (S) => {
          const _ = js(BI(S, a));
          return {
            name: S.name,
            align: S.align,
            memento: _
          };
        }), C = (S) => $I(d, p, S);
        return A.some({
          lookupByName: C,
          footerButtons: p
        });
      };
      return {
        dom: Ug('<div class="tox-dialog__footer"></div>'),
        components: [],
        behaviours: Ut([vn.config({
          channel: `${$O}-${s}`,
          initialData: t,
          updateState: i,
          renderComponents: cj
        })])
      };
    }, Ge = (t, s, a) => Yo(t, s, a), qn = (t, s, a) => Va.parts.footer(Yo(t, s, a)), Uo = (t, s) => {
      if (t.getRoot().getSystem().isConnected()) {
        const i = ts.getCurrent(t.getFormWrapper()).getOr(t.getFormWrapper());
        return Pv.getField(i, s).orThunk(() => t.getFooter().bind((p) => vn.getState(p).get()).bind((p) => p.lookupByName(s)));
      } else
        return A.none();
    }, Wa = (t, s) => {
      const a = t.getRoot();
      return vn.getState(a).get().map((i) => Js($r("data", i.dataValidator, s))).getOr(s);
    }, bl = (t, s, a) => {
      const i = (Y) => {
        const me = t.getRoot();
        me.getSystem().isConnected() && Y(me);
      }, V = {
        getData: () => {
          const Y = t.getRoot(), me = Y.getSystem().isConnected() ? t.getFormWrapper() : Y, Pe = ln.getValue(me), xe = et(a, (Ce) => Ce.get());
          return {
            ...Pe,
            ...xe
          };
        },
        setData: (Y) => {
          i((me) => {
            const Pe = V.getData(), xe = Ms(Pe, Y), Ce = Wa(t, xe), Be = t.getFormWrapper();
            ln.setValue(Be, Ce), Ie(a, (St, ct) => {
              Lo(xe, ct) && St.set(xe[ct]);
            });
          });
        },
        setEnabled: (Y, me) => {
          Uo(t, Y).each(me ? mo.enable : mo.disable);
        },
        focus: (Y) => {
          Uo(t, Y).each(po.focus);
        },
        block: (Y) => {
          if (!Ee(Y))
            throw new Error("The dialogInstanceAPI.block function should be passed a blocking message of type string as an argument");
          i((me) => {
            to(me, rO, { message: Y });
          });
        },
        unblock: () => {
          i((Y) => {
            cs(Y, aO);
          });
        },
        showTab: (Y) => {
          i((me) => {
            const Pe = t.getBody();
            vn.getState(Pe).get().exists((Ce) => Ce.isTabPanel()) && ts.getCurrent(Pe).each((Ce) => {
              Ls.showTab(Ce, Y);
            });
          });
        },
        redial: (Y) => {
          i((me) => {
            const Pe = t.getId(), xe = s(Y), Ce = dk(xe.internalDialog.buttons, a);
            me.getSystem().broadcastOn([`${Fv}-${Pe}`], xe), me.getSystem().broadcastOn([`${Gf}-${Pe}`], xe.internalDialog), me.getSystem().broadcastOn([`${ZT}-${Pe}`], xe.internalDialog), me.getSystem().broadcastOn([`${$O}-${Pe}`], {
              ...xe.internalDialog,
              buttons: Ce
            }), V.setData(xe.initialData);
          });
        },
        close: () => {
          i((Y) => {
            cs(Y, Ov);
          });
        },
        toggleFullscreen: t.toggleFullscreen
      };
      return V;
    }, tl = (t, s, a) => {
      const i = An("dialog"), d = t.internalDialog, g = Ze(d.title, i, a), p = w(d.size), C = Ua(p.get()).toArray(), S = (Ce, Be) => (p.set(Be.internalDialog.size), sc(Be.internalDialog.size, Ce), A.some(Be)), _ = Yp({
        body: d.body,
        initialData: d.initialData
      }, i, a), D = dk(d.buttons), P = F4(D), L = Zn(D.length !== 0, qn({ buttons: D }, i, a)), V = I4(() => xe, Lt(() => me, a.shared.providers, s), a.shared.getSink), Y = {
        id: i,
        header: g,
        body: _,
        footer: L,
        extraClasses: C,
        extraBehaviours: [vn.config({
          channel: `${Fv}-${i}`,
          updateState: S,
          initialData: t
        })],
        extraStyles: {}
      }, me = hy(Y, V, a), Pe = (() => {
        const Ce = () => {
          const St = Va.getBody(me);
          return ts.getCurrent(St).getOr(St);
        }, Be = () => {
          gy(me, p.get());
        };
        return {
          getId: U(i),
          getRoot: U(me),
          getBody: () => Va.getBody(me),
          getFooter: () => Va.getFooter(me),
          getFormWrapper: Ce,
          toggleFullscreen: Be
        };
      })(), xe = bl(Pe, s.redial, P);
      return {
        dialog: me,
        instanceApi: xe
      };
    }, pu = (t, s, a, i = !1, d) => {
      const g = An("dialog"), p = An("dialog-label"), C = An("dialog-content"), S = t.internalDialog, _ = w(S.size), D = Ua(_.get()).toArray(), P = (tt, Vt) => (_.set(Vt.internalDialog.size), sc(Vt.internalDialog.size, tt), d(), A.some(Vt)), L = js(Dw({
        title: S.title,
        draggable: !0
      }, g, p, a.shared.providers)), V = js(lk({
        body: S.body,
        initialData: S.initialData
      }, g, C, a, i)), Y = dk(S.buttons), me = F4(Y), Pe = Zn(Y.length !== 0, js(Ge({ buttons: Y }, g, a))), xe = I4(() => ct, {
        onBlock: (tt) => {
          Ym.block(Be, (Vt, Xt) => {
            const $o = L.getOpt(Be).map((Hn) => hr(Hn.element));
            return jt(tt.message, Xt, a.shared.providers, $o);
          });
        },
        onUnblock: () => {
          Ym.unblock(Be);
        },
        onClose: () => s.closeWindow()
      }, a.shared.getSink), Be = Xc({
        dom: {
          tag: "div",
          classes: [
            "tox-dialog",
            "tox-dialog-inline",
            ...D
          ],
          attributes: {
            role: "dialog",
            "aria-labelledby": p
          }
        },
        eventOrder: {
          [vg()]: [
            vn.name(),
            Wi.name()
          ],
          [cl()]: ["execute-on-form"],
          [Nl()]: [
            "reflecting",
            "execute-on-form"
          ]
        },
        behaviours: Ut([
          no.config({
            mode: "cyclic",
            onEscape: (tt) => (cs(tt, Ov), A.some(!0)),
            useTabstopAt: (tt) => !$v(tt) && (Ds(tt) !== "button" || rr(tt, "disabled") !== "disabled"),
            firstTabstop: 1
          }),
          vn.config({
            channel: `${Fv}-${g}`,
            updateState: P,
            initialData: t
          }),
          po.config({}),
          Bo("execute-on-form", xe.concat([
            $d($c(), (tt, Vt) => {
              no.focusIn(tt);
            }),
            mt(t0(), (tt, Vt) => {
              tt.getSystem().broadcastOn([Iv], { newFocus: Vt.event.newFocus });
            })
          ])),
          Ym.config({ getRoot: () => A.some(Be) }),
          Oo.config({}),
          UT({})
        ]),
        components: [
          L.asSpec(),
          V.asSpec(),
          ...Pe.map((tt) => tt.asSpec()).toArray()
        ]
      }), St = () => {
        gy(Be, _.get());
      }, ct = bl({
        getId: U(g),
        getRoot: U(Be),
        getFooter: () => Pe.map((tt) => tt.get(Be)),
        getBody: () => V.get(Be),
        getFormWrapper: () => {
          const tt = V.get(Be);
          return ts.getCurrent(tt).getOr(tt);
        },
        toggleFullscreen: St
      }, s.redial, me);
      return {
        dialog: Be,
        instanceApi: ct
      };
    };
    var cm = tinymce.util.Tools.resolve("tinymce.util.URI");
    const Rw = (t) => {
      const s = (p) => {
        t.getSystem().isConnected() && p(t);
      };
      return {
        block: (p) => {
          if (!Ee(p))
            throw new Error("The urlDialogInstanceAPI.block function should be passed a blocking message of type string as an argument");
          s((C) => {
            to(C, rO, { message: p });
          });
        },
        unblock: () => {
          s((p) => {
            cs(p, aO);
          });
        },
        close: () => {
          s((p) => {
            cs(p, Ov);
          });
        },
        sendMessage: (p) => {
          s((C) => {
            C.getSystem().broadcastOn([FO], p);
          });
        }
      };
    }, vl = [
      "insertContent",
      "setContent",
      "execCommand",
      "close",
      "block",
      "unblock"
    ], FI = (t) => Bt(t) && vl.indexOf(t.mceAction) !== -1, II = (t) => !FI(t) && Bt(t) && Lo(t, "mceAction"), LI = (t, s, a) => {
      switch (a.mceAction) {
        case "insertContent":
          t.insertContent(a.content);
          break;
        case "setContent":
          t.setContent(a.content);
          break;
        case "execCommand":
          const i = Ft(a.ui) ? a.ui : !1;
          t.execCommand(a.cmd, i, a.value);
          break;
        case "close":
          s.close();
          break;
        case "block":
          s.block(a.message);
          break;
        case "unblock":
          s.unblock();
          break;
      }
    }, qK = (t, s, a, i) => {
      const d = An("dialog"), g = Ze(t.title, d, i), p = dy(t), C = t.buttons.bind((Be) => Be.length === 0 ? A.none() : A.some(qn({ buttons: Be }, d, i))), S = PI(() => Ce, Lt(() => xe, i.shared.providers, s)), _ = {
        ...t.height.fold(() => ({}), (Be) => ({
          height: Be + "px",
          "max-height": Be + "px"
        })),
        ...t.width.fold(() => ({}), (Be) => ({
          width: Be + "px",
          "max-width": Be + "px"
        }))
      }, D = t.width.isNone() && t.height.isNone() ? ["tox-dialog--width-lg"] : [], P = new cm(t.url, { base_uri: new cm(window.location.href) }), L = `${P.protocol}://${P.host}${P.port ? ":" + P.port : ""}`, V = Om(), Y = (Be, St) => A.some(St), me = [
        vn.config({
          channel: `${Fv}-${d}`,
          updateState: Y,
          initialData: t
        }),
        Bo("messages", [
          cr(() => {
            const Be = hi(ve.fromDom(window), "message", (St) => {
              if (P.isSameOrigin(new cm(St.raw.origin))) {
                const ct = St.raw.data;
                FI(ct) ? LI(a, Ce, ct) : II(ct) && t.onMessage(Ce, ct);
              }
            });
            V.set(Be);
          }),
          Fd(V.clear)
        ]),
        Wi.config({
          channels: {
            [FO]: {
              onReceive: (Be, St) => {
                va(Be.element, "iframe").each((ct) => {
                  const tt = ct.dom.contentWindow;
                  En(tt) && tt.postMessage(St, L);
                });
              }
            }
          }
        })
      ], xe = hy({
        id: d,
        header: g,
        body: p,
        footer: C,
        extraClasses: D,
        extraBehaviours: me,
        extraStyles: _
      }, S, i), Ce = Rw(xe);
      return {
        dialog: xe,
        instanceApi: Ce
      };
    }, GK = (t) => {
      const s = t.shared;
      return { open: (i, d) => {
        const g = () => {
          Va.hide(_), d();
        }, p = js(oE({
          name: "close-alert",
          text: "OK",
          primary: !0,
          buttonType: A.some("primary"),
          align: "end",
          enabled: !0,
          icon: A.none()
        }, "cancel", t)), C = fy(), S = my(g, s.providers), _ = Xc(uk({
          lazySink: () => s.getSink(),
          header: Qf(C, S),
          body: Ow(i, s.providers),
          footer: A.some(Zb($4([], [p.asSpec()]))),
          onEscape: g,
          extraClasses: ["tox-alert-dialog"],
          extraBehaviours: [],
          extraStyles: {},
          dialogEvents: [mt(Np, g)],
          eventOrder: {}
        }));
        Va.show(_);
        const D = p.get(_);
        po.focus(D);
      } };
    }, KK = (t) => {
      const s = t.shared;
      return { open: (i, d) => {
        const g = (L) => {
          Va.hide(D), d(L);
        }, p = js(oE({
          name: "yes",
          text: "Yes",
          primary: !0,
          buttonType: A.some("primary"),
          align: "end",
          enabled: !0,
          icon: A.none()
        }, "submit", t)), C = oE({
          name: "no",
          text: "No",
          primary: !1,
          buttonType: A.some("secondary"),
          align: "end",
          enabled: !0,
          icon: A.none()
        }, "cancel", t), S = fy(), _ = my(() => g(!1), s.providers), D = Xc(uk({
          lazySink: () => s.getSink(),
          header: Qf(S, _),
          body: Ow(i, s.providers),
          footer: A.some(Zb($4([], [
            C,
            p.asSpec()
          ]))),
          onEscape: () => g(!1),
          extraClasses: ["tox-confirm-dialog"],
          extraBehaviours: [],
          extraStyles: {},
          dialogEvents: [
            mt(Np, () => g(!1)),
            mt(H2, () => g(!0))
          ],
          eventOrder: {}
        }));
        Va.show(D);
        const P = p.get(D);
        po.focus(P);
      } };
    }, xq = (t, s) => Js($r("data", s, t)), Tq = (t) => $2(t, ".tox-alert-dialog") || $2(t, ".tox-confirm-dialog"), YK = (t, s, a) => s && a ? [] : [Da.config({
      contextual: {
        lazyContext: () => A.some(Ar(ve.fromDom(t.getContentAreaContainer()))),
        fadeInClass: "tox-dialog-dock-fadein",
        fadeOutClass: "tox-dialog-dock-fadeout",
        transitionClass: "tox-dialog-dock-transition"
      },
      modes: ["top"],
      lazyViewport: (i) => Rp(t, i.element).map((g) => ({
        bounds: Av(g),
        optScrollEnv: A.some({
          currentScrollTop: g.element.dom.scrollTop,
          scrollElmTop: Cc(g.element).top
        })
      })).getOrThunk(() => ({
        bounds: La(),
        optScrollEnv: A.none()
      }))
    })], XK = (t) => {
      const s = t.editor, a = C2(s), i = GK(t.backstages.dialog), d = KK(t.backstages.dialog), g = (Y, me, Pe) => {
        if (!Zt(me)) {
          if (me.inline === "toolbar")
            return _(Y, t.backstages.popup.shared.anchors.inlineDialog(), Pe, me);
          if (me.inline === "bottom")
            return D(Y, t.backstages.popup.shared.anchors.inlineBottomDialog(), Pe, me);
          if (me.inline === "cursor")
            return _(Y, t.backstages.popup.shared.anchors.cursor(), Pe, me);
        }
        return S(Y, Pe);
      }, p = (Y, me) => C(Y, me), C = (Y, me) => {
        const Pe = (xe) => {
          const Ce = qK(xe, {
            closeWindow: () => {
              Va.hide(Ce.dialog), me(Ce.instanceApi);
            }
          }, s, t.backstages.dialog);
          return Va.show(Ce.dialog), Ce.instanceApi;
        };
        return Po.openUrl(Pe, Y);
      }, S = (Y, me) => {
        const Pe = (xe, Ce, Be) => {
          const St = Ce, tt = tl({
            dataValidator: Be,
            initialData: St,
            internalDialog: xe
          }, {
            redial: Po.redial,
            closeWindow: () => {
              Va.hide(tt.dialog), me(tt.instanceApi);
            }
          }, t.backstages.dialog);
          return Va.show(tt.dialog), tt.instanceApi.setData(St), tt.instanceApi;
        };
        return Po.open(Pe, Y);
      }, _ = (Y, me, Pe, xe) => {
        const Ce = (Be, St, ct) => {
          const tt = xq(St, ct), Vt = Go(), Xt = t.backstages.popup.shared.header.isPositionedAtTop(), $o = {
            dataValidator: ct,
            initialData: tt,
            internalDialog: Be
          }, Hn = () => Vt.on((ro) => {
            qr.reposition(ro), (!a || !Xt) && Da.refresh(ro);
          }), co = pu($o, {
            redial: Po.redial,
            closeWindow: () => {
              Vt.on(qr.hide), s.off("ResizeEditor", Hn), Vt.clear(), Pe(co.instanceApi);
            }
          }, t.backstages.popup, xe.ariaAttrs, Hn), bo = Xc(qr.sketch({
            lazySink: t.backstages.popup.shared.getSink,
            dom: {
              tag: "div",
              classes: []
            },
            fireDismissalEventInstead: xe.persistent ? { event: "doNotDismissYet" } : {},
            ...Xt ? {} : { fireRepositionEventInstead: {} },
            inlineBehaviours: Ut([
              Bo("window-manager-inline-events", [mt(bf(), (ro, ys) => {
                cs(co.dialog, Np);
              })]),
              ...YK(s, a, Xt)
            ]),
            isExtraPart: (ro, ys) => Tq(ys)
          }));
          Vt.set(bo);
          const zs = () => {
            const ro = s.inline ? fr() : ve.fromDom(s.getContainer()), ys = Ar(ro);
            return A.some(ys);
          };
          return qr.showWithinBounds(bo, Pl(co.dialog), { anchor: me }, zs), (!a || !Xt) && (Da.refresh(bo), s.on("ResizeEditor", Hn)), co.instanceApi.setData(tt), no.focusIn(co.dialog), co.instanceApi;
        };
        return Po.open(Ce, Y);
      }, D = (Y, me, Pe, xe) => {
        const Ce = (Be, St, ct) => {
          const tt = xq(St, ct), Vt = Go(), Xt = t.backstages.popup.shared.header.isPositionedAtTop(), $o = {
            dataValidator: ct,
            initialData: tt,
            internalDialog: Be
          }, Hn = () => Vt.on((ro) => {
            qr.reposition(ro), Da.refresh(ro);
          }), co = pu($o, {
            redial: Po.redial,
            closeWindow: () => {
              Vt.on(qr.hide), s.off("ResizeEditor ScrollWindow ElementScroll", Hn), Vt.clear(), Pe(co.instanceApi);
            }
          }, t.backstages.popup, xe.ariaAttrs, Hn), bo = Xc(qr.sketch({
            lazySink: t.backstages.popup.shared.getSink,
            dom: {
              tag: "div",
              classes: []
            },
            fireDismissalEventInstead: xe.persistent ? { event: "doNotDismissYet" } : {},
            ...Xt ? {} : { fireRepositionEventInstead: {} },
            inlineBehaviours: Ut([
              Bo("window-manager-inline-events", [mt(bf(), (ro, ys) => {
                cs(co.dialog, Np);
              })]),
              Da.config({
                contextual: {
                  lazyContext: () => A.some(Ar(ve.fromDom(s.getContentAreaContainer()))),
                  fadeInClass: "tox-dialog-dock-fadein",
                  fadeOutClass: "tox-dialog-dock-fadeout",
                  transitionClass: "tox-dialog-dock-transition"
                },
                modes: [
                  "top",
                  "bottom"
                ],
                lazyViewport: (ro) => Rp(s, ro.element).map((Jt) => ({
                  bounds: Av(Jt),
                  optScrollEnv: A.some({
                    currentScrollTop: Jt.element.dom.scrollTop,
                    scrollElmTop: Cc(Jt.element).top
                  })
                })).getOrThunk(() => ({
                  bounds: La(),
                  optScrollEnv: A.none()
                }))
              })
            ]),
            isExtraPart: (ro, ys) => Tq(ys)
          }));
          Vt.set(bo);
          const zs = () => t.backstages.popup.shared.getSink().toOptional().bind((ro) => {
            const ys = Rp(s, ro.element), Jt = 15, Fn = ys.map((uo) => Av(uo)).getOr(La()), So = Ar(ve.fromDom(s.getContentAreaContainer())), ns = sf(So, Fn);
            return A.some(Rr(ns.x, ns.y, ns.width, ns.height - Jt));
          });
          return qr.showWithinBounds(bo, Pl(co.dialog), { anchor: me }, zs), Da.refresh(bo), s.on("ResizeEditor ScrollWindow ElementScroll ResizeWindow", Hn), co.instanceApi.setData(tt), no.focusIn(co.dialog), co.instanceApi;
        };
        return Po.open(Ce, Y);
      };
      return {
        open: g,
        openUrl: p,
        alert: (Y, me) => {
          i.open(Y, me);
        },
        close: (Y) => {
          Y.close();
        },
        confirm: (Y, me) => {
          d.open(Y, me);
        }
      };
    }, JK = (t) => {
      pN(t), w8(t), AW(t);
    };
    var QK = () => {
      _l.add("silver", (t) => {
        JK(t);
        let s = () => La();
        const {
          dialogs: a,
          popups: i,
          renderUI: d
        } = kZ(t, { getPopupSinkBounds: () => s() }), g = () => {
          const S = d();
          return Rp(t, i.getMothership().element).each((D) => {
            s = () => Av(D);
          }), S;
        };
        d7.register(t, i.backstage.shared);
        const p = XK({
          editor: t,
          backstages: {
            popup: i.backstage,
            dialog: a.backstage
          }
        }), C = () => $A(t, { backstage: i.backstage }, i.getMothership());
        return {
          renderUI: g,
          getWindowManagerImpl: U(p),
          getNotificationManagerImpl: C
        };
      });
    };
    QK();
  })()), iG;
}
var uG;
function BY() {
  return uG || (uG = 1, PY()), cG;
}
BY();
var dG = {}, mG = {}, fG;
function $Y() {
  return fG || (fG = 1, tinymce.IconManager.add("default", {
    icons: {
      "accessibility-check": '<svg width="24" height="24"><path d="M12 2a2 2 0 0 1 2 2 2 2 0 0 1-2 2 2 2 0 0 1-2-2c0-1.1.9-2 2-2Zm8 7h-5v12c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-5c0-.6-.4-1-1-1a1 1 0 0 0-1 1v5c0 .6-.4 1-1 1a1 1 0 0 1-1-1V9H4a1 1 0 1 1 0-2h16c.6 0 1 .4 1 1s-.4 1-1 1Z" fill-rule="nonzero"/></svg>',
      "accordion-toggle": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M12 15c0-.6.4-1 1-1h6c.6 0 1 .4 1 1s-.4 1-1 1h-6a1 1 0 0 1-1-1Z"/><path opacity=".2" fill-rule="evenodd" clip-rule="evenodd" d="M4 15c0-.6.4-1 1-1h6c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1-1-1Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M12 19c0-.6.4-1 1-1h6c.6 0 1 .4 1 1s-.4 1-1 1h-6a1 1 0 0 1-1-1Z"/><path opacity=".2" fill-rule="evenodd" clip-rule="evenodd" d="M4 19c0-.6.4-1 1-1h6c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1-1-1Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M12.3 7.3a1 1 0 0 1 1.4 0L16 9.6l2.3-2.3a1 1 0 1 1 1.4 1.4L16 12.4l-3.7-3.7a1 1 0 0 1 0-1.4ZM4.3 11.7a1 1 0 0 1 0-1.4L6.6 8 4.3 5.7a1 1 0 0 1 1.4-1.4L9.4 8l-3.7 3.7a1 1 0 0 1-1.4 0Z"/></svg>',
      accordion: '<svg width="24" height="24"><rect x="12" y="7" width="10" height="2" rx="1"/><rect x="12" y="11" width="10" height="2" rx="1"/><rect x="12" y="15" width="6" height="2" rx="1"/><path fill-rule="evenodd" clip-rule="evenodd" d="M2.3 7.3a1 1 0 0 1 1.4 0L6 9.6l2.3-2.3a1 1 0 0 1 1.4 1.4L6 12.4 2.3 8.7a1 1 0 0 1 0-1.4Z"/></svg>',
      "action-next": '<svg width="24" height="24"><path fill-rule="nonzero" d="M5.7 7.3a1 1 0 0 0-1.4 1.4l7.7 7.7 7.7-7.7a1 1 0 1 0-1.4-1.4L12 13.6 5.7 7.3Z"/></svg>',
      "action-prev": '<svg width="24" height="24"><path fill-rule="nonzero" d="M18.3 15.7a1 1 0 0 0 1.4-1.4L12 6.6l-7.7 7.7a1 1 0 0 0 1.4 1.4L12 9.4l6.3 6.3Z"/></svg>',
      addtag: '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M15 5a2 2 0 0 1 1.6.8L21 12l-4.4 6.2a2 2 0 0 1-1.6.8h-3v-2h3l3.5-5L15 7H5v3H3V7c0-1.1.9-2 2-2h10Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M6 12a1 1 0 0 0-1 1v2H3a1 1 0 1 0 0 2h2v2a1 1 0 1 0 2 0v-2h2a1 1 0 1 0 0-2H7v-2c0-.6-.4-1-1-1Z"/></svg>',
      "ai-prompt": '<svg width="24" height="24"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M15 6.7a1 1 0 0 0-1.4 0l-9.9 10a1 1 0 0 0 0 1.3l2.1 2.1c.4.4 1 .4 1.4 0l10-9.9c.3-.3.3-1 0-1.4l-2.2-2Zm1.4 2.8-2-2-3 2.7 2.2 2.2 2.8-2.9Z"/><path d="m18.5 7.3-.7-1.5-1.5-.8 1.5-.7.7-1.5.7 1.5 1.5.7-1.5.8-.7 1.5ZM18.5 16.5l-.7-1.6-1.5-.7 1.5-.7.7-1.6.7 1.6 1.5.7-1.5.7-.7 1.6ZM9.7 7.3 9 5.8 7.5 5 9 4.3l.7-1.5.7 1.5L12 5l-1.5.8-.7 1.5Z"/></g><defs><clipPath id="a"><path d="M0 0h24v24H0z"/></clipPath></defs></svg>',
      ai: '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M5 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3V6a3 3 0 0 0-3-3H5Zm6.8 11.5.5 1.2a68.3 68.3 0 0 0 .7 1.1l.4.1c.3 0 .5 0 .7-.3.2-.1.3-.3.3-.6l-.3-1-2.6-6.2a20.4 20.4 0 0 0-.5-1.3l-.5-.4-.7-.2c-.2 0-.5 0-.6.2-.2 0-.4.2-.5.4l-.3.6-.3.7L5.7 15l-.2.6-.1.4c0 .3 0 .5.3.7l.6.2c.3 0 .5 0 .7-.2l.4-1 .5-1.2h3.9ZM9.8 9l1.5 4h-3l1.5-4Zm5.6-.9v7.6c0 .4 0 .7.2 1l.7.2c.3 0 .6 0 .8-.3l.2-.9V8.1c0-.4 0-.7-.2-.9a1 1 0 0 0-.8-.3c-.2 0-.5.1-.7.3l-.2 1Z"/></svg>',
      "align-center": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm3 4h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 1 1 0-2Zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Zm-3-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
      "align-justify": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
      "align-left": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 4h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Zm0-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
      "align-none": '<svg width="24" height="24"><path d="M14.2 5 13 7H5a1 1 0 1 1 0-2h9.2Zm4 0h.8a1 1 0 0 1 0 2h-2l1.2-2Zm-6.4 4-1.2 2H5a1 1 0 0 1 0-2h6.8Zm4 0H19a1 1 0 0 1 0 2h-4.4l1.2-2Zm-6.4 4-1.2 2H5a1 1 0 0 1 0-2h4.4Zm4 0H19a1 1 0 0 1 0 2h-6.8l1.2-2ZM7 17l-1.2 2H5a1 1 0 0 1 0-2h2Zm4 0h8a1 1 0 0 1 0 2H9.8l1.2-2Zm5.2-13.5 1.3.7-9.7 16.3-1.3-.7 9.7-16.3Z" fill-rule="evenodd"/></svg>',
      "align-right": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm6 4h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm-6-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
      "arrow-left": '<svg width="24" height="24"><path d="m5.6 13 12 6a1 1 0 0 0 1.4-1V6a1 1 0 0 0-1.4-.9l-12 6a1 1 0 0 0 0 1.8Z" fill-rule="evenodd"/></svg>',
      "arrow-right": '<svg width="24" height="24"><path d="m18.5 13-12 6A1 1 0 0 1 5 18V6a1 1 0 0 1 1.4-.9l12 6a1 1 0 0 1 0 1.8Z" fill-rule="evenodd"/></svg>',
      bold: '<svg width="24" height="24"><path d="M7.8 19c-.3 0-.5 0-.6-.2l-.2-.5V5.7c0-.2 0-.4.2-.5l.6-.2h5c1.5 0 2.7.3 3.5 1 .7.6 1.1 1.4 1.1 2.5a3 3 0 0 1-.6 1.9c-.4.6-1 1-1.6 1.2.4.1.9.3 1.3.6s.8.7 1 1.2c.4.4.5 1 .5 1.6 0 1.3-.4 2.3-1.3 3-.8.7-2.1 1-3.8 1H7.8Zm5-8.3c.6 0 1.2-.1 1.6-.5.4-.3.6-.7.6-1.3 0-1.1-.8-1.7-2.3-1.7H9.3v3.5h3.4Zm.5 6c.7 0 1.3-.1 1.7-.4.4-.4.6-.9.6-1.5s-.2-1-.7-1.4c-.4-.3-1-.4-2-.4H9.4v3.8h4Z" fill-rule="evenodd"/></svg>',
      bookmark: '<svg width="24" height="24"><path d="M6 4v17l6-4 6 4V4c0-.6-.4-1-1-1H7a1 1 0 0 0-1 1Z" fill-rule="nonzero"/></svg>',
      "border-style": '<svg width="24" height="24"><g fill-rule="evenodd"><rect width="18" height="2" x="3" y="6" rx="1"/><rect width="2.8" height="2" x="3" y="16" rx="1"/><rect width="2.8" height="2" x="6.8" y="16" rx="1"/><rect width="2.8" height="2" x="10.6" y="16" rx="1"/><rect width="2.8" height="2" x="14.4" y="16" rx="1"/><rect width="2.8" height="2" x="18.2" y="16" rx="1"/><rect width="8" height="2" x="3" y="11" rx="1"/><rect width="8" height="2" x="13" y="11" rx="1"/></g></svg>',
      "border-width": '<svg width="24" height="24"><g fill-rule="evenodd"><rect width="18" height="5" x="3" y="5" rx="1"/><rect width="18" height="3.5" x="3" y="11.5" rx="1"/><rect width="18" height="2" x="3" y="17" rx="1"/></g></svg>',
      brightness: '<svg width="24" height="24"><path d="M12 17c.3 0 .5.1.7.3.2.2.3.4.3.7v1c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7v-1c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3Zm0-10a1 1 0 0 1-.7-.3A1 1 0 0 1 11 6V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3.3 0 .5.1.7.3.2.2.3.4.3.7v1c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3Zm7 4c.3 0 .5.1.7.3.2.2.3.4.3.7 0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-1a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h1ZM7 12c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3H5a1 1 0 0 1-.7-.3A1 1 0 0 1 4 12c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h1c.3 0 .5.1.7.3.2.2.3.4.3.7Zm10 3.5.7.8c.2.1.3.4.3.6 0 .3-.1.6-.3.8a1 1 0 0 1-.8.3 1 1 0 0 1-.6-.3l-.8-.7a1 1 0 0 1-.3-.8c0-.2.1-.5.3-.7a1 1 0 0 1 1.4 0Zm-10-7-.7-.8a1 1 0 0 1-.3-.6c0-.3.1-.6.3-.8.2-.2.5-.3.8-.3.2 0 .5.1.7.3l.7.7c.2.2.3.5.3.8 0 .2-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.8-.3Zm10 0a1 1 0 0 1-.8.3 1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.6.3-.8l.8-.7c.1-.2.4-.3.6-.3.3 0 .6.1.8.3.2.2.3.5.3.8 0 .2-.1.5-.3.7l-.7.7Zm-10 7c.2-.2.5-.3.8-.3.2 0 .5.1.7.3a1 1 0 0 1 0 1.4l-.8.8a1 1 0 0 1-.6.3 1 1 0 0 1-.8-.3 1 1 0 0 1-.3-.8c0-.2.1-.5.3-.6l.7-.8ZM12 8a4 4 0 0 1 3.7 2.4 4 4 0 0 1 0 3.2A4 4 0 0 1 12 16a4 4 0 0 1-3.7-2.4 4 4 0 0 1 0-3.2A4 4 0 0 1 12 8Zm0 6.5c.7 0 1.3-.2 1.8-.7.5-.5.7-1.1.7-1.8s-.2-1.3-.7-1.8c-.5-.5-1.1-.7-1.8-.7s-1.3.2-1.8.7c-.5.5-.7 1.1-.7 1.8s.2 1.3.7 1.8c.5.5 1.1.7 1.8.7Z" fill-rule="evenodd"/></svg>',
      browse: '<svg width="24" height="24"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-4v-2h4V8H5v10h4v2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 9.4-2.3 2.3a1 1 0 1 1-1.4-1.4l4-4a1 1 0 0 1 1.4 0l4 4a1 1 0 0 1-1.4 1.4L13 13.4V20a1 1 0 0 1-2 0v-6.6Z" fill-rule="nonzero"/></svg>',
      cancel: '<svg width="24" height="24"><path d="M12 4.6a7.4 7.4 0 1 1 0 14.8 7.4 7.4 0 0 1 0-14.8ZM12 3a9 9 0 1 0 0 18 9 9 0 0 0 0-18Zm0 8L14.8 8l1 1.1-2.7 2.8 2.7 2.7-1.1 1.1-2.7-2.7-2.7 2.7-1-1.1 2.6-2.7-2.7-2.7 1-1.1 2.8 2.7Z" fill-rule="nonzero"/></svg>',
      "cell-background-color": '<svg width="24" height="24"><path d="m15.7 2 1.6 1.6-2.7 2.6 5.9 5.8c.7.7.7 1.7 0 2.4l-6.3 6.1a1.7 1.7 0 0 1-2.4 0l-6.3-6.1c-.7-.7-.7-1.7 0-2.4L15.7 2ZM18 12l-4.5-4L9 12h9ZM4 16s2 2.4 2 3.8C6 21 5.1 22 4 22s-2-1-2-2.2C2 18.4 4 16 4 16Z"/></svg>',
      "cell-border-color": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M5 13v5h2v2H5a2 2 0 0 1-2-2v-5h2zm8-7V4h6a2 2 0 0 1 2 2h-8z" opacity=".2"/><path fill-rule="nonzero" d="M13 4v2H5v7H3V6c0-1.1.9-2 2-2h8zm-2.6 14.1.1-.1.1.1.2.3.2.2.2.2c.4.6.8 1.2.8 1.7 0 .8-.7 1.5-1.5 1.5S9 21.3 9 20.5c0-.5.4-1.1.8-1.7l.2-.2.2-.2.2-.3z"/><path d="m13 11-2 2H5v-2h6V6h2z"/><path fill-rule="nonzero" d="m18.4 8 1 1-1.8 1.9 4 4c.5.4.5 1.1 0 1.6l-4.3 4.2a1.2 1.2 0 0 1-1.6 0l-4.4-4.2c-.4-.5-.4-1.2 0-1.7l7-6.8Zm1.6 7-3-3-3 3h6Z"/></g></svg>',
      "change-case": '<svg width="24" height="24"><path d="M18.4 18.2v-.6c-.5.8-1.3 1.2-2.4 1.2-2.2 0-3.3-1.6-3.3-4.8 0-3.1 1-4.7 3.3-4.7 1.1 0 1.8.3 2.4 1.1v-.6c0-.5.4-.8.8-.8s.8.3.8.8v8.4c0 .5-.4.8-.8.8a.8.8 0 0 1-.8-.8zm-2-7.4c-1.3 0-1.8.9-1.8 3.2 0 2.4.5 3.3 1.7 3.3 1.3 0 1.8-.9 1.8-3.2 0-2.4-.5-3.3-1.7-3.3zM10 15.7H5.5l-.8 2.6a1 1 0 0 1-1 .7h-.2a.7.7 0 0 1-.7-1l4-12a1 1 0 0 1 2 0l4 12a.7.7 0 0 1-.8 1h-.2a1 1 0 0 1-1-.7l-.8-2.6zm-.3-1.5-2-6.5-1.9 6.5h3.9z" fill-rule="evenodd"/></svg>',
      "character-count": '<svg width="24" height="24"><path d="M4 11.5h16v1H4v-1Zm4.8-6.8V10H7.7V5.8h-1v-1h2ZM11 8.3V9h2v1h-3V7.7l2-1v-.9h-2v-1h3v2.4l-2 1Zm6.3-3.4V10h-3.1V9h2.1V8h-2.1V6.8h2.1v-1h-2.1v-1h3.1ZM5.8 16.4c0-.5.2-.8.5-1 .2-.2.6-.3 1.2-.3l.8.1c.2 0 .4.2.5.3l.4.4v2.8l.2.3H8.2V18.7l-.6.3H7c-.4 0-.7 0-1-.2a1 1 0 0 1-.3-.9c0-.3 0-.6.3-.8.3-.2.7-.4 1.2-.4l.6-.2h.3v-.2l-.1-.2a.8.8 0 0 0-.5-.1 1 1 0 0 0-.4 0l-.3.4h-1Zm2.3.8h-.2l-.2.1-.4.1a1 1 0 0 0-.4.2l-.2.2.1.3.5.1h.4l.4-.4v-.6Zm2-3.4h1.2v1.7l.5-.3h.5c.5 0 .9.1 1.2.5.3.4.5.8.5 1.4 0 .6-.2 1.1-.5 1.5-.3.4-.7.6-1.3.6l-.6-.1-.4-.4v.4h-1.1v-5.4Zm1.1 3.3c0 .3 0 .6.2.8a.7.7 0 0 0 1.2 0l.2-.8c0-.4 0-.6-.2-.8a.7.7 0 0 0-.6-.3l-.6.3-.2.8Zm6.1-.5c0-.2 0-.3-.2-.4a.8.8 0 0 0-.5-.2c-.3 0-.5.1-.6.3l-.2.9c0 .3 0 .6.2.8.1.2.3.3.6.3.2 0 .4 0 .5-.2l.2-.4h1.1c0 .5-.3.8-.6 1.1a2 2 0 0 1-1.3.4c-.5 0-1-.2-1.3-.6a2 2 0 0 1-.5-1.4c0-.6.1-1.1.5-1.5.3-.4.8-.5 1.4-.5.5 0 1 0 1.2.3.4.3.5.7.5 1.2h-1v-.1Z" fill-rule="evenodd"/></svg>',
      "checklist-rtl": '<svg width="24" height="24"><path d="M5 17h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2zm14.2 11c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 20c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 14c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 8c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8z" fill-rule="evenodd"/></svg>',
      checklist: '<svg width="24" height="24"><path d="M11 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8a1 1 0 0 1 0 2h-8a1 1 0 0 1 0-2ZM7.2 16c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 20c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8Zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 14c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8Zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 8c-.2.3-.7.4-1 0L3.8 6.9a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8Z" fill-rule="evenodd"/></svg>',
      checkmark: '<svg width="24" height="24"><path d="M18.2 5.4a1 1 0 0 1 1.6 1.2l-8 12a1 1 0 0 1-1.5.1l-5-5a1 1 0 1 1 1.4-1.4l4.1 4.1 7.4-11Z" fill-rule="nonzero"/></svg>',
      "chevron-down": '<svg width="10" height="10"><path d="M8.7 2.2c.3-.3.8-.3 1 0 .4.4.4.9 0 1.2L5.7 7.8c-.3.3-.9.3-1.2 0L.2 3.4a.8.8 0 0 1 0-1.2c.3-.3.8-.3 1.1 0L5 6l3.7-3.8Z" fill-rule="nonzero"/></svg>',
      "chevron-left": '<svg width="10" height="10"><path d="M7.8 1.3 4 5l3.8 3.7c.3.3.3.8 0 1-.4.4-.9.4-1.2 0L2.2 5.7a.8.8 0 0 1 0-1.2L6.6.2C7 0 7.4 0 7.8.2c.3.3.3.8 0 1.1Z" fill-rule="nonzero"/></svg>',
      "chevron-right": '<svg width="10" height="10"><path d="M2.2 1.3a.8.8 0 0 1 0-1c.4-.4.9-.4 1.2 0l4.4 4.1c.3.4.3.9 0 1.2L3.4 9.8c-.3.3-.8.3-1.2 0a.8.8 0 0 1 0-1.1L6 5 2.2 1.3Z" fill-rule="nonzero"/></svg>',
      "chevron-up": '<svg width="10" height="10"><path d="M8.7 7.8 5 4 1.3 7.8c-.3.3-.8.3-1 0a.8.8 0 0 1 0-1.2l4.1-4.4c.3-.3.9-.3 1.2 0l4.2 4.4c.3.3.3.9 0 1.2-.3.3-.8.3-1.1 0Z" fill-rule="nonzero"/></svg>',
      close: '<svg width="24" height="24"><path d="M17.3 8.2 13.4 12l3.9 3.8a1 1 0 0 1-1.5 1.5L12 13.4l-3.8 3.9a1 1 0 0 1-1.5-1.5l3.9-3.8-3.9-3.8a1 1 0 0 1 1.5-1.5l3.8 3.9 3.8-3.9a1 1 0 0 1 1.5 1.5Z" fill-rule="evenodd"/></svg>',
      "code-sample": '<svg width="24" height="26"><path d="M7.1 11a2.8 2.8 0 0 1-.8 2 2.8 2.8 0 0 1 .8 2v1.7c0 .3.1.6.4.8.2.3.5.4.8.4.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.7 0-1.4-.3-2-.8-.5-.6-.8-1.3-.8-2V15c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 0 1-.4-.4v-.8c0-.2.2-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V9.3c0-.7.3-1.4.8-2 .6-.5 1.3-.8 2-.8.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8V11Zm9.8 0V9.3c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 0 1-.4-.4V7c0-.2.1-.4.4-.4.7 0 1.4.3 2 .8.5.6.8 1.3.8 2V11c0 .3.1.6.4.8.2.3.5.4.8.4.2 0 .4.2.4.4v.8c0 .2-.2.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8v1.7c0 .7-.3 1.4-.8 2-.6.5-1.3.8-2 .8a.4.4 0 0 1-.4-.4v-.8c0-.2.1-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V15a2.8 2.8 0 0 1 .8-2 2.8 2.8 0 0 1-.8-2Zm-3.3-.4c0 .4-.1.8-.5 1.1-.3.3-.7.5-1.1.5-.4 0-.8-.2-1.1-.5-.4-.3-.5-.7-.5-1.1 0-.5.1-.9.5-1.2.3-.3.7-.4 1.1-.4.4 0 .8.1 1.1.4.4.3.5.7.5 1.2ZM12 13c.4 0 .8.1 1.1.5.4.3.5.7.5 1.1 0 1-.1 1.6-.5 2a3 3 0 0 1-1.1 1c-.4.3-.8.4-1.1.4a.5.5 0 0 1-.5-.5V17a3 3 0 0 0 1-.2l.6-.6c-.6 0-1-.2-1.3-.5-.2-.3-.3-.7-.3-1 0-.5.1-1 .5-1.2.3-.4.7-.5 1.1-.5Z" fill-rule="evenodd"/></svg>',
      "color-levels": '<svg width="24" height="24"><path d="M17.5 11.4A9 9 0 0 1 18 14c0 .5 0 1-.2 1.4 0 .4-.3.9-.5 1.3a6.2 6.2 0 0 1-3.7 3 5.7 5.7 0 0 1-3.2 0A5.9 5.9 0 0 1 7.6 18a6.2 6.2 0 0 1-1.4-2.6 6.7 6.7 0 0 1 0-2.8c0-.4.1-.9.3-1.3a13.6 13.6 0 0 1 2.3-4A20 20 0 0 1 12 4a26.4 26.4 0 0 1 3.2 3.4 18.2 18.2 0 0 1 2.3 4Zm-2 4.5c.4-.7.5-1.4.5-2a7.3 7.3 0 0 0-1-3.2c.2.6.2 1.2.2 1.9a4.5 4.5 0 0 1-1.3 3 5.3 5.3 0 0 1-2.3 1.5 4.9 4.9 0 0 1-2 .1 4.3 4.3 0 0 0 2.4.8 4 4 0 0 0 2-.6 4 4 0 0 0 1.5-1.5Z" fill-rule="evenodd"/></svg>',
      "color-picker": '<svg width="24" height="24"><path d="M12 3a9 9 0 0 0 0 18 1.5 1.5 0 0 0 1.1-2.5c-.2-.3-.4-.6-.4-1 0-.8.7-1.5 1.5-1.5H16a5 5 0 0 0 5-5c0-4.4-4-8-9-8Zm-5.5 9a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm3-4a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm5 0a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm3 4a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Z" fill-rule="nonzero"/></svg>',
      "color-swatch-remove-color": '<svg width="24" height="24"><path stroke="#000" stroke-width="2" d="M21 3 3 21" fill-rule="evenodd"/></svg>',
      "color-swatch": '<svg width="24" height="24"><rect x="3" y="3" width="18" height="18" rx="1" fill-rule="evenodd"/></svg>',
      "comment-add": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="m9 19 3-2h7c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H5a1 1 0 0 0-1 1v10c0 .6.4 1 1 1h4v2Zm-2 4v-4H5a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v10a3 3 0 0 1-3 3h-6.4L7 23Z"/><path d="M13 10h2a1 1 0 0 1 0 2h-2v2a1 1 0 0 1-2 0v-2H9a1 1 0 0 1 0-2h2V8a1 1 0 0 1 2 0v2Z"/></g></svg>',
      comment: '<svg width="24" height="24"><path fill-rule="nonzero" d="m9 19 3-2h7c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H5a1 1 0 0 0-1 1v10c0 .6.4 1 1 1h4v2Zm-2 4v-4H5a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v10a3 3 0 0 1-3 3h-6.4L7 23Z"/></svg>',
      contrast: '<svg width="24" height="24"><path d="M12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4Zm-6 8a6 6 0 0 0 6 6V6a6 6 0 0 0-6 6Z" fill-rule="evenodd"/></svg>',
      copy: '<svg width="24" height="24"><path d="M16 3H6a2 2 0 0 0-2 2v11h2V5h10V3Zm1 4a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2V9c0-1.2.9-2 2-2h7Zm0 12V9h-7v10h7Z" fill-rule="nonzero"/></svg>',
      crop: '<svg width="24" height="24"><path d="M17 8v7h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v2c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-2H7V9H5a1 1 0 1 1 0-2h2V5c0-.6.4-1 1-1s1 .4 1 1v2h7l3-3 1 1-3 3ZM9 9v5l5-5H9Zm1 6h5v-5l-5 5Z" fill-rule="evenodd"/></svg>',
      "cut-column": '<svg width="24" height="24"><path fill-rule="evenodd" d="M7.2 4.5c.9 0 1.6.4 2.2 1A3.7 3.7 0 0 1 10.5 8v.5l1 1 4-4 1-.5a3.3 3.3 0 0 1 2 0c.4 0 .7.3 1 .5L17 8h4v13h-6V10l-1.5 1.5.5.5v4l-2.5-2.5-1 1v.5c0 .4 0 .8-.3 1.2-.2.5-.4.9-.8 1.2-.6.7-1.3 1-2.2 1-.8.2-1.5 0-2-.6l-.5-.8-.2-1c0-.4 0-.8.3-1.2A3.9 3.9 0 0 1 7 12.7c.5-.2 1-.3 1.5-.2l1-1-1-1c-.5 0-1 0-1.5-.2-.5-.1-1-.4-1.4-.9-.4-.3-.6-.7-.8-1.2L4.5 7c0-.4 0-.7.2-1 0-.3.3-.6.5-.8.5-.5 1.2-.8 2-.7Zm12.3 5h-3v10h3v-10ZM8 13.8h-.3l-.4.2a2.8 2.8 0 0 0-.7.4v.1a2.8 2.8 0 0 0-.6.8l-.1.4v.7l.2.5.5.2h.7a2.6 2.6 0 0 0 .8-.3 2.4 2.4 0 0 0 .7-.7 2.5 2.5 0 0 0 .3-.8 1.5 1.5 0 0 0 0-.8 1 1 0 0 0-.2-.4 1 1 0 0 0-.5-.2H8Zm3.5-3.7c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4s.7-.1 1-.4c.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4ZM7 5.8h-.4a1 1 0 0 0-.5.3 1 1 0 0 0-.2.5v.7a2.5 2.5 0 0 0 .3.8l.2.3h.1l.4.4.4.2.4.1h.7L9 9l.2-.4a1.6 1.6 0 0 0 0-.8 2.6 2.6 0 0 0-.3-.8A2.5 2.5 0 0 0 7.7 6l-.4-.1H7Z"/></svg>',
      "cut-row": '<svg width="24" height="24"><path fill-rule="evenodd" d="M22 3v5H9l3 3 2-2h4l-4 4 1 1h.5c.4 0 .8 0 1.2.3.5.2.9.4 1.2.8.7.6 1 1.3 1 2.2.2.8 0 1.5-.6 2l-.8.5-1 .2c-.4 0-.8 0-1.2-.3a3.9 3.9 0 0 1-2.1-2.2c-.2-.5-.3-1-.2-1.5l-1-1-1 1c0 .5 0 1-.2 1.5-.1.5-.4 1-.9 1.4-.3.4-.7.6-1.2.8l-1.2.3c-.4 0-.7 0-1-.2-.3 0-.6-.3-.8-.5-.5-.5-.8-1.2-.7-2 0-.9.4-1.6 1-2.2A3.7 3.7 0 0 1 8.6 14H9l1-1-4-4-.5-1a3.3 3.3 0 0 1 0-2c0-.4.3-.7.5-1l2 2V3h14ZM8.5 15.3h-.3a2.6 2.6 0 0 0-.8.4 2.5 2.5 0 0 0-.9 1.1l-.1.4v.7l.2.5.5.2h.7a2.5 2.5 0 0 0 .8-.3L9 18V18l.4-.4.2-.4.1-.4v-.7a1 1 0 0 0-.2-.5 1 1 0 0 0-.4-.2h-.5Zm7 0H15a1 1 0 0 0-.4.3 1 1 0 0 0-.2.5 1.5 1.5 0 0 0 0 .7v.4a2.8 2.8 0 0 0 .5.7h.1a2.8 2.8 0 0 0 .8.6l.4.1h.7l.5-.2.2-.5v-.7a2.6 2.6 0 0 0-.3-.8 2.4 2.4 0 0 0-.7-.7 2.5 2.5 0 0 0-.8-.3h-.3ZM12 11.6c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4s.7-.1 1-.4c.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4Zm8.5-7.1h-11v2h11v-2Z"/></svg>',
      cut: '<svg width="24" height="24"><path d="M18 15c.6.7 1 1.4 1 2.3 0 .8-.2 1.5-.7 2l-.8.5-1 .2c-.4 0-.8 0-1.2-.3a3.9 3.9 0 0 1-2.1-2.2c-.2-.5-.3-1-.2-1.5l-1-1-1 1c0 .5 0 1-.2 1.5-.1.5-.4 1-.9 1.4-.3.4-.7.6-1.2.8l-1.2.3c-.4 0-.7 0-1-.2-.3 0-.6-.3-.8-.5-.5-.5-.8-1.2-.7-2 0-.9.4-1.6 1-2.2A3.7 3.7 0 0 1 8.6 14H9l1-1-4-4-.5-1a3.3 3.3 0 0 1 0-2c0-.4.3-.7.5-1l6 6 6-6 .5 1a3.3 3.3 0 0 1 0 2c0 .4-.3.7-.5 1l-4 4 1 1h.5c.4 0 .8 0 1.2.3.5.2.9.4 1.2.8Zm-8.5 2.2.1-.4v-.7a1 1 0 0 0-.2-.5 1 1 0 0 0-.4-.2 1.6 1.6 0 0 0-.8 0 2.6 2.6 0 0 0-.8.3 2.5 2.5 0 0 0-.9 1.1l-.1.4v.7l.2.5.5.2h.7a2.5 2.5 0 0 0 .8-.3 2.8 2.8 0 0 0 1-1Zm2.5-2.8c.4 0 .7-.1 1-.4.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4s-.7.1-1 .4c-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4Zm5.4 4 .2-.5v-.7a2.6 2.6 0 0 0-.3-.8 2.4 2.4 0 0 0-.7-.7 2.5 2.5 0 0 0-.8-.3 1.5 1.5 0 0 0-.8 0 1 1 0 0 0-.4.2 1 1 0 0 0-.2.5 1.5 1.5 0 0 0 0 .7v.4l.3.4.3.4a2.8 2.8 0 0 0 .8.5l.4.1h.7l.5-.2Z" fill-rule="evenodd"/></svg>',
      "document-properties": '<svg width="24" height="24"><path d="M14.4 3H7a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V7.6L14.4 3ZM17 19H7V5h6v4h4v10Z" fill-rule="nonzero"/></svg>',
      drag: '<svg width="24" height="24"><path d="M13 5h2v2h-2V5Zm0 4h2v2h-2V9ZM9 9h2v2H9V9Zm4 4h2v2h-2v-2Zm-4 0h2v2H9v-2Zm0 4h2v2H9v-2Zm4 0h2v2h-2v-2ZM9 5h2v2H9V5Z" fill-rule="evenodd"/></svg>',
      "duplicate-column": '<svg width="24" height="24"><path d="M17 6v16h-7V6h7Zm-2 2h-3v12h3V8Zm-2-6v2H8v15H6V2h7Z"/></svg>',
      "duplicate-row": '<svg width="24" height="24"><path d="M22 11v7H6v-7h16Zm-2 2H8v3h12v-3Zm-1-6v2H4v5H2V7h17Z"/></svg>',
      duplicate: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M16 3v2H6v11H4V5c0-1.1.9-2 2-2h10Zm3 8h-2V9h-7v10h9a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2V9c0-1.2.9-2 2-2h7a2 2 0 0 1 2 2v2Z"/><path d="M17 14h1a1 1 0 0 1 0 2h-1v1a1 1 0 0 1-2 0v-1h-1a1 1 0 0 1 0-2h1v-1a1 1 0 0 1 2 0v1Z"/></g></svg>',
      "edit-block": '<svg width="24" height="24"><path fill-rule="nonzero" d="m19.8 8.8-9.4 9.4c-.2.2-.5.4-.9.4l-5.4 1.2 1.2-5.4.5-.8 9.4-9.4c.7-.7 1.8-.7 2.5 0l2.1 2.1c.7.7.7 1.8 0 2.5Zm-2-.2 1-.9v-.3l-2.2-2.2a.3.3 0 0 0-.3 0l-1 1L18 8.5Zm-1 1-2.5-2.4-6 6 2.5 2.5 6-6Zm-7 7.1-2.6-2.4-.3.3-.1.2-.7 3 3.1-.6h.1l.4-.5Z"/></svg>',
      "edit-image": '<svg width="24" height="24"><path d="M18 16h2V7a2 2 0 0 0-2-2H7v2h11v9ZM6 17h15a1 1 0 0 1 0 2h-1v1a1 1 0 0 1-2 0v-1H6a2 2 0 0 1-2-2V7H3a1 1 0 1 1 0-2h1V4a1 1 0 1 1 2 0v13Zm3-5.3 1.3 2 3-4.7 3.7 6H7l2-3.3Z" fill-rule="nonzero"/></svg>',
      "embed-page": '<svg width="24" height="24"><path d="M19 6V5H5v14h2A13 13 0 0 1 19 6Zm0 1.4c-.8.8-1.6 2.4-2.2 4.6H19V7.4Zm0 5.6h-2.4c-.4 1.8-.6 3.8-.6 6h3v-6Zm-4 6c0-2.2.2-4.2.6-6H13c-.7 1.8-1.1 3.8-1.1 6h3Zm-4 0c0-2.2.4-4.2 1-6H9.6A12 12 0 0 0 8 19h3ZM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm11.8 9c.4-1.9 1-3.4 1.8-4.5a9.2 9.2 0 0 0-4 4.5h2.2Zm-3.4 0a12 12 0 0 1 2.8-4 12 12 0 0 0-5 4h2.2Z" fill-rule="nonzero"/></svg>',
      embed: '<svg width="24" height="24"><path d="M4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm1 2v14h14V5H5Zm4.8 2.6 5.6 4a.5.5 0 0 1 0 .8l-5.6 4A.5.5 0 0 1 9 16V8a.5.5 0 0 1 .8-.4Z" fill-rule="nonzero"/></svg>',
      emoji: '<svg width="24" height="24"><path d="M9 11c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 0 0-1 1c0 .6.4 1 1 1Zm6 0c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 0 0-1 1c0 .6.4 1 1 1Zm-3 5.5c2.1 0 4-1.5 4.4-3.5H7.6c.5 2 2.3 3.5 4.4 3.5ZM12 4a8 8 0 1 0 0 16 8 8 0 0 0 0-16Zm0 14.5a6.5 6.5 0 1 1 0-13 6.5 6.5 0 0 1 0 13Z" fill-rule="nonzero"/></svg>',
      export: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M14.4 3 18 7v1h-5V5H7v14h9a1 1 0 0 1 2 0c0 1-.8 2-1.9 2H7c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2h7.5Z"/><path d="M18.1 12c.5 0 .9.4.9 1 0 .5-.3 1-.8 1h-7.3c-.5 0-.9-.4-.9-1 0-.5.3-1 .8-1h7.3Z"/><path d="M16.4 9.2a1 1 0 0 1 1.4.2l2.4 3.6-2.4 3.6a1 1 0 0 1-1.7-1v-.2l1.7-2.4-1.6-2.4a1 1 0 0 1 .2-1.4Z"/></g></svg>',
      fill: '<svg width="24" height="26"><path d="m16.6 12-9-9-1.4 1.4 2.4 2.4-5.2 5.1c-.5.6-.5 1.6 0 2.2L9 19.6a1.5 1.5 0 0 0 2.2 0l5.5-5.5c.5-.6.5-1.6 0-2.2ZM5.2 13 10 8.2l4.8 4.8H5.2ZM19 14.5s-2 2.2-2 3.5c0 1.1.9 2 2 2a2 2 0 0 0 2-2c0-1.3-2-3.5-2-3.5Z" fill-rule="nonzero"/></svg>',
      "flip-horizontally": '<svg width="24" height="24"><path d="M14 19h2v-2h-2v2Zm4-8h2V9h-2v2ZM4 7v10c0 1.1.9 2 2 2h3v-2H6V7h3V5H6a2 2 0 0 0-2 2Zm14-2v2h2a2 2 0 0 0-2-2Zm-7 16h2V3h-2v18Zm7-6h2v-2h-2v2Zm-4-8h2V5h-2v2Zm4 12a2 2 0 0 0 2-2h-2v2Z" fill-rule="nonzero"/></svg>',
      "flip-vertically": '<svg width="24" height="24"><path d="M5 14v2h2v-2H5Zm8 4v2h2v-2h-2Zm4-14H7a2 2 0 0 0-2 2v3h2V6h10v3h2V6a2 2 0 0 0-2-2Zm2 14h-2v2a2 2 0 0 0 2-2ZM3 11v2h18v-2H3Zm6 7v2h2v-2H9Zm8-4v2h2v-2h-2ZM5 18c0 1.1.9 2 2 2v-2H5Z" fill-rule="nonzero"/></svg>',
      footnote: '<svg width="24" height="24"><path d="M19 13c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2h14Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M19 4v6h-1V5h-1.5V4h2.6Z"/><path d="M12 18c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2h7ZM14 8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2h9Z"/></svg>',
      "format-painter": '<svg width="24" height="24"><path d="M18 5V4c0-.5-.4-1-1-1H5a1 1 0 0 0-1 1v4c0 .6.5 1 1 1h12c.6 0 1-.4 1-1V7h1v4H9v9c0 .6.4 1 1 1h2c.6 0 1-.4 1-1v-7h8V5h-3Z" fill-rule="nonzero"/></svg>',
      format: '<svg width="24" height="24"><path fill-rule="evenodd" d="M17 5a1 1 0 0 1 0 2h-4v11a1 1 0 0 1-2 0V7H7a1 1 0 1 1 0-2h10Z"/></svg>',
      fullscreen: '<svg width="24" height="24"><path d="m15.3 10-1.2-1.3 2.9-3h-2.3a.9.9 0 1 1 0-1.7H19c.5 0 .9.4.9.9v4.4a.9.9 0 1 1-1.8 0V7l-2.9 3Zm0 4 3 3v-2.3a.9.9 0 1 1 1.7 0V19c0 .5-.4.9-.9.9h-4.4a.9.9 0 1 1 0-1.8H17l-3-2.9 1.3-1.2ZM10 15.4l-2.9 3h2.3a.9.9 0 1 1 0 1.7H5a.9.9 0 0 1-.9-.9v-4.4a.9.9 0 1 1 1.8 0V17l2.9-3 1.2 1.3ZM8.7 10 5.7 7v2.3a.9.9 0 0 1-1.7 0V5c0-.5.4-.9.9-.9h4.4a.9.9 0 0 1 0 1.8H7l3 2.9-1.3 1.2Z" fill-rule="nonzero"/></svg>',
      gallery: '<svg width="24" height="24"><path fill-rule="nonzero" d="m5 15.7 2.3-2.2c.3-.3.7-.3 1 0L11 16l5.1-5c.3-.4.8-.4 1 0l2 1.9V8H5v7.7ZM5 18V19h3l1.8-1.9-2-2L5 17.9Zm14-3-2.5-2.4-6.4 6.5H19v-4ZM4 6h16c.6 0 1 .4 1 1v13c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V7c0-.6.4-1 1-1Zm6 7a2 2 0 1 1 0-4 2 2 0 0 1 0 4ZM4.5 4h15a.5.5 0 1 1 0 1h-15a.5.5 0 0 1 0-1Zm2-2h11a.5.5 0 1 1 0 1h-11a.5.5 0 0 1 0-1Z"/></svg>',
      gamma: '<svg width="24" height="24"><path d="M4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm1 2v14h14V5H5Zm6.5 11.8V14L9.2 8.7a5.1 5.1 0 0 0-.4-.8l-.1-.2H8v-1l.3-.1.3-.1h.7a1 1 0 0 1 .6.5l.1.3a8.5 8.5 0 0 1 .3.6l1.9 4.6 2-5.2a1 1 0 0 1 1-.6.5.5 0 0 1 .5.6L13 14v2.8a.7.7 0 0 1-1.4 0Z" fill-rule="nonzero"/></svg>',
      help: '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M12 5.5a6.5 6.5 0 0 0-6 9 6.3 6.3 0 0 0 1.4 2l1 1a6.3 6.3 0 0 0 3.6 1 6.5 6.5 0 0 0 6-9 6.3 6.3 0 0 0-1.4-2l-1-1a6.3 6.3 0 0 0-3.6-1ZM12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4Z"/><path d="M9.6 9.7a.7.7 0 0 1-.7-.8c0-1.1 1.5-1.8 3.2-1.8 1.8 0 3.2.8 3.2 2.4 0 1.4-.4 2.1-1.5 2.8-.2 0-.3.1-.3.2a2 2 0 0 0-.8.8.8.8 0 0 1-1.4-.6c.3-.7.8-1 1.3-1.5l.4-.2c.7-.4.8-.6.8-1.5 0-.5-.6-.9-1.7-.9-.5 0-1 .1-1.4.3-.2 0-.3.1-.3.2v-.2c0 .4-.4.8-.8.8Z" fill-rule="nonzero"/><circle cx="12" cy="16" r="1"/></g></svg>',
      "highlight-bg-color": '<svg width="24" height="24"><g fill-rule="evenodd"><path class="tox-icon-highlight-bg-color__color" d="M3 18h18v3H3z"/><path fill-rule="nonzero" d="M7.7 16.7H3l3.3-3.3-.7-.8L10.2 8l4 4.1-4 4.2c-.2.2-.6.2-.8 0l-.6-.7-1.1 1.1zm5-7.5L11 7.4l3-2.9a2 2 0 0 1 2.6 0L18 6c.7.7.7 2 0 2.7l-2.9 2.9-1.8-1.8-.5-.6"/></g></svg>',
      home: '<svg width="24" height="24"><path fill-rule="nonzero" d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>',
      "horizontal-rule": '<svg width="24" height="24"><path d="M4 11h16v2H4z" fill-rule="evenodd"/></svg>',
      "image-options": '<svg width="24" height="24"><path d="M6 10a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm12 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm-6 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Z" fill-rule="nonzero"/></svg>',
      image: '<svg width="24" height="24"><path d="m5 15.7 3.3-3.2c.3-.3.7-.3 1 0L12 15l4.1-4c.3-.4.8-.4 1 0l2 1.9V5H5v10.7ZM5 18V19h3l2.8-2.9-2-2L5 17.9Zm14-3-2.5-2.4-6.4 6.5H19v-4ZM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm6 8a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z" fill-rule="nonzero"/></svg>',
      indent: '<svg width="24" height="24"><path d="M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 1 1 0-2Zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm-5 4h12a1 1 0 0 1 0 2H7a1 1 0 0 1 0-2Zm-2.6-3.8L6.2 12l-1.8-1.2a1 1 0 0 1 1.2-1.6l3 2a1 1 0 0 1 0 1.6l-3 2a1 1 0 1 1-1.2-1.6Z" fill-rule="evenodd"/></svg>',
      info: '<svg width="24" height="24"><path d="M12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4Zm-1 3v2h2V7h-2Zm3 10v-1h-1v-5h-3v1h1v4h-1v1h4Z" fill-rule="evenodd"/></svg>',
      "insert-character": '<svg width="24" height="24"><path d="M15 18h4l1-2v4h-6v-3.3l1.4-1a6 6 0 0 0 1.8-2.9 6.3 6.3 0 0 0-.1-4.1 5.8 5.8 0 0 0-3-3.2c-.6-.3-1.3-.5-2.1-.5a5.1 5.1 0 0 0-3.9 1.8 6.3 6.3 0 0 0-1.3 6 6.2 6.2 0 0 0 1.8 3l1.4.9V20H4v-4l1 2h4v-.5l-2-1L5.4 15A6.5 6.5 0 0 1 4 11c0-1 .2-1.9.6-2.7A7 7 0 0 1 6.3 6C7.1 5.4 8 5 9 4.5c1-.3 2-.5 3.1-.5a8.8 8.8 0 0 1 5.7 2 7 7 0 0 1 1.7 2.3 6 6 0 0 1 .2 4.8c-.2.7-.6 1.3-1 1.9a7.6 7.6 0 0 1-3.6 2.5v.5Z" fill-rule="evenodd"/></svg>',
      "insert-time": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M12 19a7 7 0 1 0 0-14 7 7 0 0 0 0 14Zm0 2a9 9 0 1 1 0-18 9 9 0 0 1 0 18Z"/><path d="M16 12h-3V7c0-.6-.4-1-1-1a1 1 0 0 0-1 1v7h5c.6 0 1-.4 1-1s-.4-1-1-1Z"/></g></svg>',
      invert: '<svg width="24" height="24"><path d="M18 19.3 16.5 18a5.8 5.8 0 0 1-3.1 1.9 6.1 6.1 0 0 1-5.5-1.6A5.8 5.8 0 0 1 6 14v-.3l.1-1.2A13.9 13.9 0 0 1 7.7 9l-3-3 .7-.8 2.8 2.9 9 8.9 1.5 1.6-.7.6Zm0-5.5v.3l-.1 1.1-.4 1-1.2-1.2a4.3 4.3 0 0 0 .2-1v-.2c0-.4 0-.8-.2-1.3l-.5-1.4a14.8 14.8 0 0 0-3-4.2L12 6a26.1 26.1 0 0 0-2.2 2.5l-1-1a20.9 20.9 0 0 1 2.9-3.3L12 4l1 .8a22.2 22.2 0 0 1 4 5.4c.6 1.2 1 2.4 1 3.6Z" fill-rule="evenodd"/></svg>',
      italic: '<svg width="24" height="24"><path d="m16.7 4.7-.1.9h-.3c-.6 0-1 0-1.4.3-.3.3-.4.6-.5 1.1l-2.1 9.8v.6c0 .5.4.8 1.4.8h.2l-.2.8H8l.2-.8h.2c1.1 0 1.8-.5 2-1.5l2-9.8.1-.5c0-.6-.4-.8-1.4-.8h-.3l.2-.9h5.8Z" fill-rule="evenodd"/></svg>',
      language: '<svg width="24" height="24"><path d="M12 3a9 9 0 1 1 0 18 9 9 0 0 1 0-18Zm4.3 13.3c-.5 1-1.2 2-2 2.9a7.5 7.5 0 0 0 3.2-2.1l-.2-.2a6 6 0 0 0-1-.6Zm-8.6 0c-.5.2-.9.5-1.2.8.9 1 2 1.7 3.2 2a10 10 0 0 1-2-2.8Zm3.6-.8c-.8 0-1.6.1-2.2.3.5 1 1.2 1.9 2.1 2.7Zm1.5 0v3c.9-.8 1.6-1.7 2.1-2.7-.6-.2-1.4-.3-2.1-.3Zm-6-2.7H4.5c.2 1 .5 2.1 1 3h.3l1.3-1a10 10 0 0 1-.3-2Zm12.7 0h-2.3c0 .7-.1 1.4-.3 2l1.6 1.1c.5-1 .9-2 1-3.1Zm-3.8 0h-3V14c1 0 2 .1 2.7.4.2-.5.3-1 .3-1.6Zm-4.4 0h-3l.3 1.6c.8-.3 1.7-.4 2.7-.4v-1.3Zm-5.5-5c-.7 1-1.1 2.2-1.3 3.5h2.3c0-1 .2-1.8.5-2.6l-1.5-1Zm2.9 1.4v.1c-.2.6-.4 1.3-.4 2h3V9.4c-1 0-1.8-.1-2.6-.3Zm6.6 0h-.1l-2.4.3v1.8h3l-.5-2.1Zm3-1.4-.3.1-1.3.8c.3.8.5 1.6.5 2.6h2.3a7.5 7.5 0 0 0-1.3-3.5Zm-9 0 2 .2V5.5a9 9 0 0 0-2 2.2Zm3.5-2.3V8c.6 0 1.3 0 1.9-.2a9 9 0 0 0-2-2.3Zm-3-.7h-.1c-1.1.4-2.1 1-3 1.8l1.2.7a10 10 0 0 1 1.9-2.5Zm4.4 0 .1.1a10 10 0 0 1 1.8 2.4l1.1-.7a7.5 7.5 0 0 0-3-1.8Z"/></svg>',
      "line-height": '<svg width="24" height="24"><path d="M21 5a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zm0 4a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zm0 4a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zm0 4a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zM7 3.6l3.7 3.7a1 1 0 0 1-1.3 1.5h-.1L8 7.3v9.2l1.3-1.3a1 1 0 0 1 1.3 0h.1c.4.4.4 1 0 1.3v.1L7 20.4l-3.7-3.7a1 1 0 0 1 1.3-1.5h.1L6 16.7V7.4L4.7 8.7a1 1 0 0 1-1.3 0h-.1a1 1 0 0 1 0-1.3v-.1L7 3.6z"/></svg>',
      line: '<svg width="24" height="24"><path d="m15 9-8 8H4v-3l8-8 3 3Zm1-1-3-3 1-1h1c-.2 0 0 0 0 0l2 2s0 .2 0 0v1l-1 1ZM4 18h16v2H4v-2Z" fill-rule="evenodd"/></svg>',
      link: '<svg width="24" height="24"><path d="M6.2 12.3a1 1 0 0 1 1.4 1.4l-2 2a2 2 0 1 0 2.6 2.8l4.8-4.8a1 1 0 0 0 0-1.4 1 1 0 1 1 1.4-1.3 2.9 2.9 0 0 1 0 4L9.6 20a3.9 3.9 0 0 1-5.5-5.5l2-2Zm11.6-.6a1 1 0 0 1-1.4-1.4l2-2a2 2 0 1 0-2.6-2.8L11 10.3a1 1 0 0 0 0 1.4A1 1 0 1 1 9.6 13a2.9 2.9 0 0 1 0-4L14.4 4a3.9 3.9 0 0 1 5.5 5.5l-2 2Z" fill-rule="nonzero"/></svg>',
      "list-bull-circle": '<svg width="48" height="48"><g fill-rule="evenodd"><path d="M11 16a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6ZM11 26a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6ZM11 36a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6Z" fill-rule="nonzero"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>',
      "list-bull-default": '<svg width="48" height="48"><g fill-rule="evenodd"><circle cx="11" cy="14" r="3"/><circle cx="11" cy="24" r="3"/><circle cx="11" cy="34" r="3"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>',
      "list-bull-square": '<svg width="48" height="48"><g fill-rule="evenodd"><path d="M8 11h6v6H8zM8 21h6v6H8zM8 31h6v6H8z"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>',
      "list-num-default-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M37.4 17v-4.8h-.1l-1.5 1v-1.1l1.6-1.1h1.2v6zM33.3 17.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm1.7 5.7c0-1.2 1-2 2.2-2 1.3 0 2.1.8 2.1 1.8 0 .7-.3 1.2-1.3 2.2l-1.2 1v.2h2.6v1h-4.3v-.9l2-1.9c.8-.8 1-1.1 1-1.5 0-.5-.4-.8-1-.8-.5 0-.9.3-.9.9H35zm-1.7 4.3c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm3.2 7.3v-1h.7c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7s-1 .3-1 .8H35c0-1.1 1-1.8 2.2-1.8 1.2 0 2.1.6 2.1 1.6 0 .7-.4 1.2-1 1.3v.1c.7.1 1.3.7 1.3 1.4 0 1-1 1.9-2.4 1.9-1.3 0-2.2-.8-2.3-2h1.2c0 .6.5 1 1.1 1 .6 0 1-.4 1-1 0-.5-.3-.8-1-.8h-.7zm-3.3 2.7c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7z"/></g></svg>',
      "list-num-default": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10 17v-4.8l-1.5 1v-1.1l1.6-1h1.2V17h-1.2Zm3.6.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7Zm-5 5.7c0-1.2.8-2 2.1-2s2.1.8 2.1 1.8c0 .7-.3 1.2-1.4 2.2l-1.1 1v.2h2.6v1H8.6v-.9l2-1.9c.8-.8 1-1.1 1-1.5 0-.5-.4-.8-1-.8-.5 0-.9.3-.9.9H8.5Zm6.3 4.3c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7ZM10 34.4v-1h.7c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7s-1 .3-1 .8H8.6c0-1.1 1-1.8 2.2-1.8 1.3 0 2.1.6 2.1 1.6 0 .7-.4 1.2-1 1.3v.1c.8.1 1.3.7 1.3 1.4 0 1-1 1.9-2.4 1.9-1.3 0-2.2-.8-2.3-2h1.2c0 .6.5 1 1.1 1 .7 0 1-.4 1-1 0-.5-.3-.8-1-.8h-.7Zm4.7 2.7c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7Z"/></g></svg>',
      "list-num-lower-alpha-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M36.5 16c-.9 0-1.5-.5-1.5-1.3s.6-1.3 1.8-1.4h1v-.4c0-.4-.2-.6-.7-.6-.4 0-.7.1-.8.4h-1.1c0-.8.8-1.4 2-1.4S39 12 39 13V16h-1.2v-.6c-.3.4-.8.7-1.4.7Zm.4-.8c.6 0 1-.4 1-.9V14h-1c-.5.1-.7.3-.7.6 0 .4.3.6.7.6ZM33.1 16.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7ZM37.7 26c-.7 0-1.2-.2-1.5-.7v.7H35v-6.3h1.2v2.5c.3-.5.8-.9 1.5-.9 1.1 0 1.8 1 1.8 2.4 0 1.5-.7 2.4-1.8 2.4Zm-.5-3.6c-.6 0-1 .5-1 1.3s.4 1.4 1 1.4c.7 0 1-.6 1-1.4 0-.8-.3-1.3-1-1.3ZM33.2 26.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7zm6 7h-1c-.1-.5-.4-.8-1-.8s-1 .5-1 1.4c0 1 .4 1.4 1 1.4.5 0 .9-.2 1-.7h1c0 1-.8 1.7-2 1.7-1.4 0-2.2-.9-2.2-2.4s.8-2.4 2.2-2.4c1.2 0 2 .7 2 1.7zm-6.1 3c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>',
      "list-num-lower-alpha": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10.3 15.2c.5 0 1-.4 1-.9V14h-1c-.5.1-.8.3-.8.6 0 .4.3.6.8.6Zm-.4.9c-1 0-1.5-.6-1.5-1.4 0-.8.6-1.3 1.7-1.4h1.1v-.4c0-.4-.2-.6-.7-.6-.5 0-.8.1-.9.4h-1c0-.8.8-1.4 2-1.4 1.1 0 1.8.6 1.8 1.6V16h-1.1v-.6h-.1c-.2.4-.7.7-1.3.7Zm4.6 0c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm-3.2 10c-.6 0-1.2-.3-1.4-.8v.7H8.5v-6.3H10v2.5c.3-.5.8-.9 1.4-.9 1.2 0 1.9 1 1.9 2.4 0 1.5-.7 2.4-1.9 2.4Zm-.4-3.7c-.7 0-1 .5-1 1.3s.3 1.4 1 1.4c.6 0 1-.6 1-1.4 0-.8-.4-1.3-1-1.3Zm4 3.7c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm-2.2 7h-1.2c0-.5-.4-.8-.9-.8-.6 0-1 .5-1 1.4 0 1 .4 1.4 1 1.4.5 0 .8-.2 1-.7h1c0 1-.8 1.7-2 1.7-1.4 0-2.2-.9-2.2-2.4s.8-2.4 2.2-2.4c1.2 0 2 .7 2 1.7Zm1.8 3c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
      "list-num-lower-greek-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M37.4 16c-1.2 0-2-.8-2-2.3 0-1.5.8-2.4 2-2.4.6 0 1 .4 1.3 1v-.9H40v3.2c0 .4.1.5.4.5h.2v.9h-.6c-.6 0-1-.2-1-.7h-.2c-.2.4-.7.8-1.3.8Zm.3-1c.6 0 1-.5 1-1.3s-.4-1.3-1-1.3-1 .5-1 1.3.4 1.4 1 1.4ZM33.3 16.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7ZM36 21.9c0-1.5.8-2.3 2.1-2.3 1.2 0 2 .6 2 1.6 0 .6-.3 1-.9 1.3.9.3 1.3.8 1.3 1.7 0 1.2-.7 1.9-1.8 1.9-.6 0-1.1-.3-1.4-.8v2.2H36V22Zm1.8 1.2v-1h.3c.5 0 .9-.2.9-.7 0-.5-.3-.8-.9-.8-.5 0-.8.3-.8 1v2.2c0 .8.4 1.3 1 1.3s1-.4 1-1-.4-1-1.2-1h-.3ZM33.3 26.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7ZM37.1 34.6 34.8 30h1.4l1.7 3.5 1.7-3.5h1.1l-2.2 4.6v.1c.5.8.7 1.4.7 1.8 0 .4-.2.8-.4 1-.2.2-.6.3-1 .3-.9 0-1.3-.4-1.3-1.2 0-.5.2-1 .5-1.7l.1-.2Zm.7 1a2 2 0 0 0-.4.9c0 .3.1.4.4.4.3 0 .4-.1.4-.4 0-.2-.1-.6-.4-1ZM33.3 36.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
      "list-num-lower-greek": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10.5 15c.7 0 1-.5 1-1.3s-.3-1.3-1-1.3c-.5 0-.9.5-.9 1.3s.4 1.4 1 1.4Zm-.3 1c-1.1 0-1.8-.8-1.8-2.3 0-1.5.7-2.4 1.8-2.4.7 0 1.1.4 1.3 1h.1v-.9h1.2v3.2c0 .4.1.5.4.5h.2v.9h-.6c-.6 0-1-.2-1.1-.7h-.1c-.2.4-.7.8-1.4.8Zm5 .1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7Zm-4.9 7v-1h.3c.6 0 1-.2 1-.7 0-.5-.4-.8-1-.8-.5 0-.8.3-.8 1v2.2c0 .8.4 1.3 1.1 1.3.6 0 1-.4 1-1s-.5-1-1.3-1h-.3ZM8.6 22c0-1.5.7-2.3 2-2.3 1.2 0 2 .6 2 1.6 0 .6-.3 1-.8 1.3.8.3 1.3.8 1.3 1.7 0 1.2-.8 1.9-1.9 1.9-.6 0-1.1-.3-1.3-.8v2.2H8.5V22Zm6.2 4.2c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7Zm-4.5 8.5L8 30h1.4l1.7 3.5 1.7-3.5h1.1l-2.2 4.6v.1c.5.8.7 1.4.7 1.8 0 .4-.1.8-.4 1-.2.2-.6.3-1 .3-.9 0-1.3-.4-1.3-1.2 0-.5.2-1 .5-1.7l.1-.2Zm.7 1a2 2 0 0 0-.4.9c0 .3.1.4.4.4.3 0 .4-.1.4-.4 0-.2-.1-.6-.4-1Zm4.5.5c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
      "list-num-lower-roman-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M32.9 16v-1.2h-1.3V16H33Zm0 10v-1.2h-1.3V26H33Zm0 10v-1.2h-1.3V36H33Z"/><path fill-rule="nonzero" d="M36 21h-1.5v5H36zM36 31h-1.5v5H36zM39 21h-1.5v5H39zM39 31h-1.5v5H39zM42 31h-1.5v5H42zM36 11h-1.5v5H36zM36 19h-1.5v1H36zM36 29h-1.5v1H36zM39 19h-1.5v1H39zM39 29h-1.5v1H39zM42 29h-1.5v1H42zM36 9h-1.5v1H36z"/></g></svg>',
      "list-num-lower-roman": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M15.1 16v-1.2h1.3V16H15Zm0 10v-1.2h1.3V26H15Zm0 10v-1.2h1.3V36H15Z"/><path fill-rule="nonzero" d="M12 21h1.5v5H12zM12 31h1.5v5H12zM9 21h1.5v5H9zM9 31h1.5v5H9zM6 31h1.5v5H6zM12 11h1.5v5H12zM12 19h1.5v1H12zM12 29h1.5v1H12zM9 19h1.5v1H9zM9 29h1.5v1H9zM6 29h1.5v1H6zM12 9h1.5v1H12z"/></g></svg>',
      "list-num-upper-alpha-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="m39.3 17-.5-1.4h-2l-.5 1.4H35l2-6h1.6l2 6h-1.3Zm-1.6-4.7-.7 2.3h1.6l-.8-2.3ZM33.4 17c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7Zm4.7 9.9h-2.7v-6H38c1.2 0 1.9.6 1.9 1.5 0 .6-.5 1.2-1 1.3.7.1 1.3.7 1.3 1.5 0 1-.8 1.7-2 1.7Zm-1.4-5v1.5h1c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7h-1Zm0 4h1.1c.7 0 1.1-.3 1.1-.8 0-.6-.4-.9-1.1-.9h-1.1V26ZM33 27.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm4.9 10c-1.8 0-2.8-1.1-2.8-3.1s1-3.1 2.8-3.1c1.4 0 2.5.9 2.6 2.2h-1.3c0-.7-.6-1.1-1.3-1.1-1 0-1.6.7-1.6 2s.6 2 1.6 2c.7 0 1.2-.4 1.4-1h1.2c-.1 1.3-1.2 2.2-2.6 2.2Zm-4.5 0c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
      "list-num-upper-alpha": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="m12.6 17-.5-1.4h-2L9.5 17H8.3l2-6H12l2 6h-1.3ZM11 12.3l-.7 2.3h1.6l-.8-2.3Zm4.7 4.8c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7ZM11.4 27H8.7v-6h2.6c1.2 0 1.9.6 1.9 1.5 0 .6-.5 1.2-1 1.3.7.1 1.3.7 1.3 1.5 0 1-.8 1.7-2 1.7ZM10 22v1.5h1c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7h-1Zm0 4H11c.7 0 1.1-.3 1.1-.8 0-.6-.4-.9-1.1-.9H10V26Zm5.4 1.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm-4.1 10c-1.8 0-2.8-1.1-2.8-3.1s1-3.1 2.8-3.1c1.4 0 2.5.9 2.6 2.2h-1.3c0-.7-.6-1.1-1.3-1.1-1 0-1.6.7-1.6 2s.6 2 1.6 2c.7 0 1.2-.4 1.4-1h1.2c-.1 1.3-1.2 2.2-2.6 2.2Zm4.5 0c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
      "list-num-upper-roman-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M31.6 17v-1.2H33V17h-1.3Zm0 10v-1.2H33V27h-1.3Zm0 10v-1.2H33V37h-1.3Z"/><path fill-rule="nonzero" d="M34.5 20H36v7h-1.5zM34.5 30H36v7h-1.5zM37.5 20H39v7h-1.5zM37.5 30H39v7h-1.5zM40.5 30H42v7h-1.5zM34.5 10H36v7h-1.5z"/></g></svg>',
      "list-num-upper-roman": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M15.1 17v-1.2h1.3V17H15Zm0 10v-1.2h1.3V27H15Zm0 10v-1.2h1.3V37H15Z"/><path fill-rule="nonzero" d="M12 20h1.5v7H12zM12 30h1.5v7H12zM9 20h1.5v7H9zM9 30h1.5v7H9zM6 30h1.5v7H6zM12 10h1.5v7H12z"/></g></svg>',
      lock: '<svg width="24" height="24"><path d="M16.3 11c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H8V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h.3ZM10 8v3h4V8a1 1 0 0 0-.3-.7A1 1 0 0 0 13 7h-2a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7Z" fill-rule="evenodd"/></svg>',
      ltr: '<svg width="24" height="24"><path d="M11 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 7.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L11 5ZM4.4 16.2 6.2 15l-1.8-1.2a1 1 0 0 1 1.2-1.6l3 2a1 1 0 0 1 0 1.6l-3 2a1 1 0 1 1-1.2-1.6Z" fill-rule="evenodd"/></svg>',
      minus: '<svg width="24" height="24"><path d="M19 11a1 1 0 0 1 .1 2H5a1 1 0 0 1-.1-2H19Z"/></svg>',
      "more-drawer": '<svg width="24" height="24"><path d="M6 10a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm12 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm-6 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Z" fill-rule="nonzero"/></svg>',
      "new-document": '<svg width="24" height="24"><path d="M14.4 3H7a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V7.6L14.4 3ZM17 19H7V5h6v4h4v10Z" fill-rule="nonzero"/></svg>',
      "new-tab": '<svg width="24" height="24"><path d="m15 13 2-2v8H5V7h8l-2 2H7v8h8v-4Zm4-8v5.5l-2-2-5.6 5.5H10v-1.4L15.5 7l-2-2H19Z" fill-rule="evenodd"/></svg>',
      "non-breaking": '<svg width="24" height="24"><path d="M11 11H8a1 1 0 1 1 0-2h3V6c0-.6.4-1 1-1s1 .4 1 1v3h3c.6 0 1 .4 1 1s-.4 1-1 1h-3v3c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-3Zm10 4v5H3v-5c0-.6.4-1 1-1s1 .4 1 1v3h14v-3c0-.6.4-1 1-1s1 .4 1 1Z" fill-rule="evenodd"/></svg>',
      notice: '<svg width="24" height="24"><path d="M15.5 4 20 8.5v7L15.5 20h-7L4 15.5v-7L8.5 4h7ZM13 17v-2h-2v2h2Zm0-4V7h-2v6h2Z" fill-rule="evenodd" clip-rule="evenodd"/></svg>',
      "ordered-list-rtl": '<svg width="24" height="24"><path d="M6 17h8a1 1 0 0 1 0 2H6a1 1 0 0 1 0-2Zm0-6h8a1 1 0 0 1 0 2H6a1 1 0 0 1 0-2Zm0-6h8a1 1 0 0 1 0 2H6a1 1 0 1 1 0-2Zm13-1v3.5a.5.5 0 1 1-1 0V5h-.5a.5.5 0 1 1 0-1H19Zm-1 8.8.2.2h1.3a.5.5 0 1 1 0 1h-1.6a1 1 0 0 1-.9-1V13c0-.4.3-.8.6-1l1.2-.4.2-.3a.2.2 0 0 0-.2-.2h-1.3a.5.5 0 0 1-.5-.5c0-.3.2-.5.5-.5h1.6c.5 0 .9.4.9 1v.1c0 .4-.3.8-.6 1l-1.2.4-.2.3Zm2 4.2v2c0 .6-.4 1-1 1h-1.5a.5.5 0 0 1 0-1h1.2a.3.3 0 1 0 0-.6h-1.3a.4.4 0 1 1 0-.8h1.3a.3.3 0 0 0 0-.6h-1.2a.5.5 0 1 1 0-1H19c.6 0 1 .4 1 1Z" fill-rule="evenodd"/></svg>',
      "ordered-list": '<svg width="24" height="24"><path d="M10 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 1 1 0-2ZM6 4v3.5c0 .3-.2.5-.5.5a.5.5 0 0 1-.5-.5V5h-.5a.5.5 0 0 1 0-1H6Zm-1 8.8.2.2h1.3c.3 0 .5.2.5.5s-.2.5-.5.5H4.9a1 1 0 0 1-.9-1V13c0-.4.3-.8.6-1l1.2-.4.2-.3a.2.2 0 0 0-.2-.2H4.5a.5.5 0 0 1-.5-.5c0-.3.2-.5.5-.5h1.6c.5 0 .9.4.9 1v.1c0 .4-.3.8-.6 1l-1.2.4-.2.3ZM7 17v2c0 .6-.4 1-1 1H4.5a.5.5 0 0 1 0-1h1.2c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.4a.4.4 0 1 1 0-.8h1.3c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.5a.5.5 0 1 1 0-1H6c.6 0 1 .4 1 1Z" fill-rule="evenodd"/></svg>',
      orientation: '<svg width="24" height="24"><path d="M7.3 6.4 1 13l6.4 6.5 6.5-6.5-6.5-6.5ZM3.7 13l3.6-3.7L11 13l-3.7 3.7-3.6-3.7ZM12 6l2.8 2.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0L9.2 5.7a.8.8 0 0 1 0-1.2L13.6.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L12 4h1a9 9 0 1 1-4.3 16.9l1.5-1.5A7 7 0 1 0 13 6h-1Z" fill-rule="nonzero"/></svg>',
      outdent: '<svg width="24" height="24"><path d="M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 1 1 0-2Zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm-5 4h12a1 1 0 0 1 0 2H7a1 1 0 0 1 0-2Zm1.6-3.8a1 1 0 0 1-1.2 1.6l-3-2a1 1 0 0 1 0-1.6l3-2a1 1 0 0 1 1.2 1.6L6.8 12l1.8 1.2Z" fill-rule="evenodd"/></svg>',
      "page-break": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M5 11c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1h-1a1 1 0 0 1 0-2Zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2ZM7 3v5h10V3c0-.6.4-1 1-1s1 .4 1 1v7H5V3c0-.6.4-1 1-1s1 .4 1 1ZM6 22a1 1 0 0 1-1-1v-7h14v7c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-5H7v5c0 .6-.4 1-1 1Z"/></g></svg>',
      paragraph: '<svg width="24" height="24"><path fill-rule="evenodd" d="M10 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 6.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L10 5Z"/></svg>',
      "paste-column-after": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V7h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h7v2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm8 7v12h-6V8h6Zm-1.5 1.5h-3v9h3v-9ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>',
      "paste-column-before": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V18c0 1-.8 2-1.9 2H11v-2h7V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v2H4V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm-2 7v12H4V8h6ZM8.5 9.5h-3v9h3v-9ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>',
      "paste-row-after": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V11h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h14c0 1-.8 2-1.9 2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm10 11v5H8v-5h14Zm-1.5 1.5h-11v2h11v-2ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>',
      "paste-row-before": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V7h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h12v-4h2v4c0 1-.8 2-1.9 2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm10 7v5H8V8h14Zm-1.5 1.5h-11v2h11v-2ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>',
      "paste-text": '<svg width="24" height="24"><path d="M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h3V9h9ZM9 20H6a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0 1 12 1a3 3 0 0 1 2.8 2H18a2 2 0 0 1 2 2v4h1v12H9v-1Zm1.5-9.5v9h9v-9h-9ZM12 3a1 1 0 0 0-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1Zm0 9h6v2h-.5l-.5-1h-1v4h.8v1h-3.6v-1h.8v-4h-1l-.5 1H12v-2Z" fill-rule="nonzero"/></svg>',
      paste: '<svg width="24" height="24"><path d="M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h3V9h9ZM9 20H6a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0 1 12 1a3 3 0 0 1 2.8 2H18a2 2 0 0 1 2 2v4h1v12H9v-1Zm1.5-9.5v9h9v-9h-9ZM12 3a1 1 0 0 0-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1Z" fill-rule="nonzero"/></svg>',
      "permanent-pen": '<svg width="24" height="24"><path d="M10.5 17.5 8 20H3v-3l3.5-3.5a2 2 0 0 1 0-3L14 3l1 1-7.3 7.3a1 1 0 0 0 0 1.4l3.6 3.6c.4.4 1 .4 1.4 0L20 9l1 1-7.6 7.6a2 2 0 0 1-2.8 0l-.1-.1Z" fill-rule="nonzero"/></svg>',
      plus: '<svg width="24" height="24"><path d="M12 4c.5 0 1 .4 1 .9V11h6a1 1 0 0 1 .1 2H13v6a1 1 0 0 1-2 .1V13H5a1 1 0 0 1-.1-2H11V5c0-.6.4-1 1-1Z"/></svg>',
      preferences: '<svg width="24" height="24"><path d="m20.1 13.5-1.9.2a5.8 5.8 0 0 1-.6 1.5l1.2 1.5c.4.4.3 1 0 1.4l-.7.7a1 1 0 0 1-1.4 0l-1.5-1.2a6.2 6.2 0 0 1-1.5.6l-.2 1.9c0 .5-.5.9-1 .9h-1a1 1 0 0 1-1-.9l-.2-1.9a5.8 5.8 0 0 1-1.5-.6l-1.5 1.2a1 1 0 0 1-1.4 0l-.7-.7a1 1 0 0 1 0-1.4l1.2-1.5a6.2 6.2 0 0 1-.6-1.5l-1.9-.2a1 1 0 0 1-.9-1v-1c0-.5.4-1 .9-1l1.9-.2a5.8 5.8 0 0 1 .6-1.5L5.2 7.3a1 1 0 0 1 0-1.4l.7-.7a1 1 0 0 1 1.4 0l1.5 1.2a6.2 6.2 0 0 1 1.5-.6l.2-1.9c0-.5.5-.9 1-.9h1c.5 0 1 .4 1 .9l.2 1.9a5.8 5.8 0 0 1 1.5.6l1.5-1.2a1 1 0 0 1 1.4 0l.7.7c.3.4.4 1 0 1.4l-1.2 1.5a6.2 6.2 0 0 1 .6 1.5l1.9.2c.5 0 .9.5.9 1v1c0 .5-.4 1-.9 1ZM12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z" fill-rule="evenodd"/></svg>',
      preview: '<svg width="24" height="24"><path d="M3.5 12.5c.5.8 1.1 1.6 1.8 2.3 2 2 4.2 3.2 6.7 3.2s4.7-1.2 6.7-3.2a16.2 16.2 0 0 0 2.1-2.8 15.7 15.7 0 0 0-2.1-2.8c-2-2-4.2-3.2-6.7-3.2a9.3 9.3 0 0 0-6.7 3.2A16.2 16.2 0 0 0 3.2 12c0 .2.2.3.3.5Zm-2.4-1 .7-1.2L4 7.8C6.2 5.4 8.9 4 12 4c3 0 5.8 1.4 8.1 3.8a18.2 18.2 0 0 1 2.8 3.7v1l-.7 1.2-2.1 2.5c-2.3 2.4-5 3.8-8.1 3.8-3 0-5.8-1.4-8.1-3.8a18.2 18.2 0 0 1-2.8-3.7 1 1 0 0 1 0-1Zm12-3.3a2 2 0 1 0 2.7 2.6 4 4 0 1 1-2.6-2.6Z" fill-rule="nonzero"/></svg>',
      print: '<svg width="24" height="24"><path d="M18 8H6a3 3 0 0 0-3 3v6h2v3h14v-3h2v-6a3 3 0 0 0-3-3Zm-1 10H7v-4h10v4Zm.5-5c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5 1.5.7 1.5 1.5-.7 1.5-1.5 1.5Zm.5-8H6v2h12V5Z" fill-rule="nonzero"/></svg>',
      quote: '<svg width="24" height="24"><path d="M7.5 17h.9c.4 0 .7-.2.9-.6L11 13V8c0-.6-.4-1-1-1H6a1 1 0 0 0-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 0 0 .8 1.3Zm8 0h.9c.4 0 .7-.2.9-.6L19 13V8c0-.6-.4-1-1-1h-4a1 1 0 0 0-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 0 0 .8 1.3Z" fill-rule="nonzero"/></svg>',
      redo: '<svg width="24" height="24"><path d="M17.6 10H12c-2.8 0-4.4 1.4-4.9 3.5-.4 2 .3 4 1.4 4.6a1 1 0 1 1-1 1.8c-2-1.2-2.9-4.1-2.3-6.8.6-3 3-5.1 6.8-5.1h5.6l-3.3-3.3a1 1 0 1 1 1.4-1.4l5 5a1 1 0 0 1 0 1.4l-5 5a1 1 0 0 1-1.4-1.4l3.3-3.3Z" fill-rule="nonzero"/></svg>',
      reload: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="m5 22.1-1.2-4.7v-.2a1 1 0 0 1 1-1l5 .4a1 1 0 1 1-.2 2l-2.2-.2a7.8 7.8 0 0 0 8.4.2 7.5 7.5 0 0 0 3.5-6.4 1 1 0 1 1 2 0 9.5 9.5 0 0 1-4.5 8 9.9 9.9 0 0 1-10.2 0l.4 1.4a1 1 0 1 1-2 .5ZM13.6 7.4c0-.5.5-1 1-.9l2.8.2a8 8 0 0 0-9.5-1 7.5 7.5 0 0 0-3.6 7 1 1 0 0 1-2 0 9.5 9.5 0 0 1 4.5-8.6 10 10 0 0 1 10.9.3l-.3-1a1 1 0 0 1 2-.5l1.1 4.8a1 1 0 0 1-1 1.2l-5-.4a1 1 0 0 1-.9-1Z"/></g></svg>',
      "remove-formatting": '<svg width="24" height="24"><path d="M13.2 6a1 1 0 0 1 0 .2l-2.6 10a1 1 0 0 1-1 .8h-.2a.8.8 0 0 1-.8-1l2.6-10H8a1 1 0 1 1 0-2h9a1 1 0 0 1 0 2h-3.8ZM5 18h7a1 1 0 0 1 0 2H5a1 1 0 0 1 0-2Zm13 1.5L16.5 18 15 19.5a.7.7 0 0 1-1-1l1.5-1.5-1.5-1.5a.7.7 0 0 1 1-1l1.5 1.5 1.5-1.5a.7.7 0 0 1 1 1L17.5 17l1.5 1.5a.7.7 0 0 1-1 1Z" fill-rule="evenodd"/></svg>',
      remove: '<svg width="24" height="24"><path d="M16 7h3a1 1 0 0 1 0 2h-1v9a3 3 0 0 1-3 3H9a3 3 0 0 1-3-3V9H5a1 1 0 1 1 0-2h3V6a3 3 0 0 1 3-3h2a3 3 0 0 1 3 3v1Zm-2 0V6c0-.6-.4-1-1-1h-2a1 1 0 0 0-1 1v1h4Zm2 2H8v9c0 .6.4 1 1 1h6c.6 0 1-.4 1-1V9Zm-7 3a1 1 0 0 1 2 0v4a1 1 0 0 1-2 0v-4Zm4 0a1 1 0 0 1 2 0v4a1 1 0 0 1-2 0v-4Z" fill-rule="nonzero"/></svg>',
      "resize-handle": '<svg width="10" height="10"><g fill-rule="nonzero"><path d="M8.1 1.1A.5.5 0 1 1 9 2l-7 7A.5.5 0 1 1 1 8l7-7ZM8.1 5.1A.5.5 0 1 1 9 6l-3 3A.5.5 0 1 1 5 8l3-3Z"/></g></svg>',
      resize: '<svg width="24" height="24"><path d="M4 5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h6c.3 0 .5.1.7.3.2.2.3.4.3.7 0 .3-.1.5-.3.7a1 1 0 0 1-.7.3H7.4L18 16.6V13c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3.3 0 .5.1.7.3.2.2.3.4.3.7v6c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-6a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3.6L6 7.4V11c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.7-.3A1 1 0 0 1 4 11V5Z" fill-rule="evenodd"/></svg>',
      "restore-draft": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M17 13c0 .6-.4 1-1 1h-4V8c0-.6.4-1 1-1s1 .4 1 1v4h2c.6 0 1 .4 1 1Z"/><path d="M4.7 10H9a1 1 0 0 1 0 2H3a1 1 0 0 1-1-1V5a1 1 0 1 1 2 0v3l2.5-2.4a9.2 9.2 0 0 1 10.8-1.5A9 9 0 0 1 13.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 1 1 1.3-1.5 7.2 7.2 0 0 0 11.6-3.7 7 7 0 0 0-3.5-7.7A7.2 7.2 0 0 0 8 7L4.7 10Z" fill-rule="nonzero"/></g></svg>',
      "rotate-left": '<svg width="24" height="24"><path d="M4.7 10H9a1 1 0 0 1 0 2H3a1 1 0 0 1-1-1V5a1 1 0 1 1 2 0v3l2.5-2.4a9.2 9.2 0 0 1 10.8-1.5A9 9 0 0 1 13.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 1 1 1.3-1.5 7.2 7.2 0 0 0 11.6-3.7 7 7 0 0 0-3.5-7.7A7.2 7.2 0 0 0 8 7L4.7 10Z" fill-rule="nonzero"/></svg>',
      "rotate-right": '<svg width="24" height="24"><path d="M20 8V5a1 1 0 0 1 2 0v6c0 .6-.4 1-1 1h-6a1 1 0 0 1 0-2h4.3L16 7A7.2 7.2 0 0 0 7.7 6a7 7 0 0 0 3 13.1c1.9.1 3.7-.5 5-1.7a1 1 0 0 1 1.4 1.5A9.2 9.2 0 0 1 2.2 14c-.9-3.9 1-8 4.5-9.9 3.5-1.9 8-1.3 10.8 1.5L20 8Z" fill-rule="nonzero"/></svg>',
      rtl: '<svg width="24" height="24"><path d="M8 5h8v2h-2v12h-2V7h-2v12H8v-7c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 4.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L8 5Zm12 11.2a1 1 0 1 1-1 1.6l-3-2a1 1 0 0 1 0-1.6l3-2a1 1 0 1 1 1 1.6L18.4 15l1.8 1.2Z" fill-rule="evenodd"/></svg>',
      save: '<svg width="24" height="24"><path d="M5 16h14a2 2 0 0 1 2 2v2a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-2c0-1.1.9-2 2-2Zm0 2v2h14v-2H5Zm10 0h2v2h-2v-2Zm-4-6.4L8.7 9.3a1 1 0 1 0-1.4 1.4l4 4c.4.4 1 .4 1.4 0l4-4a1 1 0 1 0-1.4-1.4L13 11.6V4a1 1 0 0 0-2 0v7.6Z" fill-rule="nonzero"/></svg>',
      search: '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3Zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12Z" fill-rule="nonzero"/></svg>',
      "select-all": '<svg width="24" height="24"><path d="M3 5h2V3a2 2 0 0 0-2 2Zm0 8h2v-2H3v2Zm4 8h2v-2H7v2ZM3 9h2V7H3v2Zm10-6h-2v2h2V3Zm6 0v2h2a2 2 0 0 0-2-2ZM5 21v-2H3c0 1.1.9 2 2 2Zm-2-4h2v-2H3v2ZM9 3H7v2h2V3Zm2 18h2v-2h-2v2Zm8-8h2v-2h-2v2Zm0 8a2 2 0 0 0 2-2h-2v2Zm0-12h2V7h-2v2Zm0 8h2v-2h-2v2Zm-4 4h2v-2h-2v2Zm0-16h2V3h-2v2ZM7 17h10V7H7v10Zm2-8h6v6H9V9Z" fill-rule="nonzero"/></svg>',
      selected: '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2Zm3.6 10.9L7 12.3a.7.7 0 0 0-1 1L9.6 17 18 8.6a.7.7 0 0 0 0-1 .7.7 0 0 0-1 0l-7.4 7.3Z"/></svg>',
      send: '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="m13.3 22 7-18.3-18.3 7L9 15l4.3 7ZM18 6.8l-.7-.7L9.4 14l.7.7L18 6.8Z"/></svg>',
      settings: '<svg width="24" height="24"><path d="M11 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V8H5a1 1 0 1 1 0-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.5V6ZM8 8h2V6H8v2Zm9 2.8v.2h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v.3c0 .2 0 .3-.2.5l-.6.2h-2.4c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V13H5a1 1 0 0 1 0-2h8v-.3c0-.2 0-.3.2-.5l.6-.2h2.4c.3 0 .4 0 .6.2l.2.6ZM14 13h2v-2h-2v2Zm-3 2.8v.2h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V18H5a1 1 0 0 1 0-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.6ZM8 18h2v-2H8v2Z" fill-rule="evenodd"/></svg>',
      sharpen: '<svg width="24" height="24"><path d="m16 6 4 4-8 9-8-9 4-4h8Zm-4 10.2 5.5-6.2-.1-.1H12v-.3h5.1l-.2-.2H12V9h4.6l-.2-.2H12v-.3h4.1l-.2-.2H12V8h3.6l-.2-.2H8.7L6.5 10l.1.1H12v.3H6.9l.2.2H12v.3H7.3l.2.2H12v.3H7.7l.3.2h4v.3H8.2l.2.2H12v.3H8.6l.3.2H12v.3H9l.3.2H12v.3H9.5l.2.2H12v.3h-2l.2.2H12v.3h-1.6l.2.2H12v.3h-1.1l.2.2h.9v.3h-.7l.2.2h.5v.3h-.3l.3.2Z" fill-rule="evenodd"/></svg>',
      sourcecode: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M9.8 15.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0l-4.4-4.1a.8.8 0 0 1 0-1.2l4.4-4.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L6 12l3.8 3.7ZM14.2 15.7c-.3.3-.3.8 0 1 .4.4.9.4 1.2 0l4.4-4.1c.3-.3.3-.9 0-1.2l-4.4-4.2a.8.8 0 0 0-1.2 0c-.3.3-.3.8 0 1.1L18 12l-3.8 3.7Z"/></g></svg>',
      "spell-check": '<svg width="24" height="24"><path d="M6 8v3H5V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h2c.3 0 .5.1.7.3.2.2.3.4.3.7v6H8V8H6Zm0-3v2h2V5H6Zm13 0h-3v5h3v1h-3a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3v1Zm-5 1.5-.1.7c-.1.2-.3.3-.6.3.3 0 .5.1.6.3l.1.7V10c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-3V4h3c.3 0 .5.1.7.3.2.2.3.4.3.7v1.5ZM13 10V8h-2v2h2Zm0-3V5h-2v2h2Zm3 5 1 1-6.5 7L7 15.5l1.3-1 2.2 2.2L16 12Z" fill-rule="evenodd"/></svg>',
      "strike-through": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M15.6 8.5c-.5-.7-1-1.1-1.3-1.3-.6-.4-1.3-.6-2-.6-2.7 0-2.8 1.7-2.8 2.1 0 1.6 1.8 2 3.2 2.3 4.4.9 4.6 2.8 4.6 3.9 0 1.4-.7 4.1-5 4.1A6.2 6.2 0 0 1 7 16.4l1.5-1.1c.4.6 1.6 2 3.7 2 1.6 0 2.5-.4 3-1.2.4-.8.3-2-.8-2.6-.7-.4-1.6-.7-2.9-1-1-.2-3.9-.8-3.9-3.6C7.6 6 10.3 5 12.4 5c2.9 0 4.2 1.6 4.7 2.4l-1.5 1.1Z"/><path d="M5 11h14a1 1 0 0 1 0 2H5a1 1 0 0 1 0-2Z" fill-rule="nonzero"/></g></svg>',
      subscript: '<svg width="24" height="24"><path d="m10.4 10 4.6 4.6-1.4 1.4L9 11.4 4.4 16 3 14.6 7.6 10 3 5.4 4.4 4 9 8.6 13.6 4 15 5.4 10.4 10ZM21 19h-5v-1l1-.8 1.7-1.6c.3-.4.5-.8.5-1.2 0-.3 0-.6-.2-.7-.2-.2-.5-.3-.9-.3a2 2 0 0 0-.8.2l-.7.3-.4-1.1 1-.6 1.2-.2c.8 0 1.4.3 1.8.7.4.4.6.9.6 1.5s-.2 1.1-.5 1.6a8 8 0 0 1-1.3 1.3l-.6.6h2.6V19Z" fill-rule="nonzero"/></svg>',
      superscript: '<svg width="24" height="24"><path d="M15 9.4 10.4 14l4.6 4.6-1.4 1.4L9 15.4 4.4 20 3 18.6 7.6 14 3 9.4 4.4 8 9 12.6 13.6 8 15 9.4Zm5.9 1.6h-5v-1l1-.8 1.7-1.6c.3-.5.5-.9.5-1.3 0-.3 0-.5-.2-.7-.2-.2-.5-.3-.9-.3l-.8.2-.7.4-.4-1.2c.2-.2.5-.4 1-.5.3-.2.8-.2 1.2-.2.8 0 1.4.2 1.8.6.4.4.6 1 .6 1.6 0 .5-.2 1-.5 1.5l-1.3 1.4-.6.5h2.6V11Z" fill-rule="nonzero"/></svg>',
      "table-caption": '<svg width="24" height="24"><g fill-rule="nonzero"><rect width="12" height="2" x="3" y="4" rx="1"/><path d="M19 8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-8c0-1.1.9-2 2-2h14ZM5 15v3h6v-3H5Zm14 0h-6v3h6v-3Zm0-5h-6v3h6v-3ZM5 13h6v-3H5v3Z"/></g></svg>',
      "table-cell-classes": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M13 4v9H3V6c0-1.1.9-2 2-2h8Zm-2 2H5v5h6V6Z"/><path fill-rule="nonzero" d="M13 4h6a2 2 0 0 1 2 2v7h-8v-2h6V6h-6V4Z" opacity=".2"/><path d="m18 20-2.6 1.6.7-3-2.4-2 3.1-.2 1.2-2.9 1.2 2.9 3.1.2-2.4 2 .7 3z"/><path fill-rule="nonzero" d="M3 13v5c0 1.1.9 2 2 2h8v-7h-2v5H5v-5H3Z" opacity=".2"/></g></svg>',
      "table-cell-properties": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 9H5v5h6v-5Zm8 0h-6v5h6v-5Zm-8-7H5v5h6V6Z"/></svg>',
      "table-cell-select-all": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 2H5v12h14V6Z"/><path d="M13 6v5h6v2h-6v5h-2v-5H5v-2h6V6h2Z" opacity=".2"/></g></svg>',
      "table-cell-select-inner": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 2H5v12h14V6Z" opacity=".2"/><path d="M13 6v5h6v2h-6v5h-2v-5H5v-2h6V6h2Z"/></g></svg>',
      "table-classes": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v7h-8v7H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 9H5v5h6v-5Zm8-7h-6v5h6V6Zm-8 0H5v5h6V6Z"/><path d="m18 20-2.6 1.6.7-3-2.4-2 3.1-.2 1.2-2.9 1.2 2.9 3.1.2-2.4 2 .7 3z"/></g></svg>',
      "table-delete-column": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-4 4h-2V6h-2v2H9V6H5v12h4v-2h2v2h2v-2h2v2h4V6h-4v2Zm.3.5 1 1.2-3 2.3 3 2.3-1 1.2L12 13l-3.3 2.6-1-1.2 3-2.3-3-2.3 1-1.2L12 11l3.3-2.5Z"/></svg>',
      "table-delete-row": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 2H5v3h2.5v2H5v2h2.5v2H5v3h14v-3h-2.5v-2H19v-2h-2.5V9H19V6Zm-4.7 1.8 1.2 1L13 12l2.6 3.3-1.2 1-2.3-3-2.3 3-1.2-1L11 12 8.5 8.7l1.2-1 2.3 3 2.3-3Z"/></svg>',
      "table-delete-table": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 6v12h14V6H5Z"/><path d="m14.4 8.6 1.1 1-2.4 2.4 2.4 2.4-1.1 1.1-2.4-2.4-2.4 2.4-1-1.1 2.3-2.4-2.3-2.4 1-1 2.4 2.3z"/></g></svg>',
      "table-insert-column-after": '<svg width="24" height="24"><path fill-rule="nonzero" d="M20 4c.6 0 1 .4 1 1v2a1 1 0 0 1-2 0V6h-8v12h8v-1a1 1 0 0 1 2 0v2c0 .5-.4 1-.9 1H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h15ZM9 13H5v5h4v-5Zm7-5c.5 0 1 .4 1 .9V11h2a1 1 0 0 1 .1 2H17v2a1 1 0 0 1-2 .1V13h-2a1 1 0 0 1-.1-2H15V9c0-.6.4-1 1-1ZM9 6H5v5h4V6Z"/></svg>',
      "table-insert-column-before": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a1 1 0 0 1-1-1v-2a1 1 0 0 1 2 0v1h8V6H5v1a1 1 0 1 1-2 0V5c0-.6.4-1 1-1h15Zm0 9h-4v5h4v-5ZM8 8c.5 0 1 .4 1 .9V11h2a1 1 0 0 1 .1 2H9v2a1 1 0 0 1-2 .1V13H5a1 1 0 0 1-.1-2H7V9c0-.6.4-1 1-1Zm11-2h-4v5h4V6Z"/></svg>',
      "table-insert-row-above": '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4a1 1 0 1 1 0 2H5v6h14V6h-1a1 1 0 0 1 0-2h2c.6 0 1 .4 1 1v13a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5c0-.6.4-1 1-1h2Zm5 10H5v4h6v-4Zm8 0h-6v4h6v-4ZM12 3c.5 0 1 .4 1 .9V6h2a1 1 0 0 1 0 2h-2v2a1 1 0 0 1-2 .1V8H9a1 1 0 0 1 0-2h2V4c0-.6.4-1 1-1Z"/></svg>',
      "table-insert-row-after": '<svg width="24" height="24"><path fill-rule="nonzero" d="M12 13c.5 0 1 .4 1 .9V16h2a1 1 0 0 1 .1 2H13v2a1 1 0 0 1-2 .1V18H9a1 1 0 0 1-.1-2H11v-2c0-.6.4-1 1-1Zm6 7a1 1 0 0 1 0-2h1v-6H5v6h1a1 1 0 0 1 0 2H4a1 1 0 0 1-1-1V6c0-1.1.9-2 2-2h14a2 2 0 0 1 2 2v13c0 .5-.4 1-.9 1H18ZM11 6H5v4h6V6Zm8 0h-6v4h6V6Z"/></svg>',
      "table-left-header": '<svg width="24" height="24"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 9h-4v5h4v-5Zm-6 0H9v5h4v-5Zm0-7H9v5h4V6Zm6 0h-4v5h4V6Z"/></svg>',
      "table-merge-cells": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 15.5V18h3v-2.5H5Zm14-5h-9V18h9v-7.5ZM19 6h-4v2.5h4V6ZM8 6H5v2.5h3V6Zm5 0h-3v2.5h3V6Zm-8 7.5h3v-3H5v3Z"/></svg>',
      "table-row-numbering-rtl": '<svg width="24" height="24"><path d="M6 4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2h12a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2H6Zm0 12h8v3H6v-3Zm11 0c.6 0 1 .4 1 1v1a1 1 0 0 1-2 0v-1c0-.6.4-1 1-1ZM6 11h8v3H6v-3Zm11 0c.6 0 1 .4 1 1v1a1 1 0 0 1-2 0v-1c0-.6.4-1 1-1ZM6 6h8v3H6V6Zm11 0c.6 0 1 .4 1 1v1a1 1 0 1 1-2 0V7c0-.6.4-1 1-1Z"/></svg>',
      "table-row-numbering": '<svg width="24" height="24"><path d="M18 4a2 2 0 0 1 2 2v13a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h12Zm0 12h-8v3h8v-3ZM7 16a1 1 0 0 0-1 1v1a1 1 0 0 0 2 0v-1c0-.6-.4-1-1-1Zm11-5h-8v3h8v-3ZM7 11a1 1 0 0 0-1 1v1a1 1 0 0 0 2 0v-1c0-.6-.4-1-1-1Zm11-5h-8v3h8V6ZM7 6a1 1 0 0 0-1 1v1a1 1 0 1 0 2 0V7c0-.6-.4-1-1-1Z"/></svg>',
      "table-row-properties": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 15v3h6v-3H5Zm14 0h-6v3h6v-3Zm0-9h-6v3h6V6ZM5 9h6V6H5v3Z"/></svg>',
      "table-split-cells": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM8 15.5H5V18h3v-2.5Zm11-5h-9V18h9v-7.5Zm-2.5 1 1 1-2 2 2 2-1 1-2-2-2 2-1-1 2-2-2-2 1-1 2 2 2-2Zm-8.5-1H5v3h3v-3ZM19 6h-4v2.5h4V6ZM8 6H5v2.5h3V6Zm5 0h-3v2.5h3V6Z"/></svg>',
      "table-top-header": '<svg width="24" height="24"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 11H5v3h6v-3Zm8 0h-6v3h6v-3Zm0-5h-6v3h6v-3ZM5 13h6v-3H5v3Z"/></svg>',
      table: '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 14v4h6v-4H5Zm14 0h-6v4h6v-4Zm0-6h-6v4h6V8ZM5 12h6V8H5v4Z"/></svg>',
      "template-add": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 12v4H5a2 2 0 0 0-2 2v3h9.3a6 6 0 0 1-.3-2H5v-1h7a6 6 0 0 1 .8-2H11v-5l-.8-.6a3 3 0 1 1 3.6 0l-.8.6v4.7a6 6 0 0 1 2-1.9V12a5 5 0 1 0-6 0Z"/><path d="M18 15c.5 0 1 .4 1 .9V18h2a1 1 0 0 1 .1 2H19v2a1 1 0 0 1-2 .1V20h-2a1 1 0 0 1-.1-2H17v-2c0-.6.4-1 1-1Z"/></svg>',
      template: '<svg width="24" height="24"><path d="M19 19v-1H5v1h14ZM9 16v-4a5 5 0 1 1 6 0v4h4a2 2 0 0 1 2 2v3H3v-3c0-1.1.9-2 2-2h4Zm4 0v-5l.8-.6a3 3 0 1 0-3.6 0l.8.6v5h2Z" fill-rule="nonzero"/></svg>',
      "temporary-placeholder": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M9 7.6V6h2.5V4.5a.5.5 0 1 1 1 0V6H15v1.6a8 8 0 1 1-6 0Zm-2.6 5.3a.5.5 0 0 0 .3.6c.3 0 .6 0 .6-.3l.1-.2a5 5 0 0 1 3.3-2.8c.3-.1.4-.4.4-.6-.1-.3-.4-.5-.6-.4a6 6 0 0 0-4.1 3.7Z"/><circle cx="14" cy="4" r="1"/><circle cx="12" cy="2" r="1"/><circle cx="10" cy="4" r="1"/></g></svg>',
      "text-color": '<svg width="24" height="24"><g fill-rule="evenodd"><path class="tox-icon-text-color__color" d="M3 18h18v3H3z"/><path d="M8.7 16h-.8a.5.5 0 0 1-.5-.6l2.7-9c.1-.3.3-.4.5-.4h2.8c.2 0 .4.1.5.4l2.7 9a.5.5 0 0 1-.5.6h-.8a.5.5 0 0 1-.4-.4l-.7-2.2c0-.3-.3-.4-.5-.4h-3.4c-.2 0-.4.1-.5.4l-.7 2.2c0 .3-.2.4-.4.4Zm2.6-7.6-.6 2a.5.5 0 0 0 .5.6h1.6a.5.5 0 0 0 .5-.6l-.6-2c0-.3-.3-.4-.5-.4h-.4c-.2 0-.4.1-.5.4Z"/></g></svg>',
      "text-size-decrease": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M14 5a1 1 0 1 1 0 2h-4v11a1 1 0 1 1-2 0V7H4a1 1 0 0 1 0-2h10ZM14 12a1 1 0 1 0 0 2h6a1 1 0 1 0 0-2h-6Z"/></svg>',
      "text-size-increase": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M14 5a1 1 0 1 1 0 2h-4v11a1 1 0 1 1-2 0V7H4a1 1 0 0 1 0-2h10ZM17 9a1 1 0 0 0-1 1v2h-2a1 1 0 1 0 0 2h2v2a1 1 0 1 0 2 0v-2h2a1 1 0 1 0 0-2h-2v-2c0-.6-.4-1-1-1Z"/></svg>',
      toc: '<svg width="24" height="24"><path d="M5 5c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 1 1 0-2Zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 1 1 0-2Zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Zm0-4c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 1 1 0-2Zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
      translate: '<svg width="24" height="24"><path d="m12.7 14.3-.3.7-.4.7-2.2-2.2-3.1 3c-.3.4-.8.4-1 0a.7.7 0 0 1 0-1l3.1-3A12.4 12.4 0 0 1 6.7 9H8a10.1 10.1 0 0 0 1.7 2.4c.5-.5 1-1.1 1.4-1.8l.9-2H4.7a.7.7 0 1 1 0-1.5h4.4v-.7c0-.4.3-.8.7-.8.4 0 .7.4.7.8v.7H15c.4 0 .8.3.8.7 0 .4-.4.8-.8.8h-1.4a12.3 12.3 0 0 1-1 2.4 13.5 13.5 0 0 1-1.7 2.3l1.9 1.8Zm4.3-3 2.7 7.3a.5.5 0 0 1-.4.7 1 1 0 0 1-1-.7l-.6-1.5h-3.4l-.6 1.5a1 1 0 0 1-1 .7.5.5 0 0 1-.4-.7l2.7-7.4a1 1 0 0 1 2 0Zm-2.2 4.4h2.4L16 12.5l-1.2 3.2Z" fill-rule="evenodd"/></svg>',
      typography: '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M17 5a1 1 0 1 1 0 2h-4v11a1 1 0 1 1-2 0V7H7a1 1 0 0 1 0-2h10Z"/><path d="m17.5 14 .8-1.7 1.7-.8-1.7-.8-.8-1.7-.8 1.7-1.7.8 1.7.8.8 1.7ZM7 14l1 2 2 1-2 1-1 2-1-2-2-1 2-1 1-2Z"/></svg>',
      underline: '<svg width="24" height="24"><path d="M16 5c.6 0 1 .4 1 1v5.5a4 4 0 0 1-.4 1.8l-1 1.4a5.3 5.3 0 0 1-5.5 1 5 5 0 0 1-1.6-1c-.5-.4-.8-.9-1.1-1.4a4 4 0 0 1-.4-1.8V6c0-.6.4-1 1-1s1 .4 1 1v5.5c0 .3 0 .6.2 1l.6.7a3.3 3.3 0 0 0 2.2.8 3.4 3.4 0 0 0 2.2-.8c.3-.2.4-.5.6-.8l.2-.9V6c0-.6.4-1 1-1ZM8 17h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
      undo: '<svg width="24" height="24"><path d="M6.4 8H12c3.7 0 6.2 2 6.8 5.1.6 2.7-.4 5.6-2.3 6.8a1 1 0 0 1-1-1.8c1.1-.6 1.8-2.7 1.4-4.6-.5-2.1-2.1-3.5-4.9-3.5H6.4l3.3 3.3a1 1 0 1 1-1.4 1.4l-5-5a1 1 0 0 1 0-1.4l5-5a1 1 0 0 1 1.4 1.4L6.4 8Z" fill-rule="nonzero"/></svg>',
      unlink: '<svg width="24" height="24"><path d="M6.2 12.3a1 1 0 0 1 1.4 1.4l-2 2a2 2 0 1 0 2.6 2.8l4.8-4.8a1 1 0 0 0 0-1.4 1 1 0 1 1 1.4-1.3 2.9 2.9 0 0 1 0 4L9.6 20a3.9 3.9 0 0 1-5.5-5.5l2-2Zm11.6-.6a1 1 0 0 1-1.4-1.4l2.1-2a2 2 0 1 0-2.7-2.8L11 10.3a1 1 0 0 0 0 1.4A1 1 0 1 1 9.6 13a2.9 2.9 0 0 1 0-4L14.4 4a3.9 3.9 0 0 1 5.5 5.5l-2 2ZM7.6 6.3a.8.8 0 0 1-1 1.1L3.3 4.2a.7.7 0 1 1 1-1l3.2 3.1ZM5.1 8.6a.8.8 0 0 1 0 1.5H3a.8.8 0 0 1 0-1.5H5Zm5-3.5a.8.8 0 0 1-1.5 0V3a.8.8 0 0 1 1.5 0V5Zm6 11.8a.8.8 0 0 1 1-1l3.2 3.2a.8.8 0 0 1-1 1L16 17Zm-2.2 2a.8.8 0 0 1 1.5 0V21a.8.8 0 0 1-1.5 0V19Zm5-3.5a.7.7 0 1 1 0-1.5H21a.8.8 0 0 1 0 1.5H19Z" fill-rule="nonzero"/></svg>',
      unlock: '<svg width="24" height="24"><path d="M16 5c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h-2V8a1 1 0 0 0-.3-.7A1 1 0 0 0 16 7h-2a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7v3h.3c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H4.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H11V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2Z" fill-rule="evenodd"/></svg>',
      "unordered-list": '<svg width="24" height="24"><path d="M11 5h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2ZM4.5 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1Zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1Zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1Z" fill-rule="evenodd"/></svg>',
      unselected: '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2Zm0 1a1 1 0 0 0-1 1v12c0 .6.4 1 1 1h12c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H6Z"/></svg>',
      upload: '<svg width="24" height="24"><path d="M18 19v-2a1 1 0 0 1 2 0v3c0 .6-.4 1-1 1H5a1 1 0 0 1-1-1v-3a1 1 0 0 1 2 0v2h12ZM11 6.4 8.7 8.7a1 1 0 0 1-1.4-1.4l4-4a1 1 0 0 1 1.4 0l4 4a1 1 0 1 1-1.4 1.4L13 6.4V16a1 1 0 0 1-2 0V6.4Z" fill-rule="nonzero"/></svg>',
      user: '<svg width="24" height="24"><path d="M12 24a12 12 0 1 1 0-24 12 12 0 0 1 0 24Zm-8.7-5.3a11 11 0 0 0 17.4 0C19.4 16.3 14.6 15 12 15c-2.6 0-7.4 1.3-8.7 3.7ZM12 13c2.2 0 4-2 4-4.5S14.2 4 12 4 8 6 8 8.5 9.8 13 12 13Z" fill-rule="nonzero"/></svg>',
      "vertical-align": '<svg width="24" height="24"><g fill-rule="nonzero"><rect width="18" height="2" x="3" y="11" rx="1"/><path d="M12 2c.6 0 1 .4 1 1v4l2-1.3a1 1 0 0 1 1.2 1.5l-.1.1-4.1 3-4-3a1 1 0 0 1 1-1.7l2 1.5V3c0-.6.4-1 1-1zm0 11.8 4 2.9a1 1 0 0 1-1 1.7l-2-1.5V21c0 .5-.4 1-.9 1H12a1 1 0 0 1-1-1v-4l-2 1.3a1 1 0 0 1-1.2-.1l-.1-.1a1 1 0 0 1 .1-1.3l.1-.1 4.1-3z"/></g></svg>',
      visualblocks: '<svg width="24" height="24"><path d="M9 19v2H7v-2h2Zm-4 0v2a2 2 0 0 1-2-2h2Zm8 0v2h-2v-2h2Zm8 0a2 2 0 0 1-2 2v-2h2Zm-4 0v2h-2v-2h2ZM15 7a1 1 0 0 1 0 2v7a1 1 0 0 1-2 0V9h-1v7a1 1 0 0 1-2 0v-4a2.5 2.5 0 0 1-.2-5H15ZM5 15v2H3v-2h2Zm16 0v2h-2v-2h2ZM5 11v2H3v-2h2Zm16 0v2h-2v-2h2ZM5 7v2H3V7h2Zm16 0v2h-2V7h2ZM5 3v2H3c0-1.1.9-2 2-2Zm8 0v2h-2V3h2Zm6 0a2 2 0 0 1 2 2h-2V3ZM9 3v2H7V3h2Zm8 0v2h-2V3h2Z" fill-rule="evenodd"/></svg>',
      visualchars: '<svg width="24" height="24"><path d="M10 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 6.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L10 5Z" fill-rule="evenodd"/></svg>',
      warning: '<svg width="24" height="24"><path d="M19.8 18.3c.2.5.3.9 0 1.2-.1.3-.5.5-1 .5H5.2c-.5 0-.9-.2-1-.5-.3-.3-.2-.7 0-1.2L11 4.7l.5-.5.5-.2c.2 0 .3 0 .5.2.2 0 .3.3.5.5l6.8 13.6ZM12 18c.3 0 .5-.1.7-.3.2-.2.3-.4.3-.7a1 1 0 0 0-.3-.7 1 1 0 0 0-.7-.3 1 1 0 0 0-.7.3 1 1 0 0 0-.3.7c0 .3.1.5.3.7.2.2.4.3.7.3Zm.7-3 .3-4a1 1 0 0 0-.3-.7 1 1 0 0 0-.7-.3 1 1 0 0 0-.7.3 1 1 0 0 0-.3.7l.3 4h1.4Z" fill-rule="evenodd"/></svg>',
      "zoom-in": '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3Zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12Zm-1-9a1 1 0 0 1 2 0v6a1 1 0 0 1-2 0V8Zm-2 4a1 1 0 0 1 0-2h6a1 1 0 0 1 0 2H8Z" fill-rule="nonzero"/></svg>',
      "zoom-out": '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3Zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12Zm-3-5a1 1 0 0 1 0-2h6a1 1 0 0 1 0 2H8Z" fill-rule="nonzero"/></svg>'
    }
  })), mG;
}
var gG;
function FY() {
  return gG || (gG = 1, $Y()), dG;
}
FY();
var hG = {}, pG = {}, bG;
function IY() {
  return bG || (bG = 1, (function() {
    var vt = tinymce.util.Tools.resolve("tinymce.PluginManager");
    const Ot = (Te, Oe, A) => {
      const mn = Oe === "UL" ? "InsertUnorderedList" : "InsertOrderedList";
      Te.execCommand(mn, !1, A === !1 ? null : { "list-style-type": A });
    }, Pt = (Te) => {
      Te.addCommand("ApplyUnorderedListStyle", (Oe, A) => {
        Ot(Te, "UL", A["list-style-type"]);
      }), Te.addCommand("ApplyOrderedListStyle", (Oe, A) => {
        Ot(Te, "OL", A["list-style-type"]);
      });
    }, yt = (Te) => (Oe) => Oe.options.get(Te), Nt = (Te) => {
      const Oe = Te.options.register;
      Oe("advlist_number_styles", {
        processor: "string[]",
        default: "default,lower-alpha,lower-greek,lower-roman,upper-alpha,upper-roman".split(",")
      }), Oe("advlist_bullet_styles", {
        processor: "string[]",
        default: "default,circle,square".split(",")
      });
    }, Wt = yt("advlist_number_styles"), Fe = yt("advlist_bullet_styles"), Ee = (Te) => Te == null, Bt = (Te) => !Ee(Te);
    var fn = tinymce.util.Tools.resolve("tinymce.util.Tools");
    class dn {
      constructor(Oe, A) {
        this.tag = Oe, this.value = A;
      }
      static some(Oe) {
        return new dn(!0, Oe);
      }
      static none() {
        return dn.singletonNone;
      }
      fold(Oe, A) {
        return this.tag ? A(this.value) : Oe();
      }
      isSome() {
        return this.tag;
      }
      isNone() {
        return !this.tag;
      }
      map(Oe) {
        return this.tag ? dn.some(Oe(this.value)) : dn.none();
      }
      bind(Oe) {
        return this.tag ? Oe(this.value) : dn.none();
      }
      exists(Oe) {
        return this.tag && Oe(this.value);
      }
      forall(Oe) {
        return !this.tag || Oe(this.value);
      }
      filter(Oe) {
        return !this.tag || Oe(this.value) ? this : dn.none();
      }
      getOr(Oe) {
        return this.tag ? this.value : Oe;
      }
      or(Oe) {
        return this.tag ? this : Oe;
      }
      getOrThunk(Oe) {
        return this.tag ? this.value : Oe();
      }
      orThunk(Oe) {
        return this.tag ? this : Oe();
      }
      getOrDie(Oe) {
        if (this.tag)
          return this.value;
        throw new Error(Oe ?? "Called getOrDie on None");
      }
      static from(Oe) {
        return Bt(Oe) ? dn.some(Oe) : dn.none();
      }
      getOrNull() {
        return this.tag ? this.value : null;
      }
      getOrUndefined() {
        return this.value;
      }
      each(Oe) {
        this.tag && Oe(this.value);
      }
      toArray() {
        return this.tag ? [this.value] : [];
      }
      toString() {
        return this.tag ? `some(${this.value})` : "none()";
      }
    }
    dn.singletonNone = new dn(!1);
    const Sn = (Te, Oe, A) => {
      for (let mn = 0, it = Te.length; mn < it; mn++) {
        const Gn = Te[mn];
        if (Oe(Gn, mn))
          return dn.some(Gn);
        if (A(Gn, mn))
          break;
      }
      return dn.none();
    }, Ft = (Te) => /\btox\-/.test(Te.className), Zt = (Te, Oe) => Te.dom.isChildOf(Oe, Te.getBody()), Qt = (Te) => (Oe) => Bt(Oe) && Te.test(Oe.nodeName), En = Qt(/^(OL|UL|DL)$/), st = Qt(/^(TH|TD)$/), Pn = (Te, Oe, A) => Sn(Oe, (mn) => En(mn) && !Ft(mn), st).exists((mn) => mn.nodeName === A && Zt(Te, mn)), Kt = (Te) => {
      const Oe = Te.dom.getParent(Te.selection.getNode(), "ol,ul"), A = Te.dom.getStyle(Oe, "listStyleType");
      return dn.from(A);
    }, J = (Te, Oe) => Oe !== null && !Te.dom.isEditable(Oe), Qe = (Te, Oe) => {
      const A = Te.dom.getParent(Oe, "ol,ul,dl");
      return J(Te, A) && Te.selection.isEditable();
    }, xo = (Te, Oe) => {
      const A = Te.selection.getNode();
      return Oe({
        parents: Te.dom.getParents(A),
        element: A
      }), Te.on("NodeChange", Oe), () => Te.off("NodeChange", Oe);
    }, ht = (Te) => Te.replace(/\-/g, " ").replace(/\b\w/g, (Oe) => Oe.toUpperCase()), U = (Te) => Ee(Te) || Te === "default" ? "" : Te, Tt = (Te, Oe) => (A) => {
      const mn = (Gn, rn) => {
        const Ye = Gn.selection.getStart(!0);
        A.setActive(Pn(Gn, rn, Oe)), A.setEnabled(!Qe(Gn, Ye) && Gn.selection.isEditable());
      };
      return xo(Te, (Gn) => mn(Te, Gn.parents));
    }, Ht = (Te, Oe, A, mn, it, Gn) => {
      Te.ui.registry.addSplitButton(Oe, {
        tooltip: A,
        icon: it === "OL" ? "ordered-list" : "unordered-list",
        presets: "listpreview",
        columns: 3,
        fetch: (rn) => {
          const Ye = fn.map(Gn, (io) => {
            const jo = it === "OL" ? "num" : "bull", bt = io === "disc" || io === "decimal" ? "default" : io, kn = U(io), $e = ht(io);
            return {
              type: "choiceitem",
              value: kn,
              icon: "list-" + jo + "-" + bt,
              text: $e
            };
          });
          rn(Ye);
        },
        onAction: () => Te.execCommand(mn),
        onItemAction: (rn, Ye) => {
          Ot(Te, it, Ye);
        },
        select: (rn) => Kt(Te).map((io) => rn === io).getOr(!1),
        onSetup: Tt(Te, it)
      });
    }, gn = (Te, Oe, A, mn, it, Gn) => {
      Te.ui.registry.addToggleButton(Oe, {
        active: !1,
        tooltip: A,
        icon: it === "OL" ? "ordered-list" : "unordered-list",
        onSetup: Tt(Te, it),
        onAction: () => Te.queryCommandState(mn) || Gn === "" ? Te.execCommand(mn) : Ot(Te, it, Gn)
      });
    }, De = (Te, Oe, A, mn, it, Gn) => {
      Gn.length > 1 ? Ht(Te, Oe, A, mn, it, Gn) : gn(Te, Oe, A, mn, it, U(Gn[0]));
    }, re = (Te) => {
      De(Te, "numlist", "Numbered list", "InsertOrderedList", "OL", Wt(Te)), De(Te, "bullist", "Bullet list", "InsertUnorderedList", "UL", Fe(Te));
    };
    var ho = () => {
      vt.add("advlist", (Te) => {
        Te.hasPlugin("lists") && (Nt(Te), re(Te), Pt(Te));
      });
    };
    ho();
  })()), pG;
}
var vG;
function LY() {
  return vG || (vG = 1, IY()), hG;
}
LY();
var yG = {}, CG = {}, wG;
function HY() {
  return wG || (wG = 1, (function() {
    var vt = tinymce.util.Tools.resolve("tinymce.PluginManager"), Ot = tinymce.util.Tools.resolve("tinymce.dom.RangeUtils"), Pt = tinymce.util.Tools.resolve("tinymce.util.Tools");
    const yt = (Te) => (Oe) => Oe.options.get(Te), Nt = (Te) => {
      const Oe = Te.options.register;
      Oe("allow_html_in_named_anchor", {
        processor: "boolean",
        default: !1
      });
    }, Wt = yt("allow_html_in_named_anchor"), Fe = "a:not([href])", Ee = (Te) => !Te, Bt = (Te) => Te.getAttribute("id") || Te.getAttribute("name") || "", fn = (Te) => Te.nodeName.toLowerCase() === "a", dn = (Te) => fn(Te) && !Te.getAttribute("href") && Bt(Te) !== "", Sn = (Te) => dn(Te) && !Te.firstChild, Ft = (Te) => {
      const Oe = Te.dom;
      Ot(Oe).walk(Te.selection.getRng(), (A) => {
        Pt.each(A, (mn) => {
          Sn(mn) && Oe.remove(mn, !1);
        });
      });
    }, Zt = (Te) => /^[A-Za-z][A-Za-z0-9\-:._]*$/.test(Te), Qt = (Te) => Te.dom.getParent(Te.selection.getStart(), Fe), En = (Te) => {
      const Oe = Qt(Te);
      return Oe ? Bt(Oe) : "";
    }, st = (Te, Oe) => {
      Te.undoManager.transact(() => {
        Wt(Te) || Te.selection.collapse(!0), Te.selection.isCollapsed() ? Te.insertContent(Te.dom.createHTML("a", { id: Oe })) : (Ft(Te), Te.formatter.remove("namedAnchor", void 0, void 0, !0), Te.formatter.apply("namedAnchor", { value: Oe }), Te.addVisual());
      });
    }, Pn = (Te, Oe, A) => {
      A.removeAttribute("name"), A.id = Oe, Te.addVisual(), Te.undoManager.add();
    }, Kt = (Te, Oe) => {
      const A = Qt(Te);
      A ? Pn(Te, Oe, A) : st(Te, Oe), Te.focus();
    }, J = (Te, Oe) => Zt(Oe) ? (Kt(Te, Oe), !0) : (Te.windowManager.alert("ID should start with a letter, followed only by letters, numbers, dashes, dots, colons or underscores."), !1), Qe = (Te) => {
      const Oe = En(Te);
      Te.windowManager.open({
        title: "Anchor",
        size: "normal",
        body: {
          type: "panel",
          items: [{
            name: "id",
            type: "input",
            label: "ID",
            placeholder: "example"
          }]
        },
        buttons: [
          {
            type: "cancel",
            name: "cancel",
            text: "Cancel"
          },
          {
            type: "submit",
            name: "save",
            text: "Save",
            primary: !0
          }
        ],
        initialData: { id: Oe },
        onSubmit: (A) => {
          J(Te, A.getData().id) && A.close();
        }
      });
    }, xo = (Te) => {
      Te.addCommand("mceAnchor", () => {
        Qe(Te);
      });
    }, ht = (Te) => Ee(Te.attr("href")) && !Ee(Te.attr("id") || Te.attr("name")), U = (Te) => ht(Te) && !Te.firstChild, Tt = (Te) => (Oe) => {
      for (let A = 0; A < Oe.length; A++) {
        const mn = Oe[A];
        U(mn) && mn.attr("contenteditable", Te);
      }
    }, Ht = (Te) => {
      Te.on("PreInit", () => {
        Te.parser.addNodeFilter("a", Tt("false")), Te.serializer.addNodeFilter("a", Tt(null));
      });
    }, gn = (Te) => {
      Te.formatter.register("namedAnchor", {
        inline: "a",
        selector: Fe,
        remove: "all",
        split: !0,
        deep: !0,
        attributes: { id: "%value" },
        onmatch: (Oe, A, mn) => dn(Oe)
      });
    }, De = (Te) => (Oe) => {
      const A = () => {
        Oe.setEnabled(Te.selection.isEditable());
      };
      return Te.on("NodeChange", A), A(), () => {
        Te.off("NodeChange", A);
      };
    }, re = (Te) => {
      const Oe = () => Te.execCommand("mceAnchor");
      Te.ui.registry.addToggleButton("anchor", {
        icon: "bookmark",
        tooltip: "Anchor",
        onAction: Oe,
        onSetup: (A) => {
          const mn = Te.selection.selectorChangedWithUnbind("a:not([href])", A.setActive).unbind, it = De(Te)(A);
          return () => {
            mn(), it();
          };
        }
      }), Te.ui.registry.addMenuItem("anchor", {
        icon: "bookmark",
        text: "Anchor...",
        onAction: Oe,
        onSetup: De(Te)
      });
    };
    var ho = () => {
      vt.add("anchor", (Te) => {
        Nt(Te), Ht(Te), xo(Te), re(Te), Te.on("PreInit", () => {
          gn(Te);
        });
      });
    };
    ho();
  })()), CG;
}
var SG;
function zY() {
  return SG || (SG = 1, HY()), yG;
}
zY();
var xG = {}, TG = {}, EG;
function VY() {
  return EG || (EG = 1, (function() {
    var vt = tinymce.util.Tools.resolve("tinymce.PluginManager");
    const Ot = () => /(?:[A-Za-z][A-Za-z\d.+-]{0,14}:\/\/(?:[-.~*+=!&;:'%@?^${}(),\w]+@)?|www\.|[-;:&=+$,.\w]+@)[A-Za-z\d-]+(?:\.[A-Za-z\d-]+)*(?::\d+)?(?:\/(?:[-.~*+=!;:'%@$(),\/\w]*[-~*+=%@$()\/\w])?)?(?:\?(?:[-.~*+=!&;:'%@?^${}(),\/\w]+))?(?:#(?:[-.~*+=!&;:'%@?^${}(),\/\w]+))?/g, Pt = (bt) => (kn) => kn.options.get(bt), yt = (bt) => {
      const kn = bt.options.register;
      kn("autolink_pattern", {
        processor: "regexp",
        default: new RegExp("^" + Ot().source + "$", "i")
      }), kn("link_default_target", { processor: "string" }), kn("link_default_protocol", {
        processor: "string",
        default: "https"
      });
    }, Nt = Pt("autolink_pattern"), Wt = Pt("link_default_target"), Fe = Pt("link_default_protocol"), Ee = Pt("allow_unsafe_link_target"), Bt = (bt, kn, $e) => {
      var ot;
      return $e(bt, kn.prototype) ? !0 : ((ot = bt.constructor) === null || ot === void 0 ? void 0 : ot.name) === kn.name;
    }, fn = (bt) => {
      const kn = typeof bt;
      return bt === null ? "null" : kn === "object" && Array.isArray(bt) ? "array" : kn === "object" && Bt(bt, String, ($e, ot) => ot.isPrototypeOf($e)) ? "string" : kn;
    }, dn = (bt) => (kn) => fn(kn) === bt, Sn = (bt) => (kn) => bt === kn, Ft = dn("string"), Zt = Sn(void 0), Qt = (bt) => bt == null, En = (bt) => !Qt(bt), st = (bt) => (kn) => !bt(kn), Pn = Object.hasOwnProperty, Kt = (bt, kn) => Pn.call(bt, kn), J = (bt, kn, $e) => bt.length >= kn.length && bt.substr($e, $e + kn.length) === kn, Qe = (bt, kn, $e = 0, ot) => {
      const F = bt.indexOf(kn, $e);
      return F !== -1 ? Zt(ot) ? !0 : F + kn.length <= ot : !1;
    }, xo = (bt, kn) => J(bt, kn, 0), ht = "\uFEFF", U = (bt) => bt === ht, Tt = (bt) => bt.replace(/\uFEFF/g, "");
    var Ht = tinymce.util.Tools.resolve("tinymce.dom.TextSeeker");
    const gn = (bt) => bt.nodeType === 3, De = (bt) => bt.nodeType === 1, re = (bt) => /^[(\[{ \u00a0]$/.test(bt), ho = (bt) => /^([A-Za-z][A-Za-z\d.+-]*:\/\/)|mailto:/.test(bt), Te = (bt) => /[?!,.;:]/.test(bt), Oe = (bt, kn, $e) => {
      for (let ot = kn - 1; ot >= 0; ot--) {
        const F = bt.charAt(ot);
        if (!U(F) && $e(F))
          return ot;
      }
      return -1;
    }, A = (bt, kn) => {
      let $e = bt, ot = kn;
      for (; De($e) && $e.childNodes[ot]; )
        $e = $e.childNodes[ot], ot = gn($e) ? $e.data.length : $e.childNodes.length;
      return {
        container: $e,
        offset: ot
      };
    }, mn = (bt, kn) => {
      var $e;
      const ot = bt.schema.getVoidElements(), F = Nt(bt), { dom: ss, selection: fo } = bt;
      if (ss.getParent(fo.getNode(), "a[href]") !== null)
        return null;
      const at = fo.getRng(), lt = Ht(ss, (Xe) => ss.isBlock(Xe) || Kt(ot, Xe.nodeName.toLowerCase()) || ss.getContentEditable(Xe) === "false"), {
        container: Rn,
        offset: ee
      } = A(at.endContainer, at.endOffset), pe = ($e = ss.getParent(Rn, ss.isBlock)) !== null && $e !== void 0 ? $e : ss.getRoot(), ye = lt.backwards(Rn, ee + kn, (Xe, In) => {
        const hn = Xe.data, Xn = Oe(hn, In, st(re));
        return Xn === -1 || Te(hn[Xn]) ? Xn : Xn + 1;
      }, pe);
      if (!ye)
        return null;
      let ae = ye.container;
      const kt = lt.backwards(ye.container, ye.offset, (Xe, In) => {
        ae = Xe;
        const hn = Oe(Xe.data, In, re);
        return hn === -1 ? hn : hn + 1;
      }, pe), Vn = ss.createRng();
      kt ? Vn.setStart(kt.container, kt.offset) : Vn.setStart(ae, 0), Vn.setEnd(ye.container, ye.offset);
      const Ct = Tt(Vn.toString()).match(F);
      if (Ct) {
        let Xe = Ct[0];
        return xo(Xe, "www.") ? Xe = Fe(bt) + "://" + Xe : Qe(Xe, "@") && !ho(Xe) && (Xe = "mailto:" + Xe), {
          rng: Vn,
          url: Xe
        };
      } else
        return null;
    }, it = (bt, kn) => {
      const { dom: $e, selection: ot } = bt, { rng: F, url: ss } = kn, fo = ot.getBookmark();
      ot.setRng(F);
      const at = "createlink", lt = {
        command: at,
        ui: !1,
        value: ss
      };
      if (!bt.dispatch("BeforeExecCommand", lt).isDefaultPrevented()) {
        bt.getDoc().execCommand(at, !1, ss), bt.dispatch("ExecCommand", lt);
        const ee = Wt(bt);
        if (Ft(ee)) {
          const pe = ot.getNode();
          $e.setAttrib(pe, "target", ee), ee === "_blank" && !Ee(bt) && $e.setAttrib(pe, "rel", "noopener");
        }
      }
      ot.moveToBookmark(fo), bt.nodeChanged();
    }, Gn = (bt) => {
      const kn = mn(bt, -1);
      En(kn) && it(bt, kn);
    }, rn = Gn, Ye = (bt) => {
      const kn = mn(bt, 0);
      En(kn) && it(bt, kn);
    }, io = (bt) => {
      bt.on("keydown", (kn) => {
        kn.keyCode === 13 && !kn.isDefaultPrevented() && Ye(bt);
      }), bt.on("keyup", (kn) => {
        kn.keyCode === 32 ? Gn(bt) : (kn.keyCode === 48 && kn.shiftKey || kn.keyCode === 221) && rn(bt);
      });
    };
    var jo = () => {
      vt.add("autolink", (bt) => {
        yt(bt), io(bt);
      });
    };
    jo();
  })()), TG;
}
var kG;
function UY() {
  return kG || (kG = 1, VY()), xG;
}
UY();
var _G = {}, AG = {}, OG;
function WY() {
  return OG || (OG = 1, (function() {
    const vt = (J) => {
      let Qe = J;
      return {
        get: () => Qe,
        set: (U) => {
          Qe = U;
        }
      };
    };
    var Ot = tinymce.util.Tools.resolve("tinymce.PluginManager");
    const Pt = (J) => () => J;
    var yt = tinymce.util.Tools.resolve("tinymce.Env");
    const Nt = (J) => J.dispatch("ResizeEditor"), Wt = (J) => (Qe) => Qe.options.get(J), Fe = (J) => {
      const Qe = J.options.register;
      Qe("autoresize_overflow_padding", {
        processor: "number",
        default: 1
      }), Qe("autoresize_bottom_margin", {
        processor: "number",
        default: 50
      });
    }, Ee = Wt("min_height"), Bt = Wt("max_height"), fn = Wt("autoresize_overflow_padding"), dn = Wt("autoresize_bottom_margin"), Sn = (J) => J.plugins.fullscreen && J.plugins.fullscreen.isFullscreen(), Ft = (J, Qe) => {
      const xo = J.getBody();
      xo && (xo.style.overflowY = Qe ? "" : "hidden", Qe || (xo.scrollTop = 0));
    }, Zt = (J, Qe, xo, ht) => {
      var U;
      const Tt = parseInt((U = J.getStyle(Qe, xo, ht)) !== null && U !== void 0 ? U : "", 10);
      return isNaN(Tt) ? 0 : Tt;
    }, Qt = (J) => {
      if (J?.type.toLowerCase() === "setcontent") {
        const Qe = J;
        return Qe.selection === !0 || Qe.paste === !0;
      } else
        return !1;
    }, En = (J, Qe, xo, ht) => {
      var U;
      const Tt = J.dom, Ht = J.getDoc();
      if (!Ht)
        return;
      if (Sn(J)) {
        Ft(J, !0);
        return;
      }
      const gn = Ht.documentElement, De = ht ? ht() : fn(J), re = (U = Ee(J)) !== null && U !== void 0 ? U : J.getElement().offsetHeight;
      let ho = re;
      const Te = Zt(Tt, gn, "margin-top", !0), Oe = Zt(Tt, gn, "margin-bottom", !0);
      let A = gn.offsetHeight + Te + Oe + De;
      A < 0 && (A = 0);
      const mn = J.getContainer().offsetHeight, it = J.getContentAreaContainer().offsetHeight, Gn = mn - it;
      A + Gn > re && (ho = A + Gn);
      const rn = Bt(J);
      if (rn && ho > rn ? (ho = rn, Ft(J, !0)) : Ft(J, !1), ho !== Qe.get()) {
        const Ye = ho - Qe.get();
        if (Tt.setStyle(J.getContainer(), "height", ho + "px"), Qe.set(ho), Nt(J), yt.browser.isSafari() && (yt.os.isMacOS() || yt.os.isiOS())) {
          const io = J.getWin();
          io.scrollTo(io.pageXOffset, io.pageYOffset);
        }
        J.hasFocus() && Qt(xo) && J.selection.scrollIntoView(), (yt.browser.isSafari() || yt.browser.isChromium()) && Ye < 0 && En(J, Qe, xo, ht);
      }
    }, st = (J, Qe) => {
      let xo = () => dn(J), ht, U;
      J.on("init", (Tt) => {
        ht = 0;
        const Ht = fn(J), gn = J.dom;
        gn.setStyles(J.getDoc().documentElement, { height: "auto" }), yt.browser.isEdge() || yt.browser.isIE() ? gn.setStyles(J.getBody(), {
          paddingLeft: Ht,
          paddingRight: Ht,
          "min-height": 0
        }) : gn.setStyles(J.getBody(), {
          paddingLeft: Ht,
          paddingRight: Ht
        }), En(J, Qe, Tt, xo), ht += 1;
      }), J.on("NodeChange SetContent keyup FullscreenStateChanged ResizeContent", (Tt) => {
        if (ht === 1)
          U = J.getContainer().offsetHeight, En(J, Qe, Tt, xo), ht += 1;
        else if (ht === 2) {
          const Ht = U < J.getContainer().offsetHeight;
          if (Ht) {
            const gn = J.dom, De = J.getDoc();
            gn.setStyles(De.documentElement, { "min-height": 0 }), gn.setStyles(J.getBody(), { "min-height": "inherit" });
          }
          xo = Ht ? Pt(0) : xo, ht += 1;
        } else
          En(J, Qe, Tt, xo);
      });
    }, Pn = (J, Qe) => {
      J.addCommand("mceAutoResize", () => {
        En(J, Qe);
      });
    };
    var Kt = () => {
      Ot.add("autoresize", (J) => {
        if (Fe(J), J.options.isSet("resize") || J.options.set("resize", !1), !J.inline) {
          const Qe = vt(0);
          Pn(J, Qe), st(J, Qe);
        }
      });
    };
    Kt();
  })()), AG;
}
var DG;
function ZY() {
  return DG || (DG = 1, WY()), _G;
}
ZY();
var RG = {}, NG = {}, MG;
function jY() {
  return MG || (MG = 1, (function() {
    var vt = tinymce.util.Tools.resolve("tinymce.PluginManager");
    const Ot = (ee, pe) => ee.dispatch("insertCustomChar", { chr: pe }), Pt = (ee, pe) => {
      const ye = Ot(ee, pe).chr;
      ee.execCommand("mceInsertContent", !1, ye);
    }, yt = (ee, pe, ye) => {
      var ae;
      return ye(ee, pe.prototype) ? !0 : ((ae = ee.constructor) === null || ae === void 0 ? void 0 : ae.name) === pe.name;
    }, Nt = (ee) => {
      const pe = typeof ee;
      return ee === null ? "null" : pe === "object" && Array.isArray(ee) ? "array" : pe === "object" && yt(ee, String, (ye, ae) => ae.isPrototypeOf(ye)) ? "string" : pe;
    }, Wt = (ee) => (pe) => Nt(pe) === ee, Fe = (ee) => (pe) => typeof pe === ee, Ee = (ee) => (pe) => ee === pe, Bt = Wt("array"), fn = Ee(null), dn = Ee(void 0), Sn = (ee) => ee == null, Ft = (ee) => !Sn(ee), Zt = Fe("function"), En = ((ee) => () => ee)(!1);
    class st {
      constructor(pe, ye) {
        this.tag = pe, this.value = ye;
      }
      static some(pe) {
        return new st(!0, pe);
      }
      static none() {
        return st.singletonNone;
      }
      fold(pe, ye) {
        return this.tag ? ye(this.value) : pe();
      }
      isSome() {
        return this.tag;
      }
      isNone() {
        return !this.tag;
      }
      map(pe) {
        return this.tag ? st.some(pe(this.value)) : st.none();
      }
      bind(pe) {
        return this.tag ? pe(this.value) : st.none();
      }
      exists(pe) {
        return this.tag && pe(this.value);
      }
      forall(pe) {
        return !this.tag || pe(this.value);
      }
      filter(pe) {
        return !this.tag || pe(this.value) ? this : st.none();
      }
      getOr(pe) {
        return this.tag ? this.value : pe;
      }
      or(pe) {
        return this.tag ? this : pe;
      }
      getOrThunk(pe) {
        return this.tag ? this.value : pe();
      }
      orThunk(pe) {
        return this.tag ? this : pe();
      }
      getOrDie(pe) {
        if (this.tag)
          return this.value;
        throw new Error(pe ?? "Called getOrDie on None");
      }
      static from(pe) {
        return Ft(pe) ? st.some(pe) : st.none();
      }
      getOrNull() {
        return this.tag ? this.value : null;
      }
      getOrUndefined() {
        return this.value;
      }
      each(pe) {
        this.tag && pe(this.value);
      }
      toArray() {
        return this.tag ? [this.value] : [];
      }
      toString() {
        return this.tag ? `some(${this.value})` : "none()";
      }
    }
    st.singletonNone = new st(!1);
    const Pn = Array.prototype.push, Kt = (ee, pe) => {
      const ye = ee.length, ae = new Array(ye);
      for (let kt = 0; kt < ye; kt++) {
        const Vn = ee[kt];
        ae[kt] = pe(Vn, kt);
      }
      return ae;
    }, J = (ee, pe) => {
      for (let ye = 0, ae = ee.length; ye < ae; ye++) {
        const kt = ee[ye];
        pe(kt, ye);
      }
    }, Qe = (ee, pe, ye) => {
      for (let ae = 0, kt = ee.length; ae < kt; ae++) {
        const Vn = ee[ae];
        if (pe(Vn, ae))
          return st.some(Vn);
        if (ye(Vn, ae))
          break;
      }
      return st.none();
    }, xo = (ee, pe) => Qe(ee, pe, En), ht = (ee) => {
      const pe = [];
      for (let ye = 0, ae = ee.length; ye < ae; ++ye) {
        if (!Bt(ee[ye]))
          throw new Error("Arr.flatten item " + ye + " was not an array, input: " + ee);
        Pn.apply(pe, ee[ye]);
      }
      return pe;
    }, U = (ee, pe) => ht(Kt(ee, pe));
    var Tt = tinymce.util.Tools.resolve("tinymce.util.Tools");
    const Ht = (ee) => (pe) => pe.options.get(ee), gn = (ee) => {
      const pe = ee.options.register, ye = (ae) => Zt(ae) || Bt(ae);
      pe("charmap", { processor: ye }), pe("charmap_append", { processor: ye });
    }, De = Ht("charmap"), re = Ht("charmap_append"), ho = Tt.isArray, Te = "User Defined", Oe = () => [
      {
        name: "Currency",
        characters: [
          [
            36,
            "dollar sign"
          ],
          [
            162,
            "cent sign"
          ],
          [
            8364,
            "euro sign"
          ],
          [
            163,
            "pound sign"
          ],
          [
            165,
            "yen sign"
          ],
          [
            164,
            "currency sign"
          ],
          [
            8352,
            "euro-currency sign"
          ],
          [
            8353,
            "colon sign"
          ],
          [
            8354,
            "cruzeiro sign"
          ],
          [
            8355,
            "french franc sign"
          ],
          [
            8356,
            "lira sign"
          ],
          [
            8357,
            "mill sign"
          ],
          [
            8358,
            "naira sign"
          ],
          [
            8359,
            "peseta sign"
          ],
          [
            8360,
            "rupee sign"
          ],
          [
            8361,
            "won sign"
          ],
          [
            8362,
            "new sheqel sign"
          ],
          [
            8363,
            "dong sign"
          ],
          [
            8365,
            "kip sign"
          ],
          [
            8366,
            "tugrik sign"
          ],
          [
            8367,
            "drachma sign"
          ],
          [
            8368,
            "german penny symbol"
          ],
          [
            8369,
            "peso sign"
          ],
          [
            8370,
            "guarani sign"
          ],
          [
            8371,
            "austral sign"
          ],
          [
            8372,
            "hryvnia sign"
          ],
          [
            8373,
            "cedi sign"
          ],
          [
            8374,
            "livre tournois sign"
          ],
          [
            8375,
            "spesmilo sign"
          ],
          [
            8376,
            "tenge sign"
          ],
          [
            8377,
            "indian rupee sign"
          ],
          [
            8378,
            "turkish lira sign"
          ],
          [
            8379,
            "nordic mark sign"
          ],
          [
            8380,
            "manat sign"
          ],
          [
            8381,
            "ruble sign"
          ],
          [
            20870,
            "yen character"
          ],
          [
            20803,
            "yuan character"
          ],
          [
            22291,
            "yuan character, in hong kong and taiwan"
          ],
          [
            22278,
            "yen/yuan character variant one"
          ]
        ]
      },
      {
        name: "Text",
        characters: [
          [
            169,
            "copyright sign"
          ],
          [
            174,
            "registered sign"
          ],
          [
            8482,
            "trade mark sign"
          ],
          [
            8240,
            "per mille sign"
          ],
          [
            181,
            "micro sign"
          ],
          [
            183,
            "middle dot"
          ],
          [
            8226,
            "bullet"
          ],
          [
            8230,
            "three dot leader"
          ],
          [
            8242,
            "minutes / feet"
          ],
          [
            8243,
            "seconds / inches"
          ],
          [
            167,
            "section sign"
          ],
          [
            182,
            "paragraph sign"
          ],
          [
            223,
            "sharp s / ess-zed"
          ]
        ]
      },
      {
        name: "Quotations",
        characters: [
          [
            8249,
            "single left-pointing angle quotation mark"
          ],
          [
            8250,
            "single right-pointing angle quotation mark"
          ],
          [
            171,
            "left pointing guillemet"
          ],
          [
            187,
            "right pointing guillemet"
          ],
          [
            8216,
            "left single quotation mark"
          ],
          [
            8217,
            "right single quotation mark"
          ],
          [
            8220,
            "left double quotation mark"
          ],
          [
            8221,
            "right double quotation mark"
          ],
          [
            8218,
            "single low-9 quotation mark"
          ],
          [
            8222,
            "double low-9 quotation mark"
          ],
          [
            60,
            "less-than sign"
          ],
          [
            62,
            "greater-than sign"
          ],
          [
            8804,
            "less-than or equal to"
          ],
          [
            8805,
            "greater-than or equal to"
          ],
          [
            8211,
            "en dash"
          ],
          [
            8212,
            "em dash"
          ],
          [
            175,
            "macron"
          ],
          [
            8254,
            "overline"
          ],
          [
            164,
            "currency sign"
          ],
          [
            166,
            "broken bar"
          ],
          [
            168,
            "diaeresis"
          ],
          [
            161,
            "inverted exclamation mark"
          ],
          [
            191,
            "turned question mark"
          ],
          [
            710,
            "circumflex accent"
          ],
          [
            732,
            "small tilde"
          ],
          [
            176,
            "degree sign"
          ],
          [
            8722,
            "minus sign"
          ],
          [
            177,
            "plus-minus sign"
          ],
          [
            247,
            "division sign"
          ],
          [
            8260,
            "fraction slash"
          ],
          [
            215,
            "multiplication sign"
          ],
          [
            185,
            "superscript one"
          ],
          [
            178,
            "superscript two"
          ],
          [
            179,
            "superscript three"
          ],
          [
            188,
            "fraction one quarter"
          ],
          [
            189,
            "fraction one half"
          ],
          [
            190,
            "fraction three quarters"
          ]
        ]
      },
      {
        name: "Mathematical",
        characters: [
          [
            402,
            "function / florin"
          ],
          [
            8747,
            "integral"
          ],
          [
            8721,
            "n-ary sumation"
          ],
          [
            8734,
            "infinity"
          ],
          [
            8730,
            "square root"
          ],
          [
            8764,
            "similar to"
          ],
          [
            8773,
            "approximately equal to"
          ],
          [
            8776,
            "almost equal to"
          ],
          [
            8800,
            "not equal to"
          ],
          [
            8801,
            "identical to"
          ],
          [
            8712,
            "element of"
          ],
          [
            8713,
            "not an element of"
          ],
          [
            8715,
            "contains as member"
          ],
          [
            8719,
            "n-ary product"
          ],
          [
            8743,
            "logical and"
          ],
          [
            8744,
            "logical or"
          ],
          [
            172,
            "not sign"
          ],
          [
            8745,
            "intersection"
          ],
          [
            8746,
            "union"
          ],
          [
            8706,
            "partial differential"
          ],
          [
            8704,
            "for all"
          ],
          [
            8707,
            "there exists"
          ],
          [
            8709,
            "diameter"
          ],
          [
            8711,
            "backward difference"
          ],
          [
            8727,
            "asterisk operator"
          ],
          [
            8733,
            "proportional to"
          ],
          [
            8736,
            "angle"
          ]
        ]
      },
      {
        name: "Extended Latin",
        characters: [
          [
            192,
            "A - grave"
          ],
          [
            193,
            "A - acute"
          ],
          [
            194,
            "A - circumflex"
          ],
          [
            195,
            "A - tilde"
          ],
          [
            196,
            "A - diaeresis"
          ],
          [
            197,
            "A - ring above"
          ],
          [
            256,
            "A - macron"
          ],
          [
            198,
            "ligature AE"
          ],
          [
            199,
            "C - cedilla"
          ],
          [
            200,
            "E - grave"
          ],
          [
            201,
            "E - acute"
          ],
          [
            202,
            "E - circumflex"
          ],
          [
            203,
            "E - diaeresis"
          ],
          [
            274,
            "E - macron"
          ],
          [
            204,
            "I - grave"
          ],
          [
            205,
            "I - acute"
          ],
          [
            206,
            "I - circumflex"
          ],
          [
            207,
            "I - diaeresis"
          ],
          [
            298,
            "I - macron"
          ],
          [
            208,
            "ETH"
          ],
          [
            209,
            "N - tilde"
          ],
          [
            210,
            "O - grave"
          ],
          [
            211,
            "O - acute"
          ],
          [
            212,
            "O - circumflex"
          ],
          [
            213,
            "O - tilde"
          ],
          [
            214,
            "O - diaeresis"
          ],
          [
            216,
            "O - slash"
          ],
          [
            332,
            "O - macron"
          ],
          [
            338,
            "ligature OE"
          ],
          [
            352,
            "S - caron"
          ],
          [
            217,
            "U - grave"
          ],
          [
            218,
            "U - acute"
          ],
          [
            219,
            "U - circumflex"
          ],
          [
            220,
            "U - diaeresis"
          ],
          [
            362,
            "U - macron"
          ],
          [
            221,
            "Y - acute"
          ],
          [
            376,
            "Y - diaeresis"
          ],
          [
            562,
            "Y - macron"
          ],
          [
            222,
            "THORN"
          ],
          [
            224,
            "a - grave"
          ],
          [
            225,
            "a - acute"
          ],
          [
            226,
            "a - circumflex"
          ],
          [
            227,
            "a - tilde"
          ],
          [
            228,
            "a - diaeresis"
          ],
          [
            229,
            "a - ring above"
          ],
          [
            257,
            "a - macron"
          ],
          [
            230,
            "ligature ae"
          ],
          [
            231,
            "c - cedilla"
          ],
          [
            232,
            "e - grave"
          ],
          [
            233,
            "e - acute"
          ],
          [
            234,
            "e - circumflex"
          ],
          [
            235,
            "e - diaeresis"
          ],
          [
            275,
            "e - macron"
          ],
          [
            236,
            "i - grave"
          ],
          [
            237,
            "i - acute"
          ],
          [
            238,
            "i - circumflex"
          ],
          [
            239,
            "i - diaeresis"
          ],
          [
            299,
            "i - macron"
          ],
          [
            240,
            "eth"
          ],
          [
            241,
            "n - tilde"
          ],
          [
            242,
            "o - grave"
          ],
          [
            243,
            "o - acute"
          ],
          [
            244,
            "o - circumflex"
          ],
          [
            245,
            "o - tilde"
          ],
          [
            246,
            "o - diaeresis"
          ],
          [
            248,
            "o slash"
          ],
          [
            333,
            "o macron"
          ],
          [
            339,
            "ligature oe"
          ],
          [
            353,
            "s - caron"
          ],
          [
            249,
            "u - grave"
          ],
          [
            250,
            "u - acute"
          ],
          [
            251,
            "u - circumflex"
          ],
          [
            252,
            "u - diaeresis"
          ],
          [
            363,
            "u - macron"
          ],
          [
            253,
            "y - acute"
          ],
          [
            254,
            "thorn"
          ],
          [
            255,
            "y - diaeresis"
          ],
          [
            563,
            "y - macron"
          ],
          [
            913,
            "Alpha"
          ],
          [
            914,
            "Beta"
          ],
          [
            915,
            "Gamma"
          ],
          [
            916,
            "Delta"
          ],
          [
            917,
            "Epsilon"
          ],
          [
            918,
            "Zeta"
          ],
          [
            919,
            "Eta"
          ],
          [
            920,
            "Theta"
          ],
          [
            921,
            "Iota"
          ],
          [
            922,
            "Kappa"
          ],
          [
            923,
            "Lambda"
          ],
          [
            924,
            "Mu"
          ],
          [
            925,
            "Nu"
          ],
          [
            926,
            "Xi"
          ],
          [
            927,
            "Omicron"
          ],
          [
            928,
            "Pi"
          ],
          [
            929,
            "Rho"
          ],
          [
            931,
            "Sigma"
          ],
          [
            932,
            "Tau"
          ],
          [
            933,
            "Upsilon"
          ],
          [
            934,
            "Phi"
          ],
          [
            935,
            "Chi"
          ],
          [
            936,
            "Psi"
          ],
          [
            937,
            "Omega"
          ],
          [
            945,
            "alpha"
          ],
          [
            946,
            "beta"
          ],
          [
            947,
            "gamma"
          ],
          [
            948,
            "delta"
          ],
          [
            949,
            "epsilon"
          ],
          [
            950,
            "zeta"
          ],
          [
            951,
            "eta"
          ],
          [
            952,
            "theta"
          ],
          [
            953,
            "iota"
          ],
          [
            954,
            "kappa"
          ],
          [
            955,
            "lambda"
          ],
          [
            956,
            "mu"
          ],
          [
            957,
            "nu"
          ],
          [
            958,
            "xi"
          ],
          [
            959,
            "omicron"
          ],
          [
            960,
            "pi"
          ],
          [
            961,
            "rho"
          ],
          [
            962,
            "final sigma"
          ],
          [
            963,
            "sigma"
          ],
          [
            964,
            "tau"
          ],
          [
            965,
            "upsilon"
          ],
          [
            966,
            "phi"
          ],
          [
            967,
            "chi"
          ],
          [
            968,
            "psi"
          ],
          [
            969,
            "omega"
          ]
        ]
      },
      {
        name: "Symbols",
        characters: [
          [
            8501,
            "alef symbol"
          ],
          [
            982,
            "pi symbol"
          ],
          [
            8476,
            "real part symbol"
          ],
          [
            978,
            "upsilon - hook symbol"
          ],
          [
            8472,
            "Weierstrass p"
          ],
          [
            8465,
            "imaginary part"
          ]
        ]
      },
      {
        name: "Arrows",
        characters: [
          [
            8592,
            "leftwards arrow"
          ],
          [
            8593,
            "upwards arrow"
          ],
          [
            8594,
            "rightwards arrow"
          ],
          [
            8595,
            "downwards arrow"
          ],
          [
            8596,
            "left right arrow"
          ],
          [
            8629,
            "carriage return"
          ],
          [
            8656,
            "leftwards double arrow"
          ],
          [
            8657,
            "upwards double arrow"
          ],
          [
            8658,
            "rightwards double arrow"
          ],
          [
            8659,
            "downwards double arrow"
          ],
          [
            8660,
            "left right double arrow"
          ],
          [
            8756,
            "therefore"
          ],
          [
            8834,
            "subset of"
          ],
          [
            8835,
            "superset of"
          ],
          [
            8836,
            "not a subset of"
          ],
          [
            8838,
            "subset of or equal to"
          ],
          [
            8839,
            "superset of or equal to"
          ],
          [
            8853,
            "circled plus"
          ],
          [
            8855,
            "circled times"
          ],
          [
            8869,
            "perpendicular"
          ],
          [
            8901,
            "dot operator"
          ],
          [
            8968,
            "left ceiling"
          ],
          [
            8969,
            "right ceiling"
          ],
          [
            8970,
            "left floor"
          ],
          [
            8971,
            "right floor"
          ],
          [
            9001,
            "left-pointing angle bracket"
          ],
          [
            9002,
            "right-pointing angle bracket"
          ],
          [
            9674,
            "lozenge"
          ],
          [
            9824,
            "black spade suit"
          ],
          [
            9827,
            "black club suit"
          ],
          [
            9829,
            "black heart suit"
          ],
          [
            9830,
            "black diamond suit"
          ],
          [
            8194,
            "en space"
          ],
          [
            8195,
            "em space"
          ],
          [
            8201,
            "thin space"
          ],
          [
            8204,
            "zero width non-joiner"
          ],
          [
            8205,
            "zero width joiner"
          ],
          [
            8206,
            "left-to-right mark"
          ],
          [
            8207,
            "right-to-left mark"
          ]
        ]
      }
    ], A = (ee) => Tt.grep(ee, (pe) => ho(pe) && pe.length === 2), mn = (ee) => ho(ee) ? A(ee) : typeof ee == "function" ? ee() : [], it = (ee, pe) => {
      const ye = De(ee);
      ye && (pe = [{
        name: Te,
        characters: mn(ye)
      }]);
      const ae = re(ee);
      if (ae) {
        const kt = Tt.grep(pe, (Vn) => Vn.name === Te);
        return kt.length ? (kt[0].characters = [
          ...kt[0].characters,
          ...mn(ae)
        ], pe) : pe.concat({
          name: Te,
          characters: mn(ae)
        });
      }
      return pe;
    }, Gn = (ee) => {
      const pe = it(ee, Oe());
      return pe.length > 1 ? [{
        name: "All",
        characters: U(pe, (ye) => ye.characters)
      }].concat(pe) : pe;
    }, rn = (ee) => ({
      getCharMap: () => Gn(ee),
      insertChar: (ae) => {
        Pt(ee, ae);
      }
    }), Ye = (ee) => {
      let pe = ee;
      return {
        get: () => pe,
        set: (kt) => {
          pe = kt;
        }
      };
    }, io = (ee, pe) => {
      let ye = null;
      const ae = () => {
        fn(ye) || (clearTimeout(ye), ye = null);
      };
      return {
        cancel: ae,
        throttle: (...Vn) => {
          ae(), ye = setTimeout(() => {
            ye = null, ee.apply(null, Vn);
          }, pe);
        }
      };
    }, jo = (ee, pe, ye = 0, ae) => {
      const kt = ee.indexOf(pe, ye);
      return kt !== -1 ? dn(ae) ? !0 : kt + pe.length <= ae : !1;
    }, bt = String.fromCodePoint, kn = (ee, pe, ye) => jo(bt(ee).toLowerCase(), ye) ? !0 : jo(pe.toLowerCase(), ye) || jo(pe.toLowerCase().replace(/\s+/g, ""), ye), $e = (ee, pe) => {
      const ye = [], ae = pe.toLowerCase();
      return J(ee.characters, (kt) => {
        kn(kt[0], kt[1], ae) && ye.push(kt);
      }), Kt(ye, (kt) => ({
        text: kt[1],
        value: bt(kt[0]),
        icon: bt(kt[0])
      }));
    }, ot = "pattern", F = (ee, pe) => {
      const ye = () => [
        {
          label: "Search",
          type: "input",
          name: ot
        },
        {
          type: "collection",
          name: "results"
        }
      ], ae = () => Kt(pe, (No) => ({
        title: No.name,
        name: No.name,
        items: ye()
      })), kt = () => ({
        type: "panel",
        items: ye()
      }), Vn = () => ({
        type: "tabpanel",
        tabs: ae()
      }), Yt = pe.length === 1 ? Ye(Te) : Ye("All"), Ct = (No, Ao) => {
        xo(pe, (Cs) => Cs.name === Yt.get()).each((Cs) => {
          const Ie = $e(Cs, Ao);
          No.setData({ results: Ie });
        });
      }, In = io((No) => {
        const Ao = No.getData().pattern;
        Ct(No, Ao);
      }, 40), hn = pe.length === 1 ? kt() : Vn(), Xn = {
        pattern: "",
        results: $e(pe[0], "")
      }, Xo = {
        title: "Special Character",
        size: "normal",
        body: hn,
        buttons: [{
          type: "cancel",
          name: "close",
          text: "Close",
          primary: !0
        }],
        initialData: Xn,
        onAction: (No, Ao) => {
          Ao.name === "results" && (Pt(ee, Ao.value), No.close());
        },
        onTabChange: (No, Ao) => {
          Yt.set(Ao.newTabName), In.throttle(No);
        },
        onChange: (No, Ao) => {
          Ao.name === ot && In.throttle(No);
        }
      };
      ee.windowManager.open(Xo).focus(ot);
    }, ss = (ee, pe) => {
      ee.addCommand("mceShowCharmap", () => {
        F(ee, pe);
      });
    }, fo = (ee, pe) => {
      ee.ui.registry.addAutocompleter("charmap", {
        trigger: ":",
        columns: "auto",
        minChars: 2,
        fetch: (ye, ae) => new Promise((kt, Vn) => {
          kt($e(pe, ye));
        }),
        onAction: (ye, ae, kt) => {
          ee.selection.setRng(ae), ee.insertContent(kt), ye.hide();
        }
      });
    }, at = (ee) => (pe) => {
      const ye = () => {
        pe.setEnabled(ee.selection.isEditable());
      };
      return ee.on("NodeChange", ye), ye(), () => {
        ee.off("NodeChange", ye);
      };
    }, lt = (ee) => {
      const pe = () => ee.execCommand("mceShowCharmap");
      ee.ui.registry.addButton("charmap", {
        icon: "insert-character",
        tooltip: "Special character",
        onAction: pe,
        onSetup: at(ee)
      }), ee.ui.registry.addMenuItem("charmap", {
        icon: "insert-character",
        text: "Special character...",
        onAction: pe,
        onSetup: at(ee)
      });
    };
    var Rn = () => {
      vt.add("charmap", (ee) => {
        gn(ee);
        const pe = Gn(ee);
        return ss(ee, pe), lt(ee), fo(ee, pe[0]), rn(ee);
      });
    };
    Rn();
  })()), NG;
}
var PG;
function qY() {
  return PG || (PG = 1, jY()), RG;
}
qY();
var BG = {}, $G = {}, FG;
function GY() {
  return FG || (FG = 1, (function() {
    var vt = tinymce.util.Tools.resolve("tinymce.PluginManager");
    const Ot = (Ee, Bt) => {
      Ee.focus(), Ee.undoManager.transact(() => {
        Ee.setContent(Bt);
      }), Ee.selection.setCursorLocation(), Ee.nodeChanged();
    }, Pt = (Ee) => Ee.getContent({ source_view: !0 }), yt = (Ee) => {
      const Bt = Pt(Ee);
      Ee.windowManager.open({
        title: "Source Code",
        size: "large",
        body: {
          type: "panel",
          items: [{
            type: "textarea",
            name: "code"
          }]
        },
        buttons: [
          {
            type: "cancel",
            name: "cancel",
            text: "Cancel"
          },
          {
            type: "submit",
            name: "save",
            text: "Save",
            primary: !0
          }
        ],
        initialData: { code: Bt },
        onSubmit: (fn) => {
          Ot(Ee, fn.getData().code), fn.close();
        }
      });
    }, Nt = (Ee) => {
      Ee.addCommand("mceCodeEditor", () => {
        yt(Ee);
      });
    }, Wt = (Ee) => {
      const Bt = () => Ee.execCommand("mceCodeEditor");
      Ee.ui.registry.addButton("code", {
        icon: "sourcecode",
        tooltip: "Source code",
        onAction: Bt
      }), Ee.ui.registry.addMenuItem("code", {
        icon: "sourcecode",
        text: "Source code",
        onAction: Bt
      });
    };
    var Fe = () => {
      vt.add("code", (Ee) => (Nt(Ee), Wt(Ee), {}));
    };
    Fe();
  })()), $G;
}
var IG;
function KY() {
  return IG || (IG = 1, GY()), BG;
}
KY();
var LG = {}, HG = {}, zG;
function YY() {
  return zG || (zG = 1, (function() {
    var vt = tinymce.util.Tools.resolve("tinymce.PluginManager");
    const Ot = (Ie, et, nn) => {
      var qt;
      return nn(Ie, et.prototype) ? !0 : ((qt = Ie.constructor) === null || qt === void 0 ? void 0 : qt.name) === et.name;
    }, Pt = (Ie) => {
      const et = typeof Ie;
      return Ie === null ? "null" : et === "object" && Array.isArray(Ie) ? "array" : et === "object" && Ot(Ie, String, (nn, qt) => qt.isPrototypeOf(nn)) ? "string" : et;
    }, yt = (Ie) => (et) => Pt(et) === Ie, Nt = (Ie) => (et) => typeof et === Ie, Wt = yt("string"), Fe = Nt("boolean"), Ee = (Ie) => Ie == null, Bt = (Ie) => !Ee(Ie), fn = Nt("function"), dn = Nt("number"), Sn = (Ie, et) => (nn) => Ie(et(nn)), Zt = ((Ie) => () => Ie)(!1);
    class Qt {
      constructor(et, nn) {
        this.tag = et, this.value = nn;
      }
      static some(et) {
        return new Qt(!0, et);
      }
      static none() {
        return Qt.singletonNone;
      }
      fold(et, nn) {
        return this.tag ? nn(this.value) : et();
      }
      isSome() {
        return this.tag;
      }
      isNone() {
        return !this.tag;
      }
      map(et) {
        return this.tag ? Qt.some(et(this.value)) : Qt.none();
      }
      bind(et) {
        return this.tag ? et(this.value) : Qt.none();
      }
      exists(et) {
        return this.tag && et(this.value);
      }
      forall(et) {
        return !this.tag || et(this.value);
      }
      filter(et) {
        return !this.tag || et(this.value) ? this : Qt.none();
      }
      getOr(et) {
        return this.tag ? this.value : et;
      }
      or(et) {
        return this.tag ? this : et;
      }
      getOrThunk(et) {
        return this.tag ? this.value : et();
      }
      orThunk(et) {
        return this.tag ? this : et();
      }
      getOrDie(et) {
        if (this.tag)
          return this.value;
        throw new Error(et ?? "Called getOrDie on None");
      }
      static from(et) {
        return Bt(et) ? Qt.some(et) : Qt.none();
      }
      getOrNull() {
        return this.tag ? this.value : null;
      }
      getOrUndefined() {
        return this.value;
      }
      each(et) {
        this.tag && et(this.value);
      }
      toArray() {
        return this.tag ? [this.value] : [];
      }
      toString() {
        return this.tag ? `some(${this.value})` : "none()";
      }
    }
    Qt.singletonNone = new Qt(!1);
    const En = (Ie, et) => {
      const nn = Ie.length, qt = new Array(nn);
      for (let ko = 0; ko < nn; ko++) {
        const rs = Ie[ko];
        qt[ko] = et(rs, ko);
      }
      return qt;
    }, st = (Ie, et) => {
      for (let nn = 0, qt = Ie.length; nn < qt; nn++) {
        const ko = Ie[nn];
        et(ko, nn);
      }
    }, Pn = (Ie, et) => {
      const nn = [];
      for (let qt = 0, ko = Ie.length; qt < ko; qt++) {
        const rs = Ie[qt];
        et(rs, qt) && nn.push(rs);
      }
      return nn;
    }, Kt = 9, J = 11, Qe = 1, xo = 3, ht = (Ie, et) => {
      const qt = (et || document).createElement("div");
      if (qt.innerHTML = Ie, !qt.hasChildNodes() || qt.childNodes.length > 1) {
        const ko = "HTML does not have a single root node";
        throw new Error(ko);
      }
      return Ht(qt.childNodes[0]);
    }, U = (Ie, et) => {
      const qt = (et || document).createElement(Ie);
      return Ht(qt);
    }, Tt = (Ie, et) => {
      const qt = (et || document).createTextNode(Ie);
      return Ht(qt);
    }, Ht = (Ie) => {
      if (Ie == null)
        throw new Error("Node cannot be null or undefined");
      return { dom: Ie };
    }, De = {
      fromHtml: ht,
      fromTag: U,
      fromText: Tt,
      fromDom: Ht,
      fromPoint: (Ie, et, nn) => Qt.from(Ie.dom.elementFromPoint(et, nn)).map(Ht)
    }, re = (Ie, et) => {
      const nn = Ie.dom;
      if (nn.nodeType !== Qe)
        return !1;
      {
        const qt = nn;
        if (qt.matches !== void 0)
          return qt.matches(et);
        if (qt.msMatchesSelector !== void 0)
          return qt.msMatchesSelector(et);
        if (qt.webkitMatchesSelector !== void 0)
          return qt.webkitMatchesSelector(et);
        if (qt.mozMatchesSelector !== void 0)
          return qt.mozMatchesSelector(et);
        throw new Error("Browser lacks native selectors");
      }
    };
    typeof window < "u" || Function("return this;")();
    const ho = (Ie) => Ie.dom.nodeName.toLowerCase(), Te = (Ie) => Ie.dom.nodeType, Oe = (Ie) => (et) => Te(et) === Ie, A = Oe(Qe), mn = Oe(xo), it = Oe(Kt), Gn = Oe(J), rn = (Ie) => (et) => A(et) && ho(et) === Ie, Ye = (Ie) => De.fromDom(Ie.dom.ownerDocument), io = (Ie) => it(Ie) ? Ie : Ye(Ie), jo = (Ie) => Qt.from(Ie.dom.parentNode).map(De.fromDom), bt = (Ie) => En(Ie.dom.childNodes, De.fromDom), kn = (Ie, et, nn) => {
      if (Wt(nn) || Fe(nn) || dn(nn))
        Ie.setAttribute(et, nn + "");
      else
        throw new Error("Attribute value was not simple");
    }, $e = (Ie, et, nn) => {
      kn(Ie.dom, et, nn);
    }, ot = (Ie, et) => {
      Ie.dom.removeAttribute(et);
    }, F = (Ie) => Gn(Ie) && Bt(Ie.dom.host), fo = fn(Element.prototype.attachShadow) && fn(Node.prototype.getRootNode) ? (Ie) => De.fromDom(Ie.dom.getRootNode()) : io, at = (Ie) => {
      const et = fo(Ie);
      return F(et) ? Qt.some(et) : Qt.none();
    }, lt = (Ie) => De.fromDom(Ie.dom.host), Rn = (Ie) => {
      const et = mn(Ie) ? Ie.dom.parentNode : Ie.dom;
      if (et == null || et.ownerDocument === null)
        return !1;
      const nn = et.ownerDocument;
      return at(De.fromDom(et)).fold(() => nn.body.contains(et), Sn(Rn, lt));
    }, ee = (Ie, et, nn) => {
      let qt = Ie.dom;
      const ko = fn(nn) ? nn : Zt;
      for (; qt.parentNode; ) {
        qt = qt.parentNode;
        const rs = De.fromDom(qt);
        if (et(rs))
          return Qt.some(rs);
        if (ko(rs))
          break;
      }
      return Qt.none();
    }, pe = (Ie, et, nn) => ee(Ie, (qt) => re(qt, et), nn), ye = (Ie) => Ie.style !== void 0 && fn(Ie.style.getPropertyValue), ae = (Ie, et) => {
      const nn = Ie.dom, ko = window.getComputedStyle(nn).getPropertyValue(et);
      return ko === "" && !Rn(Ie) ? kt(nn, et) : ko;
    }, kt = (Ie, et) => ye(Ie) ? Ie.style.getPropertyValue(et) : "", Vn = (Ie) => ae(Ie, "direction") === "rtl" ? "rtl" : "ltr", Yt = (Ie, et) => Pn(bt(Ie), et), Ct = (Ie, et) => Yt(Ie, (nn) => re(nn, et)), Xe = (Ie) => jo(Ie).filter(A), In = (Ie, et) => (et ? pe(Ie, "ol,ul") : Qt.some(Ie)).getOr(Ie), hn = rn("li"), Xn = (Ie, et, nn) => {
      st(et, (qt) => {
        const ko = De.fromDom(qt), rs = hn(ko), Gs = In(ko, rs);
        Xe(Gs).each((Ss) => {
          if (Ie.setStyle(Gs.dom, "direction", null), Vn(Ss) === nn ? ot(Gs, "dir") : $e(Gs, "dir", nn), Vn(Gs) !== nn && Ie.setStyle(Gs.dom, "direction", nn), rs) {
            const Dt = Ct(Gs, "li[dir],li[style]");
            st(Dt, (Lo) => {
              ot(Lo, "dir"), Ie.setStyle(Lo.dom, "direction", null);
            });
          }
        });
      });
    }, Xo = (Ie, et) => {
      Ie.selection.isEditable() && (Xn(Ie.dom, Ie.selection.getSelectedBlocks(), et), Ie.nodeChanged());
    }, ds = (Ie) => {
      Ie.addCommand("mceDirectionLTR", () => {
        Xo(Ie, "ltr");
      }), Ie.addCommand("mceDirectionRTL", () => {
        Xo(Ie, "rtl");
      });
    }, No = (Ie, et) => (nn) => {
      const qt = (ko) => {
        const rs = De.fromDom(ko.element);
        nn.setActive(Vn(rs) === et), nn.setEnabled(Ie.selection.isEditable());
      };
      return Ie.on("NodeChange", qt), nn.setEnabled(Ie.selection.isEditable()), () => Ie.off("NodeChange", qt);
    }, Ao = (Ie) => {
      Ie.ui.registry.addToggleButton("ltr", {
        tooltip: "Left to right",
        icon: "ltr",
        onAction: () => Ie.execCommand("mceDirectionLTR"),
        onSetup: No(Ie, "ltr")
      }), Ie.ui.registry.addToggleButton("rtl", {
        tooltip: "Right to left",
        icon: "rtl",
        onAction: () => Ie.execCommand("mceDirectionRTL"),
        onSetup: No(Ie, "rtl")
      });
    };
    var Cs = () => {
      vt.add("directionality", (Ie) => {
        ds(Ie), Ao(Ie);
      });
    };
    Cs();
  })()), HG;
}
var VG;
function XY() {
  return VG || (VG = 1, YY()), LG;
}
XY();
var UG = {}, WG = {}, ZG;
function JY() {
  return ZG || (ZG = 1, (function() {
    const vt = (j) => {
      let oe = j;
      return {
        get: () => oe,
        set: (yn) => {
          oe = yn;
        }
      };
    };
    var Ot = tinymce.util.Tools.resolve("tinymce.PluginManager");
    const Pt = (j) => ({ isFullscreen: () => j.get() !== null }), yt = (j, oe, Le) => {
      var je;
      return Le(j, oe.prototype) ? !0 : ((je = j.constructor) === null || je === void 0 ? void 0 : je.name) === oe.name;
    }, Nt = (j) => {
      const oe = typeof j;
      return j === null ? "null" : oe === "object" && Array.isArray(j) ? "array" : oe === "object" && yt(j, String, (Le, je) => je.isPrototypeOf(Le)) ? "string" : oe;
    }, Wt = (j) => (oe) => Nt(oe) === j, Fe = (j) => (oe) => typeof oe === j, Ee = (j) => (oe) => j === oe, Bt = Wt("string"), fn = Wt("object"), dn = Wt("array"), Sn = Ee(null), Ft = Fe("boolean"), Zt = Ee(void 0), Qt = (j) => j == null, En = (j) => !Qt(j), st = Fe("function"), Pn = Fe("number"), Kt = () => {
    }, J = (j, oe) => (...Le) => j(oe.apply(null, Le)), Qe = (j, oe) => (Le) => j(oe(Le)), xo = (j) => () => j;
    function ht(j, ...oe) {
      return (...Le) => {
        const je = oe.concat(Le);
        return j.apply(null, je);
      };
    }
    const U = xo(!1), Tt = xo(!0);
    class Ht {
      constructor(oe, Le) {
        this.tag = oe, this.value = Le;
      }
      static some(oe) {
        return new Ht(!0, oe);
      }
      static none() {
        return Ht.singletonNone;
      }
      fold(oe, Le) {
        return this.tag ? Le(this.value) : oe();
      }
      isSome() {
        return this.tag;
      }
      isNone() {
        return !this.tag;
      }
      map(oe) {
        return this.tag ? Ht.some(oe(this.value)) : Ht.none();
      }
      bind(oe) {
        return this.tag ? oe(this.value) : Ht.none();
      }
      exists(oe) {
        return this.tag && oe(this.value);
      }
      forall(oe) {
        return !this.tag || oe(this.value);
      }
      filter(oe) {
        return !this.tag || oe(this.value) ? this : Ht.none();
      }
      getOr(oe) {
        return this.tag ? this.value : oe;
      }
      or(oe) {
        return this.tag ? this : oe;
      }
      getOrThunk(oe) {
        return this.tag ? this.value : oe();
      }
      orThunk(oe) {
        return this.tag ? this : oe();
      }
      getOrDie(oe) {
        if (this.tag)
          return this.value;
        throw new Error(oe ?? "Called getOrDie on None");
      }
      static from(oe) {
        return En(oe) ? Ht.some(oe) : Ht.none();
      }
      getOrNull() {
        return this.tag ? this.value : null;
      }
      getOrUndefined() {
        return this.value;
      }
      each(oe) {
        this.tag && oe(this.value);
      }
      toArray() {
        return this.tag ? [this.value] : [];
      }
      toString() {
        return this.tag ? `some(${this.value})` : "none()";
      }
    }
    Ht.singletonNone = new Ht(!1);
    const gn = Array.prototype.push, De = (j, oe) => {
      const Le = j.length, je = new Array(Le);
      for (let yn = 0; yn < Le; yn++) {
        const vo = j[yn];
        je[yn] = oe(vo, yn);
      }
      return je;
    }, re = (j, oe) => {
      for (let Le = 0, je = j.length; Le < je; Le++) {
        const yn = j[Le];
        oe(yn, Le);
      }
    }, ho = (j, oe) => {
      const Le = [];
      for (let je = 0, yn = j.length; je < yn; je++) {
        const vo = j[je];
        oe(vo, je) && Le.push(vo);
      }
      return Le;
    }, Te = (j, oe, Le) => {
      for (let je = 0, yn = j.length; je < yn; je++) {
        const vo = j[je];
        if (oe(vo, je))
          return Ht.some(vo);
        if (Le(vo, je))
          break;
      }
      return Ht.none();
    }, Oe = (j, oe) => Te(j, oe, U), A = (j) => {
      const oe = [];
      for (let Le = 0, je = j.length; Le < je; ++Le) {
        if (!dn(j[Le]))
          throw new Error("Arr.flatten item " + Le + " was not an array, input: " + j);
        gn.apply(oe, j[Le]);
      }
      return oe;
    }, mn = (j, oe) => A(De(j, oe)), it = (j, oe) => oe >= 0 && oe < j.length ? Ht.some(j[oe]) : Ht.none(), Gn = (j) => it(j, 0), rn = (j, oe) => {
      for (let Le = 0; Le < j.length; Le++) {
        const je = oe(j[Le], Le);
        if (je.isSome())
          return je;
      }
      return Ht.none();
    }, Ye = (j, oe, Le) => j.isSome() && oe.isSome() ? Ht.some(Le(j.getOrDie(), oe.getOrDie())) : Ht.none(), io = (j) => {
      const oe = vt(Ht.none()), Le = () => oe.get().each(j);
      return {
        clear: () => {
          Le(), oe.set(Ht.none());
        },
        isSet: () => oe.get().isSome(),
        get: () => oe.get(),
        set: (Ka) => {
          Le(), oe.set(Ht.some(Ka));
        }
      };
    }, jo = () => io((j) => j.unbind()), bt = () => {
      const j = io(Kt);
      return {
        ...j,
        on: (Le) => j.get().each(Le)
      };
    }, kn = (j, oe) => {
      let Le = null;
      return {
        cancel: () => {
          Sn(Le) || (clearTimeout(Le), Le = null);
        },
        throttle: (...vo) => {
          Sn(Le) && (Le = setTimeout(() => {
            Le = null, j.apply(null, vo);
          }, oe));
        }
      };
    }, $e = Object.keys, ot = (j, oe) => {
      const Le = $e(j);
      for (let je = 0, yn = Le.length; je < yn; je++) {
        const vo = Le[je], Dr = j[vo];
        oe(Dr, vo);
      }
    }, F = typeof window < "u" ? window : Function("return this;")(), ss = (j, oe) => {
      let Le = oe ?? F;
      for (let je = 0; je < j.length && Le !== void 0 && Le !== null; ++je)
        Le = Le[j[je]];
      return Le;
    }, fo = (j, oe) => {
      const Le = j.split(".");
      return ss(Le, oe);
    }, at = (j, oe) => fo(j, oe), lt = (j, oe) => {
      const Le = at(j, oe);
      if (Le == null)
        throw new Error(j + " not available on this browser");
      return Le;
    }, Rn = Object.getPrototypeOf, ee = (j) => lt("HTMLElement", j), pe = (j) => {
      const oe = fo("ownerDocument.defaultView", j);
      return fn(j) && (ee(oe).prototype.isPrototypeOf(j) || /^HTML\w*Element$/.test(Rn(j).constructor.name));
    }, ye = 9, ae = 11, kt = 1, Vn = 3, Yt = (j) => j.dom.nodeType, Ct = (j) => (oe) => Yt(oe) === j, Xe = (j) => In(j) && pe(j.dom), In = Ct(kt), hn = Ct(Vn), Xn = Ct(ye), Xo = Ct(ae), ds = (j, oe, Le) => {
      if (Bt(Le) || Ft(Le) || Pn(Le))
        j.setAttribute(oe, Le + "");
      else
        throw new Error("Attribute value was not simple");
    }, No = (j, oe, Le) => {
      ds(j.dom, oe, Le);
    }, Ao = (j, oe) => {
      const Le = j.dom.getAttribute(oe);
      return Le === null ? void 0 : Le;
    }, Cs = (j, oe) => {
      j.dom.removeAttribute(oe);
    }, Ie = (j) => j.dom.classList !== void 0, et = (j, oe) => Ie(j) && j.dom.classList.contains(oe), nn = (j, oe, Le = 0, je) => {
      const yn = j.indexOf(oe, Le);
      return yn !== -1 ? Zt(je) ? !0 : yn + oe.length <= je : !1;
    }, qt = (j) => j.style !== void 0 && st(j.style.getPropertyValue), ko = (j, oe) => {
      const je = (oe || document).createElement("div");
      if (je.innerHTML = j, !je.hasChildNodes() || je.childNodes.length > 1) {
        const yn = "HTML does not have a single root node";
        throw new Error(yn);
      }
      return Yr(je.childNodes[0]);
    }, rs = (j, oe) => {
      const je = (oe || document).createElement(j);
      return Yr(je);
    }, Gs = (j, oe) => {
      const je = (oe || document).createTextNode(j);
      return Yr(je);
    }, Yr = (j) => {
      if (j == null)
        throw new Error("Node cannot be null or undefined");
      return { dom: j };
    }, or = {
      fromHtml: ko,
      fromTag: rs,
      fromText: Gs,
      fromDom: Yr,
      fromPoint: (j, oe, Le) => Ht.from(j.dom.elementFromPoint(oe, Le)).map(Yr)
    }, Dt = (j, oe) => {
      const Le = j.dom;
      if (Le.nodeType !== kt)
        return !1;
      {
        const je = Le;
        if (je.matches !== void 0)
          return je.matches(oe);
        if (je.msMatchesSelector !== void 0)
          return je.msMatchesSelector(oe);
        if (je.webkitMatchesSelector !== void 0)
          return je.webkitMatchesSelector(oe);
        if (je.mozMatchesSelector !== void 0)
          return je.mozMatchesSelector(oe);
        throw new Error("Browser lacks native selectors");
      }
    }, Lo = (j) => j.nodeType !== kt && j.nodeType !== ye && j.nodeType !== ae || j.childElementCount === 0, Or = (j, oe) => {
      const Le = document;
      return Lo(Le) ? [] : De(Le.querySelectorAll(j), or.fromDom);
    }, aa = (j, oe) => j.dom === oe.dom, Xr = (j) => or.fromDom(j.dom.ownerDocument), Jr = (j) => Xn(j) ? j : Xr(j), xs = (j) => Ht.from(j.dom.parentNode).map(or.fromDom), fa = (j, oe) => {
      const Le = st(oe) ? oe : U;
      let je = j.dom;
      const yn = [];
      for (; je.parentNode !== null && je.parentNode !== void 0; ) {
        const vo = je.parentNode, Dr = or.fromDom(vo);
        if (yn.push(Dr), Le(Dr) === !0)
          break;
        je = vo;
      }
      return yn;
    }, Qr = (j) => {
      const oe = (Le) => ho(Le, (je) => !aa(j, je));
      return xs(j).map(Zn).map(oe).getOr([]);
    }, Ts = (j) => Ht.from(j.dom.nextSibling).map(or.fromDom), Zn = (j) => De(j.dom.childNodes, or.fromDom), dr = (j) => Xo(j) && En(j.dom.host), ga = st(Element.prototype.attachShadow) && st(Node.prototype.getRootNode), Za = xo(ga), _c = ga ? (j) => or.fromDom(j.dom.getRootNode()) : Jr, sr = (j) => {
      const oe = _c(j);
      return dr(oe) ? Ht.some(oe) : Ht.none();
    }, Ks = (j) => or.fromDom(j.dom.host), Vs = (j) => {
      if (Za() && En(j.target)) {
        const oe = or.fromDom(j.target);
        if (In(oe) && Sa(oe) && j.composed && j.composedPath) {
          const Le = j.composedPath();
          if (Le)
            return Gn(Le);
        }
      }
      return Ht.from(j.target);
    }, Sa = (j) => En(j.dom.shadowRoot), rc = (j) => {
      const oe = hn(j) ? j.dom.parentNode : j.dom;
      if (oe == null || oe.ownerDocument === null)
        return !1;
      const Le = oe.ownerDocument;
      return sr(or.fromDom(oe)).fold(() => Le.body.contains(oe), Qe(rc, Ks));
    }, wr = (j) => {
      const oe = j.dom.body;
      if (oe == null)
        throw new Error("Body is not available yet");
      return or.fromDom(oe);
    }, de = (j, oe, Le) => {
      if (!Bt(Le))
        throw new Error("CSS value must be a string: " + Le);
      qt(j) && j.style.setProperty(oe, Le);
    }, ie = (j, oe, Le) => {
      const je = j.dom;
      de(je, oe, Le);
    }, ze = (j, oe) => {
      const Le = j.dom;
      ot(oe, (je, yn) => {
        de(Le, yn, je);
      });
    }, Je = (j, oe) => {
      const Le = j.dom, yn = window.getComputedStyle(Le).getPropertyValue(oe);
      return yn === "" && !rc(j) ? Nn(Le, oe) : yn;
    }, Nn = (j, oe) => qt(j) ? j.style.getPropertyValue(oe) : "", Wn = (j, oe, Le, je, yn, vo, Dr) => ({
      target: j,
      x: oe,
      y: Le,
      stop: je,
      prevent: yn,
      kill: vo,
      raw: Dr
    }), _o = (j) => {
      const oe = or.fromDom(Vs(j).getOr(j.target)), Le = () => j.stopPropagation(), je = () => j.preventDefault(), yn = J(je, Le);
      return Wn(oe, j.clientX, j.clientY, Le, je, yn, j);
    }, Fs = (j, oe) => (Le) => {
      j(Le) && oe(_o(Le));
    }, ve = (j, oe, Le, je, yn) => {
      const vo = Fs(Le, je);
      return j.dom.addEventListener(oe, vo, yn), { unbind: ht(ue, j, oe, vo, yn) };
    }, go = (j, oe, Le, je) => ve(j, oe, Le, je, !1), ue = (j, oe, Le, je) => {
      j.dom.removeEventListener(oe, Le, je);
    }, he = Tt, dt = (j, oe, Le) => go(j, oe, he, Le), wt = (j) => {
      let oe = !1, Le;
      return (...je) => (oe || (oe = !0, Le = j.apply(null, je)), Le);
    }, on = (j, oe, Le, je) => {
      const yn = j.isiOS() && /ipad/i.test(Le) === !0, vo = j.isiOS() && !yn, Dr = j.isiOS() || j.isAndroid(), Ka = Dr || je("(pointer:coarse)"), pr = yn || !vo && Dr && je("(min-device-width:768px)"), cc = vo || Dr && !pr, ks = oe.isSafari() && j.isiOS() && /safari/i.test(Le) === !1, Br = !cc && !pr && !ks;
      return {
        isiPad: xo(yn),
        isiPhone: xo(vo),
        isTablet: xo(pr),
        isPhone: xo(cc),
        isTouch: xo(Ka),
        isAndroid: j.isAndroid,
        isiOS: j.isiOS,
        isWebView: xo(ks),
        isDesktop: xo(Br)
      };
    }, Ln = (j, oe) => {
      for (let Le = 0; Le < j.length; Le++) {
        const je = j[Le];
        if (je.test(oe))
          return je;
      }
    }, On = (j, oe) => {
      const Le = Ln(j, oe);
      if (!Le)
        return {
          major: 0,
          minor: 0
        };
      const je = (yn) => Number(oe.replace(Le, "$" + yn));
      return Kn(je(1), je(2));
    }, Dn = (j, oe) => {
      const Le = String(oe).toLowerCase();
      return j.length === 0 ? Mn() : On(j, Le);
    }, Mn = () => Kn(0, 0), Kn = (j, oe) => ({
      major: j,
      minor: oe
    }), zo = {
      nu: Kn,
      detect: Dn,
      unknown: Mn
    }, Ds = (j, oe) => rn(oe.brands, (Le) => {
      const je = Le.brand.toLowerCase();
      return Oe(j, (yn) => {
        var vo;
        return je === ((vo = yn.brand) === null || vo === void 0 ? void 0 : vo.toLowerCase());
      }).map((yn) => ({
        current: yn.name,
        version: zo.nu(parseInt(Le.version, 10), 0)
      }));
    }), Ra = (j, oe) => {
      const Le = String(oe).toLowerCase();
      return Oe(j, (je) => je.search(Le));
    }, ac = (j, oe) => Ra(j, oe).map((Le) => {
      const je = zo.detect(Le.versionRegexes, oe);
      return {
        current: Le.name,
        version: je
      };
    }), vc = (j, oe) => Ra(j, oe).map((Le) => {
      const je = zo.detect(Le.versionRegexes, oe);
      return {
        current: Le.name,
        version: je
      };
    }), lo = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/, Fo = (j) => (oe) => nn(oe, j), ms = [
      {
        name: "Edge",
        versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
        search: (j) => nn(j, "edge/") && nn(j, "chrome") && nn(j, "safari") && nn(j, "applewebkit")
      },
      {
        name: "Chromium",
        brand: "Chromium",
        versionRegexes: [
          /.*?chrome\/([0-9]+)\.([0-9]+).*/,
          lo
        ],
        search: (j) => nn(j, "chrome") && !nn(j, "chromeframe")
      },
      {
        name: "IE",
        versionRegexes: [
          /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
          /.*?rv:([0-9]+)\.([0-9]+).*/
        ],
        search: (j) => nn(j, "msie") || nn(j, "trident")
      },
      {
        name: "Opera",
        versionRegexes: [
          lo,
          /.*?opera\/([0-9]+)\.([0-9]+).*/
        ],
        search: Fo("opera")
      },
      {
        name: "Firefox",
        versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
        search: Fo("firefox")
      },
      {
        name: "Safari",
        versionRegexes: [
          lo,
          /.*?cpu os ([0-9]+)_([0-9]+).*/
        ],
        search: (j) => (nn(j, "safari") || nn(j, "mobile/")) && nn(j, "applewebkit")
      }
    ], xa = [
      {
        name: "Windows",
        search: Fo("win"),
        versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: "iOS",
        search: (j) => nn(j, "iphone") || nn(j, "ipad"),
        versionRegexes: [
          /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
          /.*cpu os ([0-9]+)_([0-9]+).*/,
          /.*cpu iphone os ([0-9]+)_([0-9]+).*/
        ]
      },
      {
        name: "Android",
        search: Fo("android"),
        versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: "macOS",
        search: Fo("mac os x"),
        versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
      },
      {
        name: "Linux",
        search: Fo("linux"),
        versionRegexes: []
      },
      {
        name: "Solaris",
        search: Fo("sunos"),
        versionRegexes: []
      },
      {
        name: "FreeBSD",
        search: Fo("freebsd"),
        versionRegexes: []
      },
      {
        name: "ChromeOS",
        search: Fo("cros"),
        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
      }
    ], zr = {
      browsers: xo(ms),
      oses: xo(xa)
    }, mr = "Edge", Hs = "Chromium", Fa = "IE", nl = "Opera", Rs = "Firefox", ca = "Safari", Ia = () => Pr({
      current: void 0,
      version: zo.unknown()
    }), Pr = (j) => {
      const oe = j.current, Le = j.version, je = (yn) => () => oe === yn;
      return {
        current: oe,
        version: Le,
        isEdge: je(mr),
        isChromium: je(Hs),
        isIE: je(Fa),
        isOpera: je(nl),
        isFirefox: je(Rs),
        isSafari: je(ca)
      };
    }, yc = {
      unknown: Ia,
      nu: Pr
    }, Uc = "Windows", Ta = "iOS", Ac = "Android", Oc = "Linux", vu = "macOS", Dc = "Solaris", yl = "FreeBSD", ja = "ChromeOS", wi = () => Bi({
      current: void 0,
      version: zo.unknown()
    }), Bi = (j) => {
      const oe = j.current, Le = j.version, je = (yn) => () => oe === yn;
      return {
        current: oe,
        version: Le,
        isWindows: je(Uc),
        isiOS: je(Ta),
        isAndroid: je(Ac),
        isMacOS: je(vu),
        isLinux: je(Oc),
        isSolaris: je(Dc),
        isFreeBSD: je(yl),
        isChromeOS: je(ja)
      };
    }, Cl = {
      unknown: wi,
      nu: Bi
    }, Z = { detect: (j, oe, Le) => {
      const je = zr.browsers(), yn = zr.oses(), vo = oe.bind((pr) => Ds(je, pr)).orThunk(() => ac(je, j)).fold(yc.unknown, yc.nu), Dr = vc(yn, j).fold(Cl.unknown, Cl.nu), Ka = on(Dr, vo, j, Le);
      return {
        browser: vo,
        os: Dr,
        deviceType: Ka
      };
    } }, fe = (j) => window.matchMedia(j).matches;
    let _e = wt(() => Z.detect(navigator.userAgent, Ht.from(navigator.userAgentData), fe));
    const Ve = () => _e(), Rt = (j, oe) => ({
      left: j,
      top: oe,
      translate: (je, yn) => Rt(j + je, oe + yn)
    }), eo = Rt, Ns = (j) => {
      const oe = j !== void 0 ? j.dom : document, Le = oe.body.scrollLeft || oe.documentElement.scrollLeft, je = oe.body.scrollTop || oe.documentElement.scrollTop;
      return eo(Le, je);
    }, Is = (j) => {
      const oe = j === void 0 ? window : j;
      return Ve().browser.isFirefox() ? Ht.none() : Ht.from(oe.visualViewport);
    }, Os = (j, oe, Le, je) => ({
      x: j,
      y: oe,
      width: Le,
      height: je,
      right: j + Le,
      bottom: oe + je
    }), Ys = (j) => {
      const oe = j === void 0 ? window : j, Le = oe.document, je = Ns(or.fromDom(Le));
      return Is(oe).fold(() => {
        const yn = oe.document.documentElement, vo = yn.clientWidth, Dr = yn.clientHeight;
        return Os(je.left, je.top, vo, Dr);
      }, (yn) => Os(Math.max(yn.pageLeft, je.left), Math.max(yn.pageTop, je.top), yn.width, yn.height));
    }, qo = (j, oe, Le) => Is(Le).map((je) => {
      const yn = (vo) => oe(_o(vo));
      return je.addEventListener(j, yn), { unbind: () => je.removeEventListener(j, yn) };
    }).getOrThunk(() => ({ unbind: Kt }));
    var fr = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils"), Na = tinymce.util.Tools.resolve("tinymce.Env");
    const ol = (j, oe) => {
      j.dispatch("FullscreenStateChanged", { state: oe }), j.dispatch("ResizeEditor");
    }, sn = (j) => (oe) => oe.options.get(j), Ql = (j) => {
      const oe = j.options.register;
      oe("fullscreen_native", {
        processor: "boolean",
        default: !1
      });
    }, rr = sn("fullscreen_native"), B = (j) => {
      const oe = or.fromDom(j.getElement());
      return sr(oe).map(Ks).getOrThunk(() => wr(Xr(oe)));
    }, K = (j) => j.fullscreenElement !== void 0 ? j.fullscreenElement : j.msFullscreenElement !== void 0 ? j.msFullscreenElement : j.webkitFullscreenElement !== void 0 ? j.webkitFullscreenElement : null, se = () => document.fullscreenElement !== void 0 ? "fullscreenchange" : document.msFullscreenElement !== void 0 ? "MSFullscreenChange" : document.webkitFullscreenElement !== void 0 ? "webkitfullscreenchange" : "fullscreenchange", Ue = (j) => {
      const oe = j.dom;
      oe.requestFullscreen ? oe.requestFullscreen() : oe.msRequestFullscreen ? oe.msRequestFullscreen() : oe.webkitRequestFullScreen && oe.webkitRequestFullScreen();
    }, en = (j) => {
      const oe = j.dom;
      oe.exitFullscreen ? oe.exitFullscreen() : oe.msExitFullscreen ? oe.msExitFullscreen() : oe.webkitCancelFullScreen && oe.webkitCancelFullScreen();
    }, Io = (j) => j.dom === K(Xr(j).dom), _n = (j, oe, Le) => ho(fa(j, Le), oe), gr = (j, oe) => ho(Qr(j), oe), _t = (j) => Or(j), Us = (j, oe, Le) => _n(j, (je) => Dt(je, oe), Le), qa = (j, oe) => gr(j, (Le) => Dt(Le, oe)), Xs = "data-ephox-mobile-fullscreen-style", Zr = "display:none!important;", ri = "position:absolute!important;", Jo = "top:0!important;left:0!important;margin:0!important;padding:0!important;width:100%!important;height:100%!important;overflow:visible!important;", Ga = "background-color:rgb(255,255,255)!important;", ar = Na.os.isAndroid(), $i = (j) => {
      const oe = Je(j, "background-color");
      return oe !== void 0 && oe !== "" ? "background-color:" + oe + "!important" : Ga;
    }, hr = (j, oe, Le) => {
      const je = (cc) => qa(cc, "*:not(.tox-silver-sink)"), yn = (cc) => (ks) => {
        const Br = Ao(ks, "style"), ia = Br === void 0 ? "no-styles" : Br.trim();
        ia !== cc && (No(ks, Xs, ia), ze(ks, j.parseStyle(cc)));
      }, vo = Us(oe, "*"), Dr = mn(vo, je), Ka = $i(Le);
      re(Dr, yn(Zr)), re(vo, yn(ri + Jo + Ka)), yn((ar === !0 ? "" : ri) + Jo + Ka)(oe);
    }, yu = (j) => {
      const oe = _t("[" + Xs + "]");
      re(oe, (Le) => {
        const je = Ao(Le, Xs);
        je && je !== "no-styles" ? ze(Le, j.parseStyle(je)) : Cs(Le, "style"), Cs(Le, Xs);
      });
    }, um = fr.DOM, Xm = () => Ys(window), Es = (j) => window.scrollTo(j.x, j.y), ai = Is().fold(() => ({
      bind: Kt,
      unbind: Kt
    }), (j) => {
      const oe = bt(), Le = jo(), je = jo(), yn = () => {
        document.body.scrollTop = 0, document.documentElement.scrollTop = 0;
      }, vo = () => {
        window.requestAnimationFrame(() => {
          oe.on((cc) => ze(cc, {
            top: j.offsetTop + "px",
            left: j.offsetLeft + "px",
            height: j.height + "px",
            width: j.width + "px"
          }));
        });
      }, Dr = kn(() => {
        yn(), vo();
      }, 50);
      return {
        bind: (cc) => {
          oe.set(cc), Dr.throttle(), Le.set(qo("resize", Dr.throttle)), je.set(qo("scroll", Dr.throttle));
        },
        unbind: () => {
          oe.on(() => {
            Le.clear(), je.clear();
          }), oe.clear();
        }
      };
    }), Fi = (j, oe) => {
      const Le = document.body, je = document.documentElement, yn = j.getContainer(), vo = or.fromDom(yn), Dr = Ts(vo).filter((Vr) => Xe(Vr) && et(Vr, "tox-silver-sink")), Ka = B(j), pr = oe.get(), cc = or.fromDom(j.getBody()), ks = Na.deviceType.isTouch(), Br = yn.style, ia = j.iframeElement, wc = ia?.style, ea = (Vr) => {
        Vr(Le, "tox-fullscreen"), Vr(je, "tox-fullscreen"), Vr(yn, "tox-fullscreen"), sr(vo).map((Nc) => Ks(Nc).dom).each((Nc) => {
          Vr(Nc, "tox-fullscreen"), Vr(Nc, "tox-shadowhost");
        });
      }, _r = () => {
        ks && yu(j.dom), ea(um.removeClass), ai.unbind(), Ht.from(oe.get()).each((Vr) => Vr.fullscreenChangeHandler.unbind());
      };
      if (pr)
        pr.fullscreenChangeHandler.unbind(), rr(j) && Io(Ka) && en(Xr(Ka)), wc.width = pr.iframeWidth, wc.height = pr.iframeHeight, Br.width = pr.containerWidth, Br.height = pr.containerHeight, Br.top = pr.containerTop, Br.left = pr.containerLeft, Ye(Dr, pr.sinkCssPosition, (Vr, Nc) => {
          ie(Vr, "position", Nc);
        }), _r(), Es(pr.scrollPos), oe.set(null), ol(j, !1), j.off("remove", _r);
      else {
        const Vr = dt(Xr(Ka), se(), (Ii) => {
          rr(j) && !Io(Ka) && oe.get() !== null && Fi(j, oe);
        }), Nc = {
          scrollPos: Xm(),
          containerWidth: Br.width,
          containerHeight: Br.height,
          containerTop: Br.top,
          containerLeft: Br.left,
          iframeWidth: wc.width,
          iframeHeight: wc.height,
          fullscreenChangeHandler: Vr,
          sinkCssPosition: Dr.map((Ii) => Je(Ii, "position"))
        };
        ks && hr(j.dom, vo, cc), wc.width = wc.height = "100%", Br.width = Br.height = "", ea(um.addClass), Dr.each((Ii) => {
          ie(Ii, "position", "fixed");
        }), ai.bind(vo), j.on("remove", _r), oe.set(Nc), rr(j) && Ue(Ka), ol(j, !0);
      }
    }, Cc = (j, oe) => {
      j.addCommand("mceFullScreen", () => {
        Fi(j, oe);
      });
    }, Rc = (j, oe) => (Le) => {
      Le.setActive(oe.get() !== null);
      const je = (yn) => Le.setActive(yn.state);
      return j.on("FullscreenStateChanged", je), () => j.off("FullscreenStateChanged", je);
    }, Qu = (j, oe) => {
      const Le = () => j.execCommand("mceFullScreen");
      j.ui.registry.addToggleMenuItem("fullscreen", {
        text: "Fullscreen",
        icon: "fullscreen",
        shortcut: "Meta+Shift+F",
        onAction: Le,
        onSetup: Rc(j, oe)
      }), j.ui.registry.addToggleButton("fullscreen", {
        tooltip: "Fullscreen",
        icon: "fullscreen",
        onAction: Le,
        onSetup: Rc(j, oe)
      });
    };
    var Qo = () => {
      Ot.add("fullscreen", (j) => {
        const oe = vt(null);
        return j.inline || (Ql(j), Cc(j, oe), Qu(j, oe), j.addShortcut("Meta+Shift+F", "", "mceFullScreen")), Pt(oe);
      });
    };
    Qo();
  })()), WG;
}
var jG;
function QY() {
  return jG || (jG = 1, JY()), UG;
}
QY();
var qG = {}, GG = {}, KG;
function eX() {
  return KG || (KG = 1, (function() {
    const vt = (Ct) => {
      let Xe = Ct;
      return {
        get: () => Xe,
        set: (Xn) => {
          Xe = Xn;
        }
      };
    };
    var Ot = tinymce.util.Tools.resolve("tinymce.PluginManager");
    let Pt = 0;
    const yt = (Ct) => {
      const In = (/* @__PURE__ */ new Date()).getTime(), hn = Math.floor(Math.random() * 1e9);
      return Pt++, Ct + "_" + hn + Pt + String(In);
    }, Nt = (Ct) => ({ addTab: (In) => {
      var hn;
      const Xn = (hn = In.name) !== null && hn !== void 0 ? hn : yt("tab-name"), Xo = Ct.get();
      Xo[Xn] = In, Ct.set(Xo);
    } }), Wt = (Ct, Xe) => {
      Ct.addCommand("mceHelp", Xe);
    }, Fe = (Ct) => (Xe) => Xe.options.get(Ct), Ee = (Ct) => {
      const Xe = Ct.options.register;
      Xe("help_tabs", { processor: "array" });
    }, Bt = Fe("help_tabs"), fn = Fe("forced_plugins"), dn = (Ct, Xe) => {
      Ct.ui.registry.addButton("help", {
        icon: "help",
        tooltip: "Help",
        onAction: Xe
      }), Ct.ui.registry.addMenuItem("help", {
        text: "Help",
        icon: "help",
        shortcut: "Alt+0",
        onAction: Xe
      });
    }, Sn = (Ct, Xe, In) => {
      var hn;
      return In(Ct, Xe.prototype) ? !0 : ((hn = Ct.constructor) === null || hn === void 0 ? void 0 : hn.name) === Xe.name;
    }, Ft = (Ct) => {
      const Xe = typeof Ct;
      return Ct === null ? "null" : Xe === "object" && Array.isArray(Ct) ? "array" : Xe === "object" && Sn(Ct, String, (In, hn) => hn.isPrototypeOf(In)) ? "string" : Xe;
    }, Zt = (Ct) => (Xe) => Ft(Xe) === Ct, Qt = (Ct) => (Xe) => typeof Xe === Ct, En = (Ct) => (Xe) => Ct === Xe, st = Zt("string"), Pn = En(void 0), Kt = (Ct) => Ct == null, J = (Ct) => !Kt(Ct), Qe = Qt("function"), ht = ((Ct) => () => Ct)(!1);
    class U {
      constructor(Xe, In) {
        this.tag = Xe, this.value = In;
      }
      static some(Xe) {
        return new U(!0, Xe);
      }
      static none() {
        return U.singletonNone;
      }
      fold(Xe, In) {
        return this.tag ? In(this.value) : Xe();
      }
      isSome() {
        return this.tag;
      }
      isNone() {
        return !this.tag;
      }
      map(Xe) {
        return this.tag ? U.some(Xe(this.value)) : U.none();
      }
      bind(Xe) {
        return this.tag ? Xe(this.value) : U.none();
      }
      exists(Xe) {
        return this.tag && Xe(this.value);
      }
      forall(Xe) {
        return !this.tag || Xe(this.value);
      }
      filter(Xe) {
        return !this.tag || Xe(this.value) ? this : U.none();
      }
      getOr(Xe) {
        return this.tag ? this.value : Xe;
      }
      or(Xe) {
        return this.tag ? this : Xe;
      }
      getOrThunk(Xe) {
        return this.tag ? this.value : Xe();
      }
      orThunk(Xe) {
        return this.tag ? this : Xe();
      }
      getOrDie(Xe) {
        if (this.tag)
          return this.value;
        throw new Error(Xe ?? "Called getOrDie on None");
      }
      static from(Xe) {
        return J(Xe) ? U.some(Xe) : U.none();
      }
      getOrNull() {
        return this.tag ? this.value : null;
      }
      getOrUndefined() {
        return this.value;
      }
      each(Xe) {
        this.tag && Xe(this.value);
      }
      toArray() {
        return this.tag ? [this.value] : [];
      }
      toString() {
        return this.tag ? `some(${this.value})` : "none()";
      }
    }
    U.singletonNone = new U(!1);
    const Tt = Array.prototype.slice, Ht = Array.prototype.indexOf, gn = (Ct, Xe) => Ht.call(Ct, Xe), De = (Ct, Xe) => gn(Ct, Xe) > -1, re = (Ct, Xe) => {
      const In = Ct.length, hn = new Array(In);
      for (let Xn = 0; Xn < In; Xn++) {
        const Xo = Ct[Xn];
        hn[Xn] = Xe(Xo, Xn);
      }
      return hn;
    }, ho = (Ct, Xe) => {
      const In = [];
      for (let hn = 0, Xn = Ct.length; hn < Xn; hn++) {
        const Xo = Ct[hn];
        Xe(Xo, hn) && In.push(Xo);
      }
      return In;
    }, Te = (Ct, Xe, In) => {
      for (let hn = 0, Xn = Ct.length; hn < Xn; hn++) {
        const Xo = Ct[hn];
        if (Xe(Xo, hn))
          return U.some(Xo);
        if (In(Xo, hn))
          break;
      }
      return U.none();
    }, Oe = (Ct, Xe) => Te(Ct, Xe, ht), A = (Ct, Xe) => {
      const In = Tt.call(Ct, 0);
      return In.sort(Xe), In;
    }, mn = Object.keys, it = Object.hasOwnProperty, Gn = (Ct, Xe) => rn(Ct, Xe) ? U.from(Ct[Xe]) : U.none(), rn = (Ct, Xe) => it.call(Ct, Xe), Ye = (Ct) => {
      const Xe = [], In = (hn) => {
        Xe.push(hn);
      };
      for (let hn = 0; hn < Ct.length; hn++)
        Ct[hn].each(In);
      return Xe;
    };
    var io = tinymce.util.Tools.resolve("tinymce.Resource"), jo = tinymce.util.Tools.resolve("tinymce.util.I18n");
    const bt = (Ct, Xe) => io.load(`tinymce.html-i18n.help-keynav.${Xe}`, `${Ct}/js/i18n/keynav/${Xe}.js`), kn = (Ct) => bt(Ct, jo.getCode()).catch(() => bt(Ct, "en")), $e = (Ct, Xe) => {
      Ct.on("init", () => {
        kn(Xe);
      });
    }, ot = async (Ct) => ({
      name: "keyboardnav",
      title: "Keyboard Navigation",
      items: [{
        type: "htmlpanel",
        presets: "document",
        html: await kn(Ct)
      }]
    });
    var F = tinymce.util.Tools.resolve("tinymce.Env");
    const ss = (Ct) => {
      const Xe = F.os.isMacOS() || F.os.isiOS(), Xn = Xe ? {
        alt: "&#x2325;",
        ctrl: "&#x2303;",
        shift: "&#x21E7;",
        meta: "&#x2318;",
        access: "&#x2303;&#x2325;"
      } : {
        meta: "Ctrl ",
        access: "Shift + Alt "
      }, Xo = Ct.split("+"), ds = re(Xo, (No) => {
        const Ao = No.toLowerCase().trim();
        return rn(Xn, Ao) ? Xn[Ao] : No;
      });
      return Xe ? ds.join("").replace(/\s/, "") : ds.join("+");
    }, fo = [
      {
        shortcuts: ["Meta + B"],
        action: "Bold"
      },
      {
        shortcuts: ["Meta + I"],
        action: "Italic"
      },
      {
        shortcuts: ["Meta + U"],
        action: "Underline"
      },
      {
        shortcuts: ["Meta + A"],
        action: "Select all"
      },
      {
        shortcuts: [
          "Meta + Y",
          "Meta + Shift + Z"
        ],
        action: "Redo"
      },
      {
        shortcuts: ["Meta + Z"],
        action: "Undo"
      },
      {
        shortcuts: ["Access + 1"],
        action: "Heading 1"
      },
      {
        shortcuts: ["Access + 2"],
        action: "Heading 2"
      },
      {
        shortcuts: ["Access + 3"],
        action: "Heading 3"
      },
      {
        shortcuts: ["Access + 4"],
        action: "Heading 4"
      },
      {
        shortcuts: ["Access + 5"],
        action: "Heading 5"
      },
      {
        shortcuts: ["Access + 6"],
        action: "Heading 6"
      },
      {
        shortcuts: ["Access + 7"],
        action: "Paragraph"
      },
      {
        shortcuts: ["Access + 8"],
        action: "Div"
      },
      {
        shortcuts: ["Access + 9"],
        action: "Address"
      },
      {
        shortcuts: ["Alt + 0"],
        action: "Open help dialog"
      },
      {
        shortcuts: ["Alt + F9"],
        action: "Focus to menubar"
      },
      {
        shortcuts: ["Alt + F10"],
        action: "Focus to toolbar"
      },
      {
        shortcuts: ["Alt + F11"],
        action: "Focus to element path"
      },
      {
        shortcuts: ["Ctrl + F9"],
        action: "Focus to contextual toolbar"
      },
      {
        shortcuts: ["Shift + Enter"],
        action: "Open popup menu for split buttons"
      },
      {
        shortcuts: ["Meta + K"],
        action: "Insert link (if link plugin activated)"
      },
      {
        shortcuts: ["Meta + S"],
        action: "Save (if save plugin activated)"
      },
      {
        shortcuts: ["Meta + F"],
        action: "Find (if searchreplace plugin activated)"
      },
      {
        shortcuts: ["Meta + Shift + F"],
        action: "Switch to or from fullscreen mode"
      }
    ], at = () => {
      const Ct = re(fo, (In) => {
        const hn = re(In.shortcuts, ss).join(" or ");
        return [
          In.action,
          hn
        ];
      });
      return {
        name: "shortcuts",
        title: "Handy Shortcuts",
        items: [{
          type: "table",
          header: [
            "Action",
            "Shortcut"
          ],
          cells: Ct
        }]
      };
    }, lt = re([
      {
        key: "accordion",
        name: "Accordion"
      },
      {
        key: "advlist",
        name: "Advanced List"
      },
      {
        key: "anchor",
        name: "Anchor"
      },
      {
        key: "autolink",
        name: "Autolink"
      },
      {
        key: "autoresize",
        name: "Autoresize"
      },
      {
        key: "autosave",
        name: "Autosave"
      },
      {
        key: "charmap",
        name: "Character Map"
      },
      {
        key: "code",
        name: "Code"
      },
      {
        key: "codesample",
        name: "Code Sample"
      },
      {
        key: "colorpicker",
        name: "Color Picker"
      },
      {
        key: "directionality",
        name: "Directionality"
      },
      {
        key: "emoticons",
        name: "Emoticons"
      },
      {
        key: "fullscreen",
        name: "Full Screen"
      },
      {
        key: "help",
        name: "Help"
      },
      {
        key: "image",
        name: "Image"
      },
      {
        key: "importcss",
        name: "Import CSS"
      },
      {
        key: "insertdatetime",
        name: "Insert Date/Time"
      },
      {
        key: "link",
        name: "Link"
      },
      {
        key: "lists",
        name: "Lists"
      },
      {
        key: "media",
        name: "Media"
      },
      {
        key: "nonbreaking",
        name: "Nonbreaking"
      },
      {
        key: "pagebreak",
        name: "Page Break"
      },
      {
        key: "preview",
        name: "Preview"
      },
      {
        key: "quickbars",
        name: "Quick Toolbars"
      },
      {
        key: "save",
        name: "Save"
      },
      {
        key: "searchreplace",
        name: "Search and Replace"
      },
      {
        key: "table",
        name: "Table"
      },
      {
        key: "template",
        name: "Template"
      },
      {
        key: "textcolor",
        name: "Text Color"
      },
      {
        key: "visualblocks",
        name: "Visual Blocks"
      },
      {
        key: "visualchars",
        name: "Visual Characters"
      },
      {
        key: "wordcount",
        name: "Word Count"
      },
      {
        key: "a11ychecker",
        name: "Accessibility Checker",
        type: "premium"
      },
      {
        key: "advcode",
        name: "Advanced Code Editor",
        type: "premium"
      },
      {
        key: "advtable",
        name: "Advanced Tables",
        type: "premium"
      },
      {
        key: "advtemplate",
        name: "Advanced Templates",
        type: "premium",
        slug: "advanced-templates"
      },
      {
        key: "ai",
        name: "AI Assistant",
        type: "premium"
      },
      {
        key: "casechange",
        name: "Case Change",
        type: "premium"
      },
      {
        key: "checklist",
        name: "Checklist",
        type: "premium"
      },
      {
        key: "editimage",
        name: "Enhanced Image Editing",
        type: "premium"
      },
      {
        key: "footnotes",
        name: "Footnotes",
        type: "premium"
      },
      {
        key: "typography",
        name: "Advanced Typography",
        type: "premium",
        slug: "advanced-typography"
      },
      {
        key: "mediaembed",
        name: "Enhanced Media Embed",
        type: "premium",
        slug: "introduction-to-mediaembed"
      },
      {
        key: "export",
        name: "Export",
        type: "premium"
      },
      {
        key: "formatpainter",
        name: "Format Painter",
        type: "premium"
      },
      {
        key: "inlinecss",
        name: "Inline CSS",
        type: "premium",
        slug: "inline-css"
      },
      {
        key: "linkchecker",
        name: "Link Checker",
        type: "premium"
      },
      {
        key: "mentions",
        name: "Mentions",
        type: "premium"
      },
      {
        key: "mergetags",
        name: "Merge Tags",
        type: "premium"
      },
      {
        key: "pageembed",
        name: "Page Embed",
        type: "premium"
      },
      {
        key: "permanentpen",
        name: "Permanent Pen",
        type: "premium"
      },
      {
        key: "powerpaste",
        name: "PowerPaste",
        type: "premium",
        slug: "introduction-to-powerpaste"
      },
      {
        key: "rtc",
        name: "Real-Time Collaboration",
        type: "premium",
        slug: "rtc-introduction"
      },
      {
        key: "tinymcespellchecker",
        name: "Spell Checker Pro",
        type: "premium",
        slug: "introduction-to-tiny-spellchecker"
      },
      {
        key: "autocorrect",
        name: "Spelling Autocorrect",
        type: "premium"
      },
      {
        key: "tableofcontents",
        name: "Table of Contents",
        type: "premium"
      },
      {
        key: "tinycomments",
        name: "Tiny Comments",
        type: "premium",
        slug: "introduction-to-tiny-comments"
      },
      {
        key: "tinydrive",
        name: "Tiny Drive",
        type: "premium",
        slug: "tinydrive-introduction"
      }
    ], (Ct) => ({
      ...Ct,
      type: Ct.type || "opensource",
      slug: Ct.slug || Ct.key
    })), Rn = (Ct) => {
      const Xe = () => {
        const Cs = ho(lt, ({ type: nn }) => nn === "premium"), Ie = A(re(Cs, (nn) => nn.name), (nn, qt) => nn.localeCompare(qt)), et = re(Ie, (nn) => `<li>${nn}</li>`).join("");
        return "<div><p><b>" + jo.translate("Premium plugins:") + "</b></p><ul>" + et + '<li class="tox-help__more-link" "><a href="https://www.tiny.cloud/pricing/?utm_campaign=help_dialog_plugin_tab&utm_source=tiny&utm_medium=referral&utm_term=read_more&utm_content=premium_plugin_heading" rel="noopener" target="_blank" data-alloy-tabstop="true" tabindex="-1">' + jo.translate("Learn more...") + "</a></li></ul></div>";
      }, In = (Cs) => `<a data-alloy-tabstop="true" tabindex="-1" href="${Cs.url}" target="_blank" rel="noopener">${Cs.name}</a>`, hn = (Cs, Ie) => {
        const et = Cs.plugins[Ie].getMetadata;
        if (Qe(et)) {
          const nn = et();
          return {
            name: nn.name,
            html: In(nn)
          };
        } else
          return {
            name: Ie,
            html: Ie
          };
      }, Xn = (Cs, Ie) => Oe(lt, (et) => et.key === Ie).fold(() => hn(Cs, Ie), (et) => {
        const nn = et.type === "premium" ? `${et.name}*` : et.name, qt = In({
          name: nn,
          url: `https://www.tiny.cloud/docs/tinymce/6/${et.slug}/`
        });
        return {
          name: nn,
          html: qt
        };
      }), Xo = (Cs) => {
        const Ie = mn(Cs.plugins), et = fn(Cs);
        return Pn(et) ? Ie : ho(Ie, (nn) => !De(et, nn));
      }, ds = (Cs) => {
        const Ie = Xo(Cs), et = A(re(Ie, (Gs) => Xn(Cs, Gs)), (Gs, Yr) => Gs.name.localeCompare(Yr.name)), nn = re(et, (Gs) => "<li>" + Gs.html + "</li>"), qt = nn.length, ko = nn.join("");
        return "<p><b>" + jo.translate([
          "Plugins installed ({0}):",
          qt
        ]) + "</b></p><ul>" + ko + "</ul>";
      };
      return {
        name: "plugins",
        title: "Plugins",
        items: [{
          type: "htmlpanel",
          presets: "document",
          html: [
            ((Cs) => Cs == null ? "" : "<div>" + ds(Cs) + "</div>")(Ct),
            Xe()
          ].join("")
        }]
      };
    };
    var ee = tinymce.util.Tools.resolve("tinymce.EditorManager");
    const pe = () => {
      const In = '<a data-alloy-tabstop="true" tabindex="-1" href="https://www.tiny.cloud/docs/tinymce/6/changelog/?utm_campaign=help_dialog_version_tab&utm_source=tiny&utm_medium=referral" rel="noopener" target="_blank">TinyMCE ' + ((Xn, Xo) => Xn.indexOf("@") === 0 ? "X.X.X" : Xn + "." + Xo)(ee.majorVersion, ee.minorVersion) + "</a>";
      return {
        name: "versions",
        title: "Version",
        items: [{
          type: "htmlpanel",
          html: "<p>" + jo.translate([
            "You are using {0}",
            In
          ]) + "</p>",
          presets: "document"
        }]
      };
    }, ye = (Ct, Xe) => {
      const In = {}, hn = re(Ct, (Xn) => {
        var Xo;
        if (st(Xn))
          return rn(Xe, Xn) && (In[Xn] = Xe[Xn]), Xn;
        {
          const ds = (Xo = Xn.name) !== null && Xo !== void 0 ? Xo : yt("tab-name");
          return In[ds] = Xn, ds;
        }
      });
      return {
        tabs: In,
        names: hn
      };
    }, ae = (Ct) => {
      const Xe = mn(Ct), In = Xe.indexOf("versions");
      return In !== -1 && (Xe.splice(In, 1), Xe.push("versions")), {
        tabs: Ct,
        names: Xe
      };
    }, kt = async (Ct, Xe, In) => {
      const hn = at(), Xn = await ot(In), Xo = Rn(Ct), ds = pe(), No = {
        [hn.name]: hn,
        [Xn.name]: Xn,
        [Xo.name]: Xo,
        [ds.name]: ds,
        ...Xe.get()
      };
      return U.from(Bt(Ct)).fold(() => ae(No), (Ao) => ye(Ao, No));
    }, Vn = (Ct, Xe, In) => () => {
      kt(Ct, Xe, In).then(({ tabs: hn, names: Xn }) => {
        const Xo = re(Xn, (Ao) => Gn(hn, Ao)), No = {
          type: "tabpanel",
          tabs: Ye(Xo)
        };
        Ct.windowManager.open({
          title: "Help",
          size: "medium",
          body: No,
          buttons: [{
            type: "cancel",
            name: "close",
            text: "Close",
            primary: !0
          }],
          initialData: {}
        });
      });
    };
    var Yt = () => {
      Ot.add("help", (Ct, Xe) => {
        const In = vt({}), hn = Nt(In);
        Ee(Ct);
        const Xn = Vn(Ct, In, Xe);
        return dn(Ct, Xn), Wt(Ct, Xn), Ct.shortcuts.add("Alt+0", "Open help dialog", "mceHelp"), $e(Ct, Xe), hn;
      });
    };
    Yt();
  })()), GG;
}
var YG;
function tX() {
  return YG || (YG = 1, eX()), qG;
}
tX();
var XG = {}, JG = {}, QG;
function nX() {
  return QG || (QG = 1, (function() {
    var vt = tinymce.util.Tools.resolve("tinymce.PluginManager");
    const Ot = Object.getPrototypeOf, Pt = (B, K, se) => {
      var Ue;
      return se(B, K.prototype) ? !0 : ((Ue = B.constructor) === null || Ue === void 0 ? void 0 : Ue.name) === K.name;
    }, yt = (B) => {
      const K = typeof B;
      return B === null ? "null" : K === "object" && Array.isArray(B) ? "array" : K === "object" && Pt(B, String, (se, Ue) => Ue.isPrototypeOf(se)) ? "string" : K;
    }, Nt = (B) => (K) => yt(K) === B, Wt = (B) => (K) => typeof K === B, Fe = (B) => (K) => B === K, Ee = (B, K) => fn(B) && Pt(B, K, (se, Ue) => Ot(se) === Ue), Bt = Nt("string"), fn = Nt("object"), dn = (B) => Ee(B, Object), Sn = Nt("array"), Ft = Fe(null), Zt = Wt("boolean"), Qt = (B) => B == null, En = (B) => !Qt(B), st = Wt("function"), Pn = Wt("number"), Kt = (B, K) => {
      if (Sn(B)) {
        for (let se = 0, Ue = B.length; se < Ue; ++se)
          if (!K(B[se]))
            return !1;
        return !0;
      }
      return !1;
    }, J = () => {
    };
    class Qe {
      constructor(K, se) {
        this.tag = K, this.value = se;
      }
      static some(K) {
        return new Qe(!0, K);
      }
      static none() {
        return Qe.singletonNone;
      }
      fold(K, se) {
        return this.tag ? se(this.value) : K();
      }
      isSome() {
        return this.tag;
      }
      isNone() {
        return !this.tag;
      }
      map(K) {
        return this.tag ? Qe.some(K(this.value)) : Qe.none();
      }
      bind(K) {
        return this.tag ? K(this.value) : Qe.none();
      }
      exists(K) {
        return this.tag && K(this.value);
      }
      forall(K) {
        return !this.tag || K(this.value);
      }
      filter(K) {
        return !this.tag || K(this.value) ? this : Qe.none();
      }
      getOr(K) {
        return this.tag ? this.value : K;
      }
      or(K) {
        return this.tag ? this : K;
      }
      getOrThunk(K) {
        return this.tag ? this.value : K();
      }
      orThunk(K) {
        return this.tag ? this : K();
      }
      getOrDie(K) {
        if (this.tag)
          return this.value;
        throw new Error(K ?? "Called getOrDie on None");
      }
      static from(K) {
        return En(K) ? Qe.some(K) : Qe.none();
      }
      getOrNull() {
        return this.tag ? this.value : null;
      }
      getOrUndefined() {
        return this.value;
      }
      each(K) {
        this.tag && K(this.value);
      }
      toArray() {
        return this.tag ? [this.value] : [];
      }
      toString() {
        return this.tag ? `some(${this.value})` : "none()";
      }
    }
    Qe.singletonNone = new Qe(!1);
    const xo = Object.keys, ht = Object.hasOwnProperty, U = (B, K) => {
      const se = xo(B);
      for (let Ue = 0, en = se.length; Ue < en; Ue++) {
        const Io = se[Ue], _n = B[Io];
        K(_n, Io);
      }
    }, Tt = (B) => (K, se) => {
      B[se] = K;
    }, Ht = (B, K, se, Ue) => {
      U(B, (en, Io) => {
        (K(en, Io) ? se : Ue)(en, Io);
      });
    }, gn = (B, K) => {
      const se = {};
      return Ht(B, K, Tt(se), J), se;
    }, De = (B, K) => ht.call(B, K), re = (B, K) => De(B, K) && B[K] !== void 0 && B[K] !== null, ho = Array.prototype.push, Te = (B) => {
      const K = [];
      for (let se = 0, Ue = B.length; se < Ue; ++se) {
        if (!Sn(B[se]))
          throw new Error("Arr.flatten item " + se + " was not an array, input: " + B);
        ho.apply(K, B[se]);
      }
      return K;
    }, Oe = (B, K) => K >= 0 && K < B.length ? Qe.some(B[K]) : Qe.none(), A = (B) => Oe(B, 0), mn = (B, K) => {
      for (let se = 0; se < B.length; se++) {
        const Ue = K(B[se], se);
        if (Ue.isSome())
          return Ue;
      }
      return Qe.none();
    };
    typeof window < "u" || Function("return this;")();
    const it = (B, K, se) => {
      if (Bt(se) || Zt(se) || Pn(se))
        B.setAttribute(K, se + "");
      else
        throw new Error("Attribute value was not simple");
    }, Gn = (B, K, se) => {
      it(B.dom, K, se);
    }, rn = (B, K) => {
      B.dom.removeAttribute(K);
    }, Ye = (B, K) => {
      const Ue = (K || document).createElement("div");
      if (Ue.innerHTML = B, !Ue.hasChildNodes() || Ue.childNodes.length > 1) {
        const en = "HTML does not have a single root node";
        throw new Error(en);
      }
      return bt(Ue.childNodes[0]);
    }, io = (B, K) => {
      const Ue = (K || document).createElement(B);
      return bt(Ue);
    }, jo = (B, K) => {
      const Ue = (K || document).createTextNode(B);
      return bt(Ue);
    }, bt = (B) => {
      if (B == null)
        throw new Error("Node cannot be null or undefined");
      return { dom: B };
    }, $e = {
      fromHtml: Ye,
      fromTag: io,
      fromText: jo,
      fromDom: bt,
      fromPoint: (B, K, se) => Qe.from(B.dom.elementFromPoint(K, se)).map(bt)
    };
    var ot = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils"), F = tinymce.util.Tools.resolve("tinymce.util.URI");
    const ss = (B) => B.length > 0, fo = (B) => (K) => K.options.get(B), at = (B) => {
      const K = B.options.register;
      K("image_dimensions", {
        processor: "boolean",
        default: !0
      }), K("image_advtab", {
        processor: "boolean",
        default: !1
      }), K("image_uploadtab", {
        processor: "boolean",
        default: !0
      }), K("image_prepend_url", {
        processor: "string",
        default: ""
      }), K("image_class_list", { processor: "object[]" }), K("image_description", {
        processor: "boolean",
        default: !0
      }), K("image_title", {
        processor: "boolean",
        default: !1
      }), K("image_caption", {
        processor: "boolean",
        default: !1
      }), K("image_list", {
        processor: (se) => {
          const Ue = se === !1 || Bt(se) || Kt(se, fn) || st(se);
          return Ue ? {
            value: se,
            valid: Ue
          } : {
            valid: !1,
            message: "Must be false, a string, an array or a function."
          };
        },
        default: !1
      });
    }, lt = fo("image_dimensions"), Rn = fo("image_advtab"), ee = fo("image_uploadtab"), pe = fo("image_prepend_url"), ye = fo("image_class_list"), ae = fo("image_description"), kt = fo("image_title"), Vn = fo("image_caption"), Yt = fo("image_list"), Ct = fo("a11y_advanced_options"), Xe = fo("automatic_uploads"), In = (B) => ss(B.options.get("images_upload_url")), hn = (B) => En(B.options.get("images_upload_handler")), Xn = (B, K) => Math.max(parseInt(B, 10), parseInt(K, 10)), Xo = (B) => new Promise((K) => {
      const se = document.createElement("img"), Ue = (Io) => {
        se.onload = se.onerror = null, se.parentNode && se.parentNode.removeChild(se), K(Io);
      };
      se.onload = () => {
        const Io = Xn(se.width, se.clientWidth), _n = Xn(se.height, se.clientHeight), gr = {
          width: Io,
          height: _n
        };
        Ue(Promise.resolve(gr));
      }, se.onerror = () => {
        Ue(Promise.reject(`Failed to get image dimensions for: ${B}`));
      };
      const en = se.style;
      en.visibility = "hidden", en.position = "fixed", en.bottom = en.left = "0px", en.width = en.height = "auto", document.body.appendChild(se), se.src = B;
    }), ds = (B) => (B && (B = B.replace(/px$/, "")), B), No = (B) => (B.length > 0 && /^[0-9]+$/.test(B) && (B += "px"), B), Ao = (B) => {
      if (B.margin) {
        const K = String(B.margin).split(" ");
        switch (K.length) {
          case 1:
            B["margin-top"] = B["margin-top"] || K[0], B["margin-right"] = B["margin-right"] || K[0], B["margin-bottom"] = B["margin-bottom"] || K[0], B["margin-left"] = B["margin-left"] || K[0];
            break;
          case 2:
            B["margin-top"] = B["margin-top"] || K[0], B["margin-right"] = B["margin-right"] || K[1], B["margin-bottom"] = B["margin-bottom"] || K[0], B["margin-left"] = B["margin-left"] || K[1];
            break;
          case 3:
            B["margin-top"] = B["margin-top"] || K[0], B["margin-right"] = B["margin-right"] || K[1], B["margin-bottom"] = B["margin-bottom"] || K[2], B["margin-left"] = B["margin-left"] || K[1];
            break;
          case 4:
            B["margin-top"] = B["margin-top"] || K[0], B["margin-right"] = B["margin-right"] || K[1], B["margin-bottom"] = B["margin-bottom"] || K[2], B["margin-left"] = B["margin-left"] || K[3];
        }
        delete B.margin;
      }
      return B;
    }, Cs = (B, K) => {
      const se = Yt(B);
      Bt(se) ? fetch(se).then((Ue) => {
        Ue.ok && Ue.json().then(K);
      }) : st(se) ? se(K) : K(se);
    }, Ie = (B, K, se) => {
      const Ue = () => {
        se.onload = se.onerror = null, B.selection && (B.selection.select(se), B.nodeChanged());
      };
      se.onload = () => {
        !K.width && !K.height && lt(B) && B.dom.setAttribs(se, {
          width: String(se.clientWidth),
          height: String(se.clientHeight)
        }), Ue();
      }, se.onerror = Ue;
    }, et = (B) => new Promise((K, se) => {
      const Ue = new FileReader();
      Ue.onload = () => {
        K(Ue.result);
      }, Ue.onerror = () => {
        var en;
        se((en = Ue.error) === null || en === void 0 ? void 0 : en.message);
      }, Ue.readAsDataURL(B);
    }), nn = (B) => B.nodeName === "IMG" && (B.hasAttribute("data-mce-object") || B.hasAttribute("data-mce-placeholder")), qt = (B, K) => {
      const se = B.options.get;
      return F.isDomSafe(K, "img", {
        allow_html_data_urls: se("allow_html_data_urls"),
        allow_script_urls: se("allow_script_urls"),
        allow_svg_data_urls: se("allow_svg_data_urls")
      });
    }, ko = ot.DOM, rs = (B) => B.style.marginLeft && B.style.marginRight && B.style.marginLeft === B.style.marginRight ? ds(B.style.marginLeft) : "", Gs = (B) => B.style.marginTop && B.style.marginBottom && B.style.marginTop === B.style.marginBottom ? ds(B.style.marginTop) : "", Yr = (B) => B.style.borderWidth ? ds(B.style.borderWidth) : "", Ss = (B, K) => {
      var se;
      return B.hasAttribute(K) && (se = B.getAttribute(K)) !== null && se !== void 0 ? se : "";
    }, or = (B) => B.parentNode !== null && B.parentNode.nodeName === "FIGURE", Dt = (B, K, se) => {
      se === "" || se === null ? B.removeAttribute(K) : B.setAttribute(K, se);
    }, Lo = (B) => {
      const K = ko.create("figure", { class: "image" });
      ko.insertAfter(K, B), K.appendChild(B), K.appendChild(ko.create("figcaption", { contentEditable: "true" }, "Caption")), K.contentEditable = "false";
    }, Or = (B) => {
      const K = B.parentNode;
      En(K) && (ko.insertAfter(B, K), ko.remove(K));
    }, aa = (B) => {
      or(B) ? Or(B) : Lo(B);
    }, Xr = (B, K) => {
      const se = B.getAttribute("style"), Ue = K(se !== null ? se : "");
      Ue.length > 0 ? (B.setAttribute("style", Ue), B.setAttribute("data-mce-style", Ue)) : B.removeAttribute("style");
    }, Jr = (B, K) => (se, Ue, en) => {
      const Io = se.style;
      Io[Ue] ? (Io[Ue] = No(en), Xr(se, K)) : Dt(se, Ue, en);
    }, xs = (B, K) => B.style[K] ? ds(B.style[K]) : Ss(B, K), fa = (B, K) => {
      const se = No(K);
      B.style.marginLeft = se, B.style.marginRight = se;
    }, Qr = (B, K) => {
      const se = No(K);
      B.style.marginTop = se, B.style.marginBottom = se;
    }, Ts = (B, K) => {
      const se = No(K);
      B.style.borderWidth = se;
    }, Zn = (B, K) => {
      B.style.borderStyle = K;
    }, dr = (B) => {
      var K;
      return (K = B.style.borderStyle) !== null && K !== void 0 ? K : "";
    }, ga = (B) => En(B) && B.nodeName === "FIGURE", Za = (B) => B.nodeName === "IMG", _c = (B) => ko.getAttrib(B, "alt").length === 0 && ko.getAttrib(B, "role") === "presentation", sr = (B) => _c(B) ? "" : Ss(B, "alt"), Ks = () => ({
      src: "",
      alt: "",
      title: "",
      width: "",
      height: "",
      class: "",
      style: "",
      caption: !1,
      hspace: "",
      vspace: "",
      border: "",
      borderStyle: "",
      isDecorative: !1
    }), Vs = (B, K) => {
      var se;
      const Ue = document.createElement("img");
      return Dt(Ue, "style", K.style), (rs(Ue) || K.hspace !== "") && fa(Ue, K.hspace), (Gs(Ue) || K.vspace !== "") && Qr(Ue, K.vspace), (Yr(Ue) || K.border !== "") && Ts(Ue, K.border), (dr(Ue) || K.borderStyle !== "") && Zn(Ue, K.borderStyle), B((se = Ue.getAttribute("style")) !== null && se !== void 0 ? se : "");
    }, Sa = (B, K) => {
      const se = document.createElement("img");
      if (Je(B, {
        ...K,
        caption: !1
      }, se), de(se, K.alt, K.isDecorative), K.caption) {
        const Ue = ko.create("figure", { class: "image" });
        return Ue.appendChild(se), Ue.appendChild(ko.create("figcaption", { contentEditable: "true" }, "Caption")), Ue.contentEditable = "false", Ue;
      } else
        return se;
    }, rc = (B, K) => ({
      src: Ss(K, "src"),
      alt: sr(K),
      title: Ss(K, "title"),
      width: xs(K, "width"),
      height: xs(K, "height"),
      class: Ss(K, "class"),
      style: B(Ss(K, "style")),
      caption: or(K),
      hspace: rs(K),
      vspace: Gs(K),
      border: Yr(K),
      borderStyle: dr(K),
      isDecorative: _c(K)
    }), wr = (B, K, se, Ue, en) => {
      se[Ue] !== K[Ue] && en(B, Ue, String(se[Ue]));
    }, de = (B, K, se) => {
      if (se) {
        ko.setAttrib(B, "role", "presentation");
        const Ue = $e.fromDom(B);
        Gn(Ue, "alt", "");
      } else {
        if (Ft(K)) {
          const Ue = $e.fromDom(B);
          rn(Ue, "alt");
        } else {
          const Ue = $e.fromDom(B);
          Gn(Ue, "alt", K);
        }
        ko.getAttrib(B, "role") === "presentation" && ko.setAttrib(B, "role", "");
      }
    }, ie = (B, K, se) => {
      (se.alt !== K.alt || se.isDecorative !== K.isDecorative) && de(B, se.alt, se.isDecorative);
    }, ze = (B, K) => (se, Ue, en) => {
      B(se, en), Xr(se, K);
    }, Je = (B, K, se) => {
      const Ue = rc(B, se);
      wr(se, Ue, K, "caption", (en, Io, _n) => aa(en)), wr(se, Ue, K, "src", Dt), wr(se, Ue, K, "title", Dt), wr(se, Ue, K, "width", Jr("width", B)), wr(se, Ue, K, "height", Jr("height", B)), wr(se, Ue, K, "class", Dt), wr(se, Ue, K, "style", ze((en, Io) => Dt(en, "style", Io), B)), wr(se, Ue, K, "hspace", ze(fa, B)), wr(se, Ue, K, "vspace", ze(Qr, B)), wr(se, Ue, K, "border", ze(Ts, B)), wr(se, Ue, K, "borderStyle", ze(Zn, B)), ie(se, Ue, K);
    }, Nn = (B, K) => {
      const se = B.dom.styles.parse(K), Ue = Ao(se), en = B.dom.styles.parse(B.dom.styles.serialize(Ue));
      return B.dom.styles.serialize(en);
    }, Wn = (B) => {
      const K = B.selection.getNode(), se = B.dom.getParent(K, "figure.image");
      return se ? B.dom.select("img", se)[0] : K && (K.nodeName !== "IMG" || nn(K)) ? null : K;
    }, _o = (B, K) => {
      var se;
      const Ue = B.dom, en = gn(B.schema.getTextBlockElements(), (_n, gr) => !B.schema.isValidChild(gr, "figure")), Io = Ue.getParent(K.parentNode, (_n) => re(en, _n.nodeName), B.getBody());
      return Io && (se = Ue.split(Io, K)) !== null && se !== void 0 ? se : K;
    }, Fs = (B) => {
      const K = Wn(B);
      return K ? rc((se) => Nn(B, se), K) : Ks();
    }, ve = (B, K) => {
      const se = Sa((en) => Nn(B, en), K);
      B.dom.setAttrib(se, "data-mce-id", "__mcenew"), B.focus(), B.selection.setContent(se.outerHTML);
      const Ue = B.dom.select('*[data-mce-id="__mcenew"]')[0];
      if (B.dom.setAttrib(Ue, "data-mce-id", null), ga(Ue)) {
        const en = _o(B, Ue);
        B.selection.select(en);
      } else
        B.selection.select(Ue);
    }, go = (B, K) => {
      B.dom.setAttrib(K, "src", K.getAttribute("src"));
    }, ue = (B, K) => {
      if (K) {
        const se = B.dom.is(K.parentNode, "figure.image") ? K.parentNode : K;
        B.dom.remove(se), B.focus(), B.nodeChanged(), B.dom.isEmpty(B.getBody()) && (B.setContent(""), B.selection.setCursorLocation());
      }
    }, he = (B, K) => {
      const se = Wn(B);
      if (se)
        if (Je((Ue) => Nn(B, Ue), K, se), go(B, se), ga(se.parentNode)) {
          const Ue = se.parentNode;
          _o(B, Ue), B.selection.select(se.parentNode);
        } else
          B.selection.select(se), Ie(B, K, se);
    }, dt = (B, K) => {
      const se = K.src;
      return {
        ...K,
        src: qt(B, se) ? se : ""
      };
    }, wt = (B, K) => {
      const se = Wn(B);
      if (se) {
        const en = {
          ...rc((_n) => Nn(B, _n), se),
          ...K
        }, Io = dt(B, en);
        en.src ? he(B, Io) : ue(B, se);
      } else K.src && ve(B, {
        ...Ks(),
        ...K
      });
    }, On = ((B) => (...K) => {
      if (K.length === 0)
        throw new Error("Can't merge zero objects");
      const se = {};
      for (let Ue = 0; Ue < K.length; Ue++) {
        const en = K[Ue];
        for (const Io in en)
          De(en, Io) && (se[Io] = B(se[Io], en[Io]));
      }
      return se;
    })((B, K) => dn(B) && dn(K) ? On(B, K) : K);
    var Dn = tinymce.util.Tools.resolve("tinymce.util.ImageUploader"), Mn = tinymce.util.Tools.resolve("tinymce.util.Tools");
    const Kn = (B) => Bt(B.value) ? B.value : "", zo = (B) => Bt(B.text) ? B.text : Bt(B.title) ? B.title : "", Ds = (B, K) => {
      const se = [];
      return Mn.each(B, (Ue) => {
        const en = zo(Ue);
        if (Ue.menu !== void 0) {
          const Io = Ds(Ue.menu, K);
          se.push({
            text: en,
            items: Io
          });
        } else {
          const Io = K(Ue);
          se.push({
            text: en,
            value: Io
          });
        }
      }), se;
    }, Ra = (B = Kn) => (K) => K ? Qe.from(K).map((se) => Ds(se, B)) : Qe.none(), ac = (B) => Ra(Kn)(B), vc = (B) => De(B, "items"), lo = (B, K) => mn(B, (se) => vc(se) ? lo(se.items, K) : se.value === K ? Qe.some(se) : Qe.none()), ms = {
      sanitizer: Ra,
      sanitize: ac,
      findEntry: (B, K) => B.bind((se) => lo(se, K))
    }, zr = { makeTab: (B) => ({
      title: "Advanced",
      name: "advanced",
      items: [{
        type: "grid",
        columns: 2,
        items: [
          {
            type: "input",
            label: "Vertical space",
            name: "vspace",
            inputMode: "numeric"
          },
          {
            type: "input",
            label: "Horizontal space",
            name: "hspace",
            inputMode: "numeric"
          },
          {
            type: "input",
            label: "Border width",
            name: "border",
            inputMode: "numeric"
          },
          {
            type: "listbox",
            name: "borderstyle",
            label: "Border style",
            items: [
              {
                text: "Select...",
                value: ""
              },
              {
                text: "Solid",
                value: "solid"
              },
              {
                text: "Dotted",
                value: "dotted"
              },
              {
                text: "Dashed",
                value: "dashed"
              },
              {
                text: "Double",
                value: "double"
              },
              {
                text: "Groove",
                value: "groove"
              },
              {
                text: "Ridge",
                value: "ridge"
              },
              {
                text: "Inset",
                value: "inset"
              },
              {
                text: "Outset",
                value: "outset"
              },
              {
                text: "None",
                value: "none"
              },
              {
                text: "Hidden",
                value: "hidden"
              }
            ]
          }
        ]
      }]
    }) }, mr = (B) => {
      const K = ms.sanitizer((ar) => B.convertURL(ar.value || ar.url || "", "src")), se = new Promise((ar) => {
        Cs(B, ($i) => {
          ar(K($i).map((hr) => Te([
            [{
              text: "None",
              value: ""
            }],
            hr
          ])));
        });
      }), Ue = ms.sanitize(ye(B)), en = Rn(B), Io = ee(B), _n = In(B), gr = hn(B), _t = Fs(B), Us = ae(B), qa = kt(B), Xs = lt(B), Zr = Vn(B), ri = Ct(B), Jo = Xe(B), Ga = Qe.some(pe(B)).filter((ar) => Bt(ar) && ar.length > 0);
      return se.then((ar) => ({
        image: _t,
        imageList: ar,
        classList: Ue,
        hasAdvTab: en,
        hasUploadTab: Io,
        hasUploadUrl: _n,
        hasUploadHandler: gr,
        hasDescription: Us,
        hasImageTitle: qa,
        hasDimensions: Xs,
        hasImageCaption: Zr,
        prependURL: Ga,
        hasAccessibilityOptions: ri,
        automaticUploads: Jo
      }));
    }, Hs = (B) => {
      const K = {
        name: "src",
        type: "urlinput",
        filetype: "image",
        label: "Source",
        picker_text: "Browse files"
      }, se = B.imageList.map((qa) => ({
        name: "images",
        type: "listbox",
        label: "Image list",
        items: qa
      })), Ue = {
        name: "alt",
        type: "input",
        label: "Alternative description",
        enabled: !(B.hasAccessibilityOptions && B.image.isDecorative)
      }, en = {
        name: "title",
        type: "input",
        label: "Image title"
      }, Io = {
        name: "dimensions",
        type: "sizeinput"
      }, _n = {
        type: "label",
        label: "Accessibility",
        items: [{
          name: "isDecorative",
          type: "checkbox",
          label: "Image is decorative"
        }]
      }, gr = B.classList.map((qa) => ({
        name: "classes",
        type: "listbox",
        label: "Class",
        items: qa
      })), _t = {
        type: "label",
        label: "Caption",
        items: [{
          type: "checkbox",
          name: "caption",
          label: "Show caption"
        }]
      }, Us = (qa) => qa ? {
        type: "grid",
        columns: 2
      } : { type: "panel" };
      return Te([
        [K],
        se.toArray(),
        B.hasAccessibilityOptions && B.hasDescription ? [_n] : [],
        B.hasDescription ? [Ue] : [],
        B.hasImageTitle ? [en] : [],
        B.hasDimensions ? [Io] : [],
        [{
          ...Us(B.classList.isSome() && B.hasImageCaption),
          items: Te([
            gr.toArray(),
            B.hasImageCaption ? [_t] : []
          ])
        }]
      ]);
    }, nl = {
      makeTab: (B) => ({
        title: "General",
        name: "general",
        items: Hs(B)
      }),
      makeItems: Hs
    }, ca = { makeTab: (B) => ({
      title: "Upload",
      name: "upload",
      items: [{
        type: "dropzone",
        name: "fileinput"
      }]
    }) }, Ia = (B) => ({
      prevImage: ms.findEntry(B.imageList, B.image.src),
      prevAlt: B.image.alt,
      open: !0
    }), Pr = (B) => ({
      src: {
        value: B.src,
        meta: {}
      },
      images: B.src,
      alt: B.alt,
      title: B.title,
      dimensions: {
        width: B.width,
        height: B.height
      },
      classes: B.class,
      caption: B.caption,
      style: B.style,
      vspace: B.vspace,
      border: B.border,
      hspace: B.hspace,
      borderstyle: B.borderStyle,
      fileinput: [],
      isDecorative: B.isDecorative
    }), yc = (B, K) => ({
      src: B.src.value,
      alt: (B.alt === null || B.alt.length === 0) && K ? null : B.alt,
      title: B.title,
      width: B.dimensions.width,
      height: B.dimensions.height,
      class: B.classes,
      style: B.style,
      caption: B.caption,
      hspace: B.hspace,
      vspace: B.vspace,
      border: B.border,
      borderStyle: B.borderstyle,
      isDecorative: B.isDecorative
    }), Uc = (B, K) => /^(?:[a-zA-Z]+:)?\/\//.test(K) ? Qe.none() : B.prependURL.bind((se) => K.substring(0, se.length) !== se ? Qe.some(se + K) : Qe.none()), Ta = (B, K) => {
      const se = K.getData();
      Uc(B, se.src.value).each((Ue) => {
        K.setData({
          src: {
            value: Ue,
            meta: se.src.meta
          }
        });
      });
    }, Ac = (B, K, se) => {
      B.hasDescription && Bt(se.alt) && (K.alt = se.alt), B.hasAccessibilityOptions && (K.isDecorative = se.isDecorative || K.isDecorative || !1), B.hasImageTitle && Bt(se.title) && (K.title = se.title), B.hasDimensions && (Bt(se.width) && (K.dimensions.width = se.width), Bt(se.height) && (K.dimensions.height = se.height)), Bt(se.class) && ms.findEntry(B.classList, se.class).each((Ue) => {
        K.classes = Ue.value;
      }), B.hasImageCaption && Zt(se.caption) && (K.caption = se.caption), B.hasAdvTab && (Bt(se.style) && (K.style = se.style), Bt(se.vspace) && (K.vspace = se.vspace), Bt(se.border) && (K.border = se.border), Bt(se.hspace) && (K.hspace = se.hspace), Bt(se.borderstyle) && (K.borderstyle = se.borderstyle));
    }, Oc = (B, K) => {
      const se = K.getData(), Ue = se.src.meta;
      if (Ue !== void 0) {
        const en = On({}, se);
        Ac(B, en, Ue), K.setData(en);
      }
    }, vu = (B, K, se, Ue) => {
      const en = Ue.getData(), Io = en.src.value, _n = en.src.meta || {};
      !_n.width && !_n.height && K.hasDimensions && (ss(Io) ? B.imageSize(Io).then((gr) => {
        se.open && Ue.setData({ dimensions: gr });
      }).catch((gr) => {
      }) : Ue.setData({
        dimensions: {
          width: "",
          height: ""
        }
      }));
    }, Dc = (B, K, se) => {
      const Ue = se.getData(), en = ms.findEntry(B.imageList, Ue.src.value);
      K.prevImage = en, se.setData({ images: en.map((Io) => Io.value).getOr("") });
    }, yl = (B, K, se, Ue) => {
      Ta(K, Ue), Oc(K, Ue), vu(B, K, se, Ue), Dc(K, se, Ue);
    }, ja = (B, K, se, Ue) => {
      const en = Ue.getData(), Io = ms.findEntry(K.imageList, en.images);
      Io.each((_n) => {
        en.alt === "" || se.prevImage.map((_t) => _t.text === en.alt).getOr(!1) ? _n.value === "" ? Ue.setData({
          src: _n,
          alt: se.prevAlt
        }) : Ue.setData({
          src: _n,
          alt: _n.text
        }) : Ue.setData({ src: _n });
      }), se.prevImage = Io, yl(B, K, se, Ue);
    }, wi = (B, K, se, Ue) => {
      const en = Ue.getData();
      Ue.block("Uploading image"), A(en.fileinput).fold(() => {
        Ue.unblock();
      }, (Io) => {
        const _n = URL.createObjectURL(Io), gr = () => {
          Ue.unblock(), URL.revokeObjectURL(_n);
        }, _t = (Us) => {
          Ue.setData({
            src: {
              value: Us,
              meta: {}
            }
          }), Ue.showTab("general"), yl(B, K, se, Ue);
        };
        et(Io).then((Us) => {
          const qa = B.createBlobCache(Io, _n, Us);
          K.automaticUploads ? B.uploadImage(qa).then((Xs) => {
            _t(Xs.url), gr();
          }).catch((Xs) => {
            gr(), B.alertErr(Xs);
          }) : (B.addToBlobCache(qa), _t(qa.blobUri()), Ue.unblock());
        });
      });
    }, Bi = (B, K, se) => (Ue, en) => {
      en.name === "src" ? yl(B, K, se, Ue) : en.name === "images" ? ja(B, K, se, Ue) : en.name === "alt" ? se.prevAlt = Ue.getData().alt : en.name === "fileinput" ? wi(B, K, se, Ue) : en.name === "isDecorative" && Ue.setEnabled("alt", !Ue.getData().isDecorative);
    }, Cl = (B) => () => {
      B.open = !1;
    }, Ju = (B) => B.hasAdvTab || B.hasUploadUrl || B.hasUploadHandler ? {
      type: "tabpanel",
      tabs: Te([
        [nl.makeTab(B)],
        B.hasAdvTab ? [zr.makeTab(B)] : [],
        B.hasUploadTab && (B.hasUploadUrl || B.hasUploadHandler) ? [ca.makeTab(B)] : []
      ])
    } : {
      type: "panel",
      items: nl.makeItems(B)
    }, Z = (B, K, se) => (Ue) => {
      const en = On(Pr(K.image), Ue.getData()), Io = {
        ...en,
        style: Vs(se.normalizeCss, yc(en, !1))
      };
      B.execCommand("mceUpdateImage", !1, yc(Io, K.hasAccessibilityOptions)), B.editorUpload.uploadImagesAuto(), Ue.close();
    }, fe = (B) => (K) => qt(B, K) ? Xo(B.documentBaseURI.toAbsolute(K)).then((se) => ({
      width: String(se.width),
      height: String(se.height)
    })) : Promise.resolve({
      width: "",
      height: ""
    }), _e = (B) => (K, se, Ue) => {
      var en;
      return B.editorUpload.blobCache.create({
        blob: K,
        blobUri: se,
        name: (en = K.name) === null || en === void 0 ? void 0 : en.replace(/\.[^\.]+$/, ""),
        filename: K.name,
        base64: Ue.split(",")[1]
      });
    }, Ve = (B) => (K) => {
      B.editorUpload.blobCache.add(K);
    }, Rt = (B) => (K) => {
      B.windowManager.alert(K);
    }, eo = (B) => (K) => Nn(B, K), Ns = (B) => (K) => B.dom.parseStyle(K), Is = (B) => (K, se) => B.dom.serializeStyle(K, se), Os = (B) => (K) => Dn(B).upload([K], !1).then((se) => {
      var Ue;
      return se.length === 0 ? Promise.reject("Failed to upload image") : se[0].status === !1 ? Promise.reject((Ue = se[0].error) === null || Ue === void 0 ? void 0 : Ue.message) : se[0];
    }), Ys = (B) => {
      const K = {
        imageSize: fe(B),
        addToBlobCache: Ve(B),
        createBlobCache: _e(B),
        alertErr: Rt(B),
        normalizeCss: eo(B),
        parseStyle: Ns(B),
        serializeStyle: Is(B),
        uploadImage: Os(B)
      };
      return { open: () => {
        mr(B).then((Ue) => {
          const en = Ia(Ue);
          return {
            title: "Insert/Edit Image",
            size: "normal",
            body: Ju(Ue),
            buttons: [
              {
                type: "cancel",
                name: "cancel",
                text: "Cancel"
              },
              {
                type: "submit",
                name: "save",
                text: "Save",
                primary: !0
              }
            ],
            initialData: Pr(Ue.image),
            onSubmit: Z(B, Ue, K),
            onChange: Bi(K, Ue, en),
            onClose: Cl(en)
          };
        }).then(B.windowManager.open);
      } };
    }, qo = (B) => {
      B.addCommand("mceImage", Ys(B).open), B.addCommand("mceUpdateImage", (K, se) => {
        B.undoManager.transact(() => wt(B, se));
      });
    }, fr = (B) => {
      const K = B.attr("class");
      return En(K) && /\bimage\b/.test(K);
    }, Na = (B) => (K) => {
      let se = K.length;
      const Ue = (en) => {
        en.attr("contenteditable", B ? "true" : null);
      };
      for (; se--; ) {
        const en = K[se];
        fr(en) && (en.attr("contenteditable", B ? "false" : null), Mn.each(en.getAll("figcaption"), Ue));
      }
    }, ol = (B) => {
      B.on("PreInit", () => {
        B.parser.addNodeFilter("figure", Na(!0)), B.serializer.addNodeFilter("figure", Na(!1));
      });
    }, sn = (B) => (K) => {
      const se = () => {
        K.setEnabled(B.selection.isEditable());
      };
      return B.on("NodeChange", se), se(), () => {
        B.off("NodeChange", se);
      };
    }, Ql = (B) => {
      B.ui.registry.addToggleButton("image", {
        icon: "image",
        tooltip: "Insert/edit image",
        onAction: Ys(B).open,
        onSetup: (K) => {
          K.setActive(En(Wn(B)));
          const se = B.selection.selectorChangedWithUnbind("img:not([data-mce-object]):not([data-mce-placeholder]),figure.image", K.setActive).unbind, Ue = sn(B)(K);
          return () => {
            se(), Ue();
          };
        }
      }), B.ui.registry.addMenuItem("image", {
        icon: "image",
        text: "Image...",
        onAction: Ys(B).open,
        onSetup: sn(B)
      }), B.ui.registry.addContextMenu("image", { update: (K) => B.selection.isEditable() && (ga(K) || Za(K) && !nn(K)) ? ["image"] : [] });
    };
    var rr = () => {
      vt.add("image", (B) => {
        at(B), ol(B), Ql(B), qo(B);
      });
    };
    rr();
  })()), JG;
}
var eK;
function oX() {
  return eK || (eK = 1, nX()), XG;
}
oX();
var tK = {}, nK = {}, oK;
function sX() {
  return oK || (oK = 1, (function() {
    var vt = tinymce.util.Tools.resolve("tinymce.PluginManager");
    const Ot = (ht) => (U) => U.options.get(ht), Pt = (ht) => {
      const U = ht.options.register;
      U("insertdatetime_dateformat", {
        processor: "string",
        default: ht.translate("%Y-%m-%d")
      }), U("insertdatetime_timeformat", {
        processor: "string",
        default: ht.translate("%H:%M:%S")
      }), U("insertdatetime_formats", {
        processor: "string[]",
        default: [
          "%H:%M:%S",
          "%Y-%m-%d",
          "%I:%M:%S %p",
          "%D"
        ]
      }), U("insertdatetime_element", {
        processor: "boolean",
        default: !1
      });
    }, yt = Ot("insertdatetime_dateformat"), Nt = Ot("insertdatetime_timeformat"), Wt = Ot("insertdatetime_formats"), Fe = Ot("insertdatetime_element"), Ee = (ht) => {
      const U = Wt(ht);
      return U.length > 0 ? U[0] : Nt(ht);
    }, Bt = "Sun Mon Tue Wed Thu Fri Sat Sun".split(" "), fn = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday Sunday".split(" "), dn = "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "), Sn = "January February March April May June July August September October November December".split(" "), Ft = (ht, U) => {
      if (ht = "" + ht, ht.length < U)
        for (let Tt = 0; Tt < U - ht.length; Tt++)
          ht = "0" + ht;
      return ht;
    }, Zt = (ht, U, Tt = /* @__PURE__ */ new Date()) => (U = U.replace("%D", "%m/%d/%Y"), U = U.replace("%r", "%I:%M:%S %p"), U = U.replace("%Y", "" + Tt.getFullYear()), U = U.replace("%y", "" + Tt.getYear()), U = U.replace("%m", Ft(Tt.getMonth() + 1, 2)), U = U.replace("%d", Ft(Tt.getDate(), 2)), U = U.replace("%H", "" + Ft(Tt.getHours(), 2)), U = U.replace("%M", "" + Ft(Tt.getMinutes(), 2)), U = U.replace("%S", "" + Ft(Tt.getSeconds(), 2)), U = U.replace("%I", "" + ((Tt.getHours() + 11) % 12 + 1)), U = U.replace("%p", Tt.getHours() < 12 ? "AM" : "PM"), U = U.replace("%B", "" + ht.translate(Sn[Tt.getMonth()])), U = U.replace("%b", "" + ht.translate(dn[Tt.getMonth()])), U = U.replace("%A", "" + ht.translate(fn[Tt.getDay()])), U = U.replace("%a", "" + ht.translate(Bt[Tt.getDay()])), U = U.replace("%%", "%"), U), Qt = (ht, U, Tt, Ht) => {
      const gn = ht.dom.create("time", { datetime: Tt }, Ht);
      ht.dom.replace(gn, U), ht.selection.select(gn, !0), ht.selection.collapse(!1);
    }, En = (ht, U) => {
      if (Fe(ht)) {
        const Tt = Zt(ht, U);
        let Ht;
        /%[HMSIp]/.test(U) ? Ht = Zt(ht, "%Y-%m-%dT%H:%M") : Ht = Zt(ht, "%Y-%m-%d");
        const gn = ht.dom.getParent(ht.selection.getStart(), "time");
        gn ? Qt(ht, gn, Ht, Tt) : ht.insertContent('<time datetime="' + Ht + '">' + Tt + "</time>");
      } else
        ht.insertContent(Zt(ht, U));
    }, st = (ht) => {
      ht.addCommand("mceInsertDate", (U, Tt) => {
        En(ht, Tt ?? yt(ht));
      }), ht.addCommand("mceInsertTime", (U, Tt) => {
        En(ht, Tt ?? Nt(ht));
      });
    }, Pn = (ht) => {
      let U = ht;
      return {
        get: () => U,
        set: (gn) => {
          U = gn;
        }
      };
    };
    var Kt = tinymce.util.Tools.resolve("tinymce.util.Tools");
    const J = (ht) => (U) => {
      const Tt = () => {
        U.setEnabled(ht.selection.isEditable());
      };
      return ht.on("NodeChange", Tt), Tt(), () => {
        ht.off("NodeChange", Tt);
      };
    }, Qe = (ht) => {
      const U = Wt(ht), Tt = Pn(Ee(ht)), Ht = (De) => ht.execCommand("mceInsertDate", !1, De);
      ht.ui.registry.addSplitButton("insertdatetime", {
        icon: "insert-time",
        tooltip: "Insert date/time",
        select: (De) => De === Tt.get(),
        fetch: (De) => {
          De(Kt.map(U, (re) => ({
            type: "choiceitem",
            text: Zt(ht, re),
            value: re
          })));
        },
        onAction: (De) => {
          Ht(Tt.get());
        },
        onItemAction: (De, re) => {
          Tt.set(re), Ht(re);
        },
        onSetup: J(ht)
      });
      const gn = (De) => () => {
        Tt.set(De), Ht(De);
      };
      ht.ui.registry.addNestedMenuItem("insertdatetime", {
        icon: "insert-time",
        text: "Date/time",
        getSubmenuItems: () => Kt.map(U, (De) => ({
          type: "menuitem",
          text: Zt(ht, De),
          onAction: gn(De)
        })),
        onSetup: J(ht)
      });
    };
    var xo = () => {
      vt.add("insertdatetime", (ht) => {
        Pt(ht), st(ht), Qe(ht);
      });
    };
    xo();
  })()), nK;
}
var sK;
function rX() {
  return sK || (sK = 1, sX()), tK;
}
rX();
var rK = {}, aK = {}, cK;
function aX() {
  return cK || (cK = 1, (function() {
    var vt = tinymce.util.Tools.resolve("tinymce.PluginManager");
    const Ot = (Z, fe, _e) => {
      var Ve;
      return _e(Z, fe.prototype) ? !0 : ((Ve = Z.constructor) === null || Ve === void 0 ? void 0 : Ve.name) === fe.name;
    }, Pt = (Z) => {
      const fe = typeof Z;
      return Z === null ? "null" : fe === "object" && Array.isArray(Z) ? "array" : fe === "object" && Ot(Z, String, (_e, Ve) => Ve.isPrototypeOf(_e)) ? "string" : fe;
    }, yt = (Z) => (fe) => Pt(fe) === Z, Nt = (Z) => (fe) => typeof fe === Z, Wt = (Z) => (fe) => Z === fe, Fe = yt("string"), Ee = yt("object"), Bt = yt("array"), fn = Wt(null), dn = Nt("boolean"), Sn = (Z) => Z == null, Ft = (Z) => !Sn(Z), Zt = Nt("function"), Qt = (Z, fe) => {
      if (Bt(Z)) {
        for (let _e = 0, Ve = Z.length; _e < Ve; ++_e)
          if (!fe(Z[_e]))
            return !1;
        return !0;
      }
      return !1;
    }, En = () => {
    }, st = (Z) => () => Z, Pn = (Z, fe) => Z === fe;
    class Kt {
      constructor(fe, _e) {
        this.tag = fe, this.value = _e;
      }
      static some(fe) {
        return new Kt(!0, fe);
      }
      static none() {
        return Kt.singletonNone;
      }
      fold(fe, _e) {
        return this.tag ? _e(this.value) : fe();
      }
      isSome() {
        return this.tag;
      }
      isNone() {
        return !this.tag;
      }
      map(fe) {
        return this.tag ? Kt.some(fe(this.value)) : Kt.none();
      }
      bind(fe) {
        return this.tag ? fe(this.value) : Kt.none();
      }
      exists(fe) {
        return this.tag && fe(this.value);
      }
      forall(fe) {
        return !this.tag || fe(this.value);
      }
      filter(fe) {
        return !this.tag || fe(this.value) ? this : Kt.none();
      }
      getOr(fe) {
        return this.tag ? this.value : fe;
      }
      or(fe) {
        return this.tag ? this : fe;
      }
      getOrThunk(fe) {
        return this.tag ? this.value : fe();
      }
      orThunk(fe) {
        return this.tag ? this : fe();
      }
      getOrDie(fe) {
        if (this.tag)
          return this.value;
        throw new Error(fe ?? "Called getOrDie on None");
      }
      static from(fe) {
        return Ft(fe) ? Kt.some(fe) : Kt.none();
      }
      getOrNull() {
        return this.tag ? this.value : null;
      }
      getOrUndefined() {
        return this.value;
      }
      each(fe) {
        this.tag && fe(this.value);
      }
      toArray() {
        return this.tag ? [this.value] : [];
      }
      toString() {
        return this.tag ? `some(${this.value})` : "none()";
      }
    }
    Kt.singletonNone = new Kt(!1);
    const J = Array.prototype.indexOf, Qe = Array.prototype.push, xo = (Z, fe) => J.call(Z, fe), ht = (Z, fe) => xo(Z, fe) > -1, U = (Z, fe) => {
      const _e = Z.length, Ve = new Array(_e);
      for (let Rt = 0; Rt < _e; Rt++) {
        const eo = Z[Rt];
        Ve[Rt] = fe(eo, Rt);
      }
      return Ve;
    }, Tt = (Z, fe) => {
      for (let _e = 0, Ve = Z.length; _e < Ve; _e++) {
        const Rt = Z[_e];
        fe(Rt, _e);
      }
    }, Ht = (Z, fe, _e) => (Tt(Z, (Ve, Rt) => {
      _e = fe(_e, Ve, Rt);
    }), _e), gn = (Z) => {
      const fe = [];
      for (let _e = 0, Ve = Z.length; _e < Ve; ++_e) {
        if (!Bt(Z[_e]))
          throw new Error("Arr.flatten item " + _e + " was not an array, input: " + Z);
        Qe.apply(fe, Z[_e]);
      }
      return fe;
    }, De = (Z, fe) => gn(U(Z, fe)), re = (Z, fe) => {
      for (let _e = 0; _e < Z.length; _e++) {
        const Ve = fe(Z[_e], _e);
        if (Ve.isSome())
          return Ve;
      }
      return Kt.none();
    }, ho = (Z, fe, _e = Pn) => Z.exists((Ve) => _e(Ve, fe)), Te = (Z) => {
      const fe = [], _e = (Ve) => {
        fe.push(Ve);
      };
      for (let Ve = 0; Ve < Z.length; Ve++)
        Z[Ve].each(_e);
      return fe;
    }, Oe = (Z, fe) => Z ? Kt.some(fe) : Kt.none(), A = (Z) => (fe) => fe.options.get(Z), mn = (Z) => {
      const fe = Z.options.register;
      fe("link_assume_external_targets", {
        processor: (_e) => {
          const Ve = Fe(_e) || dn(_e);
          return Ve ? _e === !0 ? {
            value: 1,
            valid: Ve
          } : _e === "http" || _e === "https" ? {
            value: _e,
            valid: Ve
          } : {
            value: 0,
            valid: Ve
          } : {
            valid: !1,
            message: "Must be a string or a boolean."
          };
        },
        default: !1
      }), fe("link_context_toolbar", {
        processor: "boolean",
        default: !1
      }), fe("link_list", { processor: (_e) => Fe(_e) || Zt(_e) || Qt(_e, Ee) }), fe("link_default_target", { processor: "string" }), fe("link_default_protocol", {
        processor: "string",
        default: "https"
      }), fe("link_target_list", {
        processor: (_e) => dn(_e) || Qt(_e, Ee),
        default: !0
      }), fe("link_rel_list", {
        processor: "object[]",
        default: []
      }), fe("link_class_list", {
        processor: "object[]",
        default: []
      }), fe("link_title", {
        processor: "boolean",
        default: !0
      }), fe("allow_unsafe_link_target", {
        processor: "boolean",
        default: !1
      }), fe("link_quicklink", {
        processor: "boolean",
        default: !1
      });
    }, it = A("link_assume_external_targets"), Gn = A("link_context_toolbar"), rn = A("link_list"), Ye = A("link_default_target"), io = A("link_default_protocol"), jo = A("link_target_list"), bt = A("link_rel_list"), kn = A("link_class_list"), $e = A("link_title"), ot = A("allow_unsafe_link_target"), F = A("link_quicklink");
    var ss = tinymce.util.Tools.resolve("tinymce.util.Tools");
    const fo = (Z) => Fe(Z.value) ? Z.value : "", at = (Z) => Fe(Z.text) ? Z.text : Fe(Z.title) ? Z.title : "", lt = (Z, fe) => {
      const _e = [];
      return ss.each(Z, (Ve) => {
        const Rt = at(Ve);
        if (Ve.menu !== void 0) {
          const eo = lt(Ve.menu, fe);
          _e.push({
            text: Rt,
            items: eo
          });
        } else {
          const eo = fe(Ve);
          _e.push({
            text: Rt,
            value: eo
          });
        }
      }), _e;
    }, Rn = (Z = fo) => (fe) => Kt.from(fe).map((_e) => lt(_e, Z)), ye = {
      sanitize: (Z) => Rn(fo)(Z),
      sanitizeWith: Rn,
      createUi: (Z, fe) => (_e) => ({
        name: Z,
        type: "listbox",
        label: fe,
        items: _e
      }),
      getValue: fo
    }, ae = Object.keys, kt = Object.hasOwnProperty, Vn = (Z, fe) => {
      const _e = ae(Z);
      for (let Ve = 0, Rt = _e.length; Ve < Rt; Ve++) {
        const eo = _e[Ve], Ns = Z[eo];
        fe(Ns, eo);
      }
    }, Yt = (Z) => (fe, _e) => {
      Z[_e] = fe;
    }, Ct = (Z, fe, _e, Ve) => {
      Vn(Z, (Rt, eo) => {
        (fe(Rt, eo) ? _e : Ve)(Rt, eo);
      });
    }, Xe = (Z, fe) => {
      const _e = {};
      return Ct(Z, fe, Yt(_e), En), _e;
    }, In = (Z, fe) => kt.call(Z, fe), hn = (Z, fe) => In(Z, fe) && Z[fe] !== void 0 && Z[fe] !== null;
    var Xn = tinymce.util.Tools.resolve("tinymce.dom.TreeWalker"), Xo = tinymce.util.Tools.resolve("tinymce.util.URI");
    const ds = (Z) => Ft(Z) && Z.nodeName.toLowerCase() === "a", No = (Z) => ds(Z) && !!Ie(Z), Ao = (Z, fe) => {
      if (Z.collapsed)
        return [];
      {
        const _e = Z.cloneContents(), Ve = _e.firstChild, Rt = new Xn(Ve, _e), eo = [];
        let Ns = Ve;
        do
          fe(Ns) && eo.push(Ns);
        while (Ns = Rt.next());
        return eo;
      }
    }, Cs = (Z) => /^\w+:/i.test(Z), Ie = (Z) => {
      var fe, _e;
      return (_e = (fe = Z.getAttribute("data-mce-href")) !== null && fe !== void 0 ? fe : Z.getAttribute("href")) !== null && _e !== void 0 ? _e : "";
    }, et = (Z, fe) => {
      const _e = ["noopener"], Ve = Z ? Z.split(/\s+/) : [], Rt = (Os) => ss.trim(Os.sort().join(" ")), eo = (Os) => (Os = Ns(Os), Os.length > 0 ? Os.concat(_e) : _e), Ns = (Os) => Os.filter((Ys) => ss.inArray(_e, Ys) === -1), Is = fe ? eo(Ve) : Ns(Ve);
      return Is.length > 0 ? Rt(Is) : "";
    }, nn = (Z) => Z.replace(/\uFEFF/g, ""), qt = (Z, fe) => (fe = fe || Gs(Z.selection.getRng())[0] || Z.selection.getNode(), Lo(fe) ? Kt.from(Z.dom.select("a[href]", fe)[0]) : Kt.from(Z.dom.getParent(fe, "a[href]"))), ko = (Z, fe) => qt(Z, fe).isSome(), rs = (Z, fe) => {
      const _e = fe.fold(() => Z.getContent({ format: "text" }), (Ve) => Ve.innerText || Ve.textContent || "");
      return nn(_e);
    }, Gs = (Z) => Ao(Z, No), Yr = (Z) => ss.grep(Z, No), Ss = (Z) => Yr(Z).length > 0, or = (Z) => Gs(Z).length > 0, Dt = (Z) => {
      const fe = Z.schema.getTextInlineElements(), _e = (eo) => eo.nodeType === 1 && !ds(eo) && !In(fe, eo.nodeName.toLowerCase());
      if (qt(Z).exists((eo) => eo.hasAttribute("data-mce-block")))
        return !1;
      const Rt = Z.selection.getRng();
      return Rt.collapsed ? !0 : Ao(Rt, _e).length === 0;
    }, Lo = (Z) => Ft(Z) && Z.nodeName === "FIGURE" && /\bimage\b/i.test(Z.className), Or = (Z) => Ht([
      "title",
      "rel",
      "class",
      "target"
    ], (_e, Ve) => (Z[Ve].each((Rt) => {
      _e[Ve] = Rt.length > 0 ? Rt : null;
    }), _e), { href: Z.href }), aa = (Z, fe) => (fe === "http" || fe === "https") && !Cs(Z) ? fe + "://" + Z : Z, Xr = (Z, fe) => {
      const _e = { ...fe };
      if (bt(Z).length === 0 && !ot(Z)) {
        const Ve = et(_e.rel, _e.target === "_blank");
        _e.rel = Ve || null;
      }
      return Kt.from(_e.target).isNone() && jo(Z) === !1 && (_e.target = Ye(Z)), _e.href = aa(_e.href, it(Z)), _e;
    }, Jr = (Z, fe, _e, Ve) => {
      _e.each((Rt) => {
        In(fe, "innerText") ? fe.innerText = Rt : fe.textContent = Rt;
      }), Z.dom.setAttribs(fe, Ve), Z.selection.select(fe);
    }, xs = (Z, fe, _e, Ve) => {
      const Rt = Z.dom;
      Lo(fe) ? sr(Rt, fe, Ve) : _e.fold(() => {
        Z.execCommand("mceInsertLink", !1, Ve);
      }, (eo) => {
        Z.insertContent(Rt.createHTML("a", Ve, Rt.encode(eo)));
      });
    }, fa = (Z, fe, _e) => {
      const Ve = Z.selection.getNode(), Rt = qt(Z, Ve), eo = Xr(Z, Or(_e));
      Z.undoManager.transact(() => {
        _e.href === fe.href && fe.attach(), Rt.fold(() => {
          xs(Z, Ve, _e.text, eo);
        }, (Ns) => {
          Z.focus(), Jr(Z, Ns, _e.text, eo);
        });
      });
    }, Qr = (Z) => {
      const fe = Z.dom, _e = Z.selection, Ve = _e.getBookmark(), Rt = _e.getRng().cloneRange(), eo = fe.getParent(Rt.startContainer, "a[href]", Z.getBody()), Ns = fe.getParent(Rt.endContainer, "a[href]", Z.getBody());
      eo && Rt.setStartBefore(eo), Ns && Rt.setEndAfter(Ns), _e.setRng(Rt), Z.execCommand("unlink"), _e.moveToBookmark(Ve);
    }, Ts = (Z) => {
      Z.undoManager.transact(() => {
        const fe = Z.selection.getNode();
        Lo(fe) ? _c(Z, fe) : Qr(Z), Z.focus();
      });
    }, Zn = (Z) => {
      const {
        class: fe,
        href: _e,
        rel: Ve,
        target: Rt,
        text: eo,
        title: Ns
      } = Z;
      return Xe({
        class: fe.getOrNull(),
        href: _e,
        rel: Ve.getOrNull(),
        target: Rt.getOrNull(),
        text: eo.getOrNull(),
        title: Ns.getOrNull()
      }, (Is, Os) => fn(Is) === !1);
    }, dr = (Z, fe) => {
      const _e = Z.options.get, Ve = {
        allow_html_data_urls: _e("allow_html_data_urls"),
        allow_script_urls: _e("allow_script_urls"),
        allow_svg_data_urls: _e("allow_svg_data_urls")
      }, Rt = fe.href;
      return {
        ...fe,
        href: Xo.isDomSafe(Rt, "a", Ve) ? Rt : ""
      };
    }, ga = (Z, fe, _e) => {
      const Ve = dr(Z, _e);
      Z.hasPlugin("rtc", !0) ? Z.execCommand("createlink", !1, Zn(Ve)) : fa(Z, fe, Ve);
    }, Za = (Z) => {
      Z.hasPlugin("rtc", !0) ? Z.execCommand("unlink") : Ts(Z);
    }, _c = (Z, fe) => {
      var _e;
      const Ve = Z.dom.select("img", fe)[0];
      if (Ve) {
        const Rt = Z.dom.getParents(Ve, "a[href]", fe)[0];
        Rt && ((_e = Rt.parentNode) === null || _e === void 0 || _e.insertBefore(Ve, Rt), Z.dom.remove(Rt));
      }
    }, sr = (Z, fe, _e) => {
      var Ve;
      const Rt = Z.select("img", fe)[0];
      if (Rt) {
        const eo = Z.create("a", _e);
        (Ve = Rt.parentNode) === null || Ve === void 0 || Ve.insertBefore(eo, Rt), eo.appendChild(Rt);
      }
    }, Ks = (Z) => hn(Z, "items"), Vs = (Z, fe) => re(fe, (_e) => Ks(_e) ? Vs(Z, _e.items) : Oe(_e.value === Z, _e)), Sa = (Z, fe, _e, Ve) => {
      const Rt = Ve[fe], eo = Z.length > 0;
      return Rt !== void 0 ? Vs(Rt, _e).map((Ns) => ({
        url: {
          value: Ns.value,
          meta: {
            text: eo ? Z : Ns.text,
            attach: En
          }
        },
        text: eo ? Z : Ns.text
      })) : Kt.none();
    }, rc = (Z, fe) => fe === "link" ? Z.link : fe === "anchor" ? Z.anchor : Kt.none(), de = {
      init: (Z, fe) => {
        const _e = {
          text: Z.text,
          title: Z.title
        }, Ve = (Os) => {
          var Ys;
          return Oe(_e.title.length <= 0, Kt.from((Ys = Os.meta) === null || Ys === void 0 ? void 0 : Ys.title).getOr(""));
        }, Rt = (Os) => {
          var Ys;
          return Oe(_e.text.length <= 0, Kt.from((Ys = Os.meta) === null || Ys === void 0 ? void 0 : Ys.text).getOr(Os.value));
        }, eo = (Os) => {
          const Ys = Rt(Os.url), qo = Ve(Os.url);
          return Ys.isSome() || qo.isSome() ? Kt.some({
            ...Ys.map((fr) => ({ text: fr })).getOr({}),
            ...qo.map((fr) => ({ title: fr })).getOr({})
          }) : Kt.none();
        }, Ns = (Os, Ys) => {
          const qo = rc(fe, Ys).getOr([]);
          return Sa(_e.text, Ys, qo, Os);
        };
        return { onChange: (Os, Ys) => {
          const qo = Ys.name;
          return qo === "url" ? eo(Os()) : ht([
            "anchor",
            "link"
          ], qo) ? Ns(Os(), qo) : ((qo === "text" || qo === "title") && (_e[qo] = Os()[qo]), Kt.none());
        } };
      },
      getDelta: Sa
    };
    var ie = tinymce.util.Tools.resolve("tinymce.util.Delay");
    const ze = (Z, fe, _e) => {
      const Ve = Z.selection.getRng();
      ie.setEditorTimeout(Z, () => {
        Z.windowManager.confirm(fe, (Rt) => {
          Z.selection.setRng(Ve), _e(Rt);
        });
      });
    }, Je = (Z) => {
      const fe = Z.href;
      return fe.indexOf("@") > 0 && fe.indexOf("/") === -1 && fe.indexOf("mailto:") === -1 ? Kt.some({
        message: "The URL you entered seems to be an email address. Do you want to add the required mailto: prefix?",
        preprocess: (Ve) => ({
          ...Ve,
          href: "mailto:" + fe
        })
      }) : Kt.none();
    }, Nn = (Z, fe) => (_e) => {
      const Ve = _e.href;
      return Z === 1 && !Cs(Ve) || Z === 0 && /^\s*www(\.|\d\.)/i.test(Ve) ? Kt.some({
        message: `The URL you entered seems to be an external link. Do you want to add the required ${fe}:// prefix?`,
        preprocess: (eo) => ({
          ...eo,
          href: fe + "://" + Ve
        })
      }) : Kt.none();
    }, _o = { preprocess: (Z, fe) => re([
      Je,
      Nn(it(Z), io(Z))
    ], (_e) => _e(fe)).fold(() => Promise.resolve(fe), (_e) => new Promise((Ve) => {
      ze(Z, _e.message, (Rt) => {
        Ve(Rt ? _e.preprocess(fe) : fe);
      });
    })) }, ve = { getAnchors: (Z) => {
      const fe = Z.dom.select("a:not([href])"), _e = De(fe, (Ve) => {
        const Rt = Ve.name || Ve.id;
        return Rt ? [{
          text: Rt,
          value: "#" + Rt
        }] : [];
      });
      return _e.length > 0 ? Kt.some([{
        text: "None",
        value: ""
      }].concat(_e)) : Kt.none();
    } }, ue = { getClasses: (Z) => {
      const fe = kn(Z);
      return fe.length > 0 ? ye.sanitize(fe) : Kt.none();
    } }, he = (Z) => {
      try {
        return Kt.some(JSON.parse(Z));
      } catch {
        return Kt.none();
      }
    }, wt = { getLinks: (Z) => {
      const fe = (Ve) => Z.convertURL(Ve.value || Ve.url || "", "href"), _e = rn(Z);
      return new Promise((Ve) => {
        Fe(_e) ? fetch(_e).then((Rt) => Rt.ok ? Rt.text().then(he) : Promise.reject()).then(Ve, () => Ve(Kt.none())) : Zt(_e) ? _e((Rt) => Ve(Kt.some(Rt))) : Ve(Kt.from(_e));
      }).then((Ve) => Ve.bind(ye.sanitizeWith(fe)).map((Rt) => Rt.length > 0 ? [{
        text: "None",
        value: ""
      }].concat(Rt) : Rt));
    } }, Ln = { getRels: (Z, fe) => {
      const _e = bt(Z);
      if (_e.length > 0) {
        const Ve = ho(fe, "_blank"), Rt = ot(Z) === !1, eo = (Is) => et(ye.getValue(Is), Ve);
        return (Rt ? ye.sanitizeWith(eo) : ye.sanitize)(_e);
      }
      return Kt.none();
    } }, On = [
      {
        text: "Current window",
        value: ""
      },
      {
        text: "New window",
        value: "_blank"
      }
    ], Mn = { getTargets: (Z) => {
      const fe = jo(Z);
      return Bt(fe) ? ye.sanitize(fe).orThunk(() => Kt.some(On)) : fe === !1 ? Kt.none() : Kt.some(On);
    } }, Kn = (Z, fe, _e) => {
      const Ve = Z.getAttrib(fe, _e);
      return Ve !== null && Ve.length > 0 ? Kt.some(Ve) : Kt.none();
    }, zo = (Z, fe) => {
      const _e = Z.dom, Rt = Dt(Z) ? Kt.some(rs(Z.selection, fe)) : Kt.none(), eo = fe.bind((qo) => Kt.from(_e.getAttrib(qo, "href"))), Ns = fe.bind((qo) => Kt.from(_e.getAttrib(qo, "target"))), Is = fe.bind((qo) => Kn(_e, qo, "rel")), Os = fe.bind((qo) => Kn(_e, qo, "class")), Ys = fe.bind((qo) => Kn(_e, qo, "title"));
      return {
        url: eo,
        text: Rt,
        title: Ys,
        target: Ns,
        rel: Is,
        linkClass: Os
      };
    }, Ra = { collect: (Z, fe) => wt.getLinks(Z).then((_e) => {
      const Ve = zo(Z, fe);
      return {
        anchor: Ve,
        catalogs: {
          targets: Mn.getTargets(Z),
          rels: Ln.getRels(Z, Ve.target),
          classes: ue.getClasses(Z),
          anchor: ve.getAnchors(Z),
          link: _e
        },
        optNode: fe,
        flags: { titleEnabled: $e(Z) }
      };
    }) }, ac = (Z, fe) => (_e) => {
      const Ve = _e.getData();
      if (!Ve.url.value) {
        Za(Z), _e.close();
        return;
      }
      const Rt = (Is) => Kt.from(Ve[Is]).filter((Os) => !ho(fe.anchor[Is], Os)), eo = {
        href: Ve.url.value,
        text: Rt("text"),
        target: Rt("target"),
        rel: Rt("rel"),
        class: Rt("linkClass"),
        title: Rt("title")
      }, Ns = {
        href: Ve.url.value,
        attach: Ve.url.meta !== void 0 && Ve.url.meta.attach ? Ve.url.meta.attach : En
      };
      _o.preprocess(Z, eo).then((Is) => {
        ga(Z, Ns, Is);
      }), _e.close();
    }, vc = (Z) => {
      const fe = qt(Z);
      return Ra.collect(Z, fe);
    }, lo = (Z, fe) => {
      const _e = Z.anchor, Ve = _e.url.getOr("");
      return {
        url: {
          value: Ve,
          meta: { original: { value: Ve } }
        },
        text: _e.text.getOr(""),
        title: _e.title.getOr(""),
        anchor: Ve,
        link: Ve,
        rel: _e.rel.getOr(""),
        target: _e.target.or(fe).getOr(""),
        linkClass: _e.linkClass.getOr("")
      };
    }, Fo = (Z, fe, _e) => {
      const Ve = [{
        name: "url",
        type: "urlinput",
        filetype: "file",
        label: "URL",
        picker_text: "Browse links"
      }], Rt = Z.anchor.text.map(() => ({
        name: "text",
        type: "input",
        label: "Text to display"
      })).toArray(), eo = Z.flags.titleEnabled ? [{
        name: "title",
        type: "input",
        label: "Title"
      }] : [], Ns = Kt.from(Ye(_e)), Is = lo(Z, Ns), Os = Z.catalogs, Ys = de.init(Is, Os);
      return {
        title: "Insert/Edit Link",
        size: "normal",
        body: {
          type: "panel",
          items: gn([
            Ve,
            Rt,
            eo,
            Te([
              Os.anchor.map(ye.createUi("anchor", "Anchors")),
              Os.rels.map(ye.createUi("rel", "Rel")),
              Os.targets.map(ye.createUi("target", "Open link in...")),
              Os.link.map(ye.createUi("link", "Link list")),
              Os.classes.map(ye.createUi("linkClass", "Class"))
            ])
          ])
        },
        buttons: [
          {
            type: "cancel",
            name: "cancel",
            text: "Cancel"
          },
          {
            type: "submit",
            name: "save",
            text: "Save",
            primary: !0
          }
        ],
        initialData: Is,
        onChange: (fr, { name: Na }) => {
          Ys.onChange(fr.getData, { name: Na }).each((ol) => {
            fr.setData(ol);
          });
        },
        onSubmit: fe
      };
    }, ms = (Z) => {
      vc(Z).then((_e) => {
        const Ve = ac(Z, _e);
        return Fo(_e, Ve, Z);
      }).then((_e) => {
        Z.windowManager.open(_e);
      });
    }, xa = (Z) => {
      Z.addCommand("mceLink", (fe, _e) => {
        _e?.dialog === !0 || !F(Z) ? ms(Z) : Z.dispatch("contexttoolbar-show", { toolbarKey: "quicklink" });
      });
    };
    var zr = tinymce.util.Tools.resolve("tinymce.util.VK");
    const mr = (Z, fe) => {
      document.body.appendChild(Z), Z.dispatchEvent(fe), document.body.removeChild(Z);
    }, Hs = (Z) => {
      const fe = document.createElement("a");
      fe.target = "_blank", fe.href = Z, fe.rel = "noreferrer noopener";
      const _e = document.createEvent("MouseEvents");
      _e.initMouseEvent("click", !0, !0, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), mr(fe, _e);
    }, Fa = (Z, fe) => Z.dom.getParent(fe, "a[href]"), nl = (Z) => Fa(Z, Z.selection.getStart()), Rs = (Z) => Z.altKey === !0 && Z.shiftKey === !1 && Z.ctrlKey === !1 && Z.metaKey === !1, ca = (Z, fe) => {
      if (fe) {
        const _e = Ie(fe);
        if (/^#/.test(_e)) {
          const Ve = Z.dom.select(_e);
          Ve.length && Z.selection.scrollIntoView(Ve[0], !0);
        } else
          Hs(fe.href);
      }
    }, Ia = (Z) => () => {
      Z.execCommand("mceLink", !1, { dialog: !0 });
    }, Pr = (Z) => () => {
      ca(Z, nl(Z));
    }, yc = (Z) => {
      Z.on("click", (fe) => {
        const _e = Fa(Z, fe.target);
        _e && zr.metaKeyPressed(fe) && (fe.preventDefault(), ca(Z, _e));
      }), Z.on("keydown", (fe) => {
        if (!fe.isDefaultPrevented() && fe.keyCode === 13 && Rs(fe)) {
          const _e = nl(Z);
          _e && (fe.preventDefault(), ca(Z, _e));
        }
      });
    }, Uc = (Z, fe) => (Z.on("NodeChange", fe), () => Z.off("NodeChange", fe)), Ta = (Z) => (fe) => {
      const _e = () => {
        fe.setActive(!Z.mode.isReadOnly() && ko(Z, Z.selection.getNode())), fe.setEnabled(Z.selection.isEditable());
      };
      return _e(), Uc(Z, _e);
    }, Ac = (Z) => (fe) => {
      const _e = () => {
        fe.setEnabled(Z.selection.isEditable());
      };
      return _e(), Uc(Z, _e);
    }, Oc = (Z) => (Z.selection.isCollapsed() ? Yr(Z.dom.getParents(Z.selection.getStart())) : Gs(Z.selection.getRng())).length === 1, vu = (Z) => (fe) => {
      const _e = () => fe.setEnabled(Oc(Z));
      return _e(), Uc(Z, _e);
    }, Dc = (Z) => (fe) => {
      const _e = (eo) => Ss(eo) || or(Z.selection.getRng()), Ve = Z.dom.getParents(Z.selection.getStart()), Rt = (eo) => {
        fe.setEnabled(_e(eo) && Z.selection.isEditable());
      };
      return Rt(Ve), Uc(Z, (eo) => Rt(eo.parents));
    }, yl = (Z) => {
      Z.addShortcut("Meta+K", "", () => {
        Z.execCommand("mceLink");
      });
    }, ja = (Z) => {
      Z.ui.registry.addToggleButton("link", {
        icon: "link",
        tooltip: "Insert/edit link",
        onAction: Ia(Z),
        onSetup: Ta(Z)
      }), Z.ui.registry.addButton("openlink", {
        icon: "new-tab",
        tooltip: "Open link",
        onAction: Pr(Z),
        onSetup: vu(Z)
      }), Z.ui.registry.addButton("unlink", {
        icon: "unlink",
        tooltip: "Remove link",
        onAction: () => Za(Z),
        onSetup: Dc(Z)
      });
    }, wi = (Z) => {
      Z.ui.registry.addMenuItem("openlink", {
        text: "Open link",
        icon: "new-tab",
        onAction: Pr(Z),
        onSetup: vu(Z)
      }), Z.ui.registry.addMenuItem("link", {
        icon: "link",
        text: "Link...",
        shortcut: "Meta+K",
        onSetup: Ac(Z),
        onAction: Ia(Z)
      }), Z.ui.registry.addMenuItem("unlink", {
        icon: "unlink",
        text: "Remove link",
        onAction: () => Za(Z),
        onSetup: Dc(Z)
      });
    }, Bi = (Z) => {
      const fe = "link unlink openlink", _e = "link";
      Z.ui.registry.addContextMenu("link", {
        update: (Ve) => Z.dom.isEditable(Ve) ? Ss(Z.dom.getParents(Ve, "a")) ? fe : _e : ""
      });
    }, Cl = (Z) => {
      const fe = (Rt) => {
        Rt.selection.collapse(!1);
      }, _e = (Rt) => {
        const eo = Z.selection.getNode();
        return Rt.setEnabled(ko(Z, eo)), En;
      }, Ve = (Rt) => {
        const eo = qt(Z), Ns = Dt(Z);
        if (eo.isNone() && Ns) {
          const Is = rs(Z.selection, eo);
          return Oe(Is.length === 0, Rt);
        } else
          return Kt.none();
      };
      Z.ui.registry.addContextForm("quicklink", {
        launch: {
          type: "contextformtogglebutton",
          icon: "link",
          tooltip: "Link",
          onSetup: Ta(Z)
        },
        label: "Link",
        predicate: (Rt) => Gn(Z) && ko(Z, Rt),
        initValue: () => qt(Z).fold(st(""), Ie),
        commands: [
          {
            type: "contextformtogglebutton",
            icon: "link",
            tooltip: "Link",
            primary: !0,
            onSetup: (Rt) => {
              const eo = Z.selection.getNode();
              return Rt.setActive(ko(Z, eo)), Ta(Z)(Rt);
            },
            onAction: (Rt) => {
              const eo = Rt.getValue(), Ns = Ve(eo);
              ga(Z, {
                href: eo,
                attach: En
              }, {
                href: eo,
                text: Ns,
                title: Kt.none(),
                rel: Kt.none(),
                target: Kt.none(),
                class: Kt.none()
              }), fe(Z), Rt.hide();
            }
          },
          {
            type: "contextformbutton",
            icon: "unlink",
            tooltip: "Remove link",
            onSetup: _e,
            onAction: (Rt) => {
              Za(Z), Rt.hide();
            }
          },
          {
            type: "contextformbutton",
            icon: "new-tab",
            tooltip: "Open link",
            onSetup: _e,
            onAction: (Rt) => {
              Pr(Z)(), Rt.hide();
            }
          }
        ]
      });
    };
    var Ju = () => {
      vt.add("link", (Z) => {
        mn(Z), ja(Z), wi(Z), Bi(Z), Cl(Z), yc(Z), xa(Z), yl(Z);
      });
    };
    Ju();
  })()), aK;
}
var iK;
function cX() {
  return iK || (iK = 1, aX()), rK;
}
cX();
var lK = {}, uK = {}, dK;
function iX() {
  return dK || (dK = 1, (function() {
    var vt = tinymce.util.Tools.resolve("tinymce.PluginManager");
    const Ot = (x, R, z) => {
      var ce;
      return z(x, R.prototype) ? !0 : ((ce = x.constructor) === null || ce === void 0 ? void 0 : ce.name) === R.name;
    }, Pt = (x) => {
      const R = typeof x;
      return x === null ? "null" : R === "object" && Array.isArray(x) ? "array" : R === "object" && Ot(x, String, (z, ce) => ce.isPrototypeOf(z)) ? "string" : R;
    }, yt = (x) => (R) => Pt(R) === x, Nt = (x) => (R) => typeof R === x, Wt = yt("string"), Fe = yt("object"), Ee = yt("array"), Bt = Nt("boolean"), fn = (x) => x == null, dn = (x) => !fn(x), Sn = Nt("function"), Ft = Nt("number"), Zt = () => {
    }, Qt = (x, R) => (z) => x(R(z)), En = (x) => () => x, st = (x, R) => x === R;
    function Pn(x, ...R) {
      return (...z) => {
        const ce = R.concat(z);
        return x.apply(null, ce);
      };
    }
    const Kt = (x) => (R) => !x(R), J = En(!1);
    class Qe {
      constructor(R, z) {
        this.tag = R, this.value = z;
      }
      static some(R) {
        return new Qe(!0, R);
      }
      static none() {
        return Qe.singletonNone;
      }
      fold(R, z) {
        return this.tag ? z(this.value) : R();
      }
      isSome() {
        return this.tag;
      }
      isNone() {
        return !this.tag;
      }
      map(R) {
        return this.tag ? Qe.some(R(this.value)) : Qe.none();
      }
      bind(R) {
        return this.tag ? R(this.value) : Qe.none();
      }
      exists(R) {
        return this.tag && R(this.value);
      }
      forall(R) {
        return !this.tag || R(this.value);
      }
      filter(R) {
        return !this.tag || R(this.value) ? this : Qe.none();
      }
      getOr(R) {
        return this.tag ? this.value : R;
      }
      or(R) {
        return this.tag ? this : R;
      }
      getOrThunk(R) {
        return this.tag ? this.value : R();
      }
      orThunk(R) {
        return this.tag ? this : R();
      }
      getOrDie(R) {
        if (this.tag)
          return this.value;
        throw new Error(R ?? "Called getOrDie on None");
      }
      static from(R) {
        return dn(R) ? Qe.some(R) : Qe.none();
      }
      getOrNull() {
        return this.tag ? this.value : null;
      }
      getOrUndefined() {
        return this.value;
      }
      each(R) {
        this.tag && R(this.value);
      }
      toArray() {
        return this.tag ? [this.value] : [];
      }
      toString() {
        return this.tag ? `some(${this.value})` : "none()";
      }
    }
    Qe.singletonNone = new Qe(!1);
    const xo = Array.prototype.slice, ht = Array.prototype.indexOf, U = Array.prototype.push, Tt = (x, R) => ht.call(x, R), Ht = (x, R) => Tt(x, R) > -1, gn = (x, R) => {
      for (let z = 0, ce = x.length; z < ce; z++) {
        const be = x[z];
        if (R(be, z))
          return !0;
      }
      return !1;
    }, De = (x, R) => {
      const z = x.length, ce = new Array(z);
      for (let be = 0; be < z; be++) {
        const At = x[be];
        ce[be] = R(At, be);
      }
      return ce;
    }, re = (x, R) => {
      for (let z = 0, ce = x.length; z < ce; z++) {
        const be = x[z];
        R(be, z);
      }
    }, ho = (x, R) => {
      const z = [];
      for (let ce = 0, be = x.length; ce < be; ce++) {
        const At = x[ce];
        R(At, ce) && z.push(At);
      }
      return z;
    }, Te = (x, R) => {
      if (x.length === 0)
        return [];
      {
        let z = R(x[0]);
        const ce = [];
        let be = [];
        for (let At = 0, Bn = x.length; At < Bn; At++) {
          const To = x[At], Co = R(To);
          Co !== z && (ce.push(be), be = []), z = Co, be.push(To);
        }
        return be.length !== 0 && ce.push(be), ce;
      }
    }, Oe = (x, R, z) => (re(x, (ce, be) => {
      z = R(z, ce, be);
    }), z), A = (x, R, z) => {
      for (let ce = 0, be = x.length; ce < be; ce++) {
        const At = x[ce];
        if (R(At, ce))
          return Qe.some(At);
        if (z(At, ce))
          break;
      }
      return Qe.none();
    }, mn = (x, R) => A(x, R, J), it = (x) => {
      const R = [];
      for (let z = 0, ce = x.length; z < ce; ++z) {
        if (!Ee(x[z]))
          throw new Error("Arr.flatten item " + z + " was not an array, input: " + x);
        U.apply(R, x[z]);
      }
      return R;
    }, Gn = (x, R) => it(De(x, R)), rn = (x) => {
      const R = xo.call(x, 0);
      return R.reverse(), R;
    }, Ye = (x, R) => R >= 0 && R < x.length ? Qe.some(x[R]) : Qe.none(), io = (x) => Ye(x, 0), jo = (x) => Ye(x, x.length - 1), bt = (x, R) => {
      const z = [], ce = Sn(R) ? (be) => gn(z, (At) => R(At, be)) : (be) => Ht(z, be);
      for (let be = 0, At = x.length; be < At; be++) {
        const Bn = x[be];
        ce(Bn) || z.push(Bn);
      }
      return z;
    }, kn = (x, R, z = st) => x.exists((ce) => z(ce, R)), $e = (x, R, z = st) => ot(x, R, z).getOr(x.isNone() && R.isNone()), ot = (x, R, z) => x.isSome() && R.isSome() ? Qe.some(z(x.getOrDie(), R.getOrDie())) : Qe.none(), F = 8, ss = 9, fo = 11, at = 1, lt = 3, Rn = (x, R) => {
      const ce = (R || document).createElement("div");
      if (ce.innerHTML = x, !ce.hasChildNodes() || ce.childNodes.length > 1) {
        const be = "HTML does not have a single root node";
        throw new Error(be);
      }
      return ye(ce.childNodes[0]);
    }, ee = (x, R) => {
      const ce = (R || document).createElement(x);
      return ye(ce);
    }, pe = (x, R) => {
      const ce = (R || document).createTextNode(x);
      return ye(ce);
    }, ye = (x) => {
      if (x == null)
        throw new Error("Node cannot be null or undefined");
      return { dom: x };
    }, kt = {
      fromHtml: Rn,
      fromTag: ee,
      fromText: pe,
      fromDom: ye,
      fromPoint: (x, R, z) => Qe.from(x.dom.elementFromPoint(R, z)).map(ye)
    }, Vn = (x, R) => {
      const z = x.dom;
      if (z.nodeType !== at)
        return !1;
      {
        const ce = z;
        if (ce.matches !== void 0)
          return ce.matches(R);
        if (ce.msMatchesSelector !== void 0)
          return ce.msMatchesSelector(R);
        if (ce.webkitMatchesSelector !== void 0)
          return ce.webkitMatchesSelector(R);
        if (ce.mozMatchesSelector !== void 0)
          return ce.mozMatchesSelector(R);
        throw new Error("Browser lacks native selectors");
      }
    }, Yt = (x, R) => x.dom === R.dom, Ct = (x, R) => {
      const z = x.dom, ce = R.dom;
      return z === ce ? !1 : z.contains(ce);
    }, Xe = Vn, In = typeof window < "u" ? window : Function("return this;")(), hn = (x, R) => {
      let z = R ?? In;
      for (let ce = 0; ce < x.length && z !== void 0 && z !== null; ++ce)
        z = z[x[ce]];
      return z;
    }, Xn = (x, R) => {
      const z = x.split(".");
      return hn(z, R);
    }, Xo = (x, R) => Xn(x, R), ds = (x, R) => {
      const z = Xo(x, R);
      if (z == null)
        throw new Error(x + " not available on this browser");
      return z;
    }, No = Object.getPrototypeOf, Ao = (x) => ds("HTMLElement", x), Cs = (x) => {
      const R = Xn("ownerDocument.defaultView", x);
      return Fe(x) && (Ao(R).prototype.isPrototypeOf(x) || /^HTML\w*Element$/.test(No(x).constructor.name));
    }, Ie = (x) => x.dom.nodeName.toLowerCase(), et = (x) => x.dom.nodeType, nn = (x) => (R) => et(R) === x, qt = (x) => et(x) === F || Ie(x) === "#comment", ko = (x) => rs(x) && Cs(x.dom), rs = nn(at), Gs = nn(lt), Yr = nn(ss), Ss = nn(fo), or = (x) => (R) => rs(R) && Ie(R) === x, Dt = (x) => kt.fromDom(x.dom.ownerDocument), Lo = (x) => Yr(x) ? x : Dt(x), Or = (x) => Qe.from(x.dom.parentNode).map(kt.fromDom), aa = (x) => Qe.from(x.dom.parentElement).map(kt.fromDom), Xr = (x) => Qe.from(x.dom.nextSibling).map(kt.fromDom), Jr = (x) => De(x.dom.childNodes, kt.fromDom), xs = (x, R) => {
      const z = x.dom.childNodes;
      return Qe.from(z[R]).map(kt.fromDom);
    }, fa = (x) => xs(x, 0), Qr = (x) => xs(x, x.dom.childNodes.length - 1), Ts = (x) => Ss(x) && dn(x.dom.host), dr = Sn(Element.prototype.attachShadow) && Sn(Node.prototype.getRootNode) ? (x) => kt.fromDom(x.dom.getRootNode()) : Lo, ga = (x) => {
      const R = dr(x);
      return Ts(R) ? Qe.some(R) : Qe.none();
    }, Za = (x) => kt.fromDom(x.dom.host), _c = (x) => {
      const R = Gs(x) ? x.dom.parentNode : x.dom;
      if (R == null || R.ownerDocument === null)
        return !1;
      const z = R.ownerDocument;
      return ga(kt.fromDom(R)).fold(() => z.body.contains(R), Qt(_c, Za));
    };
    var sr = (x, R, z, ce, be) => x(z, ce) ? Qe.some(z) : Sn(be) && be(z) ? Qe.none() : R(z, ce, be);
    const Ks = (x, R, z) => {
      let ce = x.dom;
      const be = Sn(z) ? z : J;
      for (; ce.parentNode; ) {
        ce = ce.parentNode;
        const At = kt.fromDom(ce);
        if (R(At))
          return Qe.some(At);
        if (be(At))
          break;
      }
      return Qe.none();
    }, Vs = (x, R, z) => sr((be, At) => At(be), Ks, x, R, z), Sa = (x, R, z) => Ks(x, (ce) => Vn(ce, R), z), rc = (x, R, z) => sr((be, At) => Vn(be, At), Sa, x, R, z), wr = (x) => rc(x, "[contenteditable]"), de = (x, R = !1) => _c(x) ? x.dom.isContentEditable : wr(x).fold(En(R), (z) => ie(z) === "true"), ie = (x) => x.dom.contentEditable, ze = (x, R) => {
      Or(x).each((ce) => {
        ce.dom.insertBefore(R.dom, x.dom);
      });
    }, Je = (x, R) => {
      Xr(x).fold(() => {
        Or(x).each((be) => {
          Wn(be, R);
        });
      }, (ce) => {
        ze(ce, R);
      });
    }, Nn = (x, R) => {
      fa(x).fold(() => {
        Wn(x, R);
      }, (ce) => {
        x.dom.insertBefore(R.dom, ce.dom);
      });
    }, Wn = (x, R) => {
      x.dom.appendChild(R.dom);
    }, _o = (x, R) => {
      re(R, (z) => {
        ze(x, z);
      });
    }, Fs = (x, R) => {
      re(R, (z) => {
        Wn(x, z);
      });
    }, ve = (x) => {
      x.dom.textContent = "", re(Jr(x), (R) => {
        go(R);
      });
    }, go = (x) => {
      const R = x.dom;
      R.parentNode !== null && R.parentNode.removeChild(R);
    };
    var ue = tinymce.util.Tools.resolve("tinymce.dom.RangeUtils"), he = tinymce.util.Tools.resolve("tinymce.dom.TreeWalker"), dt = tinymce.util.Tools.resolve("tinymce.util.VK");
    const wt = (x) => De(x, kt.fromDom), on = Object.keys, Ln = (x, R) => {
      const z = on(x);
      for (let ce = 0, be = z.length; ce < be; ce++) {
        const At = z[ce], Bn = x[At];
        R(Bn, At);
      }
    }, On = (x) => (R, z) => {
      x[z] = R;
    }, Dn = (x, R, z, ce) => {
      Ln(x, (be, At) => {
        (R(be, At) ? z : ce)(be, At);
      });
    }, Mn = (x, R) => {
      const z = {};
      return Dn(x, R, On(z), Zt), z;
    }, Kn = (x, R, z) => {
      if (Wt(z) || Bt(z) || Ft(z))
        x.setAttribute(R, z + "");
      else
        throw new Error("Attribute value was not simple");
    }, zo = (x, R) => {
      const z = x.dom;
      Ln(R, (ce, be) => {
        Kn(z, be, ce);
      });
    }, Ds = (x) => Oe(x.dom.attributes, (R, z) => (R[z.name] = z.value, R), {}), Ra = (x, R) => kt.fromDom(x.dom.cloneNode(R)), ac = (x) => Ra(x, !0), vc = (x, R) => {
      const z = kt.fromTag(R), ce = Ds(x);
      return zo(z, ce), z;
    }, lo = (x, R) => {
      const z = vc(x, R);
      Je(x, z);
      const ce = Jr(x);
      return Fs(z, ce), go(x), z;
    };
    var Fo = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils"), ms = tinymce.util.Tools.resolve("tinymce.util.Tools");
    const xa = (x) => (R) => dn(R) && R.nodeName.toLowerCase() === x, zr = (x) => (R) => dn(R) && x.test(R.nodeName), mr = (x) => dn(x) && x.nodeType === 3, Hs = (x) => dn(x) && x.nodeType === 1, Fa = zr(/^(OL|UL|DL)$/), nl = zr(/^(OL|UL)$/), Rs = xa("ol"), ca = zr(/^(LI|DT|DD)$/), Ia = zr(/^(DT|DD)$/), Pr = zr(/^(TH|TD)$/), yc = xa("br"), Uc = (x) => {
      var R;
      return ((R = x.parentNode) === null || R === void 0 ? void 0 : R.firstChild) === x;
    }, Ta = (x, R) => dn(R) && R.nodeName in x.schema.getTextBlockElements(), Ac = (x, R) => dn(x) && x.nodeName in R, Oc = (x, R) => dn(R) && R.nodeName in x.schema.getVoidElements(), vu = (x, R) => yc(R) ? x.isBlock(R.nextSibling) && !yc(R.previousSibling) : !1, Dc = (x, R, z) => {
      const ce = x.isEmpty(R);
      return z && x.select("span[data-mce-type=bookmark]", R).length > 0 ? !1 : ce;
    }, yl = (x, R) => x.isChildOf(R, x.getRoot()), ja = (x) => (R) => R.options.get(x), wi = (x) => {
      const R = x.options.register;
      R("lists_indent_on_tab", {
        processor: "boolean",
        default: !0
      });
    }, Bi = ja("lists_indent_on_tab"), Cl = ja("forced_root_block"), Ju = ja("forced_root_block_attrs"), Z = (x, R) => {
      const z = x.dom, ce = x.schema.getBlockElements(), be = z.createFragment(), At = Cl(x), Bn = Ju(x);
      let To, Co, ao = !1;
      for (Co = z.create(At, Bn), Ac(R.firstChild, ce) || be.appendChild(Co); To = R.firstChild; ) {
        const Nr = To.nodeName;
        !ao && (Nr !== "SPAN" || To.getAttribute("data-mce-type") !== "bookmark") && (ao = !0), Ac(To, ce) ? (be.appendChild(To), Co = null) : (Co || (Co = z.create(At, Bn), be.appendChild(Co)), Co.appendChild(To));
      }
      return !ao && Co && Co.appendChild(z.create("br", { "data-mce-bogus": "1" })), be;
    }, fe = Fo.DOM, _e = (x, R, z) => {
      const ce = (ao) => {
        const Nr = ao.parentNode;
        Nr && ms.each(be, (Ma) => {
          Nr.insertBefore(Ma, z.parentNode);
        }), fe.remove(ao);
      }, be = fe.select('span[data-mce-type="bookmark"]', R), At = Z(x, z), Bn = fe.createRng();
      Bn.setStartAfter(z), Bn.setEndAfter(R);
      const To = Bn.extractContents();
      for (let ao = To.firstChild; ao; ao = ao.firstChild)
        if (ao.nodeName === "LI" && x.dom.isEmpty(ao)) {
          fe.remove(ao);
          break;
        }
      x.dom.isEmpty(To) || fe.insertAfter(To, R), fe.insertAfter(At, R);
      const Co = z.parentElement;
      Co && Dc(x.dom, Co) && ce(Co), fe.remove(z), Dc(x.dom, R) && fe.remove(R);
    }, Ve = or("dd"), Rt = or("dt"), eo = (x, R) => {
      Ve(R) ? lo(R, "dt") : Rt(R) && aa(R).each((z) => _e(x, z.dom, R.dom));
    }, Ns = (x) => {
      Rt(x) && lo(x, "dd");
    }, Is = (x, R, z) => {
      R === "Indent" ? re(z, Ns) : re(z, (ce) => eo(x, ce));
    }, Os = (x, R) => {
      if (mr(x))
        return {
          container: x,
          offset: R
        };
      const z = ue.getNode(x, R);
      return mr(z) ? {
        container: z,
        offset: R >= x.childNodes.length ? z.data.length : 0
      } : z.previousSibling && mr(z.previousSibling) ? {
        container: z.previousSibling,
        offset: z.previousSibling.data.length
      } : z.nextSibling && mr(z.nextSibling) ? {
        container: z.nextSibling,
        offset: 0
      } : {
        container: x,
        offset: R
      };
    }, Ys = (x) => {
      const R = x.cloneRange(), z = Os(x.startContainer, x.startOffset);
      R.setStart(z.container, z.offset);
      const ce = Os(x.endContainer, x.endOffset);
      return R.setEnd(ce.container, ce.offset), R;
    }, qo = [
      "OL",
      "UL",
      "DL"
    ], fr = qo.join(","), Na = (x, R) => {
      const z = R || x.selection.getStart(!0);
      return x.dom.getParent(z, fr, en(x, z));
    }, ol = (x, R) => dn(x) && R.length === 1 && R[0] === x, sn = (x) => ho(x.querySelectorAll(fr), Fa), Ql = (x) => {
      const R = Na(x), z = x.selection.getSelectedBlocks();
      return ol(R, z) ? sn(R) : ho(z, (ce) => Fa(ce) && R !== ce);
    }, rr = (x, R) => {
      const z = ms.map(R, (ce) => {
        const be = x.dom.getParent(ce, "li,dd,dt", en(x, ce));
        return be || ce;
      });
      return bt(z);
    }, B = (x) => {
      const R = x.selection.getSelectedBlocks();
      return ho(rr(x, R), ca);
    }, K = (x) => ho(B(x), Ia), se = (x, R) => {
      const z = x.dom.getParents(R, "TD,TH");
      return z.length > 0 ? z[0] : x.getBody();
    }, Ue = (x, R) => !Fa(R) && !ca(R) && gn(qo, (z) => x.isValidChild(R.nodeName, z)), en = (x, R) => {
      const z = x.dom.getParents(R, x.dom.isBlock);
      return mn(z, (be) => Ue(x.schema, be)).getOr(x.getBody());
    }, Io = (x) => Or(x).exists((R) => ca(R.dom) && fa(R).exists((z) => !Fa(z.dom)) && Qr(R).exists((z) => !Fa(z.dom))), _n = (x, R) => {
      const z = x.dom.getParents(R, "ol,ul", en(x, R));
      return jo(z);
    }, gr = (x) => {
      const R = _n(x, x.selection.getStart()), z = ho(x.selection.getSelectedBlocks(), nl);
      return R.toArray().concat(z);
    }, _t = (x) => {
      const R = x.selection.getStart();
      return x.dom.getParents(R, "ol,ul", en(x, R));
    }, Us = (x) => {
      const R = gr(x), z = _t(x);
      return mn(z, (ce) => Io(kt.fromDom(ce))).fold(() => qa(x, R), (ce) => [ce]);
    }, qa = (x, R) => {
      const z = De(R, (ce) => _n(x, ce).getOr(ce));
      return bt(z);
    }, Xs = (x) => /\btox\-/.test(x.className), Zr = (x, R) => A(x, Fa, Pr).exists((z) => z.nodeName === R && !Xs(z)), ri = (x, R) => R !== null && !x.dom.isEditable(R), Jo = (x) => {
      const R = Na(x);
      return ri(x, R);
    }, Ga = (x, R) => {
      const z = x.dom.getParent(R, "ol,ul,dl");
      return ri(x, z);
    }, ar = (x, R) => {
      const z = x.selection.getNode();
      return R({
        parents: x.dom.getParents(z),
        element: z
      }), x.on("NodeChange", R), () => x.off("NodeChange", R);
    }, $i = (x, R) => {
      const ce = document.createDocumentFragment();
      return re(x, (be) => {
        ce.appendChild(be.dom);
      }), kt.fromDom(ce);
    }, hr = (x, R, z) => x.dispatch("ListMutation", {
      action: R,
      element: z
    }), um = ((x) => (R) => R.replace(x, ""))(/^\s+|\s+$/g), Xm = (x) => x.length > 0, Es = (x) => !Xm(x), ai = (x) => x.style !== void 0 && Sn(x.style.getPropertyValue), Fi = (x, R, z) => {
      if (!Wt(z))
        throw new Error("CSS value must be a string: " + z);
      ai(x) && x.style.setProperty(R, z);
    }, Cc = (x, R, z) => {
      const ce = x.dom;
      Fi(ce, R, z);
    }, Rc = (x) => Xe(x, "OL,UL"), Qu = (x) => Xe(x, "LI"), Qo = (x) => fa(x).exists(Rc), j = (x) => Qr(x).exists(Rc), oe = (x) => "listAttributes" in x, Le = (x) => "isComment" in x, je = (x) => "isFragment" in x, yn = (x) => x.depth > 0, vo = (x) => x.isSelected, Dr = (x) => {
      const R = Jr(x), z = j(x) ? R.slice(0, -1) : R;
      return De(z, ac);
    }, Ka = (x, R, z) => Or(x).filter(rs).map((ce) => ({
      depth: R,
      dirty: !1,
      isSelected: z,
      content: Dr(x),
      itemAttributes: Ds(x),
      listAttributes: Ds(ce),
      listType: Ie(ce),
      isInPreviousLi: !1
    })), pr = (x, R) => {
      Wn(x.item, R.list);
    }, cc = (x) => {
      for (let R = 1; R < x.length; R++)
        pr(x[R - 1], x[R]);
    }, ks = (x, R) => {
      ot(jo(x), io(R), pr);
    }, Br = (x, R) => {
      const z = {
        list: kt.fromTag(R, x),
        item: kt.fromTag("li", x)
      };
      return Wn(z.list, z.item), z;
    }, ia = (x, R, z) => {
      const ce = [];
      for (let be = 0; be < z; be++)
        ce.push(Br(x, oe(R) ? R.listType : R.parentListType));
      return ce;
    }, wc = (x, R) => {
      for (let z = 0; z < x.length - 1; z++)
        Cc(x[z].item, "list-style-type", "none");
      jo(x).each((z) => {
        oe(R) && (zo(z.list, R.listAttributes), zo(z.item, R.itemAttributes)), Fs(z.item, R.content);
      });
    }, ea = (x, R) => {
      Ie(x.list) !== R.listType && (x.list = lo(x.list, R.listType)), zo(x.list, R.listAttributes);
    }, _r = (x, R, z) => {
      const ce = kt.fromTag("li", x);
      return zo(ce, R), Fs(ce, z), ce;
    }, Vr = (x, R) => {
      Wn(x.list, R), x.item = R;
    }, Nc = (x, R, z) => {
      const ce = R.slice(0, z.depth);
      return jo(ce).each((be) => {
        if (oe(z)) {
          const At = _r(x, z.itemAttributes, z.content);
          Vr(be, At), ea(be, z);
        } else if (je(z))
          Fs(be.item, z.content);
        else {
          const At = kt.fromHtml(`<!--${z.content}-->`);
          Wn(be.list, At);
        }
      }), ce;
    }, Ii = (x, R, z) => {
      const ce = ia(x, z, z.depth - R.length);
      return cc(ce), wc(ce, z), ks(R, ce), R.concat(ce);
    }, Jm = (x, R) => {
      let z = Qe.none();
      const ce = Oe(R, (be, At, Bn) => Le(At) ? Bn === 0 ? (z = Qe.some(At), be) : Nc(x, be, At) : At.depth > be.length ? Ii(x, be, At) : Nc(x, be, At), []);
      return z.each((be) => {
        const At = kt.fromHtml(`<!--${be.content}-->`);
        io(ce).each((Bn) => {
          Nn(Bn.list, At);
        });
      }), io(ce).map((be) => be.list);
    }, Qm = (x, R) => {
      switch (x) {
        case "Indent":
          R.depth++;
          break;
        case "Outdent":
          R.depth--;
          break;
        case "Flatten":
          R.depth = 0;
      }
      R.dirty = !0;
    }, Wc = (x, R) => {
      oe(x) && oe(R) && (x.listType = R.listType, x.listAttributes = { ...R.listAttributes });
    }, ef = (x) => {
      x.listAttributes = Mn(x.listAttributes, (R, z) => z !== "start");
    }, Zc = (x, R) => {
      const z = x[R].depth, ce = (At) => At.depth === z && !At.dirty, be = (At) => At.depth < z;
      return A(rn(x.slice(0, R)), ce, be).orThunk(() => A(x.slice(R + 1), ce, be));
    }, wl = (x) => (re(x, (R, z) => {
      Zc(x, z).fold(() => {
        R.dirty && oe(R) && ef(R);
      }, (ce) => Wc(R, ce));
    }), x), tf = (x) => {
      let R = x;
      return {
        get: () => R,
        set: (be) => {
          R = be;
        }
      };
    }, Cu = (x, R, z, ce) => {
      var be;
      if (qt(ce))
        return [{
          depth: x + 1,
          content: (be = ce.dom.nodeValue) !== null && be !== void 0 ? be : "",
          dirty: !1,
          isSelected: !1,
          isComment: !0
        }];
      R.each((To) => {
        Yt(To.start, ce) && z.set(!0);
      });
      const At = Ka(ce, x, z.get());
      R.each((To) => {
        Yt(To.end, ce) && z.set(!1);
      });
      const Bn = Qr(ce).filter(Rc).map((To) => Sl(x, R, z, To)).getOr([]);
      return At.toArray().concat(Bn);
    }, dm = (x, R, z, ce) => fa(ce).filter(Rc).fold(() => Cu(x, R, z, ce), (be) => {
      const At = Oe(Jr(ce), (Bn, To, Co) => {
        if (Co === 0)
          return Bn;
        if (Qu(To))
          return Bn.concat(Cu(x, R, z, To));
        {
          const ao = {
            isFragment: !0,
            depth: x,
            content: [To],
            isSelected: !1,
            dirty: !1,
            parentListType: Ie(be)
          };
          return Bn.concat(ao);
        }
      }, []);
      return Sl(x, R, z, be).concat(At);
    }), Sl = (x, R, z, ce) => Gn(Jr(ce), (be) => {
      const At = Rc(be) ? Sl : dm, Bn = x + 1;
      return At(Bn, R, z, be);
    }), oh = (x, R) => {
      const z = tf(!1), ce = 0;
      return De(x, (be) => ({
        sourceList: be,
        entries: Sl(ce, R, z, be)
      }));
    }, wu = (x, R) => {
      const z = wl(R);
      return De(z, (ce) => {
        const be = Le(ce) ? $i([kt.fromHtml(`<!--${ce.content}-->`)]) : $i(ce.content);
        return kt.fromDom(Z(x, be.dom));
      });
    }, sh = (x, R) => {
      const z = wl(R);
      return Jm(x.contentDocument, z).toArray();
    }, rh = (x, R) => Gn(Te(R, yn), (z) => io(z).exists(yn) ? sh(x, z) : wu(x, z)), ah = (x, R) => {
      re(ho(x, vo), (z) => Qm(R, z));
    }, Ad = (x) => {
      const R = De(B(x), kt.fromDom);
      return ot(mn(R, Kt(Qo)), mn(rn(R), Kt(Qo)), (z, ce) => ({
        start: z,
        end: ce
      }));
    }, o1 = (x, R, z) => {
      const ce = oh(R, Ad(x));
      re(ce, (be) => {
        ah(be.entries, z);
        const At = rh(x, be.entries);
        re(At, (Bn) => {
          hr(x, z === "Indent" ? "IndentList" : "OutdentList", Bn.dom);
        }), _o(be.sourceList, At), go(be.sourceList);
      });
    }, le = (x, R) => {
      const z = wt(Us(x)), ce = wt(K(x));
      let be = !1;
      if (z.length || ce.length) {
        const At = x.selection.getBookmark();
        o1(x, z, R), Is(x, R, ce), x.selection.moveToBookmark(At), x.selection.setRng(Ys(x.selection.getRng())), x.nodeChanged(), be = !0;
      }
      return be;
    }, Su = (x, R) => !Jo(x) && le(x, R), Si = (x) => Su(x, "Indent"), Od = (x) => Su(x, "Outdent"), tg = (x) => Su(x, "Flatten"), s1 = "\uFEFF", fs = (x) => x === s1, ic = (x, R, z) => Ks(x, R, z).isSome(), xl = (x, R) => ic(x, Pn(Yt, R));
    var xi = tinymce.util.Tools.resolve("tinymce.dom.BookmarkManager");
    const xu = Fo.DOM, sl = (x) => {
      const R = {}, z = (ce) => {
        let be = x[ce ? "startContainer" : "endContainer"], At = x[ce ? "startOffset" : "endOffset"];
        if (Hs(be)) {
          const Bn = xu.create("span", { "data-mce-type": "bookmark" });
          be.hasChildNodes() ? (At = Math.min(At, be.childNodes.length - 1), ce ? be.insertBefore(Bn, be.childNodes[At]) : xu.insertAfter(Bn, be.childNodes[At])) : be.appendChild(Bn), be = Bn, At = 0;
        }
        R[ce ? "startContainer" : "endContainer"] = be, R[ce ? "startOffset" : "endOffset"] = At;
      };
      return z(!0), x.collapsed || z(), R;
    }, lc = (x) => {
      const R = (ce) => {
        const be = (To) => {
          var Co;
          let ao = (Co = To.parentNode) === null || Co === void 0 ? void 0 : Co.firstChild, Nr = 0;
          for (; ao; ) {
            if (ao === To)
              return Nr;
            (!Hs(ao) || ao.getAttribute("data-mce-type") !== "bookmark") && Nr++, ao = ao.nextSibling;
          }
          return -1;
        };
        let At = x[ce ? "startContainer" : "endContainer"], Bn = x[ce ? "startOffset" : "endOffset"];
        if (At) {
          if (Hs(At) && At.parentNode) {
            const To = At;
            Bn = be(At), At = At.parentNode, xu.remove(To), !At.hasChildNodes() && xu.isBlock(At) && At.appendChild(xu.create("br"));
          }
          x[ce ? "startContainer" : "endContainer"] = At, x[ce ? "startOffset" : "endOffset"] = Bn;
        }
      };
      R(!0), R();
      const z = xu.createRng();
      return z.setStart(x.startContainer, x.startOffset), x.endContainer && z.setEnd(x.endContainer, x.endOffset), Ys(z);
    }, Tl = (x) => {
      switch (x) {
        case "UL":
          return "ToggleUlList";
        case "OL":
          return "ToggleOlList";
        case "DL":
          return "ToggleDLList";
      }
    }, ch = (x, R, z) => {
      const ce = z["list-style-type"] ? z["list-style-type"] : null;
      x.setStyle(R, "list-style-type", ce);
    }, r1 = (x, R) => {
      ms.each(R, (z, ce) => {
        x.setAttribute(ce, z);
      });
    }, Li = (x, R, z) => {
      r1(R, z["list-attributes"]), ms.each(x.select("li", R), (ce) => {
        r1(ce, z["list-item-attributes"]);
      });
    }, El = (x, R, z) => {
      ch(x, R, z), Li(x, R, z);
    }, ng = (x, R, z) => {
      ms.each(z, (ce) => x.setStyle(R, ce, ""));
    }, Sc = (x, R) => dn(R) && !Ac(R, x.schema.getBlockElements()), Ea = (x, R, z, ce) => {
      let be = R[z ? "startContainer" : "endContainer"];
      const At = R[z ? "startOffset" : "endOffset"];
      Hs(be) && (be = be.childNodes[Math.min(At, be.childNodes.length - 1)] || be), !z && yc(be.nextSibling) && (be = be.nextSibling);
      const Bn = (Co) => {
        for (; !x.dom.isBlock(Co) && Co.parentNode && ce !== Co; )
          Co = Co.parentNode;
        return Co;
      }, To = (Co, ao) => {
        var Nr;
        const Ma = new he(Co, Bn(Co)), ki = ao ? "next" : "prev";
        let eu;
        for (; eu = Ma[ki](); )
          if (!(Oc(x, eu) || fs(eu.textContent) || ((Nr = eu.textContent) === null || Nr === void 0 ? void 0 : Nr.length) === 0))
            return Qe.some(eu);
        return Qe.none();
      };
      if (z && mr(be))
        if (fs(be.textContent))
          be = To(be, !1).getOr(be);
        else
          for (be.parentNode !== null && Sc(x, be.parentNode) && (be = be.parentNode); be.previousSibling !== null && (Sc(x, be.previousSibling) || mr(be.previousSibling)); )
            be = be.previousSibling;
      if (!z && mr(be))
        if (fs(be.textContent))
          be = To(be, !0).getOr(be);
        else
          for (be.parentNode !== null && Sc(x, be.parentNode) && (be = be.parentNode); be.nextSibling !== null && (Sc(x, be.nextSibling) || mr(be.nextSibling)); )
            be = be.nextSibling;
      for (; be.parentNode !== ce; ) {
        const Co = be.parentNode;
        if (Ta(x, be) || /^(TD|TH)$/.test(Co.nodeName))
          return be;
        be = Co;
      }
      return be;
    }, ed = (x, R, z) => {
      const ce = [], be = x.dom, At = Ea(x, R, !0, z), Bn = Ea(x, R, !1, z);
      let To;
      const Co = [];
      for (let ao = At; ao && (Co.push(ao), ao !== Bn); ao = ao.nextSibling)
        ;
      return ms.each(Co, (ao) => {
        var Nr;
        if (Ta(x, ao)) {
          ce.push(ao), To = null;
          return;
        }
        if (be.isBlock(ao) || yc(ao)) {
          yc(ao) && be.remove(ao), To = null;
          return;
        }
        const Ma = ao.nextSibling;
        if (xi.isBookmarkNode(ao) && (Fa(Ma) || Ta(x, Ma) || !Ma && ao.parentNode === z)) {
          To = null;
          return;
        }
        To || (To = be.create("p"), (Nr = ao.parentNode) === null || Nr === void 0 || Nr.insertBefore(To, ao), ce.push(To)), To.appendChild(ao);
      }), ce;
    }, mm = (x, R, z) => {
      const ce = x.getStyle(R, "list-style-type");
      let be = z ? z["list-style-type"] : "";
      return be = be === null ? "" : be, ce === be;
    }, rl = (x, R) => {
      const z = x.selection.getStart(!0), ce = Ea(x, R, !0, x.getBody());
      return xl(kt.fromDom(ce), kt.fromDom(R.commonAncestorContainer)) ? R.commonAncestorContainer : z;
    }, Mc = (x, R, z) => {
      const ce = x.selection.getRng();
      let be = "LI";
      const At = en(x, rl(x, ce)), Bn = x.dom;
      if (Bn.getContentEditable(x.selection.getNode()) === "false")
        return;
      R = R.toUpperCase(), R === "DL" && (be = "DT");
      const To = sl(ce), Co = ho(ed(x, ce, At), x.dom.isEditable);
      ms.each(Co, (ao) => {
        let Nr;
        const Ma = ao.previousSibling, ki = ao.parentNode;
        ca(ki) || (Ma && Fa(Ma) && Ma.nodeName === R && mm(Bn, Ma, z) ? (Nr = Ma, ao = Bn.rename(ao, be), Ma.appendChild(ao)) : (Nr = Bn.create(R), ki.insertBefore(Nr, ao), Nr.appendChild(ao), ao = Bn.rename(ao, be)), ng(Bn, ao, [
          "margin",
          "margin-right",
          "margin-bottom",
          "margin-left",
          "margin-top",
          "padding",
          "padding-right",
          "padding-bottom",
          "padding-left",
          "padding-top"
        ]), El(Bn, Nr, z), Dd(x.dom, Nr));
      }), x.selection.setRng(lc(To));
    }, ih = (x, R) => Fa(x) && x.nodeName === R?.nodeName, a1 = (x, R, z) => {
      const ce = x.getStyle(R, "list-style-type", !0), be = x.getStyle(z, "list-style-type", !0);
      return ce === be;
    }, nf = (x, R) => x.className === R.className, of = (x, R, z) => ih(R, z) && a1(x, R, z) && nf(R, z), Dd = (x, R) => {
      let z, ce = R.nextSibling;
      if (of(x, R, ce)) {
        const be = ce;
        for (; z = be.firstChild; )
          R.appendChild(z);
        x.remove(be);
      }
      if (ce = R.previousSibling, of(x, R, ce)) {
        const be = ce;
        for (; z = be.lastChild; )
          R.insertBefore(z, R.firstChild);
        x.remove(be);
      }
    }, kl = (x, R, z, ce) => {
      if (R.nodeName !== z) {
        const be = x.dom.rename(R, z);
        El(x.dom, be, ce), hr(x, Tl(z), be);
      } else
        El(x.dom, R, ce), hr(x, Tl(z), R);
    }, lh = (x, R, z, ce) => {
      if (R.classList.forEach((be, At, Bn) => {
        be.startsWith("tox-") && (Bn.remove(be), Bn.length === 0 && R.removeAttribute("class"));
      }), R.nodeName !== z) {
        const be = x.dom.rename(R, z);
        El(x.dom, be, ce), hr(x, Tl(z), be);
      } else
        El(x.dom, R, ce), hr(x, Tl(z), R);
    }, Yb = (x, R, z, ce, be) => {
      const At = Fa(R);
      if (At && R.nodeName === ce && !og(be) && !Xs(R))
        tg(x);
      else {
        Mc(x, ce, be);
        const Bn = sl(x.selection.getRng()), To = At ? [
          R,
          ...z
        ] : z, Co = At && Xs(R) ? lh : kl;
        ms.each(To, (ao) => {
          Co(x, ao, ce, be);
        }), x.selection.setRng(lc(Bn));
      }
    }, og = (x) => "list-style-type" in x, c1 = (x, R, z, ce) => {
      if (R !== x.getBody())
        if (R)
          if (R.nodeName === z && !og(ce) && !Xs(R))
            tg(x);
          else {
            const be = sl(x.selection.getRng());
            Xs(R) && R.classList.forEach((Bn, To, Co) => {
              Bn.startsWith("tox-") && (Co.remove(Bn), Co.length === 0 && R.removeAttribute("class"));
            }), El(x.dom, R, ce);
            const At = x.dom.rename(R, z);
            Dd(x.dom, At), x.selection.setRng(lc(be)), Mc(x, z, ce), hr(x, Tl(z), At);
          }
        else
          Mc(x, z, ce), hr(x, Tl(z), R);
    }, Tu = (x, R, z) => {
      const ce = Na(x);
      if (Ga(x, ce))
        return;
      const be = Ql(x), At = Fe(z) ? z : {};
      be.length > 0 ? Yb(x, ce, be, R, At) : c1(x, ce, R, At);
    }, sg = Fo.DOM, td = (x, R) => {
      const z = R.parentElement;
      if (z && z.nodeName === "LI" && z.firstChild === R) {
        const ce = z.previousSibling;
        ce && ce.nodeName === "LI" ? (ce.appendChild(R), Dc(x, z) && sg.remove(z)) : sg.setStyle(z, "listStyleType", "none");
      }
      if (Fa(z)) {
        const ce = z.previousSibling;
        ce && ce.nodeName === "LI" && ce.appendChild(R);
      }
    }, Rr = (x, R) => {
      const z = ms.grep(x.select("ol,ul", R));
      ms.each(z, (ce) => {
        td(x, ce);
      });
    }, Ar = (x, R, z, ce) => {
      let be = R.startContainer;
      const At = R.startOffset;
      if (mr(be) && (z ? At < be.data.length : At > 0))
        return be;
      const Bn = x.schema.getNonEmptyElements();
      Hs(be) && (be = ue.getNode(be, At));
      const To = new he(be, ce);
      z && vu(x.dom, be) && To.next();
      const Co = z ? To.next.bind(To) : To.prev2.bind(To);
      for (; be = Co(); )
        if (be.nodeName === "LI" && !be.hasChildNodes() || Bn[be.nodeName] || mr(be) && be.data.length > 0)
          return be;
      return null;
    }, ci = (x, R) => {
      const z = R.childNodes;
      return z.length === 1 && !Fa(z[0]) && x.isBlock(z[0]);
    }, sf = (x) => Qe.from(x).map(kt.fromDom).filter(ko).exists((R) => de(R) && !Ht(["details"], Ie(R))), uh = (x, R) => {
      ci(x, R) && sf(R.firstChild) && x.remove(R.firstChild, !0);
    }, La = (x, R, z) => {
      let ce;
      const be = ci(x, z) ? z.firstChild : z;
      if (uh(x, R), !Dc(x, R, !0))
        for (; ce = R.firstChild; )
          be.appendChild(ce);
    }, _l = (x, R, z) => {
      let ce;
      const be = R.parentNode;
      if (!yl(x, R) || !yl(x, z))
        return;
      Fa(z.lastChild) && (ce = z.lastChild), be === z.lastChild && yc(be.previousSibling) && x.remove(be.previousSibling);
      const At = z.lastChild;
      At && yc(At) && R.hasChildNodes() && x.remove(At), Dc(x, z, !0) && ve(kt.fromDom(z)), La(x, R, z), ce && z.appendChild(ce);
      const To = Ct(kt.fromDom(z), kt.fromDom(R)) ? x.getParents(R, Fa, z) : [];
      x.remove(R), re(To, (Co) => {
        Dc(x, Co) && Co !== x.getRoot() && x.remove(Co);
      });
    }, ii = (x, R, z) => {
      ve(kt.fromDom(z)), _l(x.dom, R, z), x.selection.setCursorLocation(z, 0);
    }, Hi = (x, R, z, ce) => {
      const be = x.dom;
      if (be.isEmpty(ce))
        ii(x, z, ce);
      else {
        const At = sl(R);
        _l(be, z, ce), x.selection.setRng(lc(At));
      }
    }, dh = (x, R, z, ce) => {
      const be = sl(R);
      _l(x.dom, z, ce);
      const At = lc(be);
      x.selection.setRng(At);
    }, Mo = (x, R) => {
      const z = x.dom, ce = x.selection, be = ce.getStart(), At = se(x, be), Bn = z.getParent(ce.getStart(), "LI", At);
      if (Bn) {
        const To = Bn.parentElement;
        if (To === x.getBody() && Dc(z, To))
          return !0;
        const Co = Ys(ce.getRng()), ao = z.getParent(Ar(x, Co, R, At), "LI", At), Nr = ao && (R ? z.isChildOf(Bn, ao) : z.isChildOf(ao, Bn));
        if (ao && ao !== Bn && !Nr)
          return x.undoManager.transact(() => {
            R ? Hi(x, Co, ao, Bn) : Uc(Bn) ? Od(x) : dh(x, Co, Bn, ao);
          }), !0;
        if (Nr && !R && ao !== Bn)
          return x.undoManager.transact(() => {
            if (Co.commonAncestorContainer.parentElement) {
              const Ma = sl(Co), ki = Co.commonAncestorContainer.parentElement;
              La(z, Co.commonAncestorContainer.parentElement, ao), ki.remove();
              const eu = lc(Ma);
              x.selection.setRng(eu);
            }
          }), !0;
        if (!ao && !R && Co.startOffset === 0 && Co.endOffset === 0)
          return x.undoManager.transact(() => {
            tg(x);
          }), !0;
      }
      return !1;
    }, jc = (x, R, z) => {
      const ce = x.getParent(R.parentNode, x.isBlock, z);
      x.remove(R), ce && x.isEmpty(ce) && x.remove(ce);
    }, Eu = (x, R) => {
      const z = x.dom, ce = x.selection.getStart(), be = se(x, ce), At = z.getParent(ce, z.isBlock, be);
      if (At && z.isEmpty(At)) {
        const Bn = Ys(x.selection.getRng()), To = z.getParent(Ar(x, Bn, R, be), "LI", be);
        if (To) {
          const Co = (ki) => Ht([
            "td",
            "th",
            "caption"
          ], Ie(ki)), ao = (ki) => ki.dom === be, Nr = Vs(kt.fromDom(To), Co, ao), Ma = Vs(kt.fromDom(Bn.startContainer), Co, ao);
          return $e(Nr, Ma, Yt) ? (x.undoManager.transact(() => {
            const ki = To.parentNode;
            jc(z, At, be), Dd(z, ki), x.selection.select(To, !0), x.selection.collapse(R);
          }), !0) : !1;
        }
      }
      return !1;
    }, nd = (x, R) => Mo(x, R) || Eu(x, R), rg = (x) => {
      const R = x.selection.getStart(), z = se(x, R);
      return x.dom.getParent(R, "LI,DT,DD", z) || B(x).length > 0;
    }, rf = (x) => rg(x) ? (x.undoManager.transact(() => {
      x.execCommand("Delete"), Rr(x.dom, x.getBody());
    }), !0) : !1, Ya = (x, R) => {
      const z = x.selection;
      return !Ga(x, z.getNode()) && (z.isCollapsed() ? nd(x, R) : rf(x));
    }, ha = (x) => {
      x.on("ExecCommand", (R) => {
        const z = R.command.toLowerCase();
        (z === "delete" || z === "forwarddelete") && rg(x) && Rr(x.dom, x.getBody());
      }), x.on("keydown", (R) => {
        R.keyCode === dt.BACKSPACE ? Ya(x, !1) && R.preventDefault() : R.keyCode === dt.DELETE && Ya(x, !0) && R.preventDefault();
      });
    }, li = (x) => ({
      backspaceDelete: (R) => {
        Ya(x, R);
      }
    }), ta = (x, R) => {
      const z = Na(x);
      z === null || Ga(x, z) || x.undoManager.transact(() => {
        Fe(R.styles) && x.dom.setStyles(z, R.styles), Fe(R.attrs) && Ln(R.attrs, (ce, be) => x.dom.setAttrib(z, be, ce));
      });
    }, fm = (x) => {
      const R = rn(um(x).split("")), z = De(R, (ce, be) => {
        const At = ce.toUpperCase().charCodeAt(0) - 65 + 1;
        return Math.pow(26, be) * At;
      });
      return Oe(z, (ce, be) => ce + be, 0);
    }, od = (x) => {
      if (x--, x < 0)
        return "";
      {
        const R = x % 26, z = Math.floor(x / 26), ce = od(z), be = String.fromCharCode(65 + R);
        return ce + be;
      }
    }, na = (x) => /^[A-Z]+$/.test(x), ka = (x) => /^[a-z]+$/.test(x), Ti = (x) => /^[0-9]+$/.test(x), gm = (x) => Ti(x) ? 2 : na(x) ? 0 : ka(x) ? 1 : Es(x) ? 3 : 4, la = (x) => {
      switch (gm(x)) {
        case 2:
          return Qe.some({
            listStyleType: Qe.none(),
            start: x
          });
        case 0:
          return Qe.some({
            listStyleType: Qe.some("upper-alpha"),
            start: fm(x).toString()
          });
        case 1:
          return Qe.some({
            listStyleType: Qe.some("lower-alpha"),
            start: fm(x).toString()
          });
        case 3:
          return Qe.some({
            listStyleType: Qe.none(),
            start: ""
          });
        case 4:
          return Qe.none();
      }
    }, ag = (x) => {
      const R = parseInt(x.start, 10);
      return kn(x.listStyleType, "upper-alpha") ? od(R) : kn(x.listStyleType, "lower-alpha") ? od(R).toLowerCase() : x.start;
    }, af = (x) => {
      const R = Na(x);
      !Rs(R) || Ga(x, R) || x.windowManager.open({
        title: "List Properties",
        body: {
          type: "panel",
          items: [{
            type: "input",
            name: "start",
            label: "Start list at number",
            inputMode: "numeric"
          }]
        },
        initialData: {
          start: ag({
            start: x.dom.getAttrib(R, "start", "1"),
            listStyleType: Qe.from(x.dom.getStyle(R, "list-style-type"))
          })
        },
        buttons: [
          {
            type: "cancel",
            name: "cancel",
            text: "Cancel"
          },
          {
            type: "submit",
            name: "save",
            text: "Save",
            primary: !0
          }
        ],
        onSubmit: (z) => {
          const ce = z.getData();
          la(ce.start).each((be) => {
            x.execCommand("mceListUpdate", !1, {
              attrs: { start: be.start === "1" ? "" : be.start },
              styles: { "list-style-type": be.listStyleType.getOr("") }
            });
          }), z.close();
        }
      });
    }, Ms = (x, R) => () => {
      const z = Na(x);
      return dn(z) && z.nodeName === R;
    }, Ei = (x) => {
      x.addCommand("mceListProps", () => {
        af(x);
      });
    }, bs = (x) => {
      x.on("BeforeExecCommand", (R) => {
        const z = R.command.toLowerCase();
        z === "indent" ? Si(x) : z === "outdent" && Od(x);
      }), x.addCommand("InsertUnorderedList", (R, z) => {
        Tu(x, "UL", z);
      }), x.addCommand("InsertOrderedList", (R, z) => {
        Tu(x, "OL", z);
      }), x.addCommand("InsertDefinitionList", (R, z) => {
        Tu(x, "DL", z);
      }), x.addCommand("RemoveList", () => {
        tg(x);
      }), Ei(x), x.addCommand("mceListUpdate", (R, z) => {
        Fe(z) && ta(x, z);
      }), x.addQueryStateHandler("InsertUnorderedList", Ms(x, "UL")), x.addQueryStateHandler("InsertOrderedList", Ms(x, "OL")), x.addQueryStateHandler("InsertDefinitionList", Ms(x, "DL"));
    };
    var qc = tinymce.util.Tools.resolve("tinymce.html.Node");
    const ku = (x) => x.type === 3, _u = (x) => x.length === 0, Wo = (x) => {
      const R = (be, At) => {
        const Bn = qc.create("li");
        re(be, (To) => Bn.append(To)), At ? x.insert(Bn, At, !0) : x.append(Bn);
      }, z = (be, At) => ku(At) ? [
        ...be,
        At
      ] : !_u(be) && !ku(At) ? (R(be, At), []) : be, ce = Oe(x.children(), z, []);
      _u(ce) || R(ce);
    }, sd = (x) => {
      x.on("PreInit", () => {
        const { parser: R } = x;
        R.addNodeFilter("ul,ol", (z) => re(z, Wo));
      });
    }, mh = (x) => {
      x.on("keydown", (R) => {
        R.keyCode !== dt.TAB || dt.metaKeyPressed(R) || x.undoManager.transact(() => {
          (R.shiftKey ? Od(x) : Si(x)) && R.preventDefault();
        });
      });
    }, cg = (x) => {
      Bi(x) && mh(x), ha(x);
    }, fh = (x, R) => (z) => {
      const ce = (be) => {
        z.setActive(Zr(be.parents, R)), z.setEnabled(!Ga(x, be.element) && x.selection.isEditable());
      };
      return z.setEnabled(x.selection.isEditable()), ar(x, ce);
    }, ig = (x) => {
      const R = (z) => () => x.execCommand(z);
      x.hasPlugin("advlist") || (x.ui.registry.addToggleButton("numlist", {
        icon: "ordered-list",
        active: !1,
        tooltip: "Numbered list",
        onAction: R("InsertOrderedList"),
        onSetup: fh(x, "OL")
      }), x.ui.registry.addToggleButton("bullist", {
        icon: "unordered-list",
        active: !1,
        tooltip: "Bullet list",
        onAction: R("InsertUnorderedList"),
        onSetup: fh(x, "UL")
      }));
    }, i1 = (x, R) => (z) => ar(x, (be) => z.setEnabled(Zr(be.parents, R) && !Ga(x, be.element))), Rd = (x) => {
      const R = {
        text: "List properties...",
        icon: "ordered-list",
        onAction: () => x.execCommand("mceListProps"),
        onSetup: i1(x, "OL")
      };
      x.ui.registry.addMenuItem("listprops", R), x.ui.registry.addContextMenu("lists", {
        update: (z) => {
          const ce = Na(x, z);
          return Rs(ce) ? ["listprops"] : [];
        }
      });
    };
    var lg = () => {
      vt.add("lists", (x) => (wi(x), sd(x), x.hasPlugin("rtc", !0) ? Ei(x) : (cg(x), bs(x)), ig(x), Rd(x), li(x)));
    };
    lg();
  })()), uK;
}
var mK;
function lX() {
  return mK || (mK = 1, iX()), lK;
}
lX();
var fK = {}, gK = {}, hK;
function uX() {
  return hK || (hK = 1, (function() {
    var vt = tinymce.util.Tools.resolve("tinymce.PluginManager");
    const Ot = (de, ie, ze) => {
      var Je;
      return ze(de, ie.prototype) ? !0 : ((Je = de.constructor) === null || Je === void 0 ? void 0 : Je.name) === ie.name;
    }, Pt = (de) => {
      const ie = typeof de;
      return de === null ? "null" : ie === "object" && Array.isArray(de) ? "array" : ie === "object" && Ot(de, String, (ze, Je) => Je.isPrototypeOf(ze)) ? "string" : ie;
    }, yt = (de) => (ie) => Pt(ie) === de, Nt = yt("string"), Wt = yt("object"), Fe = yt("array"), Ee = (de) => de == null, Bt = (de) => !Ee(de);
    class fn {
      constructor(ie, ze) {
        this.tag = ie, this.value = ze;
      }
      static some(ie) {
        return new fn(!0, ie);
      }
      static none() {
        return fn.singletonNone;
      }
      fold(ie, ze) {
        return this.tag ? ze(this.value) : ie();
      }
      isSome() {
        return this.tag;
      }
      isNone() {
        return !this.tag;
      }
      map(ie) {
        return this.tag ? fn.some(ie(this.value)) : fn.none();
      }
      bind(ie) {
        return this.tag ? ie(this.value) : fn.none();
      }
      exists(ie) {
        return this.tag && ie(this.value);
      }
      forall(ie) {
        return !this.tag || ie(this.value);
      }
      filter(ie) {
        return !this.tag || ie(this.value) ? this : fn.none();
      }
      getOr(ie) {
        return this.tag ? this.value : ie;
      }
      or(ie) {
        return this.tag ? this : ie;
      }
      getOrThunk(ie) {
        return this.tag ? this.value : ie();
      }
      orThunk(ie) {
        return this.tag ? this : ie();
      }
      getOrDie(ie) {
        if (this.tag)
          return this.value;
        throw new Error(ie ?? "Called getOrDie on None");
      }
      static from(ie) {
        return Bt(ie) ? fn.some(ie) : fn.none();
      }
      getOrNull() {
        return this.tag ? this.value : null;
      }
      getOrUndefined() {
        return this.value;
      }
      each(ie) {
        this.tag && ie(this.value);
      }
      toArray() {
        return this.tag ? [this.value] : [];
      }
      toString() {
        return this.tag ? `some(${this.value})` : "none()";
      }
    }
    fn.singletonNone = new fn(!1);
    const dn = Array.prototype.push, Sn = (de, ie) => {
      for (let ze = 0, Je = de.length; ze < Je; ze++) {
        const Nn = de[ze];
        ie(Nn, ze);
      }
    }, Ft = (de) => {
      const ie = [];
      for (let ze = 0, Je = de.length; ze < Je; ++ze) {
        if (!Fe(de[ze]))
          throw new Error("Arr.flatten item " + ze + " was not an array, input: " + de);
        dn.apply(ie, de[ze]);
      }
      return ie;
    }, Zt = (de) => {
      let ie = de;
      return {
        get: () => ie,
        set: (Nn) => {
          ie = Nn;
        }
      };
    }, Qt = Object.keys, En = Object.hasOwnProperty, st = (de, ie) => {
      const ze = Qt(de);
      for (let Je = 0, Nn = ze.length; Je < Nn; Je++) {
        const Wn = ze[Je], _o = de[Wn];
        ie(_o, Wn);
      }
    }, Pn = (de, ie) => Kt(de, ie) ? fn.from(de[ie]) : fn.none(), Kt = (de, ie) => En.call(de, ie), J = (de) => (ie) => ie.options.get(de), Qe = (de) => {
      const ie = de.options.register;
      ie("audio_template_callback", { processor: "function" }), ie("video_template_callback", { processor: "function" }), ie("iframe_template_callback", { processor: "function" }), ie("media_live_embeds", {
        processor: "boolean",
        default: !0
      }), ie("media_filter_html", {
        processor: "boolean",
        default: !0
      }), ie("media_url_resolver", { processor: "function" }), ie("media_alt_source", {
        processor: "boolean",
        default: !0
      }), ie("media_poster", {
        processor: "boolean",
        default: !0
      }), ie("media_dimensions", {
        processor: "boolean",
        default: !0
      });
    }, xo = J("audio_template_callback"), ht = J("video_template_callback"), U = J("iframe_template_callback"), Tt = J("media_live_embeds"), Ht = J("media_filter_html"), gn = J("media_url_resolver"), De = J("media_alt_source"), re = J("media_poster"), ho = J("media_dimensions");
    var Te = tinymce.util.Tools.resolve("tinymce.util.Tools"), Oe = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils"), A = tinymce.util.Tools.resolve("tinymce.html.DomParser");
    const mn = Oe.DOM, it = (de) => de.replace(/px$/, ""), Gn = (de) => {
      const ie = de.attr("style"), ze = ie ? mn.parseStyle(ie) : {};
      return {
        type: "ephox-embed-iri",
        source: de.attr("data-ephox-embed-iri"),
        altsource: "",
        poster: "",
        width: Pn(ze, "max-width").map(it).getOr(""),
        height: Pn(ze, "max-height").map(it).getOr("")
      };
    }, rn = (de, ie) => {
      let ze = {};
      const Nn = A({
        validate: !1,
        forced_root_block: !1
      }, ie).parse(de);
      for (let Wn = Nn; Wn; Wn = Wn.walk())
        if (Wn.type === 1) {
          const _o = Wn.name;
          if (Wn.attr("data-ephox-embed-iri")) {
            ze = Gn(Wn);
            break;
          } else
            !ze.source && _o === "param" && (ze.source = Wn.attr("movie")), (_o === "iframe" || _o === "object" || _o === "embed" || _o === "video" || _o === "audio") && (ze.type || (ze.type = _o), ze = Te.extend(Wn.attributes.map, ze)), _o === "source" && (ze.source ? ze.altsource || (ze.altsource = Wn.attr("src")) : ze.source = Wn.attr("src")), _o === "img" && !ze.poster && (ze.poster = Wn.attr("src"));
        }
      return ze.source = ze.source || ze.src || "", ze.altsource = ze.altsource || "", ze.poster = ze.poster || "", ze;
    }, Ye = (de) => {
      var ie;
      const ze = {
        mp3: "audio/mpeg",
        m4a: "audio/x-m4a",
        wav: "audio/wav",
        mp4: "video/mp4",
        webm: "video/webm",
        ogg: "video/ogg",
        swf: "application/x-shockwave-flash"
      }, Je = (ie = de.toLowerCase().split(".").pop()) !== null && ie !== void 0 ? ie : "";
      return Pn(ze, Je).getOr("");
    };
    var io = tinymce.util.Tools.resolve("tinymce.html.Node"), jo = tinymce.util.Tools.resolve("tinymce.html.Serializer");
    const bt = (de, ie = {}) => A({
      forced_root_block: !1,
      validate: !1,
      allow_conditional_comments: !0,
      ...ie
    }, de), kn = Oe.DOM, $e = (de) => /^[0-9.]+$/.test(de) ? de + "px" : de, ot = (de, ie) => {
      const ze = ie.attr("style"), Je = ze ? kn.parseStyle(ze) : {};
      Bt(de.width) && (Je["max-width"] = $e(de.width)), Bt(de.height) && (Je["max-height"] = $e(de.height)), ie.attr("style", kn.serializeStyle(Je));
    }, F = [
      "source",
      "altsource"
    ], ss = (de, ie, ze, Je) => {
      let Nn = 0, Wn = 0;
      const _o = bt(Je);
      _o.addNodeFilter("source", (ve) => Nn = ve.length);
      const Fs = _o.parse(de);
      for (let ve = Fs; ve; ve = ve.walk())
        if (ve.type === 1) {
          const go = ve.name;
          if (ve.attr("data-ephox-embed-iri")) {
            ot(ie, ve);
            break;
          } else {
            switch (go) {
              case "video":
              case "object":
              case "embed":
              case "img":
              case "iframe":
                ie.height !== void 0 && ie.width !== void 0 && (ve.attr("width", ie.width), ve.attr("height", ie.height));
                break;
            }
            if (ze)
              switch (go) {
                case "video":
                  ve.attr("poster", ie.poster), ve.attr("src", null);
                  for (let he = Nn; he < 2; he++)
                    if (ie[F[he]]) {
                      const dt = new io("source", 1);
                      dt.attr("src", ie[F[he]]), dt.attr("type", ie[F[he] + "mime"] || null), ve.append(dt);
                    }
                  break;
                case "iframe":
                  ve.attr("src", ie.source);
                  break;
                case "object":
                  const ue = ve.getAll("img").length > 0;
                  if (ie.poster && !ue) {
                    ve.attr("src", ie.poster);
                    const he = new io("img", 1);
                    he.attr("src", ie.poster), he.attr("width", ie.width), he.attr("height", ie.height), ve.append(he);
                  }
                  break;
                case "source":
                  if (Wn < 2 && (ve.attr("src", ie[F[Wn]]), ve.attr("type", ie[F[Wn] + "mime"] || null), !ie[F[Wn]])) {
                    ve.remove();
                    continue;
                  }
                  Wn++;
                  break;
                case "img":
                  ie.poster || ve.remove();
                  break;
              }
          }
        }
      return jo({}, Je).serialize(Fs);
    }, fo = [
      {
        regex: /youtu\.be\/([\w\-_\?&=.]+)/i,
        type: "iframe",
        w: 560,
        h: 314,
        url: "www.youtube.com/embed/$1",
        allowFullscreen: !0
      },
      {
        regex: /youtube\.com(.+)v=([^&]+)(&([a-z0-9&=\-_]+))?/i,
        type: "iframe",
        w: 560,
        h: 314,
        url: "www.youtube.com/embed/$2?$4",
        allowFullscreen: !0
      },
      {
        regex: /youtube.com\/embed\/([a-z0-9\?&=\-_]+)/i,
        type: "iframe",
        w: 560,
        h: 314,
        url: "www.youtube.com/embed/$1",
        allowFullscreen: !0
      },
      {
        regex: /vimeo\.com\/([0-9]+)\?h=(\w+)/,
        type: "iframe",
        w: 425,
        h: 350,
        url: "player.vimeo.com/video/$1?h=$2&title=0&byline=0&portrait=0&color=8dc7dc",
        allowFullscreen: !0
      },
      {
        regex: /vimeo\.com\/(.*)\/([0-9]+)\?h=(\w+)/,
        type: "iframe",
        w: 425,
        h: 350,
        url: "player.vimeo.com/video/$2?h=$3&title=0&amp;byline=0",
        allowFullscreen: !0
      },
      {
        regex: /vimeo\.com\/([0-9]+)/,
        type: "iframe",
        w: 425,
        h: 350,
        url: "player.vimeo.com/video/$1?title=0&byline=0&portrait=0&color=8dc7dc",
        allowFullscreen: !0
      },
      {
        regex: /vimeo\.com\/(.*)\/([0-9]+)/,
        type: "iframe",
        w: 425,
        h: 350,
        url: "player.vimeo.com/video/$2?title=0&amp;byline=0",
        allowFullscreen: !0
      },
      {
        regex: /maps\.google\.([a-z]{2,3})\/maps\/(.+)msid=(.+)/,
        type: "iframe",
        w: 425,
        h: 350,
        url: 'maps.google.com/maps/ms?msid=$2&output=embed"',
        allowFullscreen: !1
      },
      {
        regex: /dailymotion\.com\/video\/([^_]+)/,
        type: "iframe",
        w: 480,
        h: 270,
        url: "www.dailymotion.com/embed/video/$1",
        allowFullscreen: !0
      },
      {
        regex: /dai\.ly\/([^_]+)/,
        type: "iframe",
        w: 480,
        h: 270,
        url: "www.dailymotion.com/embed/video/$1",
        allowFullscreen: !0
      }
    ], at = (de) => {
      const ie = de.match(/^(https?:\/\/|www\.)(.+)$/i);
      return ie && ie.length > 1 ? ie[1] === "www." ? "https://" : ie[1] : "https://";
    }, lt = (de, ie) => {
      const ze = at(ie), Je = de.regex.exec(ie);
      let Nn = ze + de.url;
      if (Bt(Je))
        for (let Wn = 0; Wn < Je.length; Wn++)
          Nn = Nn.replace("$" + Wn, () => Je[Wn] ? Je[Wn] : "");
      return Nn.replace(/\?$/, "");
    }, Rn = (de) => {
      const ie = fo.filter((ze) => ze.regex.test(de));
      return ie.length > 0 ? Te.extend({}, ie[0], { url: lt(ie[0], de) }) : null;
    }, ee = (de, ie) => {
      if (ie)
        return ie(de);
      {
        const ze = de.allowfullscreen ? ' allowFullscreen="1"' : "";
        return '<iframe src="' + de.source + '" width="' + de.width + '" height="' + de.height + '"' + ze + "></iframe>";
      }
    }, pe = (de) => {
      let ie = '<object data="' + de.source + '" width="' + de.width + '" height="' + de.height + '" type="application/x-shockwave-flash">';
      return de.poster && (ie += '<img src="' + de.poster + '" width="' + de.width + '" height="' + de.height + '" />'), ie += "</object>", ie;
    }, ye = (de, ie) => ie ? ie(de) : '<audio controls="controls" src="' + de.source + '">' + (de.altsource ? `
<source src="` + de.altsource + '"' + (de.altsourcemime ? ' type="' + de.altsourcemime + '"' : "") + ` />
` : "") + "</audio>", ae = (de, ie) => ie ? ie(de) : '<video width="' + de.width + '" height="' + de.height + '"' + (de.poster ? ' poster="' + de.poster + '"' : "") + ` controls="controls">
<source src="` + de.source + '"' + (de.sourcemime ? ' type="' + de.sourcemime + '"' : "") + ` />
` + (de.altsource ? '<source src="' + de.altsource + '"' + (de.altsourcemime ? ' type="' + de.altsourcemime + '"' : "") + ` />
` : "") + "</video>", kt = (de, ie) => {
      var ze;
      const Je = Te.extend({}, ie);
      if (!Je.source && (Te.extend(Je, rn((ze = Je.embed) !== null && ze !== void 0 ? ze : "", de.schema)), !Je.source))
        return "";
      Je.altsource || (Je.altsource = ""), Je.poster || (Je.poster = ""), Je.source = de.convertURL(Je.source, "source"), Je.altsource = de.convertURL(Je.altsource, "source"), Je.sourcemime = Ye(Je.source), Je.altsourcemime = Ye(Je.altsource), Je.poster = de.convertURL(Je.poster, "poster");
      const Nn = Rn(Je.source);
      if (Nn && (Je.source = Nn.url, Je.type = Nn.type, Je.allowfullscreen = Nn.allowFullscreen, Je.width = Je.width || String(Nn.w), Je.height = Je.height || String(Nn.h)), Je.embed)
        return ss(Je.embed, Je, !0, de.schema);
      {
        const Wn = xo(de), _o = ht(de), Fs = U(de);
        return Je.width = Je.width || "300", Je.height = Je.height || "150", Te.each(Je, (ve, go) => {
          Je[go] = de.dom.encode("" + ve);
        }), Je.type === "iframe" ? ee(Je, Fs) : Je.sourcemime === "application/x-shockwave-flash" ? pe(Je) : Je.sourcemime.indexOf("audio") !== -1 ? ye(Je, Wn) : ae(Je, _o);
      }
    }, Vn = (de) => de.hasAttribute("data-mce-object") || de.hasAttribute("data-ephox-embed-iri"), Yt = (de) => {
      de.on("click keyup touchend", () => {
        const ie = de.selection.getNode();
        ie && de.dom.hasClass(ie, "mce-preview-object") && de.dom.getAttrib(ie, "data-mce-selected") && ie.setAttribute("data-mce-selected", "2");
      }), de.on("ObjectResized", (ie) => {
        const ze = ie.target;
        if (ze.getAttribute("data-mce-object")) {
          let Je = ze.getAttribute("data-mce-html");
          Je && (Je = unescape(Je), ze.setAttribute("data-mce-html", escape(ss(Je, {
            width: String(ie.width),
            height: String(ie.height)
          }, !1, de.schema))));
        }
      });
    }, Ct = {}, Xe = (de, ie, ze) => new Promise((Je, Nn) => {
      const Wn = (_o) => (_o.html && (Ct[de.source] = _o), Je({
        url: de.source,
        html: _o.html ? _o.html : ie(de)
      }));
      Ct[de.source] ? Wn(Ct[de.source]) : ze({ url: de.source }, Wn, Nn);
    }), In = (de, ie) => Promise.resolve({
      html: ie(de),
      url: de.source
    }), hn = (de) => (ie) => kt(de, ie), Xn = (de, ie) => {
      const ze = gn(de);
      return ze ? Xe(ie, hn(de), ze) : In(ie, hn(de));
    }, Xo = (de) => Kt(Ct, de), ds = (de, ie) => Pn(ie, de).bind((ze) => Pn(ze, "meta")), No = (de, ie, ze) => (Je) => {
      const Nn = () => Pn(de, Je), Wn = () => Pn(ie, Je), _o = (go) => Pn(go, "value").bind((ue) => ue.length > 0 ? fn.some(ue) : fn.none()), Fs = () => Nn().bind((go) => Wt(go) ? _o(go).orThunk(Wn) : Wn().orThunk(() => fn.from(go))), ve = () => Wn().orThunk(() => Nn().bind((go) => Wt(go) ? _o(go) : fn.from(go)));
      return { [Je]: (Je === ze ? Fs() : ve()).getOr("") };
    }, Ao = (de, ie) => {
      const ze = {};
      return Pn(de, "dimensions").each((Je) => {
        Sn([
          "width",
          "height"
        ], (Nn) => {
          Pn(ie, Nn).orThunk(() => Pn(Je, Nn)).each((Wn) => ze[Nn] = Wn);
        });
      }), ze;
    }, Cs = (de, ie) => {
      const ze = ie && ie !== "dimensions" ? ds(ie, de).getOr({}) : {}, Je = No(de, ze, ie);
      return {
        ...Je("source"),
        ...Je("altsource"),
        ...Je("poster"),
        ...Je("embed"),
        ...Ao(de, ze)
      };
    }, Ie = (de) => {
      const ie = {
        ...de,
        source: { value: Pn(de, "source").getOr("") },
        altsource: { value: Pn(de, "altsource").getOr("") },
        poster: { value: Pn(de, "poster").getOr("") }
      };
      return Sn([
        "width",
        "height"
      ], (ze) => {
        Pn(de, ze).each((Je) => {
          const Nn = ie.dimensions || {};
          Nn[ze] = Je, ie.dimensions = Nn;
        });
      }), ie;
    }, et = (de) => (ie) => {
      const ze = ie && ie.msg ? "Media embed handler error: " + ie.msg : "Media embed handler threw unknown error.";
      de.notificationManager.open({
        type: "error",
        text: ze
      });
    }, nn = (de) => {
      const ie = de.selection.getNode(), ze = Vn(ie) ? de.serializer.serialize(ie, { selection: !0 }) : "", Je = rn(ze, de.schema), Wn = (() => {
        if (Gs(Je.source, Je.type)) {
          const _o = de.dom.getRect(ie);
          return {
            width: _o.w.toString().replace(/px$/, ""),
            height: _o.h.toString().replace(/px$/, "")
          };
        } else
          return {};
      })();
      return {
        embed: ze,
        ...Je,
        ...Wn
      };
    }, qt = (de, ie) => (ze) => {
      if (Nt(ze.url) && ze.url.trim().length > 0) {
        const Je = ze.html, Wn = {
          ...rn(Je, ie.schema),
          source: ze.url,
          embed: Je
        };
        de.setData(Ie(Wn));
      }
    }, ko = (de, ie) => {
      const ze = de.dom.select("*[data-mce-object]");
      for (let Je = 0; Je < ie.length; Je++)
        for (let Nn = ze.length - 1; Nn >= 0; Nn--)
          ie[Je] === ze[Nn] && ze.splice(Nn, 1);
      de.selection.select(ze[0]);
    }, rs = (de, ie) => {
      const ze = de.dom.select("*[data-mce-object]");
      de.insertContent(ie), ko(de, ze), de.nodeChanged();
    }, Gs = (de, ie) => Bt(ie) && ie === "ephox-embed-iri" && Bt(Rn(de)), Yr = (de, ie) => ((Je, Nn) => Je.width !== Nn.width || Je.height !== Nn.height)(de, ie) && Gs(ie.source, de.type), Ss = (de, ie, ze) => {
      var Je;
      ie.embed = Yr(de, ie) && ho(ze) ? kt(ze, {
        ...ie,
        embed: ""
      }) : ss((Je = ie.embed) !== null && Je !== void 0 ? Je : "", ie, !1, ze.schema), ie.embed && (de.source === ie.source || Xo(ie.source)) ? rs(ze, ie.embed) : Xn(ze, ie).then((Nn) => {
        rs(ze, Nn.html);
      }).catch(et(ze));
    }, or = (de) => {
      const ie = nn(de), ze = Zt(ie), Je = Ie(ie), Nn = (Dn, Mn) => {
        const Kn = Cs(Mn.getData(), "source");
        Dn.source !== Kn.source && (qt(On, de)({
          url: Kn.source,
          html: ""
        }), Xn(de, Kn).then(qt(On, de)).catch(et(de)));
      }, Wn = (Dn) => {
        var Mn;
        const Kn = Cs(Dn.getData()), zo = rn((Mn = Kn.embed) !== null && Mn !== void 0 ? Mn : "", de.schema);
        Dn.setData(Ie(zo));
      }, _o = (Dn, Mn, Kn) => {
        const zo = Cs(Dn.getData(), Mn), Ds = Yr(Kn, zo) && ho(de) ? {
          ...zo,
          embed: ""
        } : zo, Ra = kt(de, Ds);
        Dn.setData(Ie({
          ...Ds,
          embed: Ra
        }));
      }, Fs = [{
        name: "source",
        type: "urlinput",
        filetype: "media",
        label: "Source",
        picker_text: "Browse files"
      }], ve = ho(de) ? [{
        type: "sizeinput",
        name: "dimensions",
        label: "Constrain proportions",
        constrain: !0
      }] : [], go = {
        title: "General",
        name: "general",
        items: Ft([
          Fs,
          ve
        ])
      }, he = {
        title: "Embed",
        items: [{
          type: "textarea",
          name: "embed",
          label: "Paste your embed code below:"
        }]
      }, dt = [];
      De(de) && dt.push({
        name: "altsource",
        type: "urlinput",
        filetype: "media",
        label: "Alternative source URL"
      }), re(de) && dt.push({
        name: "poster",
        type: "urlinput",
        filetype: "image",
        label: "Media poster (Image URL)"
      });
      const wt = {
        title: "Advanced",
        name: "advanced",
        items: dt
      }, on = [
        go,
        he
      ];
      dt.length > 0 && on.push(wt);
      const Ln = {
        type: "tabpanel",
        tabs: on
      }, On = de.windowManager.open({
        title: "Insert/Edit Media",
        size: "normal",
        body: Ln,
        buttons: [
          {
            type: "cancel",
            name: "cancel",
            text: "Cancel"
          },
          {
            type: "submit",
            name: "save",
            text: "Save",
            primary: !0
          }
        ],
        onSubmit: (Dn) => {
          const Mn = Cs(Dn.getData());
          Ss(ze.get(), Mn, de), Dn.close();
        },
        onChange: (Dn, Mn) => {
          switch (Mn.name) {
            case "source":
              Nn(ze.get(), Dn);
              break;
            case "embed":
              Wn(Dn);
              break;
            case "dimensions":
            case "altsource":
            case "poster":
              _o(Dn, Mn.name, ze.get());
              break;
          }
          ze.set(Cs(Dn.getData()));
        },
        initialData: Je
      });
    }, Dt = (de) => ({ showDialog: () => {
      or(de);
    } }), Lo = (de) => {
      const ie = () => {
        or(de);
      };
      de.addCommand("mceMedia", ie);
    }, Or = (de, ie, ze) => de.length >= ie.length && de.substr(ze, ze + ie.length) === ie, aa = (de, ie) => Or(de, ie, 0);
    var Xr = tinymce.util.Tools.resolve("tinymce.Env");
    const Jr = (de) => {
      const ie = de.name;
      return ie === "iframe" || ie === "video" || ie === "audio";
    }, xs = (de, ie, ze, Je = null) => {
      const Nn = de.attr(ze);
      return Bt(Nn) ? Nn : Kt(ie, ze) ? null : Je;
    }, fa = (de, ie, ze) => {
      const Je = ie.name === "img" || de.name === "video", Nn = Je ? "300" : null, Wn = de.name === "audio" ? "30" : "150", _o = Je ? Wn : null;
      ie.attr({
        width: xs(de, ze, "width", Nn),
        height: xs(de, ze, "height", _o)
      });
    }, Qr = (de, ie, ze, Je) => {
      const Nn = bt(de.schema).parse(Je, { context: ie });
      for (; Nn.firstChild; )
        ze.append(Nn.firstChild);
    }, Ts = (de, ie) => {
      const ze = ie.name, Je = new io("img", 1);
      return dr(de, ie, Je), fa(ie, Je, {}), Je.attr({
        style: ie.attr("style"),
        src: Xr.transparentSrc,
        "data-mce-object": ze,
        class: "mce-object mce-object-" + ze
      }), Je;
    }, Zn = (de, ie) => {
      var ze;
      const Je = ie.name, Nn = new io("span", 1);
      Nn.attr({
        contentEditable: "false",
        style: ie.attr("style"),
        "data-mce-object": Je,
        class: "mce-preview-object mce-object-" + Je
      }), dr(de, ie, Nn);
      const Wn = de.dom.parseStyle((ze = ie.attr("style")) !== null && ze !== void 0 ? ze : ""), _o = new io(Je, 1);
      if (fa(ie, _o, Wn), _o.attr({
        src: ie.attr("src"),
        style: ie.attr("style"),
        class: ie.attr("class")
      }), Je === "iframe")
        _o.attr({
          allowfullscreen: ie.attr("allowfullscreen"),
          frameborder: "0",
          sandbox: ie.attr("sandbox")
        });
      else {
        Sn([
          "controls",
          "crossorigin",
          "currentTime",
          "loop",
          "muted",
          "poster",
          "preload"
        ], (ue) => {
          _o.attr(ue, ie.attr(ue));
        });
        const go = Nn.attr("data-mce-html");
        Bt(go) && Qr(de, Je, _o, unescape(go));
      }
      const Fs = new io("span", 1);
      return Fs.attr("class", "mce-shim"), Nn.append(_o), Nn.append(Fs), Nn;
    }, dr = (de, ie, ze) => {
      var Je;
      const Nn = (Je = ie.attributes) !== null && Je !== void 0 ? Je : [];
      let Wn = Nn.length;
      for (; Wn--; ) {
        const go = Nn[Wn].name;
        let ue = Nn[Wn].value;
        go !== "width" && go !== "height" && go !== "style" && !aa(go, "data-mce-") && ((go === "data" || go === "src") && (ue = de.convertURL(ue, go)), ze.attr("data-mce-p-" + go, ue));
      }
      const _o = jo({ inner: !0 }, de.schema), Fs = new io("div", 1);
      Sn(ie.children(), (go) => Fs.append(go));
      const ve = _o.serialize(Fs);
      ve && (ze.attr("data-mce-html", escape(ve)), ze.empty());
    }, ga = (de) => {
      const ie = de.attr("class");
      return Nt(ie) && /\btiny-pageembed\b/.test(ie);
    }, Za = (de) => {
      let ie = de;
      for (; ie = ie.parent; )
        if (ie.attr("data-ephox-embed-iri") || ga(ie))
          return !0;
      return !1;
    }, _c = (de) => (ie) => {
      let ze = ie.length, Je;
      for (; ze--; )
        Je = ie[ze], Je.parent && (Je.parent.attr("data-mce-object") || (Jr(Je) && Tt(de) ? Za(Je) || Je.replace(Zn(de, Je)) : Za(Je) || Je.replace(Ts(de, Je))));
    }, sr = (de, ie, ze) => {
      const Je = de.options.get, Nn = Je("xss_sanitization"), Wn = Ht(de);
      return bt(de.schema, {
        sanitize: Nn,
        validate: Wn
      }).parse(ze, { context: ie });
    }, Ks = (de) => {
      de.on("PreInit", () => {
        const { schema: ie, serializer: ze, parser: Je } = de, Nn = ie.getBoolAttrs();
        Sn("webkitallowfullscreen mozallowfullscreen".split(" "), (Wn) => {
          Nn[Wn] = {};
        }), st({ embed: ["wmode"] }, (Wn, _o) => {
          const Fs = ie.getElementRule(_o);
          Fs && Sn(Wn, (ve) => {
            Fs.attributes[ve] = {}, Fs.attributesOrder.push(ve);
          });
        }), Je.addNodeFilter("iframe,video,audio,object,embed", _c(de)), ze.addAttributeFilter("data-mce-object", (Wn, _o) => {
          var Fs;
          let ve = Wn.length;
          for (; ve--; ) {
            const go = Wn[ve];
            if (!go.parent)
              continue;
            const ue = go.attr(_o), he = new io(ue, 1);
            if (ue !== "audio") {
              const Ln = go.attr("class");
              Ln && Ln.indexOf("mce-preview-object") !== -1 && go.firstChild ? he.attr({
                width: go.firstChild.attr("width"),
                height: go.firstChild.attr("height")
              }) : he.attr({
                width: go.attr("width"),
                height: go.attr("height")
              });
            }
            he.attr({ style: go.attr("style") });
            const dt = (Fs = go.attributes) !== null && Fs !== void 0 ? Fs : [];
            let wt = dt.length;
            for (; wt--; ) {
              const Ln = dt[wt].name;
              Ln.indexOf("data-mce-p-") === 0 && he.attr(Ln.substr(11), dt[wt].value);
            }
            const on = go.attr("data-mce-html");
            if (on) {
              const Ln = sr(de, ue, unescape(on));
              Sn(Ln.children(), (On) => he.append(On));
            }
            go.replace(he);
          }
        });
      }), de.on("SetContent", () => {
        const ie = de.dom;
        Sn(ie.select("span.mce-preview-object"), (ze) => {
          ie.select("span.mce-shim", ze).length === 0 && ie.add(ze, "span", { class: "mce-shim" });
        });
      });
    }, Vs = (de) => {
      de.on("ResolveName", (ie) => {
        let ze;
        ie.target.nodeType === 1 && (ze = ie.target.getAttribute("data-mce-object")) && (ie.name = ze);
      });
    }, Sa = (de) => (ie) => {
      const ze = () => {
        ie.setEnabled(de.selection.isEditable());
      };
      return de.on("NodeChange", ze), ze(), () => {
        de.off("NodeChange", ze);
      };
    }, rc = (de) => {
      const ie = () => de.execCommand("mceMedia");
      de.ui.registry.addToggleButton("media", {
        tooltip: "Insert/edit media",
        icon: "embed",
        onAction: ie,
        onSetup: (ze) => {
          const Je = de.selection;
          ze.setActive(Vn(Je.getNode()));
          const Nn = Je.selectorChangedWithUnbind("img[data-mce-object],span[data-mce-object],div[data-ephox-embed-iri]", ze.setActive).unbind, Wn = Sa(de)(ze);
          return () => {
            Nn(), Wn();
          };
        }
      }), de.ui.registry.addMenuItem("media", {
        icon: "embed",
        text: "Media...",
        onAction: ie,
        onSetup: Sa(de)
      });
    };
    var wr = () => {
      vt.add("media", (de) => (Qe(de), Lo(de), rc(de), Vs(de), Ks(de), Yt(de), Dt(de)));
    };
    wr();
  })()), gK;
}
var pK;
function dX() {
  return pK || (pK = 1, uX()), fK;
}
dX();
var bK = {}, vK = {}, yK;
function mX() {
  return yK || (yK = 1, (function() {
    var vt = tinymce.util.Tools.resolve("tinymce.PluginManager"), Ot = tinymce.util.Tools.resolve("tinymce.Env"), Pt = tinymce.util.Tools.resolve("tinymce.util.Tools");
    const yt = (Zt) => (Qt) => Qt.options.get(Zt), Nt = yt("content_style"), Wt = yt("content_css_cors"), Fe = yt("body_class"), Ee = yt("body_id"), Bt = (Zt) => {
      var Qt;
      let En = "";
      const st = Zt.dom.encode, Pn = (Qt = Nt(Zt)) !== null && Qt !== void 0 ? Qt : "";
      En += '<base href="' + st(Zt.documentBaseURI.getURI()) + '">';
      const Kt = Wt(Zt) ? ' crossorigin="anonymous"' : "";
      Pt.each(Zt.contentCSS, (gn) => {
        En += '<link type="text/css" rel="stylesheet" href="' + st(Zt.documentBaseURI.toAbsolute(gn)) + '"' + Kt + ">";
      }), Pn && (En += '<style type="text/css">' + Pn + "</style>");
      const J = Ee(Zt), Qe = Fe(Zt), ht = '<script>document.addEventListener && document.addEventListener("click", function(e) {for (var elm = e.target; elm; elm = elm.parentNode) {if (elm.nodeName === "A" && !(' + (Ot.os.isMacOS() || Ot.os.isiOS() ? "e.metaKey" : "e.ctrlKey && !e.altKey") + ")) {e.preventDefault();}}}, false);<\/script> ", U = Zt.getBody().dir, Tt = U ? ' dir="' + st(U) + '"' : "";
      return "<!DOCTYPE html><html><head>" + En + '</head><body id="' + st(J) + '" class="mce-content-body ' + st(Qe) + '"' + Tt + ">" + Zt.getContent() + ht + "</body></html>";
    }, fn = (Zt) => {
      const Qt = Bt(Zt);
      Zt.windowManager.open({
        title: "Preview",
        size: "large",
        body: {
          type: "panel",
          items: [{
            name: "preview",
            type: "iframe",
            sandboxed: !0,
            transparent: !1
          }]
        },
        buttons: [{
          type: "cancel",
          name: "close",
          text: "Close",
          primary: !0
        }],
        initialData: { preview: Qt }
      }).focus("close");
    }, dn = (Zt) => {
      Zt.addCommand("mcePreview", () => {
        fn(Zt);
      });
    }, Sn = (Zt) => {
      const Qt = () => Zt.execCommand("mcePreview");
      Zt.ui.registry.addButton("preview", {
        icon: "preview",
        tooltip: "Preview",
        onAction: Qt
      }), Zt.ui.registry.addMenuItem("preview", {
        icon: "preview",
        text: "Preview",
        onAction: Qt
      });
    };
    var Ft = () => {
      vt.add("preview", (Zt) => {
        dn(Zt), Sn(Zt);
      });
    };
    Ft();
  })()), vK;
}
var CK;
function fX() {
  return CK || (CK = 1, mX()), bK;
}
fX();
var wK = {}, SK = {}, xK;
function gX() {
  return xK || (xK = 1, (function() {
    var vt = tinymce.util.Tools.resolve("tinymce.PluginManager");
    const Ot = (at, lt, Rn) => {
      var ee;
      return Rn(at, lt.prototype) ? !0 : ((ee = at.constructor) === null || ee === void 0 ? void 0 : ee.name) === lt.name;
    }, Pt = (at) => {
      const lt = typeof at;
      return at === null ? "null" : lt === "object" && Array.isArray(at) ? "array" : lt === "object" && Ot(at, String, (Rn, ee) => ee.isPrototypeOf(Rn)) ? "string" : lt;
    }, yt = (at) => (lt) => Pt(lt) === at, Nt = (at) => (lt) => typeof lt === at, Wt = yt("string"), Fe = Nt("boolean"), Ee = (at) => at == null, Bt = (at) => !Ee(at), fn = Nt("function"), dn = (at) => (lt) => lt.options.get(at), Sn = (at) => {
      const lt = at.options.register, Rn = (ae) => (kt) => {
        const Vn = Fe(kt) || Wt(kt);
        return Vn ? Fe(kt) ? {
          value: kt ? ae : "",
          valid: Vn
        } : {
          value: kt.trim(),
          valid: Vn
        } : {
          valid: !1,
          message: "Must be a boolean or string."
        };
      }, ee = "bold italic | quicklink h2 h3 blockquote";
      lt("quickbars_selection_toolbar", {
        processor: Rn(ee),
        default: ee
      });
      const pe = "quickimage quicktable";
      lt("quickbars_insert_toolbar", {
        processor: Rn(pe),
        default: pe
      });
      const ye = "alignleft aligncenter alignright";
      lt("quickbars_image_toolbar", {
        processor: Rn(ye),
        default: ye
      });
    }, Ft = dn("quickbars_selection_toolbar"), Zt = dn("quickbars_insert_toolbar"), Qt = dn("quickbars_image_toolbar");
    let En = 0;
    const st = (at) => {
      const Rn = (/* @__PURE__ */ new Date()).getTime(), ee = Math.floor(Math.random() * 1e9);
      return En++, at + "_" + ee + En + String(Rn);
    }, Pn = (at, lt, Rn) => {
      at.execCommand("mceInsertTable", !1, {
        rows: Rn,
        columns: lt
      });
    }, Kt = (at, lt, Rn) => {
      const ee = at.editorUpload.blobCache, pe = ee.create(st("mceu"), Rn, lt);
      ee.add(pe), at.insertContent(at.dom.createHTML("img", { src: pe.blobUri() }));
    }, J = (at) => new Promise((lt) => {
      const Rn = new FileReader();
      Rn.onloadend = () => {
        lt(Rn.result.split(",")[1]);
      }, Rn.readAsDataURL(at);
    });
    var Qe = tinymce.util.Tools.resolve("tinymce.util.Delay");
    const xo = (at) => new Promise((lt) => {
      let Rn = !1;
      const ee = document.createElement("input");
      ee.type = "file", ee.accept = "image/*", ee.style.position = "fixed", ee.style.left = "0", ee.style.top = "0", ee.style.opacity = "0.001", document.body.appendChild(ee);
      const pe = (kt) => {
        var Vn;
        Rn || ((Vn = ee.parentNode) === null || Vn === void 0 || Vn.removeChild(ee), Rn = !0, lt(kt));
      }, ye = (kt) => {
        pe(Array.prototype.slice.call(kt.target.files));
      };
      ee.addEventListener("input", ye), ee.addEventListener("change", ye);
      const ae = (kt) => {
        const Vn = () => {
          pe([]);
        };
        Rn || (kt.type === "focusin" ? Qe.setEditorTimeout(at, Vn, 1e3) : Vn()), at.off("focusin remove", ae);
      };
      at.on("focusin remove", ae), ee.click();
    }), ht = (at) => {
      at.ui.registry.addButton("quickimage", {
        icon: "image",
        tooltip: "Insert image",
        onAction: () => {
          xo(at).then((lt) => {
            if (lt.length > 0) {
              const Rn = lt[0];
              J(Rn).then((ee) => {
                Kt(at, ee, Rn);
              });
            }
          });
        }
      }), at.ui.registry.addButton("quicktable", {
        icon: "table",
        tooltip: "Insert table",
        onAction: () => {
          Pn(at, 2, 2);
        }
      });
    }, Tt = ((at) => () => at)(!1);
    class Ht {
      constructor(lt, Rn) {
        this.tag = lt, this.value = Rn;
      }
      static some(lt) {
        return new Ht(!0, lt);
      }
      static none() {
        return Ht.singletonNone;
      }
      fold(lt, Rn) {
        return this.tag ? Rn(this.value) : lt();
      }
      isSome() {
        return this.tag;
      }
      isNone() {
        return !this.tag;
      }
      map(lt) {
        return this.tag ? Ht.some(lt(this.value)) : Ht.none();
      }
      bind(lt) {
        return this.tag ? lt(this.value) : Ht.none();
      }
      exists(lt) {
        return this.tag && lt(this.value);
      }
      forall(lt) {
        return !this.tag || lt(this.value);
      }
      filter(lt) {
        return !this.tag || lt(this.value) ? this : Ht.none();
      }
      getOr(lt) {
        return this.tag ? this.value : lt;
      }
      or(lt) {
        return this.tag ? this : lt;
      }
      getOrThunk(lt) {
        return this.tag ? this.value : lt();
      }
      orThunk(lt) {
        return this.tag ? this : lt();
      }
      getOrDie(lt) {
        if (this.tag)
          return this.value;
        throw new Error(lt ?? "Called getOrDie on None");
      }
      static from(lt) {
        return Bt(lt) ? Ht.some(lt) : Ht.none();
      }
      getOrNull() {
        return this.tag ? this.value : null;
      }
      getOrUndefined() {
        return this.value;
      }
      each(lt) {
        this.tag && lt(this.value);
      }
      toArray() {
        return this.tag ? [this.value] : [];
      }
      toString() {
        return this.tag ? `some(${this.value})` : "none()";
      }
    }
    Ht.singletonNone = new Ht(!1), typeof window < "u" || Function("return this;")();
    const gn = 1, De = (at) => at.dom.nodeName.toLowerCase(), re = (at, lt) => {
      const Rn = at.dom;
      return Rn && Rn.hasAttribute ? Rn.hasAttribute(lt) : !1;
    };
    var ho = (at, lt, Rn, ee, pe) => at(Rn, ee) ? Ht.some(Rn) : fn(pe) && pe(Rn) ? Ht.none() : lt(Rn, ee, pe);
    const Te = (at, lt) => {
      const ee = (lt || document).createElement("div");
      if (ee.innerHTML = at, !ee.hasChildNodes() || ee.childNodes.length > 1) {
        const pe = "HTML does not have a single root node";
        throw new Error(pe);
      }
      return mn(ee.childNodes[0]);
    }, Oe = (at, lt) => {
      const ee = (lt || document).createElement(at);
      return mn(ee);
    }, A = (at, lt) => {
      const ee = (lt || document).createTextNode(at);
      return mn(ee);
    }, mn = (at) => {
      if (at == null)
        throw new Error("Node cannot be null or undefined");
      return { dom: at };
    }, Gn = {
      fromHtml: Te,
      fromTag: Oe,
      fromText: A,
      fromDom: mn,
      fromPoint: (at, lt, Rn) => Ht.from(at.dom.elementFromPoint(lt, Rn)).map(mn)
    }, rn = (at, lt) => {
      const Rn = at.dom;
      if (Rn.nodeType !== gn)
        return !1;
      {
        const ee = Rn;
        if (ee.matches !== void 0)
          return ee.matches(lt);
        if (ee.msMatchesSelector !== void 0)
          return ee.msMatchesSelector(lt);
        if (ee.webkitMatchesSelector !== void 0)
          return ee.webkitMatchesSelector(lt);
        if (ee.mozMatchesSelector !== void 0)
          return ee.mozMatchesSelector(lt);
        throw new Error("Browser lacks native selectors");
      }
    }, Ye = (at, lt, Rn) => {
      let ee = at.dom;
      const pe = fn(Rn) ? Rn : Tt;
      for (; ee.parentNode; ) {
        ee = ee.parentNode;
        const ye = Gn.fromDom(ee);
        if (lt(ye))
          return Ht.some(ye);
        if (pe(ye))
          break;
      }
      return Ht.none();
    }, io = (at, lt, Rn) => ho((pe, ye) => ye(pe), Ye, at, lt, Rn), jo = (at, lt, Rn) => io(at, lt, Rn).isSome(), bt = (at, lt, Rn) => Ye(at, (ee) => rn(ee, lt), Rn), kn = (at, lt, Rn) => ho((pe, ye) => rn(pe, ye), bt, at, lt, Rn), $e = (at) => {
      const lt = Zt(at);
      lt.length > 0 && at.ui.registry.addContextToolbar("quickblock", {
        predicate: (Rn) => {
          const ee = Gn.fromDom(Rn), pe = at.schema.getTextBlockElements(), ye = (ae) => ae.dom === at.getBody();
          return !re(ee, "data-mce-bogus") && kn(ee, 'table,[data-mce-bogus="all"]', ye).fold(() => jo(ee, (ae) => De(ae) in pe && at.dom.isEmpty(ae.dom), ye), Tt);
        },
        items: lt,
        position: "line",
        scope: "editor"
      });
    }, ot = (at) => at.dom.classList !== void 0, F = (at, lt) => ot(at) && at.dom.classList.contains(lt), ss = (at) => {
      const lt = (ae) => at.dom.isEditable(ae), Rn = (ae) => lt(ae.parentElement), ee = (ae) => {
        const kt = ae.nodeName === "FIGURE" && /image/i.test(ae.className), Vn = ae.nodeName === "IMG" || kt, Yt = F(Gn.fromDom(ae), "mce-pagebreak");
        return Vn && Rn(ae) && !Yt;
      }, pe = Qt(at);
      pe.length > 0 && at.ui.registry.addContextToolbar("imageselection", {
        predicate: ee,
        items: pe,
        position: "node"
      });
      const ye = Ft(at);
      ye.length > 0 && at.ui.registry.addContextToolbar("textselection", {
        predicate: (ae) => !ee(ae) && !at.selection.isCollapsed() && lt(ae),
        items: ye,
        position: "selection",
        scope: "editor"
      });
    };
    var fo = () => {
      vt.add("quickbars", (at) => {
        Sn(at), ht(at), $e(at), ss(at);
      });
    };
    fo();
  })()), SK;
}
var TK;
function hX() {
  return TK || (TK = 1, gX()), wK;
}
hX();
var EK = {}, kK = {}, _K;
function pX() {
  return _K || (_K = 1, (function() {
    const vt = (ue) => {
      let he = ue;
      return {
        get: () => he,
        set: (on) => {
          he = on;
        }
      };
    };
    var Ot = tinymce.util.Tools.resolve("tinymce.PluginManager");
    const Pt = (ue, he, dt) => {
      var wt;
      return dt(ue, he.prototype) ? !0 : ((wt = ue.constructor) === null || wt === void 0 ? void 0 : wt.name) === he.name;
    }, yt = (ue) => {
      const he = typeof ue;
      return ue === null ? "null" : he === "object" && Array.isArray(ue) ? "array" : he === "object" && Pt(ue, String, (dt, wt) => wt.isPrototypeOf(dt)) ? "string" : he;
    }, Nt = (ue) => (he) => yt(he) === ue, Wt = (ue) => (he) => typeof he === ue, Fe = Nt("string"), Ee = Nt("array"), Bt = Wt("boolean"), fn = (ue) => ue == null, dn = (ue) => !fn(ue), Sn = Wt("number"), Ft = () => {
    }, Zt = (ue) => () => ue, Qt = Zt(!0), st = Zt("[~№|!-*+-\\/:;?@\\[-`{}¡«·»¿;·՚-՟։֊־׀׃׆׳״؉؊،؍؛؞؟٪-٭۔܀-܍߷-߹࠰-࠾࡞।॥॰෴๏๚๛༄-༒༺-༽྅࿐-࿔࿙࿚၊-၏჻፡-፨᐀᙭᙮᚛᚜᛫-᛭᜵᜶។-៖៘-៚᠀-᠊᥄᥅᨞᨟᪠-᪦᪨-᪭᭚-᭠᯼-᯿᰻-᰿᱾᱿᳓‐-‧‰-⁃⁅-⁑⁓-⁞⁽⁾₍₎〈〉❨-❵⟅⟆⟦-⟯⦃-⦘⧘-⧛⧼⧽⳹-⳼⳾⳿⵰⸀-⸮⸰⸱、-〃〈-】〔-〟〰〽゠・꓾꓿꘍-꘏꙳꙾꛲-꛷꡴-꡷꣎꣏꣸-꣺꤮꤯꥟꧁-꧍꧞꧟꩜-꩟꫞꫟꯫﴾﴿︐-︙︰-﹒﹔-﹡﹣﹨﹪﹫！-＃％-＊，-／：；？＠［-］＿｛｝｟-･]");
    class Pn {
      constructor(he, dt) {
        this.tag = he, this.value = dt;
      }
      static some(he) {
        return new Pn(!0, he);
      }
      static none() {
        return Pn.singletonNone;
      }
      fold(he, dt) {
        return this.tag ? dt(this.value) : he();
      }
      isSome() {
        return this.tag;
      }
      isNone() {
        return !this.tag;
      }
      map(he) {
        return this.tag ? Pn.some(he(this.value)) : Pn.none();
      }
      bind(he) {
        return this.tag ? he(this.value) : Pn.none();
      }
      exists(he) {
        return this.tag && he(this.value);
      }
      forall(he) {
        return !this.tag || he(this.value);
      }
      filter(he) {
        return !this.tag || he(this.value) ? this : Pn.none();
      }
      getOr(he) {
        return this.tag ? this.value : he;
      }
      or(he) {
        return this.tag ? this : he;
      }
      getOrThunk(he) {
        return this.tag ? this.value : he();
      }
      orThunk(he) {
        return this.tag ? this : he();
      }
      getOrDie(he) {
        if (this.tag)
          return this.value;
        throw new Error(he ?? "Called getOrDie on None");
      }
      static from(he) {
        return dn(he) ? Pn.some(he) : Pn.none();
      }
      getOrNull() {
        return this.tag ? this.value : null;
      }
      getOrUndefined() {
        return this.value;
      }
      each(he) {
        this.tag && he(this.value);
      }
      toArray() {
        return this.tag ? [this.value] : [];
      }
      toString() {
        return this.tag ? `some(${this.value})` : "none()";
      }
    }
    Pn.singletonNone = new Pn(!1);
    const Kt = st;
    var J = tinymce.util.Tools.resolve("tinymce.Env"), Qe = tinymce.util.Tools.resolve("tinymce.util.Tools");
    const xo = Array.prototype.slice, ht = Array.prototype.push, U = (ue, he) => {
      const dt = ue.length, wt = new Array(dt);
      for (let on = 0; on < dt; on++) {
        const Ln = ue[on];
        wt[on] = he(Ln, on);
      }
      return wt;
    }, Tt = (ue, he) => {
      for (let dt = 0, wt = ue.length; dt < wt; dt++) {
        const on = ue[dt];
        he(on, dt);
      }
    }, Ht = (ue, he) => {
      for (let dt = ue.length - 1; dt >= 0; dt--) {
        const wt = ue[dt];
        he(wt, dt);
      }
    }, gn = (ue, he) => {
      if (ue.length === 0)
        return [];
      {
        let dt = he(ue[0]);
        const wt = [];
        let on = [];
        for (let Ln = 0, On = ue.length; Ln < On; Ln++) {
          const Dn = ue[Ln], Mn = he(Dn);
          Mn !== dt && (wt.push(on), on = []), dt = Mn, on.push(Dn);
        }
        return on.length !== 0 && wt.push(on), wt;
      }
    }, De = (ue, he, dt) => (Tt(ue, (wt, on) => {
      dt = he(dt, wt, on);
    }), dt), re = (ue) => {
      const he = [];
      for (let dt = 0, wt = ue.length; dt < wt; ++dt) {
        if (!Ee(ue[dt]))
          throw new Error("Arr.flatten item " + dt + " was not an array, input: " + ue);
        ht.apply(he, ue[dt]);
      }
      return he;
    }, ho = (ue, he) => re(U(ue, he)), Te = (ue, he) => {
      const dt = xo.call(ue, 0);
      return dt.sort(he), dt;
    }, Oe = Object.hasOwnProperty, A = (ue, he) => Oe.call(ue, he);
    typeof window < "u" || Function("return this;")();
    const mn = 9, it = 11, Gn = 1, rn = 3, Ye = (ue) => ue.dom.nodeType, jo = ((ue) => (he) => Ye(he) === ue)(rn), bt = (ue, he, dt) => {
      if (Fe(dt) || Bt(dt) || Sn(dt))
        ue.setAttribute(he, dt + "");
      else
        throw new Error("Attribute value was not simple");
    }, kn = (ue, he, dt) => {
      bt(ue.dom, he, dt);
    }, $e = (ue, he) => {
      const wt = (he || document).createElement("div");
      if (wt.innerHTML = ue, !wt.hasChildNodes() || wt.childNodes.length > 1) {
        const on = "HTML does not have a single root node";
        throw new Error(on);
      }
      return ss(wt.childNodes[0]);
    }, ot = (ue, he) => {
      const wt = (he || document).createElement(ue);
      return ss(wt);
    }, F = (ue, he) => {
      const wt = (he || document).createTextNode(ue);
      return ss(wt);
    }, ss = (ue) => {
      if (ue == null)
        throw new Error("Node cannot be null or undefined");
      return { dom: ue };
    }, at = {
      fromHtml: $e,
      fromTag: ot,
      fromText: F,
      fromDom: ss,
      fromPoint: (ue, he, dt) => Pn.from(ue.dom.elementFromPoint(he, dt)).map(ss)
    }, lt = (ue) => ue.nodeType !== Gn && ue.nodeType !== mn && ue.nodeType !== it || ue.childElementCount === 0, Rn = (ue, he) => {
      const dt = he === void 0 ? document : he.dom;
      return lt(dt) ? [] : U(dt.querySelectorAll(ue), at.fromDom);
    }, ee = (ue) => Pn.from(ue.dom.parentNode).map(at.fromDom), pe = (ue) => U(ue.dom.childNodes, at.fromDom), ye = (ue, he) => ({
      element: ue,
      offset: he
    }), ae = (ue, he) => {
      const dt = pe(ue);
      return dt.length > 0 && he < dt.length ? ye(dt[he], 0) : ye(ue, he);
    }, kt = (ue, he) => {
      ee(ue).each((wt) => {
        wt.dom.insertBefore(he.dom, ue.dom);
      });
    }, Vn = (ue, he) => {
      ue.dom.appendChild(he.dom);
    }, Yt = (ue, he) => {
      kt(ue, he), Vn(he, ue);
    }, Xe = ((ue, he) => {
      const dt = (Ln) => {
        if (!ue(Ln))
          throw new Error("Can only get " + he + " value of a " + he + " node");
        return wt(Ln).getOr("");
      }, wt = (Ln) => ue(Ln) ? Pn.from(Ln.dom.nodeValue) : Pn.none();
      return {
        get: dt,
        getOption: wt,
        set: (Ln, On) => {
          if (!ue(Ln))
            throw new Error("Can only set raw " + he + " value of a " + he + " node");
          Ln.dom.nodeValue = On;
        }
      };
    })(jo, "text"), In = (ue) => Xe.get(ue), hn = (ue, he, dt) => (ue.compareDocumentPosition(he) & dt) !== 0, Xn = (ue, he) => hn(ue, he, Node.DOCUMENT_POSITION_PRECEDING), Xo = (ue, he) => Rn(he, ue);
    var ds = tinymce.util.Tools.resolve("tinymce.dom.TreeWalker");
    const No = (ue, he) => ue.isBlock(he) || A(ue.schema.getVoidElements(), he.nodeName), Ao = (ue, he) => !ue.isEditable(he), Cs = (ue, he) => ue.getContentEditable(he) === "true" && he.parentNode && !ue.isEditable(he.parentNode), Ie = (ue, he) => !ue.isBlock(he) && A(ue.schema.getWhitespaceElements(), he.nodeName), et = (ue, he) => No(ue, he) || Ao(ue, he) || Ie(ue, he) || Cs(ue, he), nn = (ue) => ue.nodeType === 3, qt = () => ({
      sOffset: 0,
      fOffset: 0,
      elements: []
    }), ko = (ue, he) => ae(at.fromDom(ue), he), rs = (ue, he, dt, wt, on, Ln = !0) => {
      let On = Ln ? he(!1) : dt;
      for (; On; ) {
        const Dn = Ao(ue, On);
        if (Dn || Ie(ue, On)) {
          if (Dn ? wt.cef(On) : wt.boundary(On))
            break;
          On = he(!0);
          continue;
        } else if (No(ue, On)) {
          if (wt.boundary(On))
            break;
        } else nn(On) && wt.text(On);
        if (On === on)
          break;
        On = he(!1);
      }
    }, Gs = (ue, he, dt, wt, on) => {
      var Ln;
      if (et(ue, dt))
        return;
      const On = (Ln = ue.getParent(wt, ue.isBlock)) !== null && Ln !== void 0 ? Ln : ue.getRoot(), Dn = new ds(dt, On), Mn = on ? Dn.next.bind(Dn) : Dn.prev.bind(Dn);
      rs(ue, Mn, dt, {
        boundary: Qt,
        cef: Qt,
        text: (Kn) => {
          on ? he.fOffset += Kn.length : he.sOffset += Kn.length, he.elements.push(at.fromDom(Kn));
        }
      });
    }, Yr = (ue, he, dt, wt, on, Ln = !0) => {
      const On = new ds(dt, he), Dn = [];
      let Mn = qt();
      Gs(ue, Mn, dt, he, !1);
      const Kn = () => (Mn.elements.length > 0 && (Dn.push(Mn), Mn = qt()), !1);
      return rs(ue, On.next.bind(On), dt, {
        boundary: Kn,
        cef: (zo) => (Kn(), on && Dn.push(...on.cef(zo)), !1),
        text: (zo) => {
          Mn.elements.push(at.fromDom(zo)), on && on.text(zo, Mn);
        }
      }, wt, Ln), wt && Gs(ue, Mn, wt, he, !0), Kn(), Dn;
    }, Ss = (ue, he) => {
      const dt = ko(he.startContainer, he.startOffset), wt = dt.element.dom, on = ko(he.endContainer, he.endOffset), Ln = on.element.dom;
      return Yr(ue, he.commonAncestorContainer, wt, Ln, {
        text: (On, Dn) => {
          On === Ln ? Dn.fOffset += On.length - on.offset : On === wt && (Dn.sOffset += dt.offset);
        },
        cef: (On) => {
          const Dn = ho(Xo(at.fromDom(On), "*[contenteditable=true]"), (Mn) => {
            const Kn = Mn.dom;
            return Yr(ue, Kn, Kn);
          });
          return Te(Dn, (Mn, Kn) => Xn(Mn.elements[0].dom, Kn.elements[0].dom) ? 1 : -1);
        }
      }, !1);
    }, or = (ue, he) => he.collapsed ? [] : Ss(ue, he), Dt = (ue, he) => {
      const dt = ue.createRng();
      return dt.selectNode(he), or(ue, dt);
    }, Lo = (ue, he) => ho(he, (dt) => Dt(ue, dt)), Or = (ue, he, dt = 0, wt = ue.length) => {
      const on = he.regex;
      on.lastIndex = dt;
      const Ln = [];
      let On;
      for (; On = on.exec(ue); ) {
        const Dn = On[he.matchIndex], Mn = On.index + On[0].indexOf(Dn), Kn = Mn + Dn.length;
        if (Kn > wt)
          break;
        Ln.push({
          start: Mn,
          finish: Kn
        }), on.lastIndex = Kn;
      }
      return Ln;
    }, aa = (ue, he) => {
      const dt = De(ue, (wt, on) => {
        const Ln = In(on), On = wt.last, Dn = On + Ln.length, Mn = ho(he, (Kn, zo) => Kn.start < Dn && Kn.finish > On ? [{
          element: on,
          start: Math.max(On, Kn.start) - On,
          finish: Math.min(Dn, Kn.finish) - On,
          matchId: zo
        }] : []);
        return {
          results: wt.results.concat(Mn),
          last: Dn
        };
      }, {
        results: [],
        last: 0
      }).results;
      return gn(dt, (wt) => wt.matchId);
    }, Xr = (ue, he) => ho(he, (dt) => {
      const wt = dt.elements, on = U(wt, In).join(""), Ln = Or(on, ue, dt.sOffset, on.length - dt.fOffset);
      return aa(wt, Ln);
    }), Jr = (ue, he) => {
      Ht(ue, (dt, wt) => {
        Ht(dt, (on) => {
          const Ln = at.fromDom(he.cloneNode(!1));
          kn(Ln, "data-mce-index", wt);
          const On = on.element.dom;
          if (On.length === on.finish && on.start === 0)
            Yt(on.element, Ln);
          else {
            On.length !== on.finish && On.splitText(on.finish);
            const Dn = On.splitText(on.start);
            Yt(at.fromDom(Dn), Ln);
          }
        });
      });
    }, xs = (ue, he, dt, wt) => {
      const on = Dt(ue, dt), Ln = Xr(he, on);
      return Jr(Ln, wt), Ln.length;
    }, fa = (ue, he, dt, wt) => {
      const on = dt.getBookmark(), Ln = ue.select("td[data-mce-selected],th[data-mce-selected]"), On = Ln.length > 0 ? Lo(ue, Ln) : or(ue, dt.getRng()), Dn = Xr(he, On);
      return Jr(Dn, wt), dt.moveToBookmark(on), Dn.length;
    }, Qr = (ue) => ue.getAttribute("data-mce-index"), Ts = (ue, he, dt, wt) => {
      const on = ue.dom.create("span", { "data-mce-bogus": 1 });
      on.className = "mce-match-marker";
      const Ln = ue.getBody();
      return wr(ue, he, !1), wt ? fa(ue.dom, dt, ue.selection, on) : xs(ue.dom, dt, Ln, on);
    }, Zn = (ue) => {
      var he;
      const dt = ue.parentNode;
      ue.firstChild && dt.insertBefore(ue.firstChild, ue), (he = ue.parentNode) === null || he === void 0 || he.removeChild(ue);
    }, dr = (ue, he) => {
      const dt = [], wt = Qe.toArray(ue.getBody().getElementsByTagName("span"));
      if (wt.length)
        for (let on = 0; on < wt.length; on++) {
          const Ln = Qr(wt[on]);
          Ln === null || !Ln.length || Ln === he.toString() && dt.push(wt[on]);
        }
      return dt;
    }, ga = (ue, he, dt) => {
      const wt = he.get();
      let on = wt.index;
      const Ln = ue.dom;
      dt ? on + 1 === wt.count ? on = 0 : on++ : on - 1 === -1 ? on = wt.count - 1 : on--, Ln.removeClass(dr(ue, wt.index), "mce-match-marker-selected");
      const On = dr(ue, on);
      return On.length ? (Ln.addClass(dr(ue, on), "mce-match-marker-selected"), ue.selection.scrollIntoView(On[0]), on) : -1;
    }, Za = (ue, he) => {
      const dt = he.parentNode;
      ue.remove(he), dt && ue.isEmpty(dt) && ue.remove(dt);
    }, _c = (ue, he) => {
      const wt = "(" + ue.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&").replace(/\s/g, "[^\\S\\r\\n\\uFEFF]") + ")";
      return he ? `(?:^|\\s|${Kt()})` + wt + `(?=$|\\s|${Kt()})` : wt;
    }, sr = (ue, he, dt, wt, on, Ln) => {
      const On = ue.selection, Dn = _c(dt, on), Mn = On.isForward(), Kn = {
        regex: new RegExp(Dn, wt ? "g" : "gi"),
        matchIndex: 1
      }, zo = Ts(ue, he, Kn, Ln);
      if (J.browser.isSafari() && On.setRng(On.getRng(), Mn), zo) {
        const Ds = ga(ue, he, !0);
        he.set({
          index: Ds,
          count: zo,
          text: dt,
          matchCase: wt,
          wholeWord: on,
          inSelection: Ln
        });
      }
      return zo;
    }, Ks = (ue, he) => {
      const dt = ga(ue, he, !0);
      he.set({
        ...he.get(),
        index: dt
      });
    }, Vs = (ue, he) => {
      const dt = ga(ue, he, !1);
      he.set({
        ...he.get(),
        index: dt
      });
    }, Sa = (ue) => {
      const he = Qr(ue);
      return he !== null && he.length > 0;
    }, rc = (ue, he, dt, wt, on) => {
      const Ln = he.get(), On = Ln.index;
      let Dn, Mn = On;
      wt = wt !== !1;
      const Kn = ue.getBody(), zo = Qe.grep(Qe.toArray(Kn.getElementsByTagName("span")), Sa);
      for (let Ds = 0; Ds < zo.length; Ds++) {
        const Ra = Qr(zo[Ds]);
        let ac = Dn = parseInt(Ra, 10);
        if (on || ac === Ln.index) {
          for (dt.length ? (zo[Ds].innerText = dt, Zn(zo[Ds])) : Za(ue.dom, zo[Ds]); zo[++Ds]; )
            if (ac = parseInt(Qr(zo[Ds]), 10), ac === Dn)
              Za(ue.dom, zo[Ds]);
            else {
              Ds--;
              break;
            }
          wt && Mn--;
        } else Dn > On && zo[Ds].setAttribute("data-mce-index", String(Dn - 1));
      }
      return he.set({
        ...Ln,
        count: on ? 0 : Ln.count - 1,
        index: Mn
      }), wt ? Ks(ue, he) : Vs(ue, he), !on && he.get().count > 0;
    }, wr = (ue, he, dt) => {
      let wt, on;
      const Ln = he.get(), On = Qe.toArray(ue.getBody().getElementsByTagName("span"));
      for (let Dn = 0; Dn < On.length; Dn++) {
        const Mn = Qr(On[Dn]);
        Mn !== null && Mn.length && (Mn === Ln.index.toString() && (wt || (wt = On[Dn].firstChild), on = On[Dn].firstChild), Zn(On[Dn]));
      }
      if (he.set({
        ...Ln,
        index: -1,
        count: 0,
        text: ""
      }), wt && on) {
        const Dn = ue.dom.createRng();
        return Dn.setStart(wt, 0), Dn.setEnd(on, on.data.length), dt !== !1 && ue.selection.setRng(Dn), Dn;
      } else
        return;
    }, de = (ue, he) => he.get().count > 1, ie = (ue, he) => he.get().count > 1, ze = (ue, he) => ({
      done: (Dn) => wr(ue, he, Dn),
      find: (Dn, Mn, Kn, zo = !1) => sr(ue, he, Dn, Mn, Kn, zo),
      next: () => Ks(ue, he),
      prev: () => Vs(ue, he),
      replace: (Dn, Mn, Kn) => rc(ue, he, Dn, Mn, Kn)
    }), Je = (ue) => {
      const he = vt(Pn.none()), dt = () => he.get().each(ue);
      return {
        clear: () => {
          dt(), he.set(Pn.none());
        },
        isSet: () => he.get().isSome(),
        get: () => he.get(),
        set: (Dn) => {
          dt(), he.set(Pn.some(Dn));
        }
      };
    }, Nn = () => {
      const ue = Je(Ft);
      return {
        ...ue,
        on: (dt) => ue.get().each(dt)
      };
    }, Wn = (ue, he) => {
      const dt = Nn();
      ue.undoManager.add();
      const wt = Qe.trim(ue.selection.getContent({ format: "text" })), on = (lo) => {
        lo.setEnabled("next", de(ue, he)), lo.setEnabled("prev", ie(ue, he));
      }, Ln = (lo) => {
        const Fo = lo.getData(), ms = he.get();
        he.set({
          ...ms,
          matchCase: Fo.matchcase,
          wholeWord: Fo.wholewords,
          inSelection: Fo.inselection
        });
      }, On = (lo, Fo) => {
        Tt([
          "replace",
          "replaceall",
          "prev",
          "next"
        ], (zr) => lo.setEnabled(zr, !Fo));
      }, Dn = (lo, Fo) => {
        Fo.redial(vc(lo, Fo.getData()));
      }, Mn = (lo, Fo) => {
        J.browser.isSafari() && J.deviceType.isTouch() && (Fo === "find" || Fo === "replace" || Fo === "replaceall") && lo.focus(Fo);
      }, Kn = (lo) => {
        wr(ue, he, !1), On(lo, !0), on(lo);
      }, zo = (lo) => {
        const Fo = lo.getData(), ms = he.get();
        if (!Fo.findtext.length) {
          Kn(lo);
          return;
        }
        if (ms.text === Fo.findtext && ms.matchCase === Fo.matchcase && ms.wholeWord === Fo.wholewords)
          Ks(ue, he);
        else {
          const xa = sr(ue, he, Fo.findtext, Fo.matchcase, Fo.wholewords, Fo.inselection);
          xa <= 0 && Dn(!0, lo), On(lo, xa === 0);
        }
        on(lo);
      }, Ds = he.get(), Ra = {
        findtext: wt,
        replacetext: "",
        wholewords: Ds.wholeWord,
        matchcase: Ds.matchCase,
        inselection: Ds.inSelection
      }, ac = (lo) => {
        const Fo = [
          {
            type: "bar",
            items: [
              {
                type: "input",
                name: "findtext",
                placeholder: "Find",
                maximized: !0,
                inputMode: "search"
              },
              {
                type: "button",
                name: "prev",
                text: "Previous",
                icon: "action-prev",
                enabled: !1,
                borderless: !0
              },
              {
                type: "button",
                name: "next",
                text: "Next",
                icon: "action-next",
                enabled: !1,
                borderless: !0
              }
            ]
          },
          {
            type: "input",
            name: "replacetext",
            placeholder: "Replace with",
            inputMode: "search"
          }
        ];
        return lo && Fo.push({
          type: "alertbanner",
          level: "error",
          text: "Could not find the specified string.",
          icon: "warning"
        }), Fo;
      }, vc = (lo, Fo) => ({
        title: "Find and Replace",
        size: "normal",
        body: {
          type: "panel",
          items: ac(lo)
        },
        buttons: [
          {
            type: "menu",
            name: "options",
            icon: "preferences",
            tooltip: "Preferences",
            align: "start",
            items: [
              {
                type: "togglemenuitem",
                name: "matchcase",
                text: "Match case"
              },
              {
                type: "togglemenuitem",
                name: "wholewords",
                text: "Find whole words only"
              },
              {
                type: "togglemenuitem",
                name: "inselection",
                text: "Find in selection"
              }
            ]
          },
          {
            type: "custom",
            name: "find",
            text: "Find",
            primary: !0
          },
          {
            type: "custom",
            name: "replace",
            text: "Replace",
            enabled: !1
          },
          {
            type: "custom",
            name: "replaceall",
            text: "Replace all",
            enabled: !1
          }
        ],
        initialData: Fo,
        onChange: (ms, xa) => {
          lo && Dn(!1, ms), xa.name === "findtext" && he.get().count > 0 && Kn(ms);
        },
        onAction: (ms, xa) => {
          const zr = ms.getData();
          switch (xa.name) {
            case "find":
              zo(ms);
              break;
            case "replace":
              rc(ue, he, zr.replacetext) ? on(ms) : Kn(ms);
              break;
            case "replaceall":
              rc(ue, he, zr.replacetext, !0, !0), Kn(ms);
              break;
            case "prev":
              Vs(ue, he), on(ms);
              break;
            case "next":
              Ks(ue, he), on(ms);
              break;
            case "matchcase":
            case "wholewords":
            case "inselection":
              Dn(!1, ms), Ln(ms), Kn(ms);
              break;
          }
          Mn(ms, xa.name);
        },
        onSubmit: (ms) => {
          zo(ms), Mn(ms, "find");
        },
        onClose: () => {
          ue.focus(), wr(ue, he), ue.undoManager.add();
        }
      });
      dt.set(ue.windowManager.open(vc(!1, Ra), { inline: "toolbar" }));
    }, _o = (ue, he) => {
      ue.addCommand("SearchReplace", () => {
        Wn(ue, he);
      });
    }, Fs = (ue, he) => () => {
      Wn(ue, he);
    }, ve = (ue, he) => {
      ue.ui.registry.addMenuItem("searchreplace", {
        text: "Find and replace...",
        shortcut: "Meta+F",
        onAction: Fs(ue, he),
        icon: "search"
      }), ue.ui.registry.addButton("searchreplace", {
        tooltip: "Find and replace",
        onAction: Fs(ue, he),
        icon: "search"
      }), ue.shortcuts.add("Meta+F", "", Fs(ue, he));
    };
    var go = () => {
      Ot.add("searchreplace", (ue) => {
        const he = vt({
          index: -1,
          count: 0,
          text: "",
          matchCase: !1,
          wholeWord: !1,
          inSelection: !1
        });
        return _o(ue, he), ve(ue, he), ze(ue, he);
      });
    };
    go();
  })()), kK;
}
var AK;
function bX() {
  return AK || (AK = 1, pX()), EK;
}
bX();
var OK = {}, DK = {}, RK;
function vX() {
  return RK || (RK = 1, (function() {
    var vt = tinymce.util.Tools.resolve("tinymce.PluginManager");
    const Ot = (w, k, H) => {
      var q;
      return H(w, k.prototype) ? !0 : ((q = w.constructor) === null || q === void 0 ? void 0 : q.name) === k.name;
    }, Pt = (w) => {
      const k = typeof w;
      return w === null ? "null" : k === "object" && Array.isArray(w) ? "array" : k === "object" && Ot(w, String, (H, q) => q.isPrototypeOf(H)) ? "string" : k;
    }, yt = (w) => (k) => Pt(k) === w, Nt = (w) => (k) => typeof k === w, Wt = (w) => (k) => w === k, Fe = yt("string"), Ee = yt("array"), Bt = Nt("boolean"), fn = Wt(void 0), dn = (w) => w == null, Sn = (w) => !dn(w), Ft = Nt("function"), Zt = Nt("number"), Qt = () => {
    }, En = (w, k) => (H) => w(k(H)), st = (w) => () => w, Pn = (w) => w, Kt = (w, k) => w === k;
    function J(w, ...k) {
      return (...H) => {
        const q = k.concat(H);
        return w.apply(null, q);
      };
    }
    const Qe = (w) => {
      w();
    }, xo = st(!1), ht = st(!0);
    class U {
      constructor(k, H) {
        this.tag = k, this.value = H;
      }
      static some(k) {
        return new U(!0, k);
      }
      static none() {
        return U.singletonNone;
      }
      fold(k, H) {
        return this.tag ? H(this.value) : k();
      }
      isSome() {
        return this.tag;
      }
      isNone() {
        return !this.tag;
      }
      map(k) {
        return this.tag ? U.some(k(this.value)) : U.none();
      }
      bind(k) {
        return this.tag ? k(this.value) : U.none();
      }
      exists(k) {
        return this.tag && k(this.value);
      }
      forall(k) {
        return !this.tag || k(this.value);
      }
      filter(k) {
        return !this.tag || k(this.value) ? this : U.none();
      }
      getOr(k) {
        return this.tag ? this.value : k;
      }
      or(k) {
        return this.tag ? this : k;
      }
      getOrThunk(k) {
        return this.tag ? this.value : k();
      }
      orThunk(k) {
        return this.tag ? this : k();
      }
      getOrDie(k) {
        if (this.tag)
          return this.value;
        throw new Error(k ?? "Called getOrDie on None");
      }
      static from(k) {
        return Sn(k) ? U.some(k) : U.none();
      }
      getOrNull() {
        return this.tag ? this.value : null;
      }
      getOrUndefined() {
        return this.value;
      }
      each(k) {
        this.tag && k(this.value);
      }
      toArray() {
        return this.tag ? [this.value] : [];
      }
      toString() {
        return this.tag ? `some(${this.value})` : "none()";
      }
    }
    U.singletonNone = new U(!1);
    const Tt = Object.keys, Ht = Object.hasOwnProperty, gn = (w, k) => {
      const H = Tt(w);
      for (let q = 0, we = H.length; q < we; q++) {
        const rt = H[q], $t = w[rt];
        k($t, rt);
      }
    }, De = (w) => (k, H) => {
      w[H] = k;
    }, re = (w, k, H, q) => {
      gn(w, (we, rt) => {
        (k(we, rt) ? H : q)(we, rt);
      });
    }, ho = (w, k) => {
      const H = {};
      return re(w, k, De(H), Qt), H;
    }, Te = (w, k) => {
      const H = [];
      return gn(w, (q, we) => {
        H.push(k(q, we));
      }), H;
    }, Oe = (w) => Te(w, Pn), A = (w) => Tt(w).length, mn = (w, k) => it(w, k) ? U.from(w[k]) : U.none(), it = (w, k) => Ht.call(w, k), Gn = (w, k) => it(w, k) && w[k] !== void 0 && w[k] !== null, rn = (w) => {
      for (const k in w)
        if (Ht.call(w, k))
          return !1;
      return !0;
    }, Ye = Array.prototype.indexOf, io = Array.prototype.push, jo = (w, k) => Ye.call(w, k), bt = (w, k) => jo(w, k) > -1, kn = (w, k) => {
      for (let H = 0, q = w.length; H < q; H++) {
        const we = w[H];
        if (k(we, H))
          return !0;
      }
      return !1;
    }, $e = (w, k) => {
      const H = [];
      for (let q = 0; q < w; q++)
        H.push(k(q));
      return H;
    }, ot = (w, k) => {
      const H = w.length, q = new Array(H);
      for (let we = 0; we < H; we++) {
        const rt = w[we];
        q[we] = k(rt, we);
      }
      return q;
    }, F = (w, k) => {
      for (let H = 0, q = w.length; H < q; H++) {
        const we = w[H];
        k(we, H);
      }
    }, ss = (w, k) => {
      for (let H = w.length - 1; H >= 0; H--) {
        const q = w[H];
        k(q, H);
      }
    }, fo = (w, k) => {
      const H = [], q = [];
      for (let we = 0, rt = w.length; we < rt; we++) {
        const $t = w[we];
        (k($t, we) ? H : q).push($t);
      }
      return {
        pass: H,
        fail: q
      };
    }, at = (w, k) => {
      const H = [];
      for (let q = 0, we = w.length; q < we; q++) {
        const rt = w[q];
        k(rt, q) && H.push(rt);
      }
      return H;
    }, lt = (w, k, H) => (ss(w, (q, we) => {
      H = k(H, q, we);
    }), H), Rn = (w, k, H) => (F(w, (q, we) => {
      H = k(H, q, we);
    }), H), ee = (w, k, H) => {
      for (let q = 0, we = w.length; q < we; q++) {
        const rt = w[q];
        if (k(rt, q))
          return U.some(rt);
        if (H(rt, q))
          break;
      }
      return U.none();
    }, pe = (w, k) => ee(w, k, xo), ye = (w) => {
      const k = [];
      for (let H = 0, q = w.length; H < q; ++H) {
        if (!Ee(w[H]))
          throw new Error("Arr.flatten item " + H + " was not an array, input: " + w);
        io.apply(k, w[H]);
      }
      return k;
    }, ae = (w, k) => ye(ot(w, k)), kt = (w, k) => {
      for (let H = 0, q = w.length; H < q; ++H) {
        const we = w[H];
        if (k(we, H) !== !0)
          return !1;
      }
      return !0;
    }, Vn = (w, k) => {
      const H = {};
      for (let q = 0, we = w.length; q < we; q++) {
        const rt = w[q];
        H[String(rt)] = k(rt, q);
      }
      return H;
    }, Yt = (w, k) => k >= 0 && k < w.length ? U.some(w[k]) : U.none(), Ct = (w) => Yt(w, 0), Xe = (w) => Yt(w, w.length - 1), In = (w, k) => {
      for (let H = 0; H < w.length; H++) {
        const q = k(w[H], H);
        if (q.isSome())
          return q;
      }
      return U.none();
    }, hn = 8, Xn = 9, Xo = 11, ds = 1, No = 3, Ao = (w, k) => {
      const q = (k || document).createElement("div");
      if (q.innerHTML = w, !q.hasChildNodes() || q.childNodes.length > 1) {
        const we = "HTML does not have a single root node";
        throw new Error(we);
      }
      return et(q.childNodes[0]);
    }, Cs = (w, k) => {
      const q = (k || document).createElement(w);
      return et(q);
    }, Ie = (w, k) => {
      const q = (k || document).createTextNode(w);
      return et(q);
    }, et = (w) => {
      if (w == null)
        throw new Error("Node cannot be null or undefined");
      return { dom: w };
    }, qt = {
      fromHtml: Ao,
      fromTag: Cs,
      fromText: Ie,
      fromDom: et,
      fromPoint: (w, k, H) => U.from(w.dom.elementFromPoint(k, H)).map(et)
    }, ko = (w, k) => {
      const H = w.dom;
      if (H.nodeType !== ds)
        return !1;
      {
        const q = H;
        if (q.matches !== void 0)
          return q.matches(k);
        if (q.msMatchesSelector !== void 0)
          return q.msMatchesSelector(k);
        if (q.webkitMatchesSelector !== void 0)
          return q.webkitMatchesSelector(k);
        if (q.mozMatchesSelector !== void 0)
          return q.mozMatchesSelector(k);
        throw new Error("Browser lacks native selectors");
      }
    }, rs = (w) => w.nodeType !== ds && w.nodeType !== Xn && w.nodeType !== Xo || w.childElementCount === 0, Gs = (w, k) => {
      const H = k === void 0 ? document : k.dom;
      return rs(H) ? [] : ot(H.querySelectorAll(w), qt.fromDom);
    }, Yr = (w, k) => {
      const H = k === void 0 ? document : k.dom;
      return rs(H) ? U.none() : U.from(H.querySelector(w)).map(qt.fromDom);
    }, Ss = (w, k) => w.dom === k.dom, or = ko;
    typeof window < "u" || Function("return this;")();
    const Dt = (w) => w.dom.nodeName.toLowerCase(), Lo = (w) => w.dom.nodeType, Or = (w) => (k) => Lo(k) === w, aa = (w) => Lo(w) === hn || Dt(w) === "#comment", Xr = Or(ds), Jr = Or(No), xs = Or(Xn), fa = Or(Xo), Qr = (w) => (k) => Xr(k) && Dt(k) === w, Ts = (w) => qt.fromDom(w.dom.ownerDocument), Zn = (w) => xs(w) ? w : Ts(w), dr = (w) => U.from(w.dom.parentNode).map(qt.fromDom), ga = (w, k) => {
      const H = Ft(k) ? k : xo;
      let q = w.dom;
      const we = [];
      for (; q.parentNode !== null && q.parentNode !== void 0; ) {
        const rt = q.parentNode, $t = qt.fromDom(rt);
        if (we.push($t), H($t) === !0)
          break;
        q = rt;
      }
      return we;
    }, Za = (w) => U.from(w.dom.previousSibling).map(qt.fromDom), _c = (w) => U.from(w.dom.nextSibling).map(qt.fromDom), sr = (w) => ot(w.dom.childNodes, qt.fromDom), Ks = (w, k) => {
      const H = w.dom.childNodes;
      return U.from(H[k]).map(qt.fromDom);
    }, Vs = (w) => Ks(w, 0), Sa = (w) => fa(w) && Sn(w.dom.host), wr = Ft(Element.prototype.attachShadow) && Ft(Node.prototype.getRootNode) ? (w) => qt.fromDom(w.dom.getRootNode()) : Zn, de = (w) => {
      const k = wr(w);
      return Sa(k) ? U.some(k) : U.none();
    }, ie = (w) => qt.fromDom(w.dom.host), ze = (w) => {
      const k = Jr(w) ? w.dom.parentNode : w.dom;
      if (k == null || k.ownerDocument === null)
        return !1;
      const H = k.ownerDocument;
      return de(qt.fromDom(k)).fold(() => H.body.contains(k), En(ze, ie));
    };
    var Je = (w, k, H, q, we) => w(H, q) ? U.some(H) : Ft(we) && we(H) ? U.none() : k(H, q, we);
    const Nn = (w, k, H) => {
      let q = w.dom;
      const we = Ft(H) ? H : xo;
      for (; q.parentNode; ) {
        q = q.parentNode;
        const rt = qt.fromDom(q);
        if (k(rt))
          return U.some(rt);
        if (we(rt))
          break;
      }
      return U.none();
    }, Wn = (w, k, H) => Je((we, rt) => rt(we), Nn, w, k, H), _o = (w, k) => {
      const H = (we) => k(qt.fromDom(we));
      return pe(w.dom.childNodes, H).map(qt.fromDom);
    }, Fs = (w, k, H) => Nn(w, (q) => ko(q, k), H), ve = (w, k) => _o(w, (H) => ko(H, k)), go = (w, k) => Yr(k, w), ue = (w, k, H) => Je((we, rt) => ko(we, rt), Fs, w, k, H), he = (w) => ue(w, "[contenteditable]"), dt = (w, k = !1) => ze(w) ? w.dom.isContentEditable : he(w).fold(st(k), (H) => wt(H) === "true"), wt = (w) => w.dom.contentEditable, on = (w) => w.nodeName.toLowerCase(), Ln = (w) => qt.fromDom(w.getBody()), On = (w) => (k) => Ss(k, Ln(w)), Dn = (w) => w ? w.replace(/px$/, "") : "", Mn = (w) => /^\d+(\.\d+)?$/.test(w) ? w + "px" : w, Kn = (w) => qt.fromDom(w.selection.getStart()), zo = (w) => qt.fromDom(w.selection.getEnd()), Ds = (w) => Wn(w, Qr("table")).forall(dt), Ra = (w, k) => at(sr(w), k), ac = (w, k) => {
      let H = [];
      return F(sr(w), (q) => {
        k(q) && (H = H.concat([q])), H = H.concat(ac(q, k));
      }), H;
    }, vc = (w, k) => Ra(w, (H) => ko(H, k)), lo = (w, k) => Gs(k, w), Fo = (w, k, H) => {
      if (Fe(H) || Bt(H) || Zt(H))
        w.setAttribute(k, H + "");
      else
        throw new Error("Attribute value was not simple");
    }, ms = (w, k, H) => {
      Fo(w.dom, k, H);
    }, xa = (w, k) => {
      const H = w.dom;
      gn(k, (q, we) => {
        Fo(H, we, q);
      });
    }, zr = (w, k) => {
      const H = w.dom.getAttribute(k);
      return H === null ? void 0 : H;
    }, mr = (w, k) => U.from(zr(w, k)), Hs = (w, k) => {
      w.dom.removeAttribute(k);
    }, Fa = (w) => Rn(w.dom.attributes, (k, H) => (k[H.name] = H.value, k), {}), nl = (w, k, H = Kt) => w.exists((q) => H(q, k)), Rs = (w) => {
      const k = [], H = (q) => {
        k.push(q);
      };
      for (let q = 0; q < w.length; q++)
        w[q].each(H);
      return k;
    }, ca = (w, k, H) => w.isSome() && k.isSome() ? U.some(H(w.getOrDie(), k.getOrDie())) : U.none(), Ia = (w) => w.bind(Pn), Pr = (w, k) => w ? U.some(k) : U.none(), yc = (w, k) => w.substring(k), Uc = (w, k, H) => k === "" || w.length >= k.length && w.substr(H, H + k.length) === k, Ta = (w, k) => Ac(w, k) ? yc(w, k.length) : w, Ac = (w, k) => Uc(w, k, 0), vu = ((w) => (k) => k.replace(w, ""))(/^\s+|\s+$/g), Dc = (w) => w.length > 0, yl = (w) => !Dc(w), ja = (w, k = 10) => {
      const H = parseInt(w, k);
      return isNaN(H) ? U.none() : U.some(H);
    }, wi = (w) => {
      const k = parseFloat(w);
      return isNaN(k) ? U.none() : U.some(k);
    }, Bi = (w) => w.style !== void 0 && Ft(w.style.getPropertyValue), Cl = (w, k, H) => {
      if (!Fe(H))
        throw new Error("CSS value must be a string: " + H);
      Bi(w) && w.style.setProperty(k, H);
    }, Ju = (w, k) => {
      Bi(w) && w.style.removeProperty(k);
    }, Z = (w, k, H) => {
      const q = w.dom;
      Cl(q, k, H);
    }, fe = (w, k) => {
      const H = w.dom, we = window.getComputedStyle(H).getPropertyValue(k);
      return we === "" && !ze(w) ? _e(H, k) : we;
    }, _e = (w, k) => Bi(w) ? w.style.getPropertyValue(k) : "", Ve = (w, k) => {
      const H = w.dom, q = _e(H, k);
      return U.from(q).filter((we) => we.length > 0);
    }, Rt = (w, k) => {
      const H = w.dom;
      Ju(H, k), nl(mr(w, "style").map(vu), "") && Hs(w, "style");
    }, eo = (w, k, H = 0) => mr(w, k).map((q) => parseInt(q, 10)).getOr(H), Ns = (w, k) => Is(w, k, ht), Is = (w, k, H) => ae(sr(w), (q) => ko(q, k) ? H(q) ? [q] : [] : Is(q, k, H)), Os = [
      "tfoot",
      "thead",
      "tbody",
      "colgroup"
    ], Ys = (w) => bt(Os, w), qo = (w, k) => ({
      rows: w,
      columns: k
    }), fr = (w, k, H) => ({
      element: w,
      rowspan: k,
      colspan: H
    }), Na = (w, k, H, q, we, rt) => ({
      element: w,
      rowspan: k,
      colspan: H,
      row: q,
      column: we,
      isLocked: rt
    }), ol = (w, k, H) => ({
      element: w,
      cells: k,
      section: H
    }), sn = (w, k, H, q) => ({
      startRow: w,
      startCol: k,
      finishRow: H,
      finishCol: q
    }), Ql = (w, k, H) => ({
      element: w,
      colspan: k,
      column: H
    }), rr = (w, k) => ({
      element: w,
      columns: k
    }), B = (w, k, H = xo) => {
      if (H(k))
        return U.none();
      if (bt(w, Dt(k)))
        return U.some(k);
      const q = (we) => ko(we, "table") || H(we);
      return Fs(k, w.join(","), q);
    }, K = (w, k) => B([
      "td",
      "th"
    ], w, k), se = (w) => Ns(w, "th,td"), Ue = (w) => ko(w, "colgroup") ? vc(w, "col") : ae(_n(w), (k) => vc(k, "col")), en = (w, k) => ue(w, "table", k), Io = (w) => Ns(w, "tr"), _n = (w) => en(w).fold(st([]), (k) => vc(k, "colgroup")), gr = (w, k) => ot(w, (H) => {
      if (Dt(H) === "colgroup") {
        const q = ot(Ue(H), (we) => {
          const rt = eo(we, "span", 1);
          return fr(we, 1, rt);
        });
        return ol(H, q, "colgroup");
      } else {
        const q = ot(se(H), (we) => {
          const rt = eo(we, "rowspan", 1), $t = eo(we, "colspan", 1);
          return fr(we, rt, $t);
        });
        return ol(H, q, k(H));
      }
    }), _t = (w) => dr(w).map((k) => {
      const H = Dt(k);
      return Ys(H) ? H : "tbody";
    }).getOr("tbody"), Us = (w) => {
      const k = Io(w), q = [
        ..._n(w),
        ...k
      ];
      return gr(q, _t);
    }, qa = "data-snooker-locked-cols", Xs = (w) => mr(w, qa).bind((k) => U.from(k.match(/\d+/g))).map((k) => Vn(k, ht)), Zr = (w, k) => w + "," + k, ri = (w, k, H) => U.from(w.access[Zr(k, H)]), Jo = (w, k, H) => {
      const q = Ga(w, (we) => H(k, we.element));
      return q.length > 0 ? U.some(q[0]) : U.none();
    }, Ga = (w, k) => {
      const H = ae(w.all, (q) => q.cells);
      return at(H, k);
    }, ar = (w) => {
      const k = {};
      let H = 0;
      return F(w.cells, (q) => {
        const we = q.colspan;
        $e(we, (rt) => {
          const $t = H + rt;
          k[$t] = Ql(q.element, we, $t);
        }), H += we;
      }), k;
    }, $i = (w) => {
      const k = {}, H = [], we = Ct(w).map((Yc) => Yc.element).bind(en).bind(Xs).getOr({});
      let rt = 0, $t = 0, pn = 0;
      const {
        pass: oo,
        fail: Jn
      } = fo(w, (Yc) => Yc.section === "colgroup");
      F(Jn, (Yc) => {
        const au = [];
        F(Yc.cells, (Vi) => {
          let Ol = 0;
          for (; k[Zr(pn, Ol)] !== void 0; )
            Ol++;
          const vh = Gn(we, Ol.toString()), Dl = Na(Vi.element, Vi.rowspan, Vi.colspan, pn, Ol, vh);
          for (let cf = 0; cf < Vi.colspan; cf++)
            for (let lf = 0; lf < Vi.rowspan; lf++) {
              const gg = pn + lf, uf = Ol + cf, Aa = Zr(gg, uf);
              k[Aa] = Dl, $t = Math.max($t, uf + 1);
            }
          au.push(Dl);
        }), rt++, H.push(ol(Yc.element, au, Yc.section)), pn++;
      });
      const { columns: Fr, colgroups: Sr } = Xe(oo).map((Yc) => {
        const au = ar(Yc);
        return {
          colgroups: [rr(Yc.element, Oe(au))],
          columns: au
        };
      }).getOrThunk(() => ({
        colgroups: [],
        columns: {}
      }));
      return {
        grid: qo(rt, $t),
        access: k,
        all: H,
        columns: Fr,
        colgroups: Sr
      };
    }, ai = {
      fromTable: (w) => {
        const k = Us(w);
        return $i(k);
      },
      generate: $i,
      getAt: ri,
      findItem: Jo,
      filterItems: Ga,
      justCells: (w) => ae(w.all, (k) => k.cells),
      justColumns: (w) => Oe(w.columns),
      hasColumns: (w) => Tt(w.columns).length > 0,
      getColumnAt: (w, k) => U.from(w.columns[k])
    };
    var Fi = tinymce.util.Tools.resolve("tinymce.util.Tools");
    const Cc = (w, k, H) => {
      const q = w.select("td,th", k);
      let we;
      for (let rt = 0; rt < q.length; rt++) {
        const $t = w.getStyle(q[rt], H);
        if (fn(we) && (we = $t), we !== $t)
          return "";
      }
      return we;
    }, Rc = (w, k, H) => {
      Fi.each("left center right".split(" "), (q) => {
        q !== H && w.formatter.remove("align" + q, {}, k);
      }), H && w.formatter.apply("align" + H, {}, k);
    }, Qu = (w, k, H) => {
      Fi.each("top middle bottom".split(" "), (q) => {
        q !== H && w.formatter.remove("valign" + q, {}, k);
      }), H && w.formatter.apply("valign" + H, {}, k);
    }, Qo = (w, k, H) => {
      w.dispatch("TableModified", {
        ...H,
        table: k
      });
    }, j = (w, k) => wi(w).getOr(k), oe = (w, k, H) => j(fe(w, k), H), Le = (w, k, H, q) => {
      const we = oe(w, `padding-${H}`, 0), rt = oe(w, `padding-${q}`, 0), $t = oe(w, `border-${H}-width`, 0), pn = oe(w, `border-${q}-width`, 0);
      return k - we - rt - $t - pn;
    }, je = (w, k) => {
      const H = w.dom, q = H.getBoundingClientRect().width || H.offsetWidth;
      return Le(w, q, "left", "right");
    }, vo = (w) => je(w);
    var Dr = tinymce.util.Tools.resolve("tinymce.Env");
    const Ka = "tableprops tabledelete | tableinsertrowbefore tableinsertrowafter tabledeleterow | tableinsertcolbefore tableinsertcolafter tabledeletecol", pr = $e(5, (w) => {
      const k = `${w + 1}px`;
      return {
        title: k,
        value: k
      };
    }), cc = ot([
      "Solid",
      "Dotted",
      "Dashed",
      "Double",
      "Groove",
      "Ridge",
      "Inset",
      "Outset",
      "None",
      "Hidden"
    ], (w) => ({
      title: w,
      value: w.toLowerCase()
    })), ks = "100%", Br = (w) => {
      var k;
      const H = w.dom, q = (k = H.getParent(w.selection.getStart(), H.isBlock)) !== null && k !== void 0 ? k : w.getBody();
      return vo(qt.fromDom(q)) + "px";
    }, ia = (w, k) => rh(w) || !wl(w) ? k : sh(w) ? {
      ...k,
      width: Br(w)
    } : {
      ...k,
      width: ks
    }, wc = (w, k) => rh(w) || wl(w) ? k : sh(w) ? {
      ...k,
      width: Br(w)
    } : {
      ...k,
      width: ks
    }, ea = (w) => (k) => k.options.get(w), _r = (w) => {
      const k = w.options.register;
      k("table_border_widths", {
        processor: "object[]",
        default: pr
      }), k("table_border_styles", {
        processor: "object[]",
        default: cc
      }), k("table_cell_advtab", {
        processor: "boolean",
        default: !0
      }), k("table_row_advtab", {
        processor: "boolean",
        default: !0
      }), k("table_advtab", {
        processor: "boolean",
        default: !0
      }), k("table_appearance_options", {
        processor: "boolean",
        default: !0
      }), k("table_grid", {
        processor: "boolean",
        default: !Dr.deviceType.isTouch()
      }), k("table_cell_class_list", {
        processor: "object[]",
        default: []
      }), k("table_row_class_list", {
        processor: "object[]",
        default: []
      }), k("table_class_list", {
        processor: "object[]",
        default: []
      }), k("table_toolbar", {
        processor: "string",
        default: Ka
      }), k("table_background_color_map", {
        processor: "object[]",
        default: []
      }), k("table_border_color_map", {
        processor: "object[]",
        default: []
      });
    }, Vr = ea("table_sizing_mode"), Nc = ea("table_border_widths"), Ii = ea("table_border_styles"), Jm = ea("table_cell_advtab"), Qm = ea("table_row_advtab"), Wc = ea("table_advtab"), ef = ea("table_appearance_options"), Zc = ea("table_grid"), wl = ea("table_style_by_css"), tf = ea("table_cell_class_list"), Cu = ea("table_row_class_list"), dm = ea("table_class_list"), Sl = ea("table_toolbar"), oh = ea("table_background_color_map"), wu = ea("table_border_color_map"), sh = (w) => Vr(w) === "fixed", rh = (w) => Vr(w) === "responsive", ah = (w) => {
      const k = w.options, H = k.get("table_default_styles");
      return k.isSet("table_default_styles") ? H : ia(w, H);
    }, Ad = (w) => {
      const k = w.options, H = k.get("table_default_attributes");
      return k.isSet("table_default_attributes") ? H : wc(w, H);
    }, o1 = (w, k) => k.column >= w.startCol && k.column + k.colspan - 1 <= w.finishCol && k.row >= w.startRow && k.row + k.rowspan - 1 <= w.finishRow, le = (w, k) => {
      let H = !0;
      const q = J(o1, k);
      for (let we = k.startRow; we <= k.finishRow; we++)
        for (let rt = k.startCol; rt <= k.finishCol; rt++)
          H = H && ai.getAt(w, we, rt).exists(q);
      return H ? U.some(k) : U.none();
    }, Su = (w, k) => sn(Math.min(w.row, k.row), Math.min(w.column, k.column), Math.max(w.row + w.rowspan - 1, k.row + k.rowspan - 1), Math.max(w.column + w.colspan - 1, k.column + k.colspan - 1)), Si = (w, k, H) => {
      const q = ai.findItem(w, k, Ss), we = ai.findItem(w, H, Ss);
      return q.bind((rt) => we.map(($t) => Su(rt, $t)));
    }, Od = (w, k, H) => Si(w, k, H).bind((q) => le(w, q)), tg = (w, k, H) => {
      const q = s1(w);
      return Od(q, k, H);
    }, s1 = ai.fromTable, fs = (w, k) => {
      dr(w).each((q) => {
        q.dom.insertBefore(k.dom, w.dom);
      });
    }, ic = (w, k) => {
      _c(w).fold(() => {
        dr(w).each((we) => {
          xi(we, k);
        });
      }, (q) => {
        fs(q, k);
      });
    }, xl = (w, k) => {
      Vs(w).fold(() => {
        xi(w, k);
      }, (q) => {
        w.dom.insertBefore(k.dom, q.dom);
      });
    }, xi = (w, k) => {
      w.dom.appendChild(k.dom);
    }, xu = (w, k) => {
      fs(w, k), xi(k, w);
    }, sl = (w, k) => {
      F(k, (H, q) => {
        const we = q === 0 ? w : k[q - 1];
        ic(we, H);
      });
    }, lc = (w, k) => {
      F(k, (H) => {
        xi(w, H);
      });
    }, Tl = (w) => {
      const k = w.dom;
      k.parentNode !== null && k.parentNode.removeChild(k);
    }, ch = (w) => {
      const k = sr(w);
      k.length > 0 && sl(w, k), Tl(w);
    }, Li = ((w, k) => {
      const H = (rt) => {
        if (!w(rt))
          throw new Error("Can only get " + k + " value of a " + k + " node");
        return q(rt).getOr("");
      }, q = (rt) => w(rt) ? U.from(rt.dom.nodeValue) : U.none();
      return {
        get: H,
        getOption: q,
        set: (rt, $t) => {
          if (!w(rt))
            throw new Error("Can only set raw " + k + " value of a " + k + " node");
          rt.dom.nodeValue = $t;
        }
      };
    })(Jr, "text"), El = (w) => Li.get(w), ng = (w, k) => Li.set(w, k);
    var Sc = [
      "body",
      "p",
      "div",
      "article",
      "aside",
      "figcaption",
      "figure",
      "footer",
      "header",
      "nav",
      "section",
      "ol",
      "ul",
      "li",
      "table",
      "thead",
      "tbody",
      "tfoot",
      "caption",
      "tr",
      "td",
      "th",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "blockquote",
      "pre",
      "address"
    ], Ea = () => {
      const w = (Jn) => qt.fromDom(Jn.dom.cloneNode(!1)), k = (Jn) => Zn(Jn).dom, H = (Jn) => Xr(Jn) ? Dt(Jn) === "body" ? !0 : bt(Sc, Dt(Jn)) : !1, q = (Jn) => Xr(Jn) ? bt([
        "br",
        "img",
        "hr",
        "input"
      ], Dt(Jn)) : !1, we = (Jn) => Xr(Jn) && zr(Jn, "contenteditable") === "false", rt = (Jn, Fr) => Jn.dom.compareDocumentPosition(Fr.dom), $t = (Jn, Fr) => {
        const Sr = Fa(Jn);
        xa(Fr, Sr);
      }, pn = (Jn) => {
        const Fr = Dt(Jn);
        return bt([
          "script",
          "noscript",
          "iframe",
          "noframes",
          "noembed",
          "title",
          "style",
          "textarea",
          "xmp"
        ], Fr);
      }, oo = (Jn) => Xr(Jn) ? mr(Jn, "lang") : U.none();
      return {
        up: st({
          selector: Fs,
          closest: ue,
          predicate: Nn,
          all: ga
        }),
        down: st({
          selector: lo,
          predicate: ac
        }),
        styles: st({
          get: fe,
          getRaw: Ve,
          set: Z,
          remove: Rt
        }),
        attrs: st({
          get: zr,
          set: ms,
          remove: Hs,
          copyTo: $t
        }),
        insert: st({
          before: fs,
          after: ic,
          afterAll: sl,
          append: xi,
          appendAll: lc,
          prepend: xl,
          wrap: xu
        }),
        remove: st({
          unwrap: ch,
          remove: Tl
        }),
        create: st({
          nu: qt.fromTag,
          clone: w,
          text: qt.fromText
        }),
        query: st({
          comparePosition: rt,
          prevSibling: Za,
          nextSibling: _c
        }),
        property: st({
          children: sr,
          name: Dt,
          parent: dr,
          document: k,
          isText: Jr,
          isComment: aa,
          isElement: Xr,
          isSpecial: pn,
          getLanguage: oo,
          getText: El,
          setText: ng,
          isBoundary: H,
          isEmptyTag: q,
          isNonEditable: we
        }),
        eq: Ss,
        is: or
      };
    };
    const ed = (w, k, H, q) => {
      const we = H[0], rt = H.slice(1);
      return q(w, k, we, rt);
    }, mm = (w, k, H) => H.length > 0 ? ed(w, k, H, rl) : U.none(), rl = (w, k, H, q) => {
      const we = k(w, H);
      return lt(q, (rt, $t) => {
        const pn = k(w, $t);
        return Mc(w, rt, pn);
      }, we);
    }, Mc = (w, k, H) => k.bind((q) => H.filter(J(w.eq, q))), ih = mm, a1 = Ea(), nf = (w, k) => ih(a1, (H, q) => w(q), k), of = (w) => Fs(w, "table"), Dd = (w, k) => {
      const H = lo(w, k);
      return H.length > 0 ? U.some(H) : U.none();
    }, kl = (w, k, H) => go(w, k).bind((q) => go(w, H).bind((we) => nf(of, [
      q,
      we
    ]).map((rt) => ({
      first: q,
      last: we,
      table: rt
    })))), lh = (w, k) => Dd(w, k), Yb = (w, k, H) => kl(w, k, H).bind((q) => {
      const we = (oo) => Ss(w, oo), rt = "thead,tfoot,tbody,table", $t = Fs(q.first, rt, we), pn = Fs(q.last, rt, we);
      return $t.bind((oo) => pn.bind((Jn) => Ss(oo, Jn) ? tg(q.table, q.first, q.last) : U.none()));
    }), og = (w) => ot(w, qt.fromDom), c1 = "data-mce-selected", Tu = "data-mce-first-selected", sg = "td[" + Tu + "],th[" + Tu + "]", td = "data-mce-last-selected", Rr = "td[" + td + "],th[" + td + "]", Ar = {
      selected: c1,
      firstSelectedSelector: sg,
      lastSelectedSelector: Rr
    }, ci = (w) => en(w).bind((k) => lh(k, Ar.firstSelectedSelector)).fold(st(w), (k) => k[0]), sf = (w) => (k, H) => {
      const q = Dt(k), we = q === "col" || q === "colgroup" ? ci(k) : k;
      return ue(we, w, H);
    }, uh = sf("th,td,caption"), La = sf("th,td"), _l = (w) => og(w.model.table.getSelectedCells()), ii = (w, k) => {
      const H = La(w), q = H.bind((we) => en(we)).map((we) => Io(we));
      return ca(H, q, (we, rt) => at(rt, ($t) => kn(og($t.dom.cells), (pn) => zr(pn, k) === "1" || Ss(pn, we)))).getOr([]);
    }, Hi = [
      {
        text: "None",
        value: ""
      },
      {
        text: "Top",
        value: "top"
      },
      {
        text: "Middle",
        value: "middle"
      },
      {
        text: "Bottom",
        value: "bottom"
      }
    ], dh = (w) => ({ value: nd(w) }), Mo = /^#?([a-f\d])([a-f\d])([a-f\d])$/i, jc = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i, Eu = (w) => Mo.test(w) || jc.test(w), nd = (w) => Ta(w, "#").toUpperCase(), rg = (w) => Eu(w) ? U.some({ value: nd(w) }) : U.none(), rf = (w) => {
      const k = w.toString(16);
      return (k.length === 1 ? "0" + k : k).toUpperCase();
    }, Ya = (w) => {
      const k = rf(w.red) + rf(w.green) + rf(w.blue);
      return dh(k);
    }, ha = /^\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/i, li = /^\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?(?:\.\d+)?)\s*\)\s*$/i, ta = (w, k, H, q) => ({
      red: w,
      green: k,
      blue: H,
      alpha: q
    }), fm = (w, k, H, q) => {
      const we = parseInt(w, 10), rt = parseInt(k, 10), $t = parseInt(H, 10), pn = parseFloat(q);
      return ta(we, rt, $t, pn);
    }, od = (w) => {
      if (w === "transparent")
        return U.some(ta(0, 0, 0, 0));
      const k = ha.exec(w);
      if (k !== null)
        return U.some(fm(k[1], k[2], k[3], "1"));
      const H = li.exec(w);
      return H !== null ? U.some(fm(H[1], H[2], H[3], H[4])) : U.none();
    }, na = (w) => rg(w).orThunk(() => od(w).map(Ya)).getOrThunk(() => {
      const k = document.createElement("canvas");
      k.height = 1, k.width = 1;
      const H = k.getContext("2d");
      H.clearRect(0, 0, k.width, k.height), H.fillStyle = "#FFFFFF", H.fillStyle = w, H.fillRect(0, 0, 1, 1);
      const q = H.getImageData(0, 0, 1, 1).data, we = q[0], rt = q[1], $t = q[2], pn = q[3];
      return Ya(ta(we, rt, $t, pn));
    }), ka = (w) => od(w).map(Ya).map((k) => "#" + k.value).getOr(w), Ti = (w) => {
      let k = w;
      return {
        get: () => k,
        set: (we) => {
          k = we;
        }
      };
    }, gm = (w) => {
      const k = Ti(U.none()), H = () => k.get().each(w);
      return {
        clear: () => {
          H(), k.set(U.none());
        },
        isSet: () => k.get().isSome(),
        get: () => k.get(),
        set: (pn) => {
          H(), k.set(U.some(pn));
        }
      };
    }, la = () => gm((w) => w.unbind()), ag = (w, k, H) => (q) => {
      const we = la(), rt = yl(H), $t = () => {
        const pn = _l(w), oo = (Jn) => w.formatter.match(k, { value: H }, Jn.dom, rt);
        rt ? (q.setActive(!kn(pn, oo)), we.set(w.formatter.formatChanged(k, (Jn) => q.setActive(!Jn), !0))) : (q.setActive(kt(pn, oo)), we.set(w.formatter.formatChanged(k, q.setActive, !1, { value: H })));
      };
      return w.initialized ? $t() : w.on("init", $t), we.clear;
    }, af = (w) => Gn(w, "menu"), Ms = (w) => ot(w, (k) => {
      const H = k.text || k.title || "";
      return af(k) ? {
        text: H,
        items: Ms(k.menu)
      } : {
        text: H,
        value: k.value
      };
    }), Ei = (w, k, H, q) => ot(k, (we) => {
      const rt = we.text || we.title;
      return af(we) ? {
        type: "nestedmenuitem",
        text: rt,
        getSubmenuItems: () => Ei(w, we.menu, H, q)
      } : {
        text: rt,
        type: "togglemenuitem",
        onAction: () => q(we.value),
        onSetup: ag(w, H, we.value)
      };
    }), bs = (w, k) => (H) => {
      w.execCommand("mceTableApplyCellStyle", !1, { [k]: H });
    }, qc = (w) => ae(w, (k) => af(k) ? [{
      ...k,
      menu: qc(k.menu)
    }] : Dc(k.value) ? [k] : []), ku = (w, k, H, q) => (we) => we(Ei(w, k, H, q)), _u = (w, k, H) => {
      const q = ot(k, (we) => ({
        text: we.title,
        value: "#" + na(we.value).value,
        type: "choiceitem"
      }));
      return [{
        type: "fancymenuitem",
        fancytype: "colorswatch",
        initData: {
          colors: q.length > 0 ? q : void 0,
          allowCustomColors: !1
        },
        onAction: (we) => {
          const rt = we.value === "remove" ? "" : we.value;
          w.execCommand("mceTableApplyCellStyle", !1, { [H]: rt });
        }
      }];
    }, Wo = (w) => () => {
      const H = w.queryCommandValue("mceTableRowType") === "header" ? "body" : "header";
      w.execCommand("mceTableRowType", !1, { type: H });
    }, sd = (w) => () => {
      const H = w.queryCommandValue("mceTableColType") === "th" ? "td" : "th";
      w.execCommand("mceTableColType", !1, { type: H });
    }, mh = (w) => {
      const k = Ms(tf(w));
      return k.length > 0 ? U.some({
        name: "class",
        type: "listbox",
        label: "Class",
        items: k
      }) : U.none();
    }, cg = [
      {
        name: "width",
        type: "input",
        label: "Width"
      },
      {
        name: "height",
        type: "input",
        label: "Height"
      },
      {
        name: "celltype",
        type: "listbox",
        label: "Cell type",
        items: [
          {
            text: "Cell",
            value: "td"
          },
          {
            text: "Header cell",
            value: "th"
          }
        ]
      },
      {
        name: "scope",
        type: "listbox",
        label: "Scope",
        items: [
          {
            text: "None",
            value: ""
          },
          {
            text: "Row",
            value: "row"
          },
          {
            text: "Column",
            value: "col"
          },
          {
            text: "Row group",
            value: "rowgroup"
          },
          {
            text: "Column group",
            value: "colgroup"
          }
        ]
      },
      {
        name: "halign",
        type: "listbox",
        label: "Horizontal align",
        items: [
          {
            text: "None",
            value: ""
          },
          {
            text: "Left",
            value: "left"
          },
          {
            text: "Center",
            value: "center"
          },
          {
            text: "Right",
            value: "right"
          }
        ]
      },
      {
        name: "valign",
        type: "listbox",
        label: "Vertical align",
        items: Hi
      }
    ], fh = (w) => cg.concat(mh(w).toArray()), ig = (w, k) => {
      const q = [
        {
          name: "borderstyle",
          type: "listbox",
          label: "Border style",
          items: [{
            text: "Select...",
            value: ""
          }].concat(Ms(Ii(w)))
        },
        {
          name: "bordercolor",
          type: "colorinput",
          label: "Border color"
        },
        {
          name: "backgroundcolor",
          type: "colorinput",
          label: "Background color"
        }
      ];
      return {
        title: "Advanced",
        name: "advanced",
        items: k === "cell" ? [{
          name: "borderwidth",
          type: "input",
          label: "Border width"
        }].concat(q) : q
      };
    }, Rd = { normal: (w, k) => {
      const H = w.dom;
      return {
        setAttrib: ($t, pn) => {
          H.setAttrib(k, $t, pn);
        },
        setStyle: ($t, pn) => {
          H.setStyle(k, $t, pn);
        },
        setFormat: ($t, pn) => {
          pn === "" ? w.formatter.remove($t, { value: null }, k, !0) : w.formatter.apply($t, { value: pn }, k);
        }
      };
    } }, lg = Qr("th"), x = (w, k) => w && k ? "sectionCells" : w ? "section" : "cells", R = (w) => {
      const k = w.section === "thead", H = nl(z(w.cells), "th");
      return w.section === "tfoot" ? { type: "footer" } : k || H ? {
        type: "header",
        subType: x(k, H)
      } : { type: "body" };
    }, z = (w) => {
      const k = at(w, (H) => lg(H.element));
      return k.length === 0 ? U.some("td") : k.length === w.length ? U.some("th") : U.none();
    }, ce = (w) => {
      const k = ot(w, (we) => R(we).type), H = bt(k, "header"), q = bt(k, "footer");
      if (!H && !q)
        return U.some("body");
      {
        const we = bt(k, "body");
        return H && !we && !q ? U.some("header") : !H && !we && q ? U.some("footer") : U.none();
      }
    }, be = (w) => {
      let k = !1, H;
      return (...q) => (k || (k = !0, H = w.apply(null, q)), H);
    }, At = (w, k) => In(w.all, (H) => pe(H.cells, (q) => Ss(k, q.element))), Bn = (w, k, H) => {
      const q = ot(k.selection, (rt) => K(rt).bind(($t) => At(w, $t)).filter(H)), we = Rs(q);
      return Pr(we.length > 0, we);
    }, To = (w, k) => k.mergable, Co = (w, k) => k.unmergable, ao = (w, k) => Bn(w, k, ht), Nr = (w, k) => At(w, k).exists((H) => !H.isLocked), Ma = (w, k) => kt(k, (H) => Nr(w, H)), ki = (w, k) => To(w, k).filter((H) => Ma(w, H.cells)), eu = (w, k) => Co(w, k).filter((H) => Ma(w, H));
    ({ ...{ generate: (w) => {
      if (!Ee(w))
        throw new Error("cases must be an array");
      if (w.length === 0)
        throw new Error("there must be at least one case");
      const k = [], H = {};
      return F(w, (q, we) => {
        const rt = Tt(q);
        if (rt.length !== 1)
          throw new Error("one and only one name per case");
        const $t = rt[0], pn = q[$t];
        if (H[$t] !== void 0)
          throw new Error("duplicate key detected:" + $t);
        if ($t === "cata")
          throw new Error("cannot have a case named cata (sorry)");
        if (!Ee(pn))
          throw new Error("case arguments must be an array");
        k.push($t), H[$t] = (...oo) => {
          const Jn = oo.length;
          if (Jn !== pn.length)
            throw new Error("Wrong number of arguments to case " + $t + ". Expected " + pn.length + " (" + pn + "), got " + Jn);
          return {
            fold: (...Sr) => {
              if (Sr.length !== w.length)
                throw new Error("Wrong number of arguments to fold. Expected " + w.length + ", got " + Sr.length);
              return Sr[we].apply(null, oo);
            },
            match: (Sr) => {
              const Ws = Tt(Sr);
              if (k.length !== Ws.length)
                throw new Error("Wrong number of arguments to match. Expected: " + k.join(",") + `
Actual: ` + Ws.join(","));
              if (!kt(k, (au) => bt(Ws, au)))
                throw new Error("Not all branches were specified when using match. Specified: " + Ws.join(", ") + `
Required: ` + k.join(", "));
              return Sr[$t].apply(null, oo);
            },
            log: (Sr) => {
            }
          };
        };
      }), H;
    } }.generate([
      { none: [] },
      { only: ["index"] },
      {
        left: [
          "index",
          "next"
        ]
      },
      {
        middle: [
          "prev",
          "index",
          "next"
        ]
      },
      {
        right: [
          "prev",
          "index"
        ]
      }
    ]) });
    const tu = (w, k) => {
      const H = ai.fromTable(w);
      return ao(H, k).bind((we) => {
        const rt = we[we.length - 1], $t = we[0].row, pn = rt.row + rt.rowspan, oo = H.all.slice($t, pn);
        return ce(oo);
      }).getOr("");
    }, xn = (w) => Ac(w, "rgb") ? ka(w) : w, Au = (w) => {
      const k = qt.fromDom(w);
      return {
        borderwidth: Ve(k, "border-width").getOr(""),
        borderstyle: Ve(k, "border-style").getOr(""),
        bordercolor: Ve(k, "border-color").map(xn).getOr(""),
        backgroundcolor: Ve(k, "background-color").map(xn).getOr("")
      };
    }, vy = (w) => {
      const k = w[0], H = w.slice(1);
      return F(H, (q) => {
        F(Tt(k), (we) => {
          gn(q, (rt, $t) => {
            const pn = k[we];
            pn !== "" && we === $t && pn !== rt && (k[we] = "");
          });
        });
      }), k;
    }, Ou = (w, k, H, q) => pe(w, (we) => !fn(H.formatter.matchNode(q, k + we))).getOr(""), ua = J(Ou, [
      "left",
      "center",
      "right"
    ], "align"), hm = J(Ou, [
      "top",
      "middle",
      "bottom"
    ], "valign"), ug = (w, k) => {
      const H = ah(w), q = Ad(w), we = () => ({
        borderstyle: mn(H, "border-style").getOr(""),
        bordercolor: xn(mn(H, "border-color").getOr("")),
        backgroundcolor: xn(mn(H, "background-color").getOr(""))
      }), rt = {
        height: "",
        width: "100%",
        cellspacing: "",
        cellpadding: "",
        caption: !1,
        class: "",
        align: "",
        border: ""
      }, $t = () => {
        const Fr = H["border-width"];
        return wl(w) && Fr ? { border: Fr } : mn(q, "border").fold(() => ({}), (Sr) => ({ border: Sr }));
      }, pn = k ? we() : {}, oo = () => {
        const Fr = mn(H, "border-spacing").or(mn(q, "cellspacing")).fold(() => ({}), (Ws) => ({ cellspacing: Ws })), Sr = mn(H, "border-padding").or(mn(q, "cellpadding")).fold(() => ({}), (Ws) => ({ cellpadding: Ws }));
        return {
          ...Fr,
          ...Sr
        };
      };
      return {
        ...rt,
        ...H,
        ...q,
        ...pn,
        ...$t(),
        ...oo()
      };
    }, Xa = (w) => en(qt.fromDom(w)).map((k) => {
      const H = { selection: og(w.cells) };
      return tu(k, H);
    }).getOr(""), nu = (w, k, H) => {
      const q = (pn, oo) => {
        const Jn = Ve(qt.fromDom(oo), "border-width");
        return wl(w) && Jn.isSome() ? Jn.getOr("") : pn.getAttrib(oo, "border") || Cc(w.dom, oo, "border-width") || Cc(w.dom, oo, "border") || "";
      }, we = w.dom, rt = wl(w) ? we.getStyle(k, "border-spacing") || we.getAttrib(k, "cellspacing") : we.getAttrib(k, "cellspacing") || we.getStyle(k, "border-spacing"), $t = wl(w) ? Cc(we, k, "padding") || we.getAttrib(k, "cellpadding") : we.getAttrib(k, "cellpadding") || Cc(we, k, "padding");
      return {
        width: we.getStyle(k, "width") || we.getAttrib(k, "width"),
        height: we.getStyle(k, "height") || we.getAttrib(k, "height"),
        cellspacing: rt ?? "",
        cellpadding: $t ?? "",
        border: q(we, k),
        caption: !!we.select("caption", k)[0],
        class: we.getAttrib(k, "class", ""),
        align: ua(w, k),
        ...H ? Au(k) : {}
      };
    }, gh = (w, k, H) => {
      const q = w.dom;
      return {
        height: q.getStyle(k, "height") || q.getAttrib(k, "height"),
        class: q.getAttrib(k, "class", ""),
        type: Xa(k),
        align: ua(w, k),
        ...H ? Au(k) : {}
      };
    }, Du = (w, k, H, q) => {
      const we = w.dom, rt = q.getOr(k), $t = (pn, oo) => we.getStyle(pn, oo) || we.getAttrib(pn, oo);
      return {
        width: $t(rt, "width"),
        height: $t(k, "height"),
        scope: we.getAttrib(k, "scope"),
        celltype: on(k),
        class: we.getAttrib(k, "class", ""),
        halign: ua(w, k),
        valign: hm(w, k),
        ...H ? Au(k) : {}
      };
    }, l1 = (w, k) => {
      const H = ai.fromTable(w), q = ai.justCells(H), we = at(q, (rt) => kn(k, ($t) => Ss(rt.element, $t)));
      return ot(we, (rt) => ({
        element: rt.element.dom,
        column: ai.getColumnAt(H, rt.column).map(($t) => $t.element.dom)
      }));
    }, hh = (w, k, H, q) => {
      q("scope") && w.setAttrib("scope", H.scope), q("class") && w.setAttrib("class", H.class), q("height") && w.setStyle("height", Mn(H.height)), q("width") && k.setStyle("width", Mn(H.width));
    }, Mt = (w, k, H) => {
      H("backgroundcolor") && w.setFormat("tablecellbackgroundcolor", k.backgroundcolor), H("bordercolor") && w.setFormat("tablecellbordercolor", k.bordercolor), H("borderstyle") && w.setFormat("tablecellborderstyle", k.borderstyle), H("borderwidth") && w.setFormat("tablecellborderwidth", Mn(k.borderwidth));
    }, Xb = (w, k, H, q) => {
      const we = k.length === 1;
      F(k, (rt) => {
        const $t = rt.element, pn = we ? ht : q, oo = Rd.normal(w, $t), Jn = rt.column.map((Fr) => Rd.normal(w, Fr)).getOr(oo);
        hh(oo, Jn, H, pn), Jm(w) && Mt(oo, H, pn), q("halign") && Rc(w, $t, H.halign), q("valign") && Qu(w, $t, H.valign);
      });
    }, Nd = (w, k) => {
      w.execCommand("mceTableCellType", !1, {
        type: k.celltype,
        no_events: !0
      });
    }, rd = (w, k, H, q) => {
      const we = ho(q, (rt, $t) => H[$t] !== rt);
      A(we) > 0 && k.length >= 1 && en(k[0]).each((rt) => {
        const $t = l1(rt, k), pn = A(ho(we, (Jn, Fr) => Fr !== "scope" && Fr !== "celltype")) > 0, oo = it(we, "celltype");
        (pn || it(we, "scope")) && Xb(w, $t, q, J(it, we)), oo && Nd(w, q), Qo(w, rt.dom, {
          structure: oo,
          style: pn
        });
      });
    }, dg = (w, k, H, q) => {
      const we = q.getData();
      q.close(), w.undoManager.transact(() => {
        rd(w, k, H, we), w.focus();
      });
    }, $r = (w, k) => {
      const H = en(k[0]).map((q) => ot(l1(q, k), (we) => Du(w, we.element, Jm(w), we.column)));
      return vy(H.getOrDie());
    }, Js = (w) => {
      const k = _l(w);
      if (k.length === 0)
        return;
      const H = $r(w, k), q = {
        type: "tabpanel",
        tabs: [
          {
            title: "General",
            name: "general",
            items: fh(w)
          },
          ig(w, "cell")
        ]
      }, we = {
        type: "panel",
        items: [{
          type: "grid",
          columns: 2,
          items: fh(w)
        }]
      };
      w.windowManager.open({
        title: "Cell Properties",
        size: "normal",
        body: Jm(w) ? q : we,
        buttons: [
          {
            type: "cancel",
            name: "cancel",
            text: "Cancel"
          },
          {
            type: "submit",
            name: "save",
            text: "Save",
            primary: !0
          }
        ],
        initialData: H,
        onSubmit: J(dg, w, k, H)
      });
    }, Gc = (w) => {
      const k = Ms(Cu(w));
      return k.length > 0 ? U.some({
        name: "class",
        type: "listbox",
        label: "Class",
        items: k
      }) : U.none();
    }, Kc = [
      {
        type: "listbox",
        name: "type",
        label: "Row type",
        items: [
          {
            text: "Header",
            value: "header"
          },
          {
            text: "Body",
            value: "body"
          },
          {
            text: "Footer",
            value: "footer"
          }
        ]
      },
      {
        type: "listbox",
        name: "align",
        label: "Alignment",
        items: [
          {
            text: "None",
            value: ""
          },
          {
            text: "Left",
            value: "left"
          },
          {
            text: "Center",
            value: "center"
          },
          {
            text: "Right",
            value: "right"
          }
        ]
      },
      {
        label: "Height",
        name: "height",
        type: "input"
      }
    ], es = (w) => Kc.concat(Gc(w).toArray()), mg = (w, k, H) => {
      H("class") && w.setAttrib("class", k.class), H("height") && w.setStyle("height", Mn(k.height));
    }, dc = (w, k, H) => {
      H("backgroundcolor") && w.setStyle("background-color", k.backgroundcolor), H("bordercolor") && w.setStyle("border-color", k.bordercolor), H("borderstyle") && w.setStyle("border-style", k.borderstyle);
    }, oa = (w, k, H, q) => {
      const rt = k.length === 1 ? ht : q;
      F(k, ($t) => {
        const pn = Rd.normal(w, $t);
        mg(pn, H, rt), Qm(w) && dc(pn, H, rt), q("align") && Rc(w, $t, H.align);
      });
    }, ph = (w, k) => {
      w.execCommand("mceTableRowType", !1, {
        type: k.type,
        no_events: !0
      });
    }, gt = (w, k, H, q) => {
      const we = ho(q, (rt, $t) => H[$t] !== rt);
      if (A(we) > 0) {
        const rt = it(we, "type"), $t = rt ? A(we) > 1 : !0;
        $t && oa(w, k, q, J(it, we)), rt && ph(w, q), en(qt.fromDom(k[0])).each((pn) => Qo(w, pn.dom, {
          structure: rt,
          style: $t
        }));
      }
    }, _i = (w, k, H, q) => {
      const we = q.getData();
      q.close(), w.undoManager.transact(() => {
        gt(w, k, H, we), w.focus();
      });
    }, fg = (w) => {
      const k = ii(Kn(w), Ar.selected);
      if (k.length === 0)
        return;
      const H = ot(k, ($t) => gh(w, $t.dom, Qm(w))), q = vy(H), we = {
        type: "tabpanel",
        tabs: [
          {
            title: "General",
            name: "general",
            items: es(w)
          },
          ig(w, "row")
        ]
      }, rt = {
        type: "panel",
        items: [{
          type: "grid",
          columns: 2,
          items: es(w)
        }]
      };
      w.windowManager.open({
        title: "Row Properties",
        size: "normal",
        body: Qm(w) ? we : rt,
        buttons: [
          {
            type: "cancel",
            name: "cancel",
            text: "Cancel"
          },
          {
            type: "submit",
            name: "save",
            text: "Save",
            primary: !0
          }
        ],
        initialData: q,
        onSubmit: J(_i, w, ot(k, ($t) => $t.dom), q)
      });
    }, _s = (w, k, H) => {
      const q = H ? [
        {
          type: "input",
          name: "cols",
          label: "Cols",
          inputMode: "numeric"
        },
        {
          type: "input",
          name: "rows",
          label: "Rows",
          inputMode: "numeric"
        }
      ] : [], we = [
        {
          type: "input",
          name: "width",
          label: "Width"
        },
        {
          type: "input",
          name: "height",
          label: "Height"
        }
      ], rt = ef(w) ? [
        {
          type: "input",
          name: "cellspacing",
          label: "Cell spacing",
          inputMode: "numeric"
        },
        {
          type: "input",
          name: "cellpadding",
          label: "Cell padding",
          inputMode: "numeric"
        },
        {
          type: "input",
          name: "border",
          label: "Border width"
        },
        {
          type: "label",
          label: "Caption",
          items: [{
            type: "checkbox",
            name: "caption",
            label: "Show caption"
          }]
        }
      ] : [], $t = [{
        type: "listbox",
        name: "align",
        label: "Alignment",
        items: [
          {
            text: "None",
            value: ""
          },
          {
            text: "Left",
            value: "left"
          },
          {
            text: "Center",
            value: "center"
          },
          {
            text: "Right",
            value: "right"
          }
        ]
      }], pn = k.length > 0 ? [{
        type: "listbox",
        name: "class",
        label: "Class",
        items: k
      }] : [];
      return q.concat(we).concat(rt).concat($t).concat(pn);
    }, Al = (w, k, H, q) => {
      if (k.tagName === "TD" || k.tagName === "TH")
        Fe(H) && Sn(q) ? w.setStyle(k, H, q) : w.setStyles(k, H);
      else if (k.children)
        for (let we = 0; we < k.children.length; we++)
          Al(w, k.children[we], H, q);
    }, yy = (w, k, H, q) => {
      const we = w.dom, rt = {}, $t = {}, pn = wl(w), oo = Wc(w);
      if (fn(H.class) || (rt.class = H.class), $t.height = Mn(H.height), pn ? $t.width = Mn(H.width) : we.getAttrib(k, "width") && (rt.width = Dn(H.width)), pn ? ($t["border-width"] = Mn(H.border), $t["border-spacing"] = Mn(H.cellspacing)) : (rt.border = H.border, rt.cellpadding = H.cellpadding, rt.cellspacing = H.cellspacing), pn && k.children) {
        const Jn = {};
        if (q.border && (Jn["border-width"] = Mn(H.border)), q.cellpadding && (Jn.padding = Mn(H.cellpadding)), oo && q.bordercolor && (Jn["border-color"] = H.bordercolor), !rn(Jn))
          for (let Fr = 0; Fr < k.children.length; Fr++)
            Al(we, k.children[Fr], Jn);
      }
      if (oo) {
        const Jn = H;
        $t["background-color"] = Jn.backgroundcolor, $t["border-color"] = Jn.bordercolor, $t["border-style"] = Jn.borderstyle;
      }
      we.setStyles(k, {
        ...ah(w),
        ...$t
      }), we.setAttribs(k, {
        ...Ad(w),
        ...rt
      });
    }, ou = (w, k, H, q) => {
      const we = w.dom, rt = q.getData(), $t = ho(rt, (pn, oo) => H[oo] !== pn);
      q.close(), rt.class === "" && delete rt.class, w.undoManager.transact(() => {
        if (!k) {
          const pn = ja(rt.cols).getOr(1), oo = ja(rt.rows).getOr(1);
          w.execCommand("mceInsertTable", !1, {
            rows: oo,
            columns: pn
          }), k = La(Kn(w), On(w)).bind((Jn) => en(Jn, On(w))).map((Jn) => Jn.dom).getOrDie();
        }
        if (A($t) > 0) {
          const pn = {
            border: it($t, "border"),
            bordercolor: it($t, "bordercolor"),
            cellpadding: it($t, "cellpadding")
          };
          yy(w, k, rt, pn);
          const oo = we.select("caption", k)[0];
          (oo && !rt.caption || !oo && rt.caption) && w.execCommand("mceTableToggleCaption"), Rc(w, k, rt.align);
        }
        if (w.focus(), w.addVisual(), A($t) > 0) {
          const pn = it($t, "caption"), oo = pn ? A($t) > 1 : !0;
          Qo(w, k, {
            structure: pn,
            style: oo
          });
        }
      });
    }, bh = (w, k) => {
      const H = w.dom;
      let q, we = ug(w, Wc(w));
      k ? (we.cols = "1", we.rows = "1", Wc(w) && (we.borderstyle = "", we.bordercolor = "", we.backgroundcolor = "")) : (q = H.getParent(w.selection.getStart(), "table", w.getBody()), q ? we = nu(w, q, Wc(w)) : Wc(w) && (we.borderstyle = "", we.bordercolor = "", we.backgroundcolor = ""));
      const rt = Ms(dm(w));
      rt.length > 0 && we.class && (we.class = we.class.replace(/\s*mce\-item\-table\s*/g, ""));
      const $t = {
        type: "grid",
        columns: 2,
        items: _s(w, rt, k)
      }, pn = () => ({
        type: "panel",
        items: [$t]
      }), oo = () => ({
        type: "tabpanel",
        tabs: [
          {
            title: "General",
            name: "general",
            items: [$t]
          },
          ig(w, "table")
        ]
      }), Jn = Wc(w) ? oo() : pn();
      w.windowManager.open({
        title: "Table Properties",
        size: "normal",
        body: Jn,
        onSubmit: J(ou, w, q, we),
        buttons: [
          {
            type: "cancel",
            name: "cancel",
            text: "Cancel"
          },
          {
            type: "submit",
            name: "save",
            text: "Save",
            primary: !0
          }
        ],
        initialData: we
      });
    }, su = (w) => {
      const k = (H) => {
        Ds(Kn(w)) && H();
      };
      gn({
        mceTableProps: J(bh, w, !1),
        mceTableRowProps: J(fg, w),
        mceTableCellProps: J(Js, w),
        mceInsertTableDialog: J(bh, w, !0)
      }, (H, q) => w.addCommand(q, () => k(H)));
    }, u1 = (w, k) => ve(w, k).isSome(), zi = Pn, $s = (w) => {
      const k = (q, we) => mr(q, we).exists((rt) => parseInt(rt, 10) > 1), H = (q) => k(q, "rowspan") || k(q, "colspan");
      return w.length > 0 && kt(w, H) ? U.some(w) : U.none();
    }, Ru = (w, k, H) => k.length <= 1 ? U.none() : Yb(w, H.firstSelectedSelector, H.lastSelectedSelector).map((q) => ({
      bounds: q,
      cells: k
    })), pm = (w) => ({
      element: w,
      mergable: U.none(),
      unmergable: U.none(),
      selection: [w]
    }), mc = (w, k, H) => ({
      element: H,
      mergable: Ru(k, w, Ar),
      unmergable: $s(w),
      selection: zi(w)
    }), d1 = (w) => {
      const k = Ti(U.none()), H = Ti([]);
      let q = U.none();
      const we = Qr("caption"), rt = (as) => q.forall((Ur) => !Ur[as]), $t = () => uh(Kn(w), On(w)), pn = () => uh(zo(w), On(w)), oo = () => $t().bind((as) => Ia(ca(en(as), pn().bind(en), (Ur, Zs) => Ss(Ur, Zs) ? we(as) ? U.some(pm(as)) : U.some(mc(_l(w), Ur, as)) : U.none()))), Jn = (as) => en(as.element).map((Zs) => {
        const Bc = ai.fromTable(Zs), mf = ao(Bc, as).getOr([]), m1 = Rn(mf, (Rl, $c) => ($c.isLocked && (Rl.onAny = !0, $c.column === 0 ? Rl.onFirst = !0 : $c.column + $c.colspan >= Bc.grid.columns && (Rl.onLast = !0)), Rl), {
          onAny: !1,
          onFirst: !1,
          onLast: !1
        });
        return {
          mergeable: ki(Bc, as).isSome(),
          unmergeable: eu(Bc, as).isSome(),
          locked: m1
        };
      }), Fr = () => {
        k.set(be(oo)()), q = k.get().bind(Jn), F(H.get(), Qe);
      }, Sr = (as) => (as(), H.set(H.get().concat([as])), () => {
        H.set(at(H.get(), (Ur) => Ur !== as));
      }), Ws = (as, Ur) => Sr(() => k.get().fold(() => {
        as.setEnabled(!1);
      }, (Zs) => {
        as.setEnabled(!Ur(Zs) && w.selection.isEditable());
      })), Yc = (as, Ur, Zs) => Sr(() => k.get().fold(() => {
        as.setEnabled(!1), as.setActive(!1);
      }, (Bc) => {
        as.setEnabled(!Ur(Bc) && w.selection.isEditable()), as.setActive(Zs(Bc));
      })), au = (as) => q.exists((Ur) => Ur.locked[as]), Vi = (as) => Ws(as, (Ur) => !1), Ol = (as) => Ws(as, (Ur) => we(Ur.element)), vh = (as) => (Ur) => Ws(Ur, (Zs) => we(Zs.element) || au(as)), Dl = (as) => (Ur) => Ws(Ur, (Zs) => we(Zs.element) || as().isNone()), cf = (as, Ur) => (Zs) => Ws(Zs, (Bc) => we(Bc.element) || as().isNone() || au(Ur)), lf = (as) => Ws(as, (Ur) => rt("mergeable")), gg = (as) => Ws(as, (Ur) => rt("unmergeable")), uf = (as) => Yc(as, xo, (Ur) => en(Ur.element, On(w)).exists((Bc) => u1(Bc, "caption"))), Aa = (as, Ur) => (Zs) => Yc(Zs, (Bc) => we(Bc.element), () => w.queryCommandValue(as) === Ur), Mu = Aa("mceTableRowType", "header"), df = Aa("mceTableColType", "th");
      return w.on("NodeChange ExecCommand TableSelectorChange", Fr), {
        onSetupTable: Vi,
        onSetupCellOrRow: Ol,
        onSetupColumn: vh,
        onSetupPasteable: Dl,
        onSetupPasteableColumn: cf,
        onSetupMergeable: lf,
        onSetupUnmergeable: gg,
        resetTargets: Fr,
        onSetupTableWithCaption: uf,
        onSetupTableRowHeaders: Mu,
        onSetupTableColumnHeaders: df,
        targets: k.get
      };
    };
    var bm = tinymce.util.Tools.resolve("tinymce.FakeClipboard");
    const Md = "x-tinymce/dom-table-", ui = Md + "rows", Pd = Md + "columns", Ne = (w) => {
      var k;
      const H = (k = bm.read()) !== null && k !== void 0 ? k : [];
      return In(H, (q) => U.from(q.getType(w)));
    }, Pc = () => Ne(ui), al = () => Ne(Pd), ru = (w) => (k) => {
      const H = () => {
        k.setEnabled(w.selection.isEditable());
      };
      return w.on("NodeChange", H), H(), () => {
        w.off("NodeChange", H);
      };
    }, Ai = (w, k) => {
      w.ui.registry.addMenuButton("table", {
        tooltip: "Table",
        icon: "table",
        onSetup: ru(w),
        fetch: (pn) => pn("inserttable | cell row column | advtablesort | tableprops deletetable")
      });
      const H = (pn) => () => w.execCommand(pn), q = (pn, oo) => {
        w.queryCommandSupported(oo.command) && w.ui.registry.addButton(pn, {
          ...oo,
          onAction: Ft(oo.onAction) ? oo.onAction : H(oo.command)
        });
      }, we = (pn, oo) => {
        w.queryCommandSupported(oo.command) && w.ui.registry.addToggleButton(pn, {
          ...oo,
          onAction: Ft(oo.onAction) ? oo.onAction : H(oo.command)
        });
      };
      q("tableprops", {
        tooltip: "Table properties",
        command: "mceTableProps",
        icon: "table",
        onSetup: k.onSetupTable
      }), q("tabledelete", {
        tooltip: "Delete table",
        command: "mceTableDelete",
        icon: "table-delete-table",
        onSetup: k.onSetupTable
      }), q("tablecellprops", {
        tooltip: "Cell properties",
        command: "mceTableCellProps",
        icon: "table-cell-properties",
        onSetup: k.onSetupCellOrRow
      }), q("tablemergecells", {
        tooltip: "Merge cells",
        command: "mceTableMergeCells",
        icon: "table-merge-cells",
        onSetup: k.onSetupMergeable
      }), q("tablesplitcells", {
        tooltip: "Split cell",
        command: "mceTableSplitCells",
        icon: "table-split-cells",
        onSetup: k.onSetupUnmergeable
      }), q("tableinsertrowbefore", {
        tooltip: "Insert row before",
        command: "mceTableInsertRowBefore",
        icon: "table-insert-row-above",
        onSetup: k.onSetupCellOrRow
      }), q("tableinsertrowafter", {
        tooltip: "Insert row after",
        command: "mceTableInsertRowAfter",
        icon: "table-insert-row-after",
        onSetup: k.onSetupCellOrRow
      }), q("tabledeleterow", {
        tooltip: "Delete row",
        command: "mceTableDeleteRow",
        icon: "table-delete-row",
        onSetup: k.onSetupCellOrRow
      }), q("tablerowprops", {
        tooltip: "Row properties",
        command: "mceTableRowProps",
        icon: "table-row-properties",
        onSetup: k.onSetupCellOrRow
      }), q("tableinsertcolbefore", {
        tooltip: "Insert column before",
        command: "mceTableInsertColBefore",
        icon: "table-insert-column-before",
        onSetup: k.onSetupColumn("onFirst")
      }), q("tableinsertcolafter", {
        tooltip: "Insert column after",
        command: "mceTableInsertColAfter",
        icon: "table-insert-column-after",
        onSetup: k.onSetupColumn("onLast")
      }), q("tabledeletecol", {
        tooltip: "Delete column",
        command: "mceTableDeleteCol",
        icon: "table-delete-column",
        onSetup: k.onSetupColumn("onAny")
      }), q("tablecutrow", {
        tooltip: "Cut row",
        command: "mceTableCutRow",
        icon: "cut-row",
        onSetup: k.onSetupCellOrRow
      }), q("tablecopyrow", {
        tooltip: "Copy row",
        command: "mceTableCopyRow",
        icon: "duplicate-row",
        onSetup: k.onSetupCellOrRow
      }), q("tablepasterowbefore", {
        tooltip: "Paste row before",
        command: "mceTablePasteRowBefore",
        icon: "paste-row-before",
        onSetup: k.onSetupPasteable(Pc)
      }), q("tablepasterowafter", {
        tooltip: "Paste row after",
        command: "mceTablePasteRowAfter",
        icon: "paste-row-after",
        onSetup: k.onSetupPasteable(Pc)
      }), q("tablecutcol", {
        tooltip: "Cut column",
        command: "mceTableCutCol",
        icon: "cut-column",
        onSetup: k.onSetupColumn("onAny")
      }), q("tablecopycol", {
        tooltip: "Copy column",
        command: "mceTableCopyCol",
        icon: "duplicate-column",
        onSetup: k.onSetupColumn("onAny")
      }), q("tablepastecolbefore", {
        tooltip: "Paste column before",
        command: "mceTablePasteColBefore",
        icon: "paste-column-before",
        onSetup: k.onSetupPasteableColumn(al, "onFirst")
      }), q("tablepastecolafter", {
        tooltip: "Paste column after",
        command: "mceTablePasteColAfter",
        icon: "paste-column-after",
        onSetup: k.onSetupPasteableColumn(al, "onLast")
      }), q("tableinsertdialog", {
        tooltip: "Insert table",
        command: "mceInsertTableDialog",
        icon: "table",
        onSetup: ru(w)
      });
      const rt = qc(dm(w));
      rt.length !== 0 && w.queryCommandSupported("mceTableToggleClass") && w.ui.registry.addMenuButton("tableclass", {
        icon: "table-classes",
        tooltip: "Table styles",
        fetch: ku(w, rt, "tableclass", (pn) => w.execCommand("mceTableToggleClass", !1, pn)),
        onSetup: k.onSetupTable
      });
      const $t = qc(tf(w));
      $t.length !== 0 && w.queryCommandSupported("mceTableCellToggleClass") && w.ui.registry.addMenuButton("tablecellclass", {
        icon: "table-cell-classes",
        tooltip: "Cell styles",
        fetch: ku(w, $t, "tablecellclass", (pn) => w.execCommand("mceTableCellToggleClass", !1, pn)),
        onSetup: k.onSetupCellOrRow
      }), w.queryCommandSupported("mceTableApplyCellStyle") && (w.ui.registry.addMenuButton("tablecellvalign", {
        icon: "vertical-align",
        tooltip: "Vertical align",
        fetch: ku(w, Hi, "tablecellverticalalign", bs(w, "vertical-align")),
        onSetup: k.onSetupCellOrRow
      }), w.ui.registry.addMenuButton("tablecellborderwidth", {
        icon: "border-width",
        tooltip: "Border width",
        fetch: ku(w, Nc(w), "tablecellborderwidth", bs(w, "border-width")),
        onSetup: k.onSetupCellOrRow
      }), w.ui.registry.addMenuButton("tablecellborderstyle", {
        icon: "border-style",
        tooltip: "Border style",
        fetch: ku(w, Ii(w), "tablecellborderstyle", bs(w, "border-style")),
        onSetup: k.onSetupCellOrRow
      }), w.ui.registry.addMenuButton("tablecellbackgroundcolor", {
        icon: "cell-background-color",
        tooltip: "Background color",
        fetch: (pn) => pn(_u(w, oh(w), "background-color")),
        onSetup: k.onSetupCellOrRow
      }), w.ui.registry.addMenuButton("tablecellbordercolor", {
        icon: "cell-border-color",
        tooltip: "Border color",
        fetch: (pn) => pn(_u(w, wu(w), "border-color")),
        onSetup: k.onSetupCellOrRow
      })), we("tablecaption", {
        tooltip: "Table caption",
        icon: "table-caption",
        command: "mceTableToggleCaption",
        onSetup: k.onSetupTableWithCaption
      }), we("tablerowheader", {
        tooltip: "Row header",
        icon: "table-top-header",
        command: "mceTableRowType",
        onAction: Wo(w),
        onSetup: k.onSetupTableRowHeaders
      }), we("tablecolheader", {
        tooltip: "Column header",
        icon: "table-left-header",
        command: "mceTableColType",
        onAction: sd(w),
        onSetup: k.onSetupTableColumnHeaders
      });
    }, Pa = (w) => {
      const k = (q) => w.dom.is(q, "table") && w.getBody().contains(q) && w.dom.isEditable(q.parentNode), H = Sl(w);
      H.length > 0 && w.ui.registry.addContextToolbar("table", {
        predicate: k,
        items: H,
        scope: "node",
        position: "node"
      });
    }, _a = (w) => (k) => {
      const H = () => {
        k.setEnabled(w.selection.isEditable());
      };
      return w.on("NodeChange", H), H(), () => {
        w.off("NodeChange", H);
      };
    }, Nw = (w, k) => {
      const H = (Sr) => () => w.execCommand(Sr), q = (Sr, Ws) => w.queryCommandSupported(Ws.command) ? (w.ui.registry.addMenuItem(Sr, {
        ...Ws,
        onAction: Ft(Ws.onAction) ? Ws.onAction : H(Ws.command)
      }), !0) : !1, we = (Sr, Ws) => {
        w.queryCommandSupported(Ws.command) && w.ui.registry.addToggleMenuItem(Sr, {
          ...Ws,
          onAction: Ft(Ws.onAction) ? Ws.onAction : H(Ws.command)
        });
      }, rt = (Sr) => {
        w.execCommand("mceInsertTable", !1, {
          rows: Sr.numRows,
          columns: Sr.numColumns
        });
      }, $t = [
        q("tableinsertrowbefore", {
          text: "Insert row before",
          icon: "table-insert-row-above",
          command: "mceTableInsertRowBefore",
          onSetup: k.onSetupCellOrRow
        }),
        q("tableinsertrowafter", {
          text: "Insert row after",
          icon: "table-insert-row-after",
          command: "mceTableInsertRowAfter",
          onSetup: k.onSetupCellOrRow
        }),
        q("tabledeleterow", {
          text: "Delete row",
          icon: "table-delete-row",
          command: "mceTableDeleteRow",
          onSetup: k.onSetupCellOrRow
        }),
        q("tablerowprops", {
          text: "Row properties",
          icon: "table-row-properties",
          command: "mceTableRowProps",
          onSetup: k.onSetupCellOrRow
        }),
        q("tablecutrow", {
          text: "Cut row",
          icon: "cut-row",
          command: "mceTableCutRow",
          onSetup: k.onSetupCellOrRow
        }),
        q("tablecopyrow", {
          text: "Copy row",
          icon: "duplicate-row",
          command: "mceTableCopyRow",
          onSetup: k.onSetupCellOrRow
        }),
        q("tablepasterowbefore", {
          text: "Paste row before",
          icon: "paste-row-before",
          command: "mceTablePasteRowBefore",
          onSetup: k.onSetupPasteable(Pc)
        }),
        q("tablepasterowafter", {
          text: "Paste row after",
          icon: "paste-row-after",
          command: "mceTablePasteRowAfter",
          onSetup: k.onSetupPasteable(Pc)
        })
      ], pn = [
        q("tableinsertcolumnbefore", {
          text: "Insert column before",
          icon: "table-insert-column-before",
          command: "mceTableInsertColBefore",
          onSetup: k.onSetupColumn("onFirst")
        }),
        q("tableinsertcolumnafter", {
          text: "Insert column after",
          icon: "table-insert-column-after",
          command: "mceTableInsertColAfter",
          onSetup: k.onSetupColumn("onLast")
        }),
        q("tabledeletecolumn", {
          text: "Delete column",
          icon: "table-delete-column",
          command: "mceTableDeleteCol",
          onSetup: k.onSetupColumn("onAny")
        }),
        q("tablecutcolumn", {
          text: "Cut column",
          icon: "cut-column",
          command: "mceTableCutCol",
          onSetup: k.onSetupColumn("onAny")
        }),
        q("tablecopycolumn", {
          text: "Copy column",
          icon: "duplicate-column",
          command: "mceTableCopyCol",
          onSetup: k.onSetupColumn("onAny")
        }),
        q("tablepastecolumnbefore", {
          text: "Paste column before",
          icon: "paste-column-before",
          command: "mceTablePasteColBefore",
          onSetup: k.onSetupPasteableColumn(al, "onFirst")
        }),
        q("tablepastecolumnafter", {
          text: "Paste column after",
          icon: "paste-column-after",
          command: "mceTablePasteColAfter",
          onSetup: k.onSetupPasteableColumn(al, "onLast")
        })
      ], oo = [
        q("tablecellprops", {
          text: "Cell properties",
          icon: "table-cell-properties",
          command: "mceTableCellProps",
          onSetup: k.onSetupCellOrRow
        }),
        q("tablemergecells", {
          text: "Merge cells",
          icon: "table-merge-cells",
          command: "mceTableMergeCells",
          onSetup: k.onSetupMergeable
        }),
        q("tablesplitcells", {
          text: "Split cell",
          icon: "table-split-cells",
          command: "mceTableSplitCells",
          onSetup: k.onSetupUnmergeable
        })
      ];
      Zc(w) ? w.ui.registry.addNestedMenuItem("inserttable", {
        text: "Table",
        icon: "table",
        getSubmenuItems: () => [{
          type: "fancymenuitem",
          fancytype: "inserttable",
          onAction: rt
        }],
        onSetup: _a(w)
      }) : w.ui.registry.addMenuItem("inserttable", {
        text: "Table",
        icon: "table",
        onAction: H("mceInsertTableDialog"),
        onSetup: _a(w)
      }), w.ui.registry.addMenuItem("inserttabledialog", {
        text: "Insert table",
        icon: "table",
        onAction: H("mceInsertTableDialog"),
        onSetup: _a(w)
      }), q("tableprops", {
        text: "Table properties",
        onSetup: k.onSetupTable,
        command: "mceTableProps"
      }), q("deletetable", {
        text: "Delete table",
        icon: "table-delete-table",
        onSetup: k.onSetupTable,
        command: "mceTableDelete"
      }), bt($t, !0) && w.ui.registry.addNestedMenuItem("row", {
        type: "nestedmenuitem",
        text: "Row",
        getSubmenuItems: st("tableinsertrowbefore tableinsertrowafter tabledeleterow tablerowprops | tablecutrow tablecopyrow tablepasterowbefore tablepasterowafter")
      }), bt(pn, !0) && w.ui.registry.addNestedMenuItem("column", {
        type: "nestedmenuitem",
        text: "Column",
        getSubmenuItems: st("tableinsertcolumnbefore tableinsertcolumnafter tabledeletecolumn | tablecutcolumn tablecopycolumn tablepastecolumnbefore tablepastecolumnafter")
      }), bt(oo, !0) && w.ui.registry.addNestedMenuItem("cell", {
        type: "nestedmenuitem",
        text: "Cell",
        getSubmenuItems: st("tablecellprops tablemergecells tablesplitcells")
      }), w.ui.registry.addContextMenu("table", {
        update: () => (k.resetTargets(), k.targets().fold(st(""), (Sr) => Dt(Sr.element) === "caption" ? "tableprops deletetable" : "cell row column | advtablesort | tableprops deletetable"))
      });
      const Jn = qc(dm(w));
      Jn.length !== 0 && w.queryCommandSupported("mceTableToggleClass") && w.ui.registry.addNestedMenuItem("tableclass", {
        icon: "table-classes",
        text: "Table styles",
        getSubmenuItems: () => Ei(w, Jn, "tableclass", (Sr) => w.execCommand("mceTableToggleClass", !1, Sr)),
        onSetup: k.onSetupTable
      });
      const Fr = qc(tf(w));
      Fr.length !== 0 && w.queryCommandSupported("mceTableCellToggleClass") && w.ui.registry.addNestedMenuItem("tablecellclass", {
        icon: "table-cell-classes",
        text: "Cell styles",
        getSubmenuItems: () => Ei(w, Fr, "tablecellclass", (Sr) => w.execCommand("mceTableCellToggleClass", !1, Sr)),
        onSetup: k.onSetupCellOrRow
      }), w.queryCommandSupported("mceTableApplyCellStyle") && (w.ui.registry.addNestedMenuItem("tablecellvalign", {
        icon: "vertical-align",
        text: "Vertical align",
        getSubmenuItems: () => Ei(w, Hi, "tablecellverticalalign", bs(w, "vertical-align")),
        onSetup: k.onSetupCellOrRow
      }), w.ui.registry.addNestedMenuItem("tablecellborderwidth", {
        icon: "border-width",
        text: "Border width",
        getSubmenuItems: () => Ei(w, Nc(w), "tablecellborderwidth", bs(w, "border-width")),
        onSetup: k.onSetupCellOrRow
      }), w.ui.registry.addNestedMenuItem("tablecellborderstyle", {
        icon: "border-style",
        text: "Border style",
        getSubmenuItems: () => Ei(w, Ii(w), "tablecellborderstyle", bs(w, "border-style")),
        onSetup: k.onSetupCellOrRow
      }), w.ui.registry.addNestedMenuItem("tablecellbackgroundcolor", {
        icon: "cell-background-color",
        text: "Background color",
        getSubmenuItems: () => _u(w, oh(w), "background-color"),
        onSetup: k.onSetupCellOrRow
      }), w.ui.registry.addNestedMenuItem("tablecellbordercolor", {
        icon: "cell-border-color",
        text: "Border color",
        getSubmenuItems: () => _u(w, wu(w), "border-color"),
        onSetup: k.onSetupCellOrRow
      })), we("tablecaption", {
        icon: "table-caption",
        text: "Table caption",
        command: "mceTableToggleCaption",
        onSetup: k.onSetupTableWithCaption
      }), we("tablerowheader", {
        text: "Row header",
        icon: "table-top-header",
        command: "mceTableRowType",
        onAction: Wo(w),
        onSetup: k.onSetupTableRowHeaders
      }), we("tablecolheader", {
        text: "Column header",
        icon: "table-left-header",
        command: "mceTableColType",
        onAction: sd(w),
        onSetup: k.onSetupTableRowHeaders
      });
    }, di = (w) => {
      const k = d1(w);
      _r(w), su(w), Nw(w, k), Ai(w, k), Pa(w);
    };
    var Nu = () => {
      vt.add("table", di);
    };
    Nu();
  })()), DK;
}
var NK;
function yX() {
  return NK || (NK = 1, vX()), OK;
}
yX();
var MK = {}, PK = {}, BK;
function CX() {
  return BK || (BK = 1, (function() {
    const vt = (Ft) => {
      let Zt = Ft;
      return {
        get: () => Zt,
        set: (st) => {
          Zt = st;
        }
      };
    };
    var Ot = tinymce.util.Tools.resolve("tinymce.PluginManager");
    const Pt = (Ft, Zt) => {
      Ft.dispatch("VisualBlocks", { state: Zt });
    }, yt = (Ft, Zt, Qt) => {
      Ft.dom.toggleClass(Ft.getBody(), "mce-visualblocks"), Qt.set(!Qt.get()), Pt(Ft, Qt.get());
    }, Nt = (Ft, Zt, Qt) => {
      Ft.addCommand("mceVisualBlocks", () => {
        yt(Ft, Zt, Qt);
      });
    }, Wt = (Ft) => (Zt) => Zt.options.get(Ft), Fe = (Ft) => {
      const Zt = Ft.options.register;
      Zt("visualblocks_default_state", {
        processor: "boolean",
        default: !1
      });
    }, Ee = Wt("visualblocks_default_state"), Bt = (Ft, Zt, Qt) => {
      Ft.on("PreviewFormats AfterPreviewFormats", (En) => {
        Qt.get() && Ft.dom.toggleClass(Ft.getBody(), "mce-visualblocks", En.type === "afterpreviewformats");
      }), Ft.on("init", () => {
        Ee(Ft) && yt(Ft, Zt, Qt);
      });
    }, fn = (Ft, Zt) => (Qt) => {
      Qt.setActive(Zt.get());
      const En = (st) => Qt.setActive(st.state);
      return Ft.on("VisualBlocks", En), () => Ft.off("VisualBlocks", En);
    }, dn = (Ft, Zt) => {
      const Qt = () => Ft.execCommand("mceVisualBlocks");
      Ft.ui.registry.addToggleButton("visualblocks", {
        icon: "visualblocks",
        tooltip: "Show blocks",
        onAction: Qt,
        onSetup: fn(Ft, Zt)
      }), Ft.ui.registry.addToggleMenuItem("visualblocks", {
        text: "Show blocks",
        icon: "visualblocks",
        onAction: Qt,
        onSetup: fn(Ft, Zt)
      });
    };
    var Sn = () => {
      Ot.add("visualblocks", (Ft, Zt) => {
        Fe(Ft);
        const Qt = vt(!1);
        Nt(Ft, Zt, Qt), dn(Ft, Qt), Bt(Ft, Zt, Qt);
      });
    };
    Sn();
  })()), PK;
}
var $K;
function wX() {
  return $K || ($K = 1, CX()), MK;
}
wX();
var FK = {}, IK = {}, LK;
function SX() {
  return LK || (LK = 1, (function() {
    var vt = tinymce.util.Tools.resolve("tinymce.PluginManager");
    const Pt = ((ee) => (pe) => ee === pe)(null), yt = (ee) => ee, Nt = (ee, pe) => {
      const ye = ee.length, ae = new Array(ye);
      for (let kt = 0; kt < ye; kt++) {
        const Vn = ee[kt];
        ae[kt] = pe(Vn, kt);
      }
      return ae;
    }, Fe = {
      aletter: "[A-Za-zªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԧԱ-Ֆՙա-ևא-תװ-׳ؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘऄ-हऽॐक़-ॡॱ-ॷॹ-ॿঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-ళవ-హఽౘౙౠౡಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൠൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆༀཀ-ཇཉ-ཬྈ-ྌႠ-Ⴥა-ჺჼᄀ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏼᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛰᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰᠠ-ᡷᢀ-ᢨᢪᢰ-ᣵᤀ-ᤜᨀ-ᨖᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᯀ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᳩ-ᳬᳮ-ᳱᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⒶ-ⓩⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⴀ-ⴥⴰ-ⵥⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞⸯ々〻〼ㄅ-ㄭㄱ-ㆎㆠ-ㆺꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚗꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞎꞐꞑꞠ-ꞩꟺ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꨀ-ꨨꩀ-ꩂꩄ-ꩋꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꯀ-ꯢ가-힣ힰ-ퟆퟋ-ퟻﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚﾠ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ]",
      midnumlet: "[-'\\.‘’․﹒＇．]",
      midletter: "[:··״‧︓﹕：]",
      midnum: "[±+*/,;;։،؍٬߸⁄︐︔﹐﹔，；]",
      numeric: "[0-9٠-٩٫۰-۹߀-߉०-९০-৯੦-੯૦-૯୦-୯௦-௯౦-౯೦-೯൦-൯๐-๙໐-໙༠-༩၀-၉႐-႙០-៩᠐-᠙᥆-᥏᧐-᧙᪀-᪉᪐-᪙᭐-᭙᮰-᮹᱀-᱉᱐-᱙꘠-꘩꣐-꣙꤀-꤉꧐-꧙꩐-꩙꯰-꯹]",
      cr: "\\r",
      lf: "\\n",
      newline: "[\v\f\u2028\u2029]",
      extend: "[̀-ͯ҃-҉֑-ׇֽֿׁׂׅׄؐ-ًؚ-ٰٟۖ-ۜ۟-۪ۤۧۨ-ܑۭܰ-݊ަ-ް߫-߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ऀ-ःऺ-़ा-ॏ॑-ॗॢॣঁ-ঃ়া-ৄেৈো-্ৗৢৣਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑੰੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣଁ-ଃ଼ା-ୄେୈୋ-୍ୖୗୢୣஂா-ூெ-ைொ-்ௗఁ-ఃా-ౄె-ైొ-్ౕౖౢౣಂಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣംഃാ-ൄെ-ൈൊ-്ൗൢൣංඃ්ා-ුූෘ-ෟෲෳัิ-ฺ็-๎ັິ-ູົຼ່-ໍ༹༘༙༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏႚ-ႝ፝-፟ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳា-៓៝᠋-᠍ᢩᤠ-ᤫᤰ-᤻ᦰ-ᧀᧈᧉᨗ-ᨛᩕ-ᩞ᩠-᩿᩼ᬀ-ᬄ᬴-᭄᭫-᭳ᮀ-ᮂᮡ-᯦᮪-᯳ᰤ-᰷᳐-᳔᳒-᳨᳭ᳲ᷀-ᷦ᷼-᷿‌‍⃐-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꙯-꙲꙼꙽꛰꛱ꠂ꠆ꠋꠣ-ꠧꢀꢁꢴ-꣄꣠-꣱ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀ꨩ-ꨶꩃꩌꩍꩻꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꯣ-ꯪ꯬꯭ﬞ︀-️︠-︦ﾞﾟ]",
      format: "[­؀-؃۝܏឴឵‎‏‪-‮⁠-⁤⁪-⁯\uFEFF￹-￻]",
      katakana: "[〱-〵゛゜゠-ヺー-ヿㇰ-ㇿ㋐-㋾㌀-㍗ｦ-ﾝ]",
      extendnumlet: "[=_‿⁀⁔︳︴﹍-﹏＿∀-⋿<>]",
      punctuation: "[~№|!-*+-\\/:;?@\\[-`{}¡«·»¿;·՚-՟։֊־׀׃׆׳״؉؊،؍؛؞؟٪-٭۔܀-܍߷-߹࠰-࠾࡞।॥॰෴๏๚๛༄-༒༺-༽྅࿐-࿔࿙࿚၊-၏჻፡-፨᐀᙭᙮᚛᚜᛫-᛭᜵᜶។-៖៘-៚᠀-᠊᥄᥅᨞᨟᪠-᪦᪨-᪭᭚-᭠᯼-᯿᰻-᰿᱾᱿᳓‐-‧‰-⁃⁅-⁑⁓-⁞⁽⁾₍₎〈〉❨-❵⟅⟆⟦-⟯⦃-⦘⧘-⧛⧼⧽⳹-⳼⳾⳿⵰⸀-⸮⸰⸱、-〃〈-】〔-〟〰〽゠・꓾꓿꘍-꘏꙳꙾꛲-꛷꡴-꡷꣎꣏꣸-꣺꤮꤯꥟꧁-꧍꧞꧟꩜-꩟꫞꫟꯫﴾﴿︐-︙︰-﹒﹔-﹡﹣﹨﹪﹫！-＃％-＊，-／：；？＠［-］＿｛｝｟-･]"
    }, Ee = {
      ALETTER: 0,
      MIDNUMLET: 1,
      MIDLETTER: 2,
      MIDNUM: 3,
      NUMERIC: 4,
      CR: 5,
      LF: 6,
      NEWLINE: 7,
      EXTEND: 8,
      FORMAT: 9,
      KATAKANA: 10,
      EXTENDNUMLET: 11,
      AT: 12,
      OTHER: 13
    }, Bt = [
      new RegExp(Fe.aletter),
      new RegExp(Fe.midnumlet),
      new RegExp(Fe.midletter),
      new RegExp(Fe.midnum),
      new RegExp(Fe.numeric),
      new RegExp(Fe.cr),
      new RegExp(Fe.lf),
      new RegExp(Fe.newline),
      new RegExp(Fe.extend),
      new RegExp(Fe.format),
      new RegExp(Fe.katakana),
      new RegExp(Fe.extendnumlet),
      new RegExp("@")
    ], fn = "", dn = new RegExp("^" + Fe.punctuation + "$"), Sn = /^\s+$/, Ft = Bt, Zt = Ee.OTHER, Qt = (ee) => {
      let pe = Zt;
      const ye = Ft.length;
      for (let ae = 0; ae < ye; ++ae) {
        const kt = Ft[ae];
        if (kt && kt.test(ee)) {
          pe = ae;
          break;
        }
      }
      return pe;
    }, En = (ee) => {
      const pe = {};
      return (ye) => {
        if (pe[ye])
          return pe[ye];
        {
          const ae = ee(ye);
          return pe[ye] = ae, ae;
        }
      };
    }, st = (ee) => {
      const pe = En(Qt);
      return Nt(ee, pe);
    }, Pn = (ee, pe) => {
      const ye = ee[pe], ae = ee[pe + 1];
      if (pe < 0 || pe > ee.length - 1 && pe !== 0 || ye === Ee.ALETTER && ae === Ee.ALETTER)
        return !1;
      const kt = ee[pe + 2];
      if (ye === Ee.ALETTER && (ae === Ee.MIDLETTER || ae === Ee.MIDNUMLET || ae === Ee.AT) && kt === Ee.ALETTER)
        return !1;
      const Vn = ee[pe - 1];
      return (ye === Ee.MIDLETTER || ye === Ee.MIDNUMLET || ae === Ee.AT) && ae === Ee.ALETTER && Vn === Ee.ALETTER || (ye === Ee.NUMERIC || ye === Ee.ALETTER) && (ae === Ee.NUMERIC || ae === Ee.ALETTER) || (ye === Ee.MIDNUM || ye === Ee.MIDNUMLET) && ae === Ee.NUMERIC && Vn === Ee.NUMERIC || ye === Ee.NUMERIC && (ae === Ee.MIDNUM || ae === Ee.MIDNUMLET) && kt === Ee.NUMERIC || (ye === Ee.EXTEND || ye === Ee.FORMAT) && (ae === Ee.ALETTER || ae === Ee.NUMERIC || ae === Ee.KATAKANA || ae === Ee.EXTEND || ae === Ee.FORMAT) || (ae === Ee.EXTEND || ae === Ee.FORMAT && (kt === Ee.ALETTER || kt === Ee.NUMERIC || kt === Ee.KATAKANA || kt === Ee.EXTEND || kt === Ee.FORMAT)) && (ye === Ee.ALETTER || ye === Ee.NUMERIC || ye === Ee.KATAKANA || ye === Ee.EXTEND || ye === Ee.FORMAT) || ye === Ee.CR && ae === Ee.LF ? !1 : ye === Ee.NEWLINE || ye === Ee.CR || ye === Ee.LF || ae === Ee.NEWLINE || ae === Ee.CR || ae === Ee.LF ? !0 : !(ye === Ee.KATAKANA && ae === Ee.KATAKANA || ae === Ee.EXTENDNUMLET && (ye === Ee.ALETTER || ye === Ee.NUMERIC || ye === Ee.KATAKANA || ye === Ee.EXTENDNUMLET) || ye === Ee.EXTENDNUMLET && (ae === Ee.ALETTER || ae === Ee.NUMERIC || ae === Ee.KATAKANA) || ye === Ee.AT);
    }, Kt = fn, J = Sn, Qe = dn, xo = (ee) => ee === "http" || ee === "https", ht = (ee, pe) => {
      let ye;
      for (ye = pe; ye < ee.length && !J.test(ee[ye]); ye++)
        ;
      return ye;
    }, U = (ee, pe) => {
      const ye = ht(ee, pe + 1);
      return ee.slice(pe + 1, ye).join(Kt).substr(0, 3) === "://" ? ye : pe;
    }, Tt = (ee, pe, ye, ae) => {
      const kt = [], Vn = [];
      let Yt = [];
      for (let Ct = 0; Ct < ye.length; ++Ct)
        if (Yt.push(ee[Ct]), Pn(ye, Ct)) {
          const Xe = pe[Ct];
          if ((ae.includeWhitespace || !J.test(Xe)) && (ae.includePunctuation || !Qe.test(Xe))) {
            const In = Ct - Yt.length + 1, hn = Ct + 1, Xn = pe.slice(In, hn).join(Kt);
            if (xo(Xn)) {
              const Xo = U(pe, Ct), ds = ee.slice(hn, Xo);
              Array.prototype.push.apply(Yt, ds), Ct = Xo;
            }
            kt.push(Yt), Vn.push({
              start: In,
              end: hn
            });
          }
          Yt = [];
        }
      return {
        words: kt,
        indices: Vn
      };
    }, Ht = () => ({
      includeWhitespace: !1,
      includePunctuation: !1
    }), gn = (ee, pe, ye) => {
      ye = {
        ...Ht(),
        ...ye
      };
      const ae = Nt(ee, pe), kt = st(ae);
      return Tt(ee, ae, kt, ye);
    }, re = (ee, pe, ye) => gn(ee, pe, ye).words, ho = (ee) => ee.replace(/\uFEFF/g, "");
    var Te = tinymce.util.Tools.resolve("tinymce.dom.TreeWalker");
    const Oe = (ee, pe) => {
      const ye = pe.getBlockElements(), ae = pe.getVoidElements(), kt = (In) => ye[In.nodeName] || ae[In.nodeName], Vn = [];
      let Yt = "";
      const Ct = new Te(ee, ee);
      let Xe;
      for (; Xe = Ct.next(); )
        Xe.nodeType === 3 ? Yt += ho(Xe.data) : kt(Xe) && Yt.length && (Vn.push(Yt), Yt = "");
      return Yt.length && Vn.push(Yt), Vn;
    }, A = (ee) => ee.replace(/\u200B/g, ""), mn = (ee) => ee.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "_").length, it = (ee, pe) => {
      const ye = A(Oe(ee, pe).join(`
`));
      return re(ye.split(""), yt).length;
    }, Gn = (ee, pe) => {
      const ye = Oe(ee, pe).join("");
      return mn(ye);
    }, rn = (ee, pe) => {
      const ye = Oe(ee, pe).join("").replace(/\s/g, "");
      return mn(ye);
    }, Ye = (ee, pe) => () => pe(ee.getBody(), ee.schema), io = (ee, pe) => () => pe(ee.selection.getRng().cloneContents(), ee.schema), jo = (ee) => Ye(ee, it), bt = (ee) => ({
      body: {
        getWordCount: jo(ee),
        getCharacterCount: Ye(ee, Gn),
        getCharacterCountWithoutSpaces: Ye(ee, rn)
      },
      selection: {
        getWordCount: io(ee, it),
        getCharacterCount: io(ee, Gn),
        getCharacterCountWithoutSpaces: io(ee, rn)
      },
      getCount: jo(ee)
    }), kn = (ee, pe) => {
      ee.windowManager.open({
        title: "Word Count",
        body: {
          type: "panel",
          items: [{
            type: "table",
            header: [
              "Count",
              "Document",
              "Selection"
            ],
            cells: [
              [
                "Words",
                String(pe.body.getWordCount()),
                String(pe.selection.getWordCount())
              ],
              [
                "Characters (no spaces)",
                String(pe.body.getCharacterCountWithoutSpaces()),
                String(pe.selection.getCharacterCountWithoutSpaces())
              ],
              [
                "Characters",
                String(pe.body.getCharacterCount()),
                String(pe.selection.getCharacterCount())
              ]
            ]
          }]
        },
        buttons: [{
          type: "cancel",
          name: "close",
          text: "Close",
          primary: !0
        }]
      });
    }, $e = (ee, pe) => {
      ee.addCommand("mceWordCount", () => kn(ee, pe));
    }, ot = (ee, pe) => {
      let ye = null;
      return {
        cancel: () => {
          Pt(ye) || (clearTimeout(ye), ye = null);
        },
        throttle: (...Vn) => {
          Pt(ye) && (ye = setTimeout(() => {
            ye = null, ee.apply(null, Vn);
          }, pe));
        }
      };
    };
    var F = tinymce.util.Tools.resolve("tinymce.util.Delay");
    const ss = (ee, pe) => {
      ee.dispatch("wordCountUpdate", {
        wordCount: {
          words: pe.body.getWordCount(),
          characters: pe.body.getCharacterCount(),
          charactersWithoutSpaces: pe.body.getCharacterCountWithoutSpaces()
        }
      });
    }, fo = (ee, pe) => {
      ss(ee, pe);
    }, at = (ee, pe, ye) => {
      const ae = ot(() => fo(ee, pe), ye);
      ee.on("init", () => {
        fo(ee, pe), F.setEditorTimeout(ee, () => {
          ee.on("SetContent BeforeAddUndo Undo Redo ViewUpdate keyup", ae.throttle);
        }, 0), ee.on("remove", ae.cancel);
      });
    }, lt = (ee) => {
      const pe = () => ee.execCommand("mceWordCount");
      ee.ui.registry.addButton("wordcount", {
        tooltip: "Word count",
        icon: "character-count",
        onAction: pe
      }), ee.ui.registry.addMenuItem("wordcount", {
        text: "Word count",
        icon: "character-count",
        onAction: pe
      });
    };
    var Rn = (ee = 300) => {
      vt.add("wordcount", (pe) => {
        const ye = bt(pe);
        return $e(pe, ye), lt(pe), at(pe, ye, ee), ye;
      });
    };
    Rn();
  })()), IK;
}
var HK;
function xX() {
  return HK || (HK = 1, SX()), FK;
}
xX();
function TX(vt) {
  return {
    font: vt?.zimbraPrefHtmlEditorDefaultFontFamily,
    fontSize: vt?.zimbraPrefHtmlEditorDefaultFontSize,
    color: vt?.zimbraPrefHtmlEditorDefaultFontColor
  };
}
function EX(vt) {
  return `body { color: ${vt.color}; font-size: ${vt.fontSize}; font-family: ${vt.font}; }`;
}
const UK = {
  zh_CN: {
    name: "中文 (中国)",
    value: "zh_CN",
    tinymceLocale: "zh-Hans",
    labelKey: "locale.label_chinese",
    labelDefaultValue: "Chinese (China) - {{value}}"
  },
  nl: {
    name: "Nederlands",
    value: "nl",
    tinymceLocale: "nl",
    labelKey: "locale.label_dutch",
    labelDefaultValue: "Dutch - {{value}}"
  },
  en: {
    name: "English",
    value: "en",
    tinymceLocale: "en",
    labelKey: "locale.label_english",
    labelDefaultValue: "English - {{value}}"
  },
  de: {
    name: "Deutsch",
    value: "de",
    tinymceLocale: "de",
    labelKey: "locale.label_german",
    labelDefaultValue: "German - {{value}}"
  },
  hi: {
    name: "हिंदी",
    value: "hi",
    tinymceLocale: "hi",
    labelKey: "locale.label_hindi",
    labelDefaultValue: "Hindi - {{value}}"
  },
  hu: {
    name: "Magyar",
    value: "hu",
    tinymceLocale: "hu_HU",
    labelKey: "locale.label_hungarian",
    labelDefaultValue: "Hungarian - {{value}}"
  },
  it: {
    name: "italiano",
    value: "it",
    tinymceLocale: "it",
    labelKey: "locale.label_italian",
    labelDefaultValue: "Italian - {{value}}"
  },
  ja: {
    name: "日本語",
    value: "ja",
    tinymceLocale: "ja",
    labelKey: "locale.label_japanese",
    labelDefaultValue: "Japanese - {{value}}"
  },
  pt: {
    name: "português",
    value: "pt",
    tinymceLocale: "pt_BR",
    labelKey: "locale.label_portuguese",
    labelDefaultValue: "Portuguese - {{value}}"
  },
  pl: {
    name: "polski",
    value: "pl",
    tinymceLocale: "pl",
    labelKey: "locale.label_polish",
    labelDefaultValue: "Polish - {{value}}"
  },
  ro: {
    name: "română",
    value: "ro",
    tinymceLocale: "ro",
    labelKey: "locale.label_romanian",
    labelDefaultValue: "Romanian - {{value}}"
  },
  ru: {
    name: "русский",
    value: "ru",
    tinymceLocale: "ru",
    labelKey: "locale.label_russian",
    labelDefaultValue: "Russian - {{value}}"
  },
  es: {
    name: "español",
    value: "es",
    tinymceLocale: "es",
    labelKey: "locale.label_spanish",
    labelDefaultValue: "Spanish - {{value}}"
  },
  th: {
    name: "ไทย",
    value: "th",
    tinymceLocale: "th_TH",
    labelKey: "locale.label_thai",
    labelDefaultValue: "Thai - {{value}}"
  },
  tr: {
    name: "Türkçe",
    value: "tr",
    tinymceLocale: "tr",
    labelKey: "locale.label_turkish",
    labelDefaultValue: "Turkish - {{value}}"
  },
  fr: {
    name: "français",
    value: "fr",
    tinymceLocale: "fr_FR",
    labelKey: "locale.label_french",
    labelDefaultValue: "French - {{value}}"
  },
  vi: {
    name: "Tiếng Việt",
    value: "vi",
    tinymceLocale: "vi",
    labelKey: "locale.label_vietnamese",
    labelDefaultValue: "Vietnamese - {{value}}"
  },
  ky: {
    name: "Кыргызча",
    value: "ky",
    tinymceLocale: "ky",
    labelKey: "locale.label_kyrgyz",
    labelDefaultValue: "Kyrgyz - {{value}}"
  },
  bs: {
    name: "Bosanski",
    value: "bs",
    tinymceLocale: "bs",
    labelKey: "locale.label_bosnian",
    labelDefaultValue: "Bosnian - {{value}}"
  },
  sl: {
    name: "Slovenščina",
    value: "sl",
    tinymceLocale: "sl_SI",
    labelKey: "locale.label_slovenian",
    labelDefaultValue: "Slovenian - {{value}}"
  }
};
function kX(vt) {
  return vt in UK;
}
function _X(vt) {
  const Ot = vt ?? "en", Pt = kX(Ot) ? UK[Ot] : void 0;
  return Pt && ("tinymceLocale" in Pt && Pt?.tinymceLocale || Pt?.value) || Ot;
}
const AX = "8pt 9pt 10pt 11pt 12pt 13pt 14pt 16pt 18pt 24pt 30pt 36pt 48pt 60pt 72pt 96pt", OX = ["advlist", "autolink", "lists", "link", "image", "charmap", "preview", "anchor", "searchreplace", "code", "fullscreen", "insertdatetime", "media", "table", "code", "help", "quickbars", "directionality", "autoresize", "visualblocks"], DX = [{
  title: "Headers",
  items: [{
    title: "h1",
    block: "h1"
  }, {
    title: "h2",
    block: "h2"
  }, {
    title: "h3",
    block: "h3"
  }, {
    title: "h4",
    block: "h4"
  }, {
    title: "h5",
    block: "h5"
  }, {
    title: "h6",
    block: "h6"
  }]
}, {
  title: "Blocks",
  items: [{
    title: "p",
    block: "p"
  }, {
    title: "div",
    block: "div"
  }, {
    title: "pre",
    block: "pre"
  }]
}, {
  title: "Containers",
  items: [{
    title: "section",
    block: "section",
    wrapper: !0,
    merge_siblings: !1
  }, {
    title: "article",
    block: "article",
    wrapper: !0,
    merge_siblings: !1
  }, {
    title: "blockquote",
    block: "blockquote",
    wrapper: !0
  }, {
    title: "hgroup",
    block: "hgroup",
    wrapper: !0
  }, {
    title: "aside",
    block: "aside",
    wrapper: !0
  }, {
    title: "figure",
    block: "figure",
    wrapper: !0
  }]
}];
function RX(vt) {
  return vt ? !1 : ["fontfamily fontsize styles visualblocks", "bold italic underline strikethrough", "removeformat code", "alignleft aligncenter alignright alignjustify", "forecolor backcolor", "bullist numlist outdent indent", "ltr rtl", "link", "insertfile image", "imageSelector"].join(" | ");
}
function NX(vt) {
  return {
    quickbars_insert_toolbar: vt ? "bullist numlist" : "",
    quickbars_selection_toolbar: vt ? "bold italic underline | forecolor backcolor | removeformat | link" : "link"
  };
}
function MX(vt) {
  const {
    language: Ot,
    inline: Pt,
    contentStyle: yt,
    setup: Nt,
    customOptions: Wt
  } = vt, Fe = NX(Pt);
  return {
    content_css: [""],
    language_url: `tinymce/langs/${Ot}.js`,
    language: Ot,
    setup: Nt,
    min_height: 350,
    auto_focus: !0,
    menubar: !1,
    statusbar: !1,
    branding: !1,
    resize: !0,
    inline: Pt,
    font_size_formats: AX,
    object_resizing: "img",
    style_formats: DX,
    plugins: OX,
    toolbar: RX(Pt),
    ...Fe,
    contextmenu: [""],
    toolbar_mode: "wrap",
    content_style: yt,
    visualblocks_default_state: !1,
    end_container_on_empty_block: !0,
    relative_urls: !1,
    remove_script_host: !1,
    newline_behavior: "default",
    browser_spellcheck: !0,
    convert_unsafe_embeds: !0,
    ...Wt ?? {}
  };
}
function PX(vt) {
  const {
    onFileSelect: Ot,
    onFileClick: Pt,
    inlineLabel: yt,
    selectImageTooltip: Nt
  } = vt;
  return (Wt) => {
    Ot && Wt.ui?.registry && Wt.ui.registry.addMenuButton("imageSelector", {
      icon: "gallery",
      tooltip: Nt,
      fetch: (Fe) => {
        Fe([{
          type: "menuitem",
          text: yt,
          onAction: () => {
            Pt();
          }
        }]);
      }
    });
  };
}
const LX = ({
  onEditorChange: vt,
  onFileSelect: Ot,
  inline: Pt = !1,
  value: yt,
  initialValue: Nt,
  customInitOptions: Wt,
  disabled: Fe,
  accountSettingsPrefs: Ee = {
    zimbraPrefLocale: "en",
    zimbraPrefHtmlEditorDefaultFontFamily: "Arial",
    zimbraPrefHtmlEditorDefaultFontSize: "16pt",
    zimbraPrefHtmlEditorDefaultFontColor: "#000000"
  },
  ...Bt
}) => {
  const fn = py(() => !!vt, [vt]), dn = gj((ht, U) => {
    vt?.([U.getContent({
      format: "text"
    }), U.getContent({
      format: "html"
    })]);
  }, [vt]), Sn = py(() => TX(Ee), [Ee]), Ft = uY(null), Zt = gj(() => {
    Ft.current && (Ft.current.value = "", Ft.current.click());
  }, []), [Qt] = mY(), En = py(() => _X(Ee.zimbraPrefLocale), [Ee.zimbraPrefLocale]), st = py(() => Qt("label.add_inline_image", "Add inline image"), [Qt]), Pn = py(() => Qt("label.select_image", "Select image"), [Qt]), Kt = py(() => PX({
    onFileSelect: Ot,
    onFileClick: Zt,
    inlineLabel: st,
    selectImageTooltip: Pn
  }), [st, Zt, Ot, Pn]), J = py(() => EX(Sn), [Sn]), Qe = py(() => MX({
    language: En,
    inline: Pt,
    contentStyle: J,
    setup: Kt,
    customOptions: Wt
  }), [J, Wt, Pt, En, Kt]), xo = gj(() => {
    Ot && Ft.current && Ot({
      editor: RY,
      files: Ft.current.files
    });
  }, [Ot]);
  return /* @__PURE__ */ lY(dY, { height: "100%", crossAlignment: "baseline", mainAlignment: "flex-start", style: {
    overflowY: "hidden"
  }, children: [
    /* @__PURE__ */ jq("input", { "data-testid": "file-input", type: "file", ref: Ft, accept: "image/*", onChange: xo, multiple: !0, style: {
      display: "none"
    } }),
    /* @__PURE__ */ jq(AY, { initialValue: Nt, value: yt, init: Qe, onEditorChange: fn ? dn : void 0, disabled: Fe, ...Bt })
  ] });
};
export {
  LX as Composer
};
